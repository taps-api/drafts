{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-07-13T00:17:36.527485+00:00",
  "repo": "ietf-tapswg/api-drafts",
  "labels": [
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "API",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "Architecture",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "Implementation",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "admin stuff",
      "description": null,
      "color": "f9d0c4"
    },
    {
      "name": "discuss",
      "description": null,
      "color": "b60205"
    },
    {
      "name": "review",
      "description": null,
      "color": "fb9a04"
    },
    {
      "name": "ready for text",
      "description": "",
      "color": "4ae0d1"
    },
    {
      "name": "future work",
      "description": "Things the WG wants, just not in the core docs",
      "color": "0d5196"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "f265b5"
    },
    {
      "name": "mappings",
      "description": "",
      "color": "ffff34"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUyOTM1NDQ4ODE=",
      "title": "Write \u00a75.1 (Resolving Remote Endpoints)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/1",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-01T14:13:34Z",
      "updatedAt": "2018-02-06T17:29:34Z",
      "closedAt": "2018-02-06T17:29:34Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "assigning @philsbln though @britram may get to this earlier...",
          "createdAt": "2018-02-05T10:18:44Z",
          "updatedAt": "2018-02-05T10:18:44Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First text is written in #da4bf2735 \u2013 opening new issue for consistency",
          "createdAt": "2018-02-06T17:29:34Z",
          "updatedAt": "2018-02-06T17:29:34Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWUyOTM1NDUwNzQ=",
      "title": "Write \u00a75.2 (Specifying Transport Parameters)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/2",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API"
      ],
      "body": "look at minset for this. note that the API should have sensible and well-defined defaults.",
      "createdAt": "2018-02-01T14:14:06Z",
      "updatedAt": "2018-02-07T13:57:46Z",
      "closedAt": "2018-02-07T13:57:46Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "note from a discussion on #8: transport parameters must note whether the application is written in such a way that it expects 0RTT to be available.",
          "createdAt": "2018-02-06T10:40:41Z",
          "updatedAt": "2018-02-06T10:40:41Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUyOTM1NDU3OTA=",
      "title": "Write \u00a75.3 (Specifying Cryptographic Parameters)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/3",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "API"
      ],
      "body": "separate out cryptographic parameters, since these bind to a local and a remote. one can also do pre-shared keying tricks here. look at Post for inspiration/text.",
      "createdAt": "2018-02-01T14:16:18Z",
      "updatedAt": "2018-02-12T12:55:03Z",
      "closedAt": "2018-02-12T12:55:02Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closing on @chris-wood's behalf...",
          "createdAt": "2018-02-12T12:55:02Z",
          "updatedAt": "2018-02-12T12:55:02Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUyOTM1NDYwNjA=",
      "title": "Write \u00a76.1 (Active Open: Initiate)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/4",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-01T14:17:07Z",
      "updatedAt": "2018-02-06T10:37:28Z",
      "closedAt": "2018-02-06T10:37:28Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWUyOTM1NDYxODY=",
      "title": "Write \u00a76.2 (Passive Open: Listen and Accept)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/5",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-01T14:17:27Z",
      "updatedAt": "2018-02-06T10:37:54Z",
      "closedAt": "2018-02-06T10:37:54Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUyOTM1NDcyNzI=",
      "title": "Write \u00a76.3 (Peer to Peer Establishment: Rendezvous)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/6",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API"
      ],
      "body": "I don't recall whether we came to consensus in Cambridge that there needed to be a separate entry point for peer-to-peer establishment: is this a kinda-simultaneous Initiate on N sides, or is it really its own call? If the latter, tagging @csperkins for this (and feel free to decide it's not necessary after all)",
      "createdAt": "2018-02-01T14:20:33Z",
      "updatedAt": "2018-02-18T19:51:27Z",
      "closedAt": "2018-02-18T19:51:27Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUyOTM1NDgwMjQ=",
      "title": "Write \u00a76.4 (Connection Groups)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/7",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "We decided that connection groups (the construct by which we support multistreaming) are technically a pre-establishment-phase construct, but \"get me a new connection in a connection group\" seems like establishment in the eyes of the application. Discuss, and write text.",
      "createdAt": "2018-02-01T14:22:33Z",
      "updatedAt": "2018-02-08T15:14:02Z",
      "closedAt": "2018-02-08T15:14:02Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "suggest @mwelzl for this one, since it's the API equivalent of #17",
          "createdAt": "2018-02-06T16:33:19Z",
          "updatedAt": "2018-02-06T16:33:19Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fine by me!  But I understand you folks didn't like my group IDs and instead wanted to have HTTP/2 / QUIC style. Also you were talking about \"cloning\" connections to get streams - this sounds easy enough as an approach, but is there a document describing this? Any pointer to a doc describing this style of opening streams? Of course I can invent something along these lines but then it's probably not quite what you have in mind - is there some documented basis for that thing that you want?",
          "createdAt": "2018-02-06T16:46:48Z",
          "updatedAt": "2018-02-06T16:46:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 4.1 in the Post Sockets draft has a drawing of how two connections are multiplexed on a stack. Section 2.1 also mentions that they're used for multistreaming.\r\n\r\nIn our API, we have a connection_create_with_connection() that takes an existing connection and opens a new stream on it that's multiplexed onto it. If you can't multiplex, this fails.",
          "createdAt": "2018-02-06T16:50:35Z",
          "updatedAt": "2018-02-06T16:50:35Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I didn't get in the discussion in Cambridge was the idea that this was a pre-establishment phase thing... yes, it's clear that you need a transport parameter to say \"hey i might try to use multiple streams in a connection later, just saying...\" but isn't this basically a new way to establish (from the API's PoV)?\r\n\r\n>In our API, we have a connection_create_with_connection() that takes an existing connection and opens a new stream on it that's multiplexed onto it. If you can't multiplex, this fails.\r\n\r\nAt one point IIRC, the PostSockets call for this was `Fork()`, which is probably just asking for confusion.\r\n\r\nOpen question: if you had a call like `InitiateClone()`, and you were running on top of a single streaming protocol stack, would it be acceptable not to fail, and to open a new flow to the same remote host/port?",
          "createdAt": "2018-02-06T16:56:39Z",
          "updatedAt": "2018-02-06T16:57:12Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, you could certainly have the clone() call just work and create a parallel connection if needed.\r\n\r\nI think the support for multiplexing either is an offshoot of the protocol that's selected, or something you request in the protocol selection parameters\u2014\"I prefer multiplexing\"",
          "createdAt": "2018-02-06T16:58:12Z",
          "updatedAt": "2018-02-06T16:58:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this is just establishment, plus an additional optional hint: \"I'd like to multiplex a little later\". I like clone.",
          "createdAt": "2018-02-06T17:14:58Z",
          "updatedAt": "2018-02-06T17:14:58Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still think it belongs to pre-establishment - you clone the selection parameters and then you initiate the connection - or the call combines pre-establishment and establishment - you clone the selection parameters and initiate the connection at the same time.\r\n\r\nI prefer having the clone call just work and create a parallel connection if needed. That way the application does not have to be aware of what protocol is selected below.\r\n\r\nIf we want to support priorities, that parameter needs to be set separately in the clone call or through some other call.",
          "createdAt": "2018-02-07T00:08:24Z",
          "updatedAt": "2018-02-07T00:08:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's see if I understand. From bottom to top in your message, I agree about priorities and don't think this changes anything about what we're discussing here, and I don't think the app would have to be aware of the selected protocol either way.\r\n\r\nSo, about whether that happens in pre-establishment or establishment... IIUC what you mean with \"prefer having the clone call just work\" is that, if a connection hasn't yet been established but you already clone it, something \"right\" will happen. Makes sense to me, but only if we'd indeed always auto-connect upon cloning - else this is a little awkward, as you could end up with a connected clone but an unconnected parent.",
          "createdAt": "2018-02-07T07:19:32Z",
          "updatedAt": "2018-02-07T07:19:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nonsense, both would be connected. Sorry, not yet awake!",
          "createdAt": "2018-02-07T07:25:42Z",
          "updatedAt": "2018-02-07T07:25:42Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My comments concerned three independent points. The preference for the clone call just working referred to what should happen if the underlying protocol does not support multistreaming, as discussed by Brian and Tommy above.",
          "createdAt": "2018-02-07T09:23:34Z",
          "updatedAt": "2018-02-07T09:23:34Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a quick note so we don't forget it:\r\nThe current \u00a75.2 briefly mentions connection groups and should perhaps elaborate on them, e.g. regarding protocol selection properties that apply only to groups, and include a reference to \u00a76.4 once it is written.",
          "createdAt": "2018-02-07T14:10:34Z",
          "updatedAt": "2018-02-07T14:10:34Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUyOTM1NDg4NTU=",
      "title": "Write \u00a77 & \u00a77.1 (Sending Data and Send Parameters)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/8",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "and note / design for the fact that an API that requires all send calls to always have all parameters won't get used for reasons of ugliness",
      "createdAt": "2018-02-01T14:24:51Z",
      "updatedAt": "2018-02-06T10:38:37Z",
      "closedAt": "2018-02-06T10:38:37Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Uncovered in writing text for this: the transport parameters (#2) probably need to include a parameter to enable 0RTT establishment; i.e. that the first N Idempotent writes after Initiate() are intended to be 0RTT data.",
          "createdAt": "2018-02-05T16:48:14Z",
          "updatedAt": "2018-02-05T16:48:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the parameters do need to indicate that 0RTT should be waited for in general. Whether or not this needs to say how many idempotent writes are expected is a bit more debatable. Two other options:\r\n\r\n- Allow idempotent send operations to be scheduled on the connection before start to be very explicit about which ones must be known about during the fast open start\r\n- Just use whatever idempotent sends are around when connecting, which may be more for candidate transport stacks later in the racing schedule.",
          "createdAt": "2018-02-05T16:51:17Z",
          "updatedAt": "2018-02-05T16:51:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(we should probably copy this over to #2...)\r\n\r\nAnother way to do this is to say that the API for 0RTT is different, and allow Send(Idempotent=true) to be taken as an implicit Initiate(). That might not play well with Rendezvous() if we define it though...",
          "createdAt": "2018-02-05T16:53:23Z",
          "updatedAt": "2018-02-05T16:53:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I don't like having a different variant of Initiate as much. Properties about how protocols treat data should be set in pre-establishment, and not create new variants of establishment for different flavors of feature.",
          "createdAt": "2018-02-05T16:54:46Z",
          "updatedAt": "2018-02-05T16:54:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Idempotent data are messages, even in case of TFO, and an app programmer needs to know the max usable size for this message. This depends on the protocol options that the TAPS system will try... so this can only be available after initialize?!  Of course, we could always just allow a size that will *always* fit... I think that could be a reasonable trade-off for the reduced API complexity?",
          "createdAt": "2018-02-05T17:05:02Z",
          "updatedAt": "2018-02-05T17:05:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also - sorry for complicating this, but there's the case of handing *non*-idempotent data over data before connecting. That's TCP with data on the SYN without TFO. Do we even care about this? While allowed in TCP, this isn't even properly defined in the RFC 793 API  :-)   I think we could ignore it...",
          "createdAt": "2018-02-05T17:06:44Z",
          "updatedAt": "2018-02-05T17:06:44Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In NEAT we explicitly pass the data in during establishment with different initiate calls, using either a neat_open call or a neat_open_with_data call. Sending it after the initiate seems strange to me as you then either don't know if your data is available in time for the racing or you need a parameter in initiate to know that you need to wait for the idempotent data, then why not just send the data? Allowing idempotent send operations to be scheduled on the connection before initiate would be a clean approach I think.",
          "createdAt": "2018-02-05T18:14:00Z",
          "updatedAt": "2018-02-05T18:14:00Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, what we use is that any send can be marked idempotent, but if you want it used for 0-RTT, send it before Initiate.\r\n\r\nI prefer this to having something like neat_open_with_data, since that fundamentally modifies the establishment process.",
          "createdAt": "2018-02-05T18:16:32Z",
          "updatedAt": "2018-02-05T18:16:32Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would be happy with that, seems the most clean.\r\n\r\nDo you use idempotent data sent in the middle of a connection for anything? ",
          "createdAt": "2018-02-05T18:24:40Z",
          "updatedAt": "2018-02-05T18:24:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, for our implementation, the main distinction is that making a Send idempotent disallows the app from setting any callback for when the content was sent. Since if we race idempotent data for multiple candidate flows, we may send it multiple times, you don't get to know if the data was sent or not.\r\n\r\nWhen you mark a later send as idempotent, you also don't get a callback. \r\n\r\nThe example we have for using the idempotent sends in this way is something like voice data that we want to start processing on a server, and we just want to send as much of it over as soon as possible. They're all marked idempotent so they are eligible for fast open if we need.",
          "createdAt": "2018-02-05T18:28:38Z",
          "updatedAt": "2018-02-05T18:28:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another use for this from earlier in Post Sockets' development  (before we added `Initiate()` back, IIRC): the API implementation could decide to switch a ~Carrier~Connection to another PSI, or could attempt to resume a PSI on connectivity loss, and it would be useful to know if such mid-flow resume or path migration could use 0RTT. See also the [cryptosep](https://datatracker.ietf.org/doc/draft-kuehlewind-taps-crypto-sep) draft.\r\n\r\nThat pattern isn't highlighted in this architecture / interface, but I don't think it should be precluded, either. In any case there is a benefit in getting the application to tell the transport on a per-`Send()` basis about idempotence, since that information may be useful to the transport, and not just when the application decides to initiate. (since initiation from the means \"you can't change your mind about the parameters anymore\", not \"this connection becomes irrevocably bound to one and only one PSI during the lifetime of the connection\", though that is certainly an acceptable behavior for lazy implementations).",
          "createdAt": "2018-02-06T07:20:51Z",
          "updatedAt": "2018-02-06T07:20:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also, @tfpauly says:\r\n\r\n> When you mark a later send as idempotent, you also don't get a callback.\r\n\r\nThis seems weird to me. Can you say more?",
          "createdAt": "2018-02-06T07:21:00Z",
          "updatedAt": "2018-02-06T07:21:00Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "since the first pass of this section is done, closing the issue. file new issues for discussion on things you don't like in the text...",
          "createdAt": "2018-02-06T10:38:37Z",
          "updatedAt": "2018-02-06T10:38:37Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUyOTM1NDkzNjU=",
      "title": "Write \u00a77.2 & \u00a78.1 (Framing)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/9",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Here, the document should talk about how to pass a framer down to the API, on the sender as well as the receiver side, and note that on some platforms this allows the API to deal in objects of some arbitrary, application-meaningful type.",
      "createdAt": "2018-02-01T14:26:16Z",
      "updatedAt": "2018-02-06T10:39:05Z",
      "closedAt": "2018-02-06T10:39:05Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "assigning @philsbln though @britram might get to this earlier...",
          "createdAt": "2018-02-05T10:18:16Z",
          "updatedAt": "2018-02-05T10:18:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this actually shouldn't be a separate issue, as it's pretty well integrated into #8 and #10, which i'm writing anyway...",
          "createdAt": "2018-02-06T07:36:35Z",
          "updatedAt": "2018-02-06T07:36:35Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUyOTM1NDk2Mjc=",
      "title": "Write \u00a78 (Receiving)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/10",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Reception is asynchronous, and happens on an event.",
      "createdAt": "2018-02-01T14:27:01Z",
      "updatedAt": "2018-02-06T10:39:20Z",
      "closedAt": "2018-02-06T10:39:20Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUyOTM1NTcwMjY=",
      "title": "Write \u00a79 (Termination)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/11",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-01T14:47:47Z",
      "updatedAt": "2018-02-08T15:28:02Z",
      "closedAt": "2018-02-08T15:28:02Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "seeing no other takers, will do this one myself.",
          "createdAt": "2018-02-06T16:33:45Z",
          "updatedAt": "2018-02-06T16:33:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I didn't react in time: I can make a start with this one today",
          "createdAt": "2018-02-08T11:04:02Z",
          "updatedAt": "2018-02-08T11:04:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cool; I wouldn't get to it 'til Monday so: sold!",
          "createdAt": "2018-02-08T11:05:02Z",
          "updatedAt": "2018-02-08T11:05:02Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUyOTQwMDA4NDg=",
      "title": "Review Architecture API Concepts for Peer-to-Peer",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/12",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "Architecture",
        "review"
      ],
      "body": "Validate that peer-to-peer use cases are sufficiently treated in the API concepts",
      "createdAt": "2018-02-02T19:41:31Z",
      "updatedAt": "2018-03-01T12:16:58Z",
      "closedAt": "2018-03-01T12:16:58Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is done, pending the resolution of #124. Closing.",
          "createdAt": "2018-03-01T12:16:57Z",
          "updatedAt": "2018-03-01T12:16:57Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUyOTQwMDEyMDI=",
      "title": "Fill out Architectural Security Considerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/13",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "We should make more comments on the role of security in the architecture, and decide what to write for the security considerations.",
      "createdAt": "2018-02-02T19:42:45Z",
      "updatedAt": "2018-02-15T15:14:16Z",
      "closedAt": "2018-02-15T15:14:16Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Closing as complete. We can revisit if its insufficient.",
          "createdAt": "2018-02-15T15:14:16Z",
          "updatedAt": "2018-02-15T15:14:16Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUyOTQwODA2MzE=",
      "title": "Write \u00a72 Implementing Transport Objects",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/14",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Fill out the description of how a TAPS implementation represents Connections and Listeners and maps them to protocol entities",
      "createdAt": "2018-02-03T03:42:45Z",
      "updatedAt": "2018-03-02T01:05:23Z",
      "closedAt": "2018-03-02T01:05:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added text",
          "createdAt": "2018-03-02T01:05:23Z",
          "updatedAt": "2018-03-02T01:05:23Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUyOTQwODA3MDA=",
      "title": "Write \u00a73.1 Configuration-time errors",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/15",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain how to process application preferences should be treated when they have conflicts, etc. Probably error out immediately to avoid creating impossible connections.",
      "createdAt": "2018-02-03T03:43:52Z",
      "updatedAt": "2018-02-20T16:40:28Z",
      "closedAt": "2018-02-20T16:40:27Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I'm currently working on an initial version of the pre-establishment configuration in the API, see #2. \r\nI would be willing to contribute an initial version of this Section, which I think is related, e.g., how do we prioritize application requirements and preferences, what do we communicate back and when...",
          "createdAt": "2018-02-06T14:22:23Z",
          "updatedAt": "2018-02-06T14:22:23Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sold!",
          "createdAt": "2018-02-06T16:31:42Z",
          "updatedAt": "2018-02-06T16:31:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds perfect!",
          "createdAt": "2018-02-07T18:21:24Z",
          "updatedAt": "2018-02-07T18:21:24Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Pushed a first version. Comments welcome.\r\nI'm assuming \"Configuration-time\" is supposed to mean Pre-Establishment, as it is under that heading, even though (some) configuration can also happen later.\r\nThinking about different errors, I also included some errors that the transport system can only know about later. \r\nNote that we try to eliminate possible errors of \"Setting a property at the wrong time\" (e.g., Protocol Selection Property after Establishment) in the API.",
          "createdAt": "2018-02-15T13:01:50Z",
          "updatedAt": "2018-02-15T13:01:50Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No comments for a few days, so I'm closing this.",
          "createdAt": "2018-02-20T16:40:27Z",
          "updatedAt": "2018-02-20T16:40:27Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUyOTQwODA3NTI=",
      "title": "Write \u00a73.2 Role of system policy",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/16",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Describe the relationship between application preferences, system policies, and implementation defaults for connection management.",
      "createdAt": "2018-02-03T03:44:51Z",
      "updatedAt": "2019-03-05T21:58:43Z",
      "closedAt": "2018-02-23T18:24:01Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added some initial text in the document; please edit/change as needed.",
          "createdAt": "2018-02-19T23:29:52Z",
          "updatedAt": "2018-02-19T23:29:52Z"
        },
        {
          "author": "karlgrin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly Complemented and revised text.",
          "createdAt": "2018-02-23T15:04:30Z",
          "updatedAt": "2018-02-23T15:04:30Z"
        },
        {
          "author": "karlgrin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Currently, it says in Section 3.2 that \"In general, any protocol or path used for a connection must conform to all three sources of constraints. **Any violation** of **any of the layers** should cause a protocol or path to be considered ineligble for use. Isn't this a bit too stringent? Shouldn't there be some kind of scoring involved in the policy resolution process that ranks Protocol Stacks. The ranking would then determine how the racing is conducted.",
          "createdAt": "2018-02-23T15:09:11Z",
          "updatedAt": "2018-02-23T15:09:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the flexibility comes in if the policy of the system or requirements of the application are flexible\u2014prefer versus require. But if the application prohibits or requires something, or the system policy does, that must not be broken to avoid violating policy (which sometimes is a legal issue for the system).",
          "createdAt": "2018-02-23T18:23:19Z",
          "updatedAt": "2018-02-23T18:23:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for your update! I tweaked one word back (the implementation being responsible for balancing all three items (system policy, application requirements, and defaults), rather than system policy itself).",
          "createdAt": "2018-02-23T18:24:01Z",
          "updatedAt": "2018-02-23T18:24:01Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUyOTQwODA4MjE=",
      "title": "Write \u00a74.5 Establishing multiplexed connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/17",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Describe how multiplexing impacts connection establishment\u2014especially opening a new flow or stream on an established connection.",
      "createdAt": "2018-02-03T03:46:01Z",
      "updatedAt": "2018-02-09T13:42:44Z",
      "closedAt": "2018-02-09T13:42:44Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I could write some text for this based on minset - and I could also write some more text for the section on SCTP.   E.g., to support priorities between streams, in SCTP, one really should use message interleaving.",
          "createdAt": "2018-02-05T13:49:06Z",
          "updatedAt": "2018-02-05T13:49:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assigned! I'll also want to make sure we address the style of opening new streams for QUIC or HTTP/2 as a transport.",
          "createdAt": "2018-02-05T15:37:48Z",
          "updatedAt": "2018-02-05T15:37:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!  (and: of course, re: QUIC / HTTP/2)",
          "createdAt": "2018-02-05T16:33:46Z",
          "updatedAt": "2018-02-05T16:33:46Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWUyOTQwODA4Njg=",
      "title": "Write \u00a74.6 Handling racing with unconnected protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/18",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "adventureloop"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain how UDP is handled for racing/fallback (application or higher protocol probably needs to give guidance)",
      "createdAt": "2018-02-03T03:46:51Z",
      "updatedAt": "2018-02-21T12:48:17Z",
      "closedAt": "2018-02-21T12:48:17Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added some initial text in the document; please check, edit/change as needed!",
          "createdAt": "2018-02-19T23:29:33Z",
          "updatedAt": "2018-02-19T23:29:33Z"
        },
        {
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems to cover it",
          "createdAt": "2018-02-21T12:48:17Z",
          "updatedAt": "2018-02-21T12:48:17Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWUyOTQwODA4OTE=",
      "title": "Write \u00a74.7 Implementing listeners ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/19",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain how to begin passive listening on various protocols",
      "createdAt": "2018-02-03T03:47:22Z",
      "updatedAt": "2018-03-02T00:47:39Z",
      "closedAt": "2018-03-02T00:47:39Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Completed text",
          "createdAt": "2018-03-02T00:47:39Z",
          "updatedAt": "2018-03-02T00:47:39Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUyOTQwODA5NjU=",
      "title": "Write \u00a75.1 Data transfer mappings",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/20",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Describe how to map sending and receiving into various kinds of protocols (streams, datagrams, and framed messages)",
      "createdAt": "2018-02-03T03:48:28Z",
      "updatedAt": "2018-02-24T19:37:46Z",
      "closedAt": "2018-02-24T19:37:46Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Written in draft",
          "createdAt": "2018-02-24T19:37:46Z",
          "updatedAt": "2018-02-24T19:37:46Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWUyOTQwODEwMjU=",
      "title": "Write \u00a76 Implementing Maintenance Events",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/21",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain how to implement events for changes to a connection, and how to handle network changes (especially for multipath protocols)",
      "createdAt": "2018-02-03T03:49:25Z",
      "updatedAt": "2018-03-02T02:33:24Z",
      "closedAt": "2018-03-02T02:33:22Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Completed maintenance events",
          "createdAt": "2018-03-02T02:33:22Z",
          "updatedAt": "2018-03-02T02:33:22Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWUyOTQwODEwNzM=",
      "title": "Write \u00a77 Implementing Termination",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/22",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain how to handle application-intiated termination, and protocol stack-initiated termination. Explain impact of terminating a stream on a multiplexed connection.",
      "createdAt": "2018-02-03T03:50:20Z",
      "updatedAt": "2018-03-02T00:48:03Z",
      "closedAt": "2018-03-02T00:48:03Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wrote some text here. I'll leave the issue open so others can check if this is missing something. If you think this is good enough, please finish it off by removing the listed items / adjusting the text a little, and close this issue.",
          "createdAt": "2018-02-09T14:52:45Z",
          "updatedAt": "2018-02-09T14:52:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, will clean up in editorial pass.",
          "createdAt": "2018-03-02T00:48:03Z",
          "updatedAt": "2018-03-02T00:48:03Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWUyOTQwODExMTQ=",
      "title": "Write \u00a78 Cached state",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/23",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Explain cached state for both protocol states (TLS, DNS) and historical performance.",
      "createdAt": "2018-02-03T03:50:59Z",
      "updatedAt": "2019-03-05T21:58:44Z",
      "closedAt": "2018-02-27T17:19:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added an initial pass to the document; feel free to edit/change as needed!",
          "createdAt": "2018-02-19T23:28:49Z",
          "updatedAt": "2018-02-19T23:28:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "I pushed a small change -- let me know what you think!",
          "createdAt": "2018-02-21T16:22:18Z",
          "updatedAt": "2018-02-21T16:22:18Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me, thanks!",
          "createdAt": "2018-02-21T16:49:28Z",
          "updatedAt": "2018-02-21T16:49:28Z"
        },
        {
          "author": "karlgrin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly I think I was supposed to write this section, however, it seems in large part to be completed. Would like to discuss what is missing. Personally, I think 'cache lifetime' is one issue missing.",
          "createdAt": "2018-02-22T10:31:22Z",
          "updatedAt": "2018-02-22T10:31:22Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@karlgrin, feel free to add to the text. ",
          "createdAt": "2018-02-22T13:45:53Z",
          "updatedAt": "2018-02-22T13:45:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great point about cache lifetime, yes.",
          "createdAt": "2018-02-22T15:41:30Z",
          "updatedAt": "2018-02-22T15:41:30Z"
        },
        {
          "author": "karlgrin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly Written some text on cache lifetime, however, I believe this needs to be discussed further. I don't really know if any more concrete guidelines could be given. Your input would be much appreciated.",
          "createdAt": "2018-02-27T09:37:56Z",
          "updatedAt": "2018-02-27T09:37:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@karlgrin Thanks! I agree with your general approach in this text. I moved the order of the sentences a bit, but other than that I think this is good for -00.",
          "createdAt": "2018-02-27T17:19:41Z",
          "updatedAt": "2018-02-27T17:19:41Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWUyOTQwODExNzI=",
      "title": "Write \u00a79 Specific Transport Protocol Considerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/24",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Explain specific concerns for given protocols, likely based on survey and minset. Anything from minset that isn't covered by earlier sections or the API explicitly should be mentioned here.",
      "createdAt": "2018-02-03T03:52:05Z",
      "updatedAt": "2018-02-25T22:11:14Z",
      "closedAt": "2018-02-25T22:10:54Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Written in draft.",
          "createdAt": "2018-02-24T19:10:36Z",
          "updatedAt": "2018-02-24T19:10:36Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly thanks for filling this in. I do not understand the part about partial messages and marking the message complete for TCP though. I do not think we have the matching parts in the API? Also do not understand the part about \"closing the sending stream\" for TCP.  Close will currently close the connection in both directions.",
          "createdAt": "2018-02-25T21:04:47Z",
          "updatedAt": "2018-02-25T21:04:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated the text to indicate that the Close does send a FIN (without saying this is specifically a half-close), and explained how multiple parts of the total message are sent.",
          "createdAt": "2018-02-25T22:10:54Z",
          "updatedAt": "2018-02-25T22:10:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll double check the API to make sure it has the right send parameters; if not, I'll open an issue.",
          "createdAt": "2018-02-25T22:11:14Z",
          "updatedAt": "2018-02-25T22:11:14Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWUyOTQwODEyMzI=",
      "title": "Write \u00a710 Rendezvous and Environment Discovery",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/25",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Explain the phase of discovery interfaces and endpoints to use for service discovery and peer to peer use cases. This section would likely benefit from moving earlier in the document. ",
      "createdAt": "2018-02-03T03:53:10Z",
      "updatedAt": "2018-03-01T12:57:43Z",
      "closedAt": "2018-03-01T12:57:43Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWUyOTQzMzg3NzE=",
      "title": "Enable CI for gh-pages",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/26",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [],
      "body": "Choose travis or circleci and set up automatic regeneration of previews on push to master",
      "createdAt": "2018-02-05T10:16:06Z",
      "updatedAt": "2018-02-06T07:34:07Z",
      "closedAt": "2018-02-06T07:34:07Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "will do this on travis; waiting for travis to notice that i've added the taps-api org, sigh...\r\n",
          "createdAt": "2018-02-06T07:11:14Z",
          "updatedAt": "2018-02-06T07:11:14Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yay it's doing something....",
          "createdAt": "2018-02-06T07:34:07Z",
          "updatedAt": "2018-02-06T07:34:07Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUyOTQ4NDc0NjA=",
      "title": "Cross Referencing between Resolving Remote Endpoints and Connection establishment",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/27",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "Resolving Remote Endpoints may result in different stack configurations - add reference to Connection Establishment and how to retrieve the protocol stack actually provided",
      "createdAt": "2018-02-06T17:32:25Z",
      "updatedAt": "2018-02-15T15:36:25Z",
      "closedAt": "2018-02-15T15:36:25Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- Isn't resolving remote endpoints a sub-step of Connection Establishment\r\n\r\n- Yes, the resolution can definitely lead to different stacks. It's a good point that you need to be able to introspect what you actually used to connect.",
          "createdAt": "2018-02-07T18:18:57Z",
          "updatedAt": "2018-02-07T18:18:57Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I wrote in the respective resolving section that the actual resolving MAY be deferred until connection establishment (might also be done immediately to save time) \u2013 so Yes and No\r\n- Still thinking whether we should rename \"Resolving Remote Endpoints\" to \"Specifying Remote Endpoints\r\n- I am not sure whether this is \"just\" introspect or something more explicit, e.g. a parameter to the connection event. \r\n   - If we can flag framers with protocols/features in pre-establishment, I think introspection is sufficient\r\n   - If we add framers _after_ connection establishment, we should make the protocols chosen more explicit.",
          "createdAt": "2018-02-08T08:14:06Z",
          "updatedAt": "2018-02-08T08:14:06Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest that \"specifying a remote endpoint\" is a different operation to \"resolving a remote endpoint\". You could specify an endpoint using a name that you can't directly connect to (e.g., a DNS name), and that may need to be resolved to find usable, concrete, names that can be used for a connection (e.g., resolving the DNS name to a set of IP addresses).\r\n\r\nDepending on what a name resolves to, might affect how the connection is established. The resolution conceptually happens before connection establishment, although a practical implementation might combine them.",
          "createdAt": "2018-02-08T17:32:36Z",
          "updatedAt": "2018-02-08T17:32:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So then we rename the Section to \"\"Specifying Remote Endpoints\".\r\n\r\nI suspect there should be no \"resolving a remote endpoint\" in the API because this is an implementation issue and not directly exposed though the API",
          "createdAt": "2018-02-08T20:23:22Z",
          "updatedAt": "2018-02-08T20:23:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to calling this \"specifying endpoints\".\r\n\r\nIt seems like there should be something either here or in the references about certain \"kinds\" of endpoint specifier / transport parameter combinations being necessary for each kind of initiation. The split between these requirements might be enough to turn Endpoint back into Remote and Local, but I'll wait for all the pending issues on the API to be closed, and if this still bothers me I'll file a new issue. ",
          "createdAt": "2018-02-12T16:34:49Z",
          "updatedAt": "2018-02-12T16:34:49Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok \u2013 this issue has become a collection of various resolving issues that have been fixed now.\r\n\r\nClosing this for now and creating Issue #47 for stack and pseudo-transport issues",
          "createdAt": "2018-02-15T15:36:09Z",
          "updatedAt": "2018-02-15T15:36:09Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUyOTUxNDkzMTk=",
      "title": "Prioritization among Transport Parameters in the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/28",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API"
      ],
      "body": "(How) Should an application be able to prioritize between Transport parameters, especially Protocol Selection Properties?\r\nSection 5.2.1 currently defines Reliability and in-order delivery as \"strict requirements\", since not providing this when an application depends on it would be bad, as explained in 5.2. Other properties are mostly \"not a strict requirement\".\r\nNow we could additionally have an explicit prioritization by the application for the \"non-strict requirements\", and/or to let the application specify that it absolutely requires a certain property, even though it is marked as \"not a strict requirement\" in the draft.\r\nWhat do you think?",
      "createdAt": "2018-02-07T14:04:51Z",
      "updatedAt": "2018-02-13T10:41:00Z",
      "closedAt": "2018-02-13T10:41:00Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A prioritization scheme could get very complicated =) If an implementation needs that, that may be better as an extension?\r\n\r\nWhat you can do is have different levels of requirement:\r\n- Require (fail if you can't do this)\r\n- Prefer (try to do this, but don't fail if you can't)\r\n- Avoid (try not to do this, but don't fail if you can't)\r\n- Prohibit (fail if you can't not do this)\r\n\r\nThe path you select is the one that meets requirements and prohibitions, and the most number of met preferences/avoidances. That's worked for us =)",
          "createdAt": "2018-02-07T18:30:57Z",
          "updatedAt": "2018-02-07T18:30:57Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, different levels of requirements are what we were aiming for. :)\r\nI just discussed this with Philipp and we propose the following:\r\nInstead of passing properties in the Create() call, make a SetRequired(),SetPreferred() and SetIntention() call which sets these properties. \r\nAvoid and Prohibit would then be a SetPreferred() or SetRequired() of the negated property, so we would add an \"Unreliable Data Transfer\" property next to the \"Reliable Data Transfer\". Not all properties make sense in their negation, e.g., \"I prohibit having the option to disable the send checksum\" is not a property I would add.\r\nDoes the above make sense to you? In that case I'd update Section 5.2 accordingly.\r\n\r\nNote that this could lead to a situation where an application requests \"Reliable Data Transfer\" only as Preferred, not as Required. This might even make sense in case the application has a congestion control mechanism of its own, but would also be okay with using TCP. On the other hand, I'm not yet convinced that we should get rid of the inherent prioritization of, e.g., Reliability over other properties.",
          "createdAt": "2018-02-08T13:00:15Z",
          "updatedAt": "2018-02-08T13:23:30Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not fully convinced about splitting this up in multiple calls for required and preferred properties. I think it may be simpler to just allow setting a property to required or preferred in the same call.\r\n\r\nIf required or prohibited properties can not be met that represents a failure. How to deal with preferred properties I think is up to the implementation of the transport system and may also depend on configured policies. I do not think the application should be able to prioritize between properties, beyond setting requirements and preferences.\r\n ",
          "createdAt": "2018-02-08T14:31:38Z",
          "updatedAt": "2018-02-08T14:31:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I am not fully convinced about splitting this up in multiple calls for required and preferred properties. I think it may be simpler to just allow setting a property to required or preferred in the same call.\r\n\r\n+1. this seems like a... property of the property. (we'll want better terminology, of course)",
          "createdAt": "2018-02-08T14:57:43Z",
          "updatedAt": "2018-02-08T14:57:43Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Theresa talked about that for quite a while.\r\n\r\nFirst, I want to make sure that we agree on some things:\r\n- The same property can be specified with different \"priorities\", e.g., \"Unreliable Transmission\" might be \"preferred\" or \"required\"\r\n- Rather than \"required x\" and \"required that not x\", we have two properties \"x\" and \"un-x\"\r\n\r\nI am of the opinion that SetProperty($prio, property, value) and  SetProperty$Prio(property, value) with $prio in (required, desired, intent) only differ in terms of syntactic sugar.\r\n\r\nThe advantage of the latter is that it feels less awkward if used with a dictionary containing (property, value) pairs instead of using a bunch of SetProperty calls.\r\n",
          "createdAt": "2018-02-08T16:09:13Z",
          "updatedAt": "2018-02-08T16:09:13Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've thought about this a bit more and I think assigning a \"priority\" (required, preferred, avoided, prohibited) to each property, with sensible default priorities, is also a good way to do this. This way, we avoid having to duplicate properties as \"x\" and \"un-x\", which may be confusing.\r\nHowever, \"priority\" sounds too much like a more fine-grained differentiation, which I agree would be too much for this API, and also it doesn't imply that the value of this property can also be \"avoid\" and \"prohibited\". \r\nI'm trying to come up with a better term. Maybe something more along the lines of \"purpose\" or \"meaning\", i.e., \"how to interpret this property\"? But that's confusing as well.\r\nAlternatively, if we have only one call to set properties, we could have different parameters within the call, like Connection.SetProperties(require=[...], prefer=[...], avoid=[...], prohibit=[...]). Then we don't have to name whatever is the general term for \"required\", \"preferred\", \"avoided\", and \"prohibited\". But also then the application has to decide where to sort each property... :/",
          "createdAt": "2018-02-08T16:53:35Z",
          "updatedAt": "2018-02-08T16:55:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, let's not use Priority for this\u2014if anything, it should be Preference.\r\n\r\nI think of, for path properties, an application setting its preference for Cellular interfaces. \"I require a cellular interface type\", \"I prohibit a cellular interface type\", \"I avoid cellular interface types\".\r\n\r\nAlso, note that these shouldn't necessarily be set directly on the Connection. We use a separate parameters/properties object, so you could configure a set of properties once, and then apply it to multiple connections if needed.",
          "createdAt": "2018-02-08T16:56:43Z",
          "updatedAt": "2018-02-08T16:56:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like Preference (FWIW). I'm still a little worried about the complexity of all of this...",
          "createdAt": "2018-02-08T17:06:29Z",
          "updatedAt": "2018-02-08T17:06:29Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed on the complexity. I think the approach for the API should aim to be as simple as possible. Having an enumeration of how to have a preference is useful as a tool for writing the API for various Protocol Selection and Path Selection properties, but the basic set of these properties should be kept tight and small for the first cut.",
          "createdAt": "2018-02-08T17:09:16Z",
          "updatedAt": "2018-02-08T17:09:16Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Very much agree on the issue of complexity and keeping the basic set small! An implementation can then add as many properties as it wants as long as it has matching policies and machinery to do something useful with them.",
          "createdAt": "2018-02-08T17:17:04Z",
          "updatedAt": "2018-02-08T17:17:04Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - then let us get the framework right and just have a very basic set of properties here.\r\n- One basic operation --- connection.setTransportParameters(preference, parameter, [value])\r\n- A very basic set of parameters to get an impression how this is used\r\n- Make explicit what can be set in pre-establishemnt and what afterward\r\n- Merge / Streamline with other mechanisms (e.g. specifying remote endpoints)\r\n \r\nAfterwards we can externalise most parameters derived from minset and socket intents into a separate document.\r\n\r\n**Question to all:** should we use methods of a Connection to set-up everything in pre-establishment or should we have an endless list of stuff to pass to the Connection constructor?\r\n",
          "createdAt": "2018-02-08T20:49:47Z",
          "updatedAt": "2018-02-08T20:49:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the plan up to the part where it says \"...into a separate document\". Either way we need to agree on the parameters.  Putting the parameters in a separate document doesn't help - in my opinion the current structure is really good!  Let's please not start creating other documents now!\r\n\r\nOne basic operation to set all the parameters seems good; we have the same in NEAT  (we call it \"setProperties\", and then there's a list of properties that this can set; the property list isn't contained in the draft https://tools.ietf.org/html/draft-fairhurst-taps-neat-00 - generally, I think the related public deliverable is a better reference, it's slightly more complete:  https://www.neat-project.org/wp-content/uploads/2015/05/D1.3.pdf  ).\r\n\r\nAbout the \"endless list of stuff\": the list will be a bit shorter when I'm done with it  :-)   but... well I guess my vote goes to giving it all to the constructor.",
          "createdAt": "2018-02-08T21:58:41Z",
          "updatedAt": "2018-02-08T21:58:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that we don't want a separate socket intents document (also, we really need to ditch the name socket-intents, since sockets aren't relevant here).\r\n\r\nWe should define the basic, tight set of properties we want and have them in the main API document. And also define how to extend them.",
          "createdAt": "2018-02-08T22:00:09Z",
          "updatedAt": "2018-02-08T22:00:09Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- After my or Theresas next pass, it is socket intents will be gone and replaced by \"application intents\" - already agreed on\r\n- Regarding the property descriptions:\r\n   - I don't think the Application Intents are not the majority of properties - there are much more derived from minset. \r\n   - The question is whether we want to keep them here and in-line, appendix or in a separate document. I fear when we have a reasonable description, this will become quite lengthy.\r\n       - whether they are path selection / protocol selection / both aforementioned / application intents / protocol tuning properties. \r\n      - Whether you can require them\r\n      - In which phase they can be use\r\n- I don't like having a \"property container object\" which we can pass to the constructor, neither do I like passing all properties as VA_ARGS. \u2013 Therefore connection.setProperties() feels right.\r\n- Passing \"endpoint objects\" to the constructor also feels right. \r\n- If we want to normalise the style of the API, either of them has to change. ",
          "createdAt": "2018-02-09T08:52:11Z",
          "updatedAt": "2018-02-09T08:52:11Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the current structure is good and would be against a separate document. \r\nAs the audience for the API draft would be application developers, let's specify what they would need to know to use this API, and put implementation considerations etc into the implementation draft. I hope by doing this we can keep it short enough.\r\n\r\nAbout the call structure, I prefer having one call that sets all properties at once to several calls which each set one property. I'm fine with a container object, since it is easier to clone and modify than a list.",
          "createdAt": "2018-02-09T09:03:21Z",
          "updatedAt": "2018-02-09T09:08:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the idea of an appendix. What about presenting and discussing (as concisely as possible, of course) all the parameters that we want to have in the main text, and then adding an appendix that clarifies in which phase they can be used, whether they can be required, etc., with a table?",
          "createdAt": "2018-02-09T09:40:51Z",
          "updatedAt": "2018-02-09T09:40:51Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me. :)",
          "createdAt": "2018-02-09T09:42:08Z",
          "updatedAt": "2018-02-09T09:42:08Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Drafting the appendix.",
          "createdAt": "2018-02-09T13:05:00Z",
          "updatedAt": "2018-02-09T13:05:00Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added a first version of the preferences table.\r\nThe current values are just a suggestion - first I was sure that prohibiting to control checksum coverage did not make any sense at all, then I thought how it might affect an application if the other side was allowed to control checksum coverage and how maybe an application developer would like to prevent that. Feedback in appreciated. \r\nIf you agree with the current preferences in principle, we could also close this issue, I think.",
          "createdAt": "2018-02-12T13:28:32Z",
          "updatedAt": "2018-02-12T13:29:03Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the table a lot.\r\n\r\nI see a problem with not being able to change Path Selection Properties if we want to support all use-cases of connection migration and multipath \u2013 open Issie #38 for that.",
          "createdAt": "2018-02-12T19:31:23Z",
          "updatedAt": "2018-02-12T19:31:23Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to I'm a fan of the table; see also a comment in #34 about how to realize this in the API.\r\n\r\nClosing this since it seems we've moved on to other issues.",
          "createdAt": "2018-02-13T10:41:00Z",
          "updatedAt": "2018-02-13T10:41:00Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUyOTUxNTUxMzA=",
      "title": "API: Add Section for Configuration and Querying parameters after establishment",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/29",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API"
      ],
      "body": "Section 5.2 currently includes Connection.QueryProperties(), but it belongs to the Pre-Establishment Phase. At this point, most Protocol Properties are not available to be queried yet. So the current version of 5.2.2 only includes \"Maximum Message Size Before Connection Establishment\", as this clearly belongs in the Pre-Establishment phase.\r\nThere should probably be a \"Configuration\" section or similar that specifies what Protocol Properties can be queried (and set?) after establishment. Maybe the Protocol Properties should even be moved there altogether, but I like them in the Pre-Establishment section, because this makes it clear that applications should specify them as early as possible.",
      "createdAt": "2018-02-07T14:21:42Z",
      "updatedAt": "2018-02-15T14:04:09Z",
      "closedAt": "2018-02-15T14:04:09Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few thoughts on the architecture implications of the properties here:\r\n\r\n- Any properties that determine protocol or path selection, or need to be known at protocol handshake time, MUST be part of Pre-Establishment\r\n- The set of protocol properties that may be set after establishment is a smaller set of knobs, and includes the per-send/receive options\r\n- Querying parameters can reflect what was originally set on the connection; which is separate from what options are currently active. Getting both is useful.\r\n\r\nThe way I've built this currently is:\r\n\r\n1. During Pre-Establishment, there is a large parameters object, which includes various protocol selection properties and protocol-specific options. Each protocol can define extensions to their own protocol options. At any point, the application can retrieve this original parameters object.\r\n\r\n2. There is a separate protocol metadata object that defines the post-establishment state and knobs. This protocol metadata may be attached to a Send(), retrieved from a Receive(), or queried directly on a connection object outside of the data path once the connection is established. Any properties of the protocol that are eligible to be modified post-connection have knobs here. It is possible that some knobs show up in both pre-establishment and post-establishment, but one is explicitly intended to drive protocol and path selection, while the other is more about dynamic behavior.",
          "createdAt": "2018-02-07T18:27:30Z",
          "updatedAt": "2018-02-07T18:27:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So whatever the application configures later on a socket is only advisory anyway - too late to make strict requests. Hence we could perhaps simply say, in this document, that ALL protocol parameters are available for later configuration of a Connection (and implementations may choose to limit this to a subset). What do you think?",
          "createdAt": "2018-02-08T17:20:37Z",
          "updatedAt": "2018-02-08T17:20:37Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really don't like the idea that all properties are available to change in the API after establishment, with the assumption that most of them do nothing or have undefined behavior.\r\n\r\nIf I say pre-establishment, \"I prohibit cellular interfaces\", and then later the API lets me express, \"I require cellular interfaces\"... what happens? You'll just ignore my requirement? Or the connection will suddenly fail?\r\n\r\nIf I say pre-establishment, \"I allow unreliable transports\", and then later the API lets me express, \"I require reliable transports\"... what happens? We fail the connection if we chose UDP?\r\n\r\nI don't see any value in letting most properties be reset.",
          "createdAt": "2018-02-08T17:24:17Z",
          "updatedAt": "2018-02-08T17:24:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "okay, that was just an idea for a possible easy way out  :-)\n\nSent from my iPhone\n\n> On 8 Feb 2018, at 18:24, Tommy Pauly <notifications@github.com> wrote:\n> \n> I really don't like the idea that all properties are available to change in the API after establishment, with the assumption that most of them do nothing or have undefined behavior.\n> \n> If I say pre-establishment, \"I prohibit cellular interfaces\", and then later the API lets me express, \"I require cellular interfaces\"... what happens? You'll just ignore my requirement? Or the connection will suddenly fail?\n> \n> If I say pre-establishment, \"I allow unreliable transports\", and then later the API lets me express, \"I require reliable transports\"... what happens? We fail the connection if we chose UDP?\n> \n> I don't see any value in letting most properties be reset.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-02-08T18:00:37Z",
          "updatedAt": "2018-02-08T18:00:37Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with Tommy - it makes no sense to allow these kinds of severe configuration errors in the API.\r\nAs protocol and path selection happen with connection establishment, I think both Protocol Selection Properties and Path Selection Properties should not be possible to change afterwards, only queried what was originally specified. On the other hand, Protocol Properties (not Selection, but configuration of the connection) and Intents can also be set later, either on the connection or on the individual Content. \r\nProtocol Properties are now spread across Section 5.2.2 (applied to Connections and Connection Groups) and 7.1 (applied to Content). I think this is fine. So maybe we do not need a Configuration section of its own in this draft after all.\r\nIn Issue #28 we came up with the idea of putting some information about properties, e.g., in which phase should they be set and whether they can be marked as \"required\", into the appendix. I think we could add content from this issue, like \"Protocol Selection properties can only be queried after Create(), while Protocol Properties can be set\" to that same appendix.",
          "createdAt": "2018-02-09T10:01:03Z",
          "updatedAt": "2018-02-09T10:01:03Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Talking about this with Philipp, we found that it might make sense to allow setting a Path Selection Property even after connection establishment in case a multi-path protocol is being used. Not in the sense of \"first I prohibit cellular, then I require cellular\", which would still be a configuration error. But we see a case where the application first does not specify any path selection properties, an MPTCP connection is established with one subflow over cellular, one over another interface. Then it might make sense for the application to specify per-Content that some Content should not go over the cellular.\r\nAs I see it, the alternative would be to model the MPTCP connection as a connection group and the subflows as connections, so the application can send the \"prohibit cellular\" content over the non-cellular connection, which we chose not to do in #31, or to not have this option at all.",
          "createdAt": "2018-02-09T15:52:49Z",
          "updatedAt": "2018-02-09T15:52:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point you make about MPTCP is potentially a use case (generally, I want to specify which policies I want for interface usage by MPTCP up front), but I think it only emphasizes the point I made before that we must separate out very specifically the properties set during pre-establishment from those after.\r\n\r\nThere is a large set of properties to be set at pre-establishment, around both path and protocol selection, and general protocol properties. In most cases, most of these properties are not eligible to be changed later. Thus exposing them in the same form later in a generic way will only lead to API misuse.\r\n\r\nFor the case of MPTCP, the fact that it may or may not be able to send certain data over certain sub flows going over interfaces is an advanced and optional feature of a specific transport protocol. This should be expressed, as I listed before, as per-content protocol metadata to influence the transport protocol that was selected. This may look like it overlaps with the properties set during pre-establishment, but from the application's view, it is now setting a specific MPTCP-send-property, rather than a connection-establishment-property. These are two very different namespaces, and we must leave them separate.\r\n\r\nIf we are not rigorous about being clear where properties are applicable, we are liable to design an API that either is non-deterministic based on which transports are selected or is full of knobs that must have detailed documentation about effects in different use cases. Better to have a fool-proof way of specifying things that focuses on making the general path as simple and transport-independent as possible.",
          "createdAt": "2018-02-09T16:16:51Z",
          "updatedAt": "2018-02-09T16:16:51Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, and I wrote a corresponding paragraph in Appendix A.2 of the current API draft.\r\n\r\nSo if we are not going to have a separate Configuration/Querying/Maintenance section, we can close this issue, right?",
          "createdAt": "2018-02-12T13:33:26Z",
          "updatedAt": "2018-02-12T13:33:26Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO the MPTCP example illustrates that this isn't the right way to split up connection properties post-establishment. Let me suggest a different way to split this up (which might feed back into the architecture document, not sure yet):\r\n\r\n- A Connection is configured with a set of properties, each bound to a preference (\"require\", \"prohibit\", \"prefer\", \"avoid\") before establishment. Until establishment, this connection is essentially *just* a container for its endpoint specifier(s) and properties. \r\n\r\n- Once a Connection is established, it is bound to one or more Protocol Stacks, some of which may disappear after racing is complete. Each of these protocol stacks also has properties, expressed in the same vocabulary, but without the preference bindings. For logging and cloning purposes, the Connection still maintains a read-only reference to its pre-establishment properties. \r\n\r\n- Each Protocol Stack also has a set of Properties, which correspond to the properties it can provide and/or has been configured with. These are defined in terms of the same vocabulary provided for pre-establishment, but are not associated with preferences. Some of these properties may be writable after (indeed, the post-establishment writability of a given property may itself be a transport property)\r\n\r\n- Each Protocol Stack is bound to one or more Paths. Paths may also have properties,  derived from the local provisioning domain, online measurement done by the protocol stack, or other sources. Path properties are mainly made accessible to the application for logging purposes.\r\n\r\nThe key idea is that pre-establishment and post-establishment properties are fundamentally differently organized, though expressed using the same vocabulary, because they refer to fundamentally different views of similar (but not the same) concepts.",
          "createdAt": "2018-02-12T13:52:57Z",
          "updatedAt": "2018-02-12T13:52:57Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do think we at least want a separate \"querying\" section -- some applications are going to want to know about the performance parameters of the machinery underlying the connections (these would be path properties in the treatment above).",
          "createdAt": "2018-02-12T13:55:00Z",
          "updatedAt": "2018-02-12T13:55:00Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with expressing pre-establishment and post-establishment properties using the same vocabulary but organizing them differently, i.e., separating them in the API. That's what I was going for in Appendix A.2, perhaps we should refine this further.\r\nSo if I understand your suggestion correctly, we would have:\r\n\r\n- Connection objects, which have transportParameters representing the application's requirements and preferences, which can only be set pre-establishment.\r\n- protocolStack objects, which have properties expressing what their protocols \"can do\", i.e., which Protocol Selection Properties they match, what transport features they have. We could name these properties protocolFeatures. They would be expressed in the same language as Protocol Selection Properties, but not have \"require\"/\"prefer\"/\"avoid\"/\"prohibit\", but just a Boolean \"True\"/\"False\" whether they support the given feature. These properties are probably static and the application can only read them to find out what a certain protocolStack is capable of.\r\n- protocolStack objects also have protocolProperties representing the actual configuration of the protocols, with defaults (e.g., connection timeout for the TCP protocolStack object). At establishment time, these protocolStack objects are bound to the Connection, and the protocolProperties that the application specified pre-establishment are set on these protocolStacks, if applicable. Additionally, protocolProperties can be changed post-establishment.\r\n- path objects, which have pathProperties. I agree that we need this and the application should be allowed to query them at any time. Intuitively, I would think that they are bound to the Connection at establishment time, to reflect the finally chosen path(s). Why bind them to the protocolStack instead?\r\n\r\nI'm not yet sure where Intents fit in this, which I guess relates to our discussion in #34. ",
          "createdAt": "2018-02-13T12:56:12Z",
          "updatedAt": "2018-02-13T12:57:40Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just updated the Appendix A.2 with some text and a table that makes the different types of properties clear: What objects they apply to, when they can be set, and when they can be queried.\r\nI split Protocol Stack into an abstract \"Protocol Stack\" representing the protocol in general and a \"Protocol Stack Instance\" representing the protocol as it is actually used in the Connection. I felt like I needed some separation here because it became awkward to always talk about \"properties of the protocol in general\" vs. \"properties that we configure\". Feel free to discuss.\r\n\r\nIn this table, Intents are either per-Connection Transport Parameters, or some of them might also become sendProperties.\r\n\r\n\"Connection\" for the Transport Parameters may become \"Connectable\" depending on #42. \r\n\r\nAdditionally, I removed some default preferences in the table in A.1 because I think it doesn't make sense to have the TAPS system prefer protocols with certain features by default if the application never expressed a wish to have these features. So essentially the defaults for an application that does not specify any Transport Parameters are now just \"Require Reliable Data Transfer and In-order delivery\".",
          "createdAt": "2018-02-14T15:40:14Z",
          "updatedAt": "2018-02-14T15:40:14Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to write a first version of that Querying Section and name it \"Maintenance\" for now.",
          "createdAt": "2018-02-15T13:16:11Z",
          "updatedAt": "2018-02-15T13:16:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "please be brief, we're trying to wrap up work on this to get a -00 out the door early next week, and @mwelzl and I still need to coordinate the review passes...",
          "createdAt": "2018-02-15T13:17:42Z",
          "updatedAt": "2018-02-15T13:17:42Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done. Kept this brief, so there is just one getProperties() call for now, but we could also have one for each type of property given there.\r\nIf this is compatible with #46, we can close this issue for now, I think.",
          "createdAt": "2018-02-15T14:00:36Z",
          "updatedAt": "2018-02-15T14:00:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2018-02-15T14:04:09Z",
          "updatedAt": "2018-02-15T14:04:09Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUyOTU0NDI4OTQ=",
      "title": "Fix \"Close\" and \"Abort\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/30",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "We had long discussions about \"Close\" and \"Abort\" in NEAT, considering what these primitives mean for TCP, UDP, SCTP, *and* SCTP streams. As these definitions stand, they are not right - the \"Close\" definition implies support of half-closed connections, which aren't very useful and not supported by all protocols. The \"Abort\" definition indicates that the remote endpoint is notified, but that should also (or, \"no less\") be the case with \"Close\"; the difference can really only be that \"Close\" will try to deliver remaining data that a sender has in its stack, whereas \"Abort\" won't. We can discuss these at length if you want to re-iterate... I think I have slides from a project meeting summarizing the discussion.\r\n\r\n\r\nAnyway, My proposed definitions are:\r\n\r\nClose is the action an application may take on a Connection to indicate that it no longer intends to send data and will not be willing to receive data, and that the protocol should signal this state to the remote endpoint if applicable.\r\n\r\nAbort is the action an application may take on a Connection to indicate that it no longer intends to send data and will not be willing to receive data, that it does not need the transport system to continue trying to deliver any outstanding data, and that the protocol should signal this state to the remote endpoint if applicable.\r\n",
      "createdAt": "2018-02-08T09:38:52Z",
      "updatedAt": "2018-02-08T16:42:51Z",
      "closedAt": "2018-02-08T16:42:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like these new definitions a lot! I think they better express what we actually do, as well. I'll incorporate into the document.",
          "createdAt": "2018-02-08T15:28:18Z",
          "updatedAt": "2018-02-08T15:28:18Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Incorporate into the architecture doc!",
          "createdAt": "2018-02-08T16:42:51Z",
          "updatedAt": "2018-02-08T16:42:51Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWUyOTU0NDQ0OTM=",
      "title": "\"Connection Group\" should be an Object",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/31",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "... I think. Right now it's only written as a Transport System implementation concept, tied to multiplexing - but it does have a meaning for an application developer.\r\n\r\nProposed definition:\r\n\r\nConnection Group\r\n\r\nA Connection Group is a set of Connections which are entangled: they share the same properties, and changing properties for one of them influences the others. To influence how network capacity is divided, an application can assign priorities to individual Connections within a Connection Group.",
      "createdAt": "2018-02-08T09:43:56Z",
      "updatedAt": "2018-02-08T16:42:27Z",
      "closedAt": "2018-02-08T16:42:27Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I know we had discussed this at the meeting. I don't agree that the Connection Group is a fundamental object. It may be an \"object\" in the code-based API that can be introspected and used for relating connections, but the objects in the architecture are the fundamental things you operate on. You don't ever read or write, or start, a connection group (in my mind).\r\n\r\nConnection Group is a Concept right now in the implementation section; I could also see it being an attribute in the Pre-Establishment, like a \"Connection Group ID\" to be a tag to tie connections together.\r\n\r\nAlso, with regards to priority, I think we can assign priorities to connections regardless of their being in a group. If I as an applications set certain priority values, like Priority 1 on Connections A and B, Priority 7 on Connection C, and Priority 20 on Connections D and E, I've expressed relative priority that can apply if they are grouped into a multiplexed transport, but also priority that will help in the IP-level interface queues on my device. Priority SHOULD NOT be expressed only in connection groups, since it is more broadly useful.",
          "createdAt": "2018-02-08T15:33:58Z",
          "updatedAt": "2018-02-08T15:33:58Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, maybe we didn't finish the discussion... or it's my memory...\r\n\r\nSo let's see. Your first two paragraphs, I agree with (indeed, you don't write to a connection group). About the last paragraph, I agree that priority should not *only* be expressed in connection groups - e.g. it can affect a DSCP setting. However, a connection group can allow you to precisely (when you're lucky and there is e.g. multiplexing available) assign a capacity share to connection within that group. Sure, some things are generally more important than others - but that's a different thing from requesting to divide the capacity, e.g. 5:1:1 between 3 connections.  I do think this is a valuable piece of functionality that we don't want to take away.\r\n\r\nNow, if this warrants connection groups being a concept in the architecture or not, I'm not sure... visible and controllable in the API, for sure.",
          "createdAt": "2018-02-08T16:10:05Z",
          "updatedAt": "2018-02-08T16:10:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, good point for the sharing (5:1:1). For this, it would make sense to have an API to give the balance if applicable. I do see those as APIs to tweak behavior either before establishment, or during the connection, to say \"when multiplexing, divide the work like this\". My concern with adding that into the fundamental architecture concepts is that the method for these options is not very generic (doesn't apply to single stream protocols) and may not have the same meaning across different multi-streamed protocols. QUIC may have different multiplexing knobs from HTTP/2, from SCTP, etc.",
          "createdAt": "2018-02-08T16:32:59Z",
          "updatedAt": "2018-02-08T16:32:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Got it - fine by me to not put it in the architecture, then. These API tweaks, I already included in the API doc.",
          "createdAt": "2018-02-08T16:42:17Z",
          "updatedAt": "2018-02-08T16:42:17Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUyOTU0ODYwNDQ=",
      "title": "7.1.2 Niceness seems awkward - tie to Connection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/32",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\"Niceness represents an unbounded hierarchy of priorities of Content, relative to other Content sent over the same Connection and/or Connection Group\". Let's consider \"Connection\": then this is about assigning a higher priority to a piece of Content than to a previously submitted piece of Content? What, to be sent earlier? This is re-scheduling inside the send buffer - generally, there are two ways to do these things: 1) complex, inside the send buffer; 2) more flexible, by allowing the application to manipulate its data until the last minute and be informed about the buffer running dry. I think we should definitely prefer the latter.\r\n\r\nAbout other content within the same Connection Group: I could see a possibility of implementing a per-Content Niceness value here, by continuously changing the priority assigned to a connection in a group.\r\n\r\nFinally, \"Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.\"  => priorities on the wire: would this control the DSCP? But I think we have clear advice to not permanently change the DSCP on the same connection.\r\n\r\nTo conclude, I think the idea of per-Content Niceness should be dropped, and Niceness should only be assigned to a connection.\r\n\r\nFinally, I'm not a fan of the \"Niceness\" term. Priority seems clearer and easier to me, while I see \"niceness\" as  a Unix artifact...  but that's a matter of taste.",
      "createdAt": "2018-02-08T11:59:43Z",
      "updatedAt": "2018-02-08T17:08:28Z",
      "closedAt": "2018-02-08T17:08:28Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the name \"Niceness\" is a Unix artefact. But its usage hides an important design decision:\r\n- Should a transport API allow to request priority above-normale using this mechanism.\r\n   - Niceness implicitly prohibits that\r\n   - Priority implies to me this would be possible",
          "createdAt": "2018-02-08T13:04:08Z",
          "updatedAt": "2018-02-08T13:04:08Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The scope is a single connection/connection group so I do not think that a priority above-normal would be a problem, so I prefer priority. \r\nBut also not sure that we need this feature. I think having priority on a connection level is sufficient.",
          "createdAt": "2018-02-08T14:40:24Z",
          "updatedAt": "2018-02-08T14:40:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Connection-level priority is important, and must be there. As commented elsewhere, this allows prioritization between multiplexed connections, as well as when connections are sending packets through a common interface that may have a local AQM.\r\n\r\nHowever, that's not what the Niceness property on a send/receive is. That's the priority of a piece of content relative to other content on the connection. If I am using an unordered protocol, then my content may be re-ordered within a single connection. Having a relative priority of content is useful.\r\n\r\nThis does not need to necessarily be within the \"transport protocol's send buffer\": I would implement this at the layer that processes send calls and schedules them into the send buffer. While moving content into that send buffer, I would re-order the content based on priority.\r\n\r\nSo, I agree that per-connection (and thus per-QUIC-stream for example) priority is more important, I don't think that it is necessary to remove a per-content priority.",
          "createdAt": "2018-02-08T15:38:26Z",
          "updatedAt": "2018-02-08T15:38:26Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, I personally tend to think that priority (at all) is a little superfluous. This was in Post Sockets for completeness.\r\n\r\nThe point of this being per-Content is to support Protocol Stacks that use multiple streams / multiple paths transparently behind a single Connection to decide which stream or path to use.\r\n\r\nThe point of it being *reversed*, and not called \"priority\", is more philosophical. Most of how we think about priority in transport came straight from the old ToS byte, which itself was meant to implement US DoD requirements for trunk line access in a nuclear emergency. This doesn't map to how applications think of transport, in part because of the APIs we've had to date: there's either \"this *really really* needs to get there because it's an interactive ^C\" (URG), \"normal\", and \"I care a bit less than normal\" (PR or unreliable).\r\n\r\n\"Niceness\" is a little UNIXy. How about \"yield\" if we end up keeping it?\r\n\r\nOTOH per-Connection priority restricts Protocol Stack implementations enough that I'd rather just ditch priority in the core API altogether rather than explicitly making it a Connection property.",
          "createdAt": "2018-02-08T15:53:22Z",
          "updatedAt": "2018-02-08T15:53:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, to me \"more important = higher priority number\" has always been more natural, but I'm definitely not going to fight for this. Anyway, \"yield\" is worse, IMO, by just making this even less intuitive than \"niceness\" which some people may understand / appreciate for its Unix heritage.\r\n\r\nWhat's more important is what this really does. I agree that we want priorities for multiple streams, but that's the same as per Connection, as your Connections may end up being streams! Hence I don't understand your last paragraph at all.\r\n\r\nPer-Content just means that, even on a single transport connection, you could have different Niceness values, and that doesn't seem extremely useful to me.",
          "createdAt": "2018-02-08T16:16:06Z",
          "updatedAt": "2018-02-08T16:16:06Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ...but that's the same as per Connection, as your Connections may end up being streams\r\n\r\nMaybe. Just because we *can* support one PSI stream per Connection, doesn't mean that we *must only* do so.\r\n\r\n> Per-Content just means that, even on a single transport connection, you could have different Niceness values, and that doesn't seem extremely useful to me.\r\n\r\nIt's primarily useful in two specific instances:\r\n\r\n1. with single-Connection, multiple-Stream protocol stacks, to note that \"nicer\" content shouldn't HoL block normal (or less-nice) content\r\n2. with partially-reliable transports, to give additional input to the transmission scheduler about what should be (re-)transmitted first\r\n\r\nArguably, Lifetime is enough for point 2, and 1 might be rare enough that it's not worth exposing. ",
          "createdAt": "2018-02-08T16:22:15Z",
          "updatedAt": "2018-02-08T16:22:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">>...but that's the same as per Connection, as your Connections may end up being streams\r\n>Maybe. Just because we can support one PSI stream per Connection, doesn't mean that we must only do so.\r\n\r\nAh, I get it. Two niceness values on two Content blocks on one Connection means that maybe, below, you're opening two streams and scheduling between them.\r\n\r\n\r\n>>Per-Content just means that, even on a single transport connection, you could have different Niceness values, and that doesn't seem extremely useful to me.\r\n>It's primarily useful in two specific instances:\r\n>\r\n>with single-Connection, multiple-Stream protocol stacks, to note that \"nicer\" content shouldn't HoL >block normal (or less-nice) content\r\n>with partially-reliable transports, to give additional input to the transmission scheduler about what >should be (re-)transmitted first\r\n>Arguably, Lifetime is enough for point 2, and 1 might be rare enough that it's not worth exposing.\r\n\r\nYes - these are the \"not extremely useful\" things I had in mind... they're reminiscent of stuff like this:\r\nhttps://tools.ietf.org/html/rfc7496#section-4.2\r\n... which always has the alternative of: don't put so much logic down there and leave the application in control (provided you have some good form of back-pressure, which we now have).\r\n\r\nAnyway, I think you have convinced me with the first argument.",
          "createdAt": "2018-02-08T16:40:29Z",
          "updatedAt": "2018-02-08T16:40:29Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUyOTY0NTEzOTE=",
      "title": "Harmonize Intents and Post Sockets concepts",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/34",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "\u00a75.2.4, taken from Socket Intents, provides the transport application hints by binding a special higher-layer class of transport parameter to the connection. \r\n\r\n\u00a77, which describes the sending API, is largely taken from Post Sockets and tends to give simpler semantics to each Content at send time.\r\n\r\nThese approaches have the similar aims, but come to them from different angles. Socket Intents was very ~Socket~Connection-oriented, and Post Sockets very ~Message~Content oriented. It seems difficult for them to coexist in a way that would allow an application developer to use this interface with ease. \r\n\r\nWe should discuss, and agree on a way forward.",
      "createdAt": "2018-02-12T17:00:59Z",
      "updatedAt": "2018-02-19T13:29:13Z",
      "closedAt": "2018-02-19T13:29:13Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Being Content-oriented is good, as it offers more potential freedom below the api. i\u2019m for making as much as possible content-oriented.\n\nhowever: the intents things seem to be longer-term statements about app expectations or behavior - it doesn\u2019t make much sense to combine all of them with messages.  same for some of the minset based parameters - i think having both is the only reasonable way out?!   why hard to use, when these are all optional configs on a connection handle?\n\nSent from my iPhone\n\n> On 12 Feb 2018, at 18:01, Brian Trammell <notifications@github.com> wrote:\n> \n> \u00a75.2.4, taken from Socket Intents, provides the transport application hints by binding a special higher-layer class of transport parameter to the connection.\n> \n> \u00a77, which describes the sending API, is largely taken from Post Sockets and tends to give simpler semantics to each Content at send time.\n> \n> These approaches have the similar aims, but come to them from different angles. Socket Intents was very SocketConnection-oriented, and Post Sockets very MessageContent oriented. It seems difficult for them to coexist in a way that would allow an application developer to use this interface with ease.\n> \n> We should discuss, and agree on a way forward.\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-02-12T17:45:02Z",
          "updatedAt": "2018-02-12T17:45:02Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For Socket Intents, we already considered on which granularity these Intents can be applied \u2013 see  \r\nhttps://datatracker.ietf.org/meeting/100/materials/slides-100-taps-5-draft-tiesel-taps-socketintents-01 slide 7 \u2013 I guess allowing them in any scope they are applicable is fine.\r\n\r\nYes, this needs to be added to the API",
          "createdAt": "2018-02-12T18:32:36Z",
          "updatedAt": "2018-02-12T18:32:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I grabbed the ticket and will try to do a pass tomorrow \u2013 Input welcome",
          "createdAt": "2018-02-12T19:23:25Z",
          "updatedAt": "2018-02-12T19:23:25Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've looked over this again, and I think there are four levels of granularity here, and part of what I'm seeing as \"lack of harmony\" is the fact that three of them are kind of mixed up, and each of them interact with the send interface a little differently.\r\n\r\nhere's where I think we are (following my comment in #29, considering intents more deeply)...\r\n\r\n- Intents are about what the application does. You could have them be bound to a whole context (i.e., a container for multiple connections; the process level object), except some applications might need to speak multiple protocols with wildly different profiles (e.g., webrtc), so it's probably a useful simplifying decision to bind them only to Connections. Since Intents are advisory only, violating an Intent while sending should never be a runtime error.\r\n\r\n- Transport selection properties are basically only about the constraints on Protocol Stack selection, and become irrelevant once the stack is selected (we can have different discussion about how to do re-pre-establishment and whether or not the perceived need to do that is an application/API design error up in #38). Certain violations of transport selection properties may be runtime errors, but the API should endeavor to gracefully degrade. \r\n\r\n- Transport stack properties are a lower-level way to reach down into the stack and tweak performance parameters, though these should be expressed in a transport-independent way when possible. Inconsistent transport stack property configuration will lead to runtime errors, but this is the application's fault for being picky. (I suspect servers will need to do more of this sort of thing than clients).\r\n\r\n- Send parameters are about what should be done with this particular piece of Content within the context of the Connection it's sent on. I think we've got the right set of these, though we still need to come to consensus on priorities, it seems...",
          "createdAt": "2018-02-12T21:47:55Z",
          "updatedAt": "2018-02-12T21:47:55Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree with this perspective because it drops path selection from consideration.\r\n\r\n- Intents are equally useful for path setup as well as assigning contents to paths \u2013 Theresa and I deeply looked into this.\\\r\nTherefore we should be able to express intents when sending contents. If the intent expressed on a content contradicts the path set up, the transport system must ignore them and continue.\r\n- It might also make sense to change path selection parameters (see Issue #38)\r\n\r\nIn addition to that, there are Transport Stack Properties that apply on a per-conetnts granularity  (e.g. \"urgent data\" in TCP) - but these are \r\n\r\nI don't like the idea to add the whole \"require/prefer/avoid/prohibit\" for all Send Parameters \u2013 Intents and all examples of Transport Stack Properties I came up with make no use of them.\r\nWhat we can to harmonize the concepts instead changing the the Protocol- and Path Selection Properties into Key/Values and put the \"require/prefer/avoid/prohibit\" into the value field\r\n\r\n~~~\r\ntransportParameters.addProperty(ReliableDataTransfer, require)\r\n~~~",
          "createdAt": "2018-02-13T08:39:38Z",
          "updatedAt": "2018-02-13T08:39:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I disagree with this perspective because it drops path selection from consideration.\r\n\r\nI don't see how, can you say more here?\r\n\r\n> Intents are equally useful for path setup as well as assigning contents to paths\r\n\r\nSo perhaps the issue here is that we're artificially trying to keep Intents separate from other path and protocol selection parameters, and we should try to recast all of these in terms of \"selection parameters\" attached to a preference.\r\n\r\n> I don't like the idea to add the whole \"require/prefer/avoid/prohibit\" for all Send Parameters\r\n\r\nUgh. Me either, but I don't think I suggested that.\r\n\r\n> What we can to harmonize the concepts instead changing the the Protocol- and Path Selection Properties into Key/Values and put the \"require/prefer/avoid/prohibit\" into the value field\r\n\r\nhm, this is moving in the right direction here, but the interface still feels a little C89ish. How about making the preference the action on the parameter object instead? i.e.:\r\n\r\n```\r\ntransportParameters.Require(AlwaysReliableDataTransfer)\r\ntransportParameters.Require(OrderedDataTransfer)\r\ntransportParameters.Prefer(Establish0RTT)\r\ntransportParameters.Intend(ConstantDataRate, 300kbps)\r\n```\r\n\r\nand so on?",
          "createdAt": "2018-02-13T09:28:13Z",
          "updatedAt": "2018-02-13T09:28:13Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> I disagree with this perspective because it drops path selection from consideration.\r\n>\r\n>I don't see how, can you say more here?\r\n\r\nI disagree with excluding Intents (and some of the Path Selection Properties) from the Contents Send Properties.\r\n\r\n> > Intents are equally useful for path setup as well as assigning contents to paths\r\n>\r\n> So perhaps the issue here is that we're artificially trying to keep Intents separate from other path and protocol selection parameters, and we should try to recast all of these in terms of \"selection parameters\" attached to a preference.\r\n\r\nAgreed \u2013 but I was arguing against artificially trying to keep Selection Parameters and Send Parameters apart. There is an intersection between both sets and that intersection should neither be duplicated nor look awkward in the API.\r\n\r\n~~~\r\ntransportParameters.Require(AlwaysReliableDataTransfer)\r\ntransportParameters.Require(OrderedDataTransfer)\r\ntransportParameters.Prefer(Establish0RTT)\r\ntransportParameters.Intend(ConstantDataRate, 300kbps)\r\n~~~\r\n\r\nI like this. How do we design the ContentsParameters then? \r\nI'd propose the following:\r\n\r\n~~~\r\nsentParameters := connection.getDefaultSendParameters()\r\nsentParameters.Prefer(Sent0RTT)\r\nsentParameters.Intend(RecvContentSize, 2MB)\r\nconnection.Send(contentRef, sentParameters)\r\n~~~",
          "createdAt": "2018-02-13T10:14:04Z",
          "updatedAt": "2018-02-13T10:14:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I disagree with excluding Intents (and some of the Path Selection Properties) from the Contents Send Properties.\r\n\r\nAh, okay. Hm. Yes, we disagree. :)\r\n\r\nThe send parameters *really* should be limited to those things which are bound to the Content. Indeed, one way to do this would for *content* to have Parameters bound to it, but that leads IMO to an unpleasant-to-use interface. In some languages, there's no way around that, but as @mwelzl points out some languages (e.g. Python) provide optional arguments, and in those cases send parameters can be optional args to the `send()` function. We shouldn't define something that mandates a clunkier interface than the idiom of the language allows.\r\n\r\nWe can of course define send parameters that are related to transport parameters (and indeed, we should provide some easy to use reference to see which of these parameters are related / exclusive / etc), but I think they're fundamentally different animals.",
          "createdAt": "2018-02-13T10:26:36Z",
          "updatedAt": "2018-02-13T10:26:36Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a bit confused here. So far I assumed that Intents could be set both per Connection and on individual Content, so they could be both transportParameters and sendParameters. For me, transportParameters and sendParameters are different things, but they can still be expressed using the same vocabulary, as discussed in #29.\r\nSo the disagreement here is on whether an application should also be allowed set Intents as sendParameters, right?",
          "createdAt": "2018-02-13T10:41:36Z",
          "updatedAt": "2018-02-13T10:41:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So the disagreement here is on whether an application should also be allowed set Intents as sendParameters, right?\r\n\r\nI think so, yes. In document terms, the two ways forward seem to be:\r\n\r\n- Keep \"Intents\" as a separate category of things in \u00a75.2.4, and note in \u00a77 that all Intents are also usable as send parameters (somehow).\r\n\r\n- Eliminate \u00a75.2.4 as a separate entity, fold intents into transport parameters, and create intents-derived send parameters where appropriate.\r\n\r\nI'm proposing the latter.\r\n\r\nThere's another discussion we need to have about which Intents stay in the API and which don't -- some of these, for instance, seem difficult to non-arbitrarily map down to behaviors in the underlying protocol stacks as @mwelzl pointed out in mail -- but that's a separate issue.",
          "createdAt": "2018-02-13T10:50:56Z",
          "updatedAt": "2018-02-13T10:50:56Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, thanks for clarifying.\r\nIn the current \u00a75.2.4, it says that some Intents can also apply to individual messages, namely Size to be Sent / Received, Timeliness, Disruption Resilience, and Cost Preferences. This reflects the previous work on granularity that Philipp pointed out in his earlier post in this thread.\r\nCreating Intents-derived send parameters for (a subset of) the above sounds feasible to me. \r\nAbout folding the Connection-based Intents into the other transport parameters, I see two potential issues which I'm not sure yet how to resolve:\r\n- Under what heading to put them - As they can influence both protocol and path selection, neither of these heading seemed appropriate for me, that's why I put them under a separate heading. If not Intents, what should this heading be?\r\n- Reformulating them - Philipp and I already discussed whether some Intents could be reformulated as properties that fit into the \"Require\", \"Prefer\", \"Avoid\", \"Prohibit\" preferences. But not all Intents can fit this scheme. What to do with those?",
          "createdAt": "2018-02-13T12:44:05Z",
          "updatedAt": "2018-02-13T12:44:05Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One quick point:\r\n\r\n> Philipp and I already discussed whether some Intents could be reformulated as properties that fit into the \"Require\", \"Prefer\", \"Avoid\", \"Prohibit\" preferences\r\n\r\nThough the phrasing sounds silly, \"Intend\" semantics are pretty much the same as \"Prefer\" semantics. (\"I intend to use this connection in this way\" -> \"I prefer PSIs/paths that work well with this assumption\")",
          "createdAt": "2018-02-13T16:37:21Z",
          "updatedAt": "2018-02-13T16:37:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Brian that the properties in the Application Intents section should be distributed between the other properties sections. If we want a new \"Data/Content Properties\" that could be good too, for the things that are more about what the application wants for its data.\r\n\r\nI'd say for you list:\r\n\r\n- Traffic Category or Service Class seems like a Protocol Selection Property (previously Generic Protocol Property). This is a generic protocol option that influences the nature of the stream or flow I have. It influences how I initialize my transport protocol.\r\n\r\n- Size/Duration/Timeliness/Resilience all seem like Protocol Selection Properties (previously Generic Protocol Properties). Again, these will help choose which protocols to use, and how to prep and schedule them.\r\n\r\n- Cost Preferences (for us, Allow/Prohibit Expensive) is a Path Selection Property.\r\n\r\nOne thing that would be good to note is that Path Selection properties take effect not just in the initial bringup, but for all of the evaluation of flows and interfaces for multipath or migratable protocols.\r\n\r\nI would argue again that any properties per-send/receive should be specified as separate APIs from the pre-establishment APIs, even if they look similar, since they have different effects and domains of relevance.",
          "createdAt": "2018-02-13T18:40:43Z",
          "updatedAt": "2018-02-13T18:40:43Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For Traffic Category and Cost Preferences, I can see them fit better into Protocol or Path Selection, but I'm not sure yet if they fit exclusively. For the other Intents I'm not convinced that they can be sorted at all. For example, so far we use Size mainly to select the path on which we predict the shortest completion time for the transfer, i.e., depending on whether it is a \"large\" or a \"small\" transfer. For Timeliness and Resilience I can also more easily think of a path selection example based on lower latency and availability, respectively. On the other hand, the same Intents can help choose and configure transport protocols. So maybe putting them as \"Data/Content Properties\" would be better than trying to squeeze them into one of the two Selection categories.\r\nI think making the above clear in the Implementation draft will help us in this discussion and I'm planning to get started on this soon.\r\nI agree with Tommy's point about Path Selection properties also taking effect later on.\r\nAbout the per-send/receive properties, Philipp is currently working on Intents-derived per-Content properties, see #38.",
          "createdAt": "2018-02-14T10:59:46Z",
          "updatedAt": "2018-02-14T10:59:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the intents fit in different parts. I think that's part of the problem - they're treated (by being under one subheading) as a category in their own right, but they're really quite a heterogeneous set of things.",
          "createdAt": "2018-02-14T23:54:22Z",
          "updatedAt": "2018-02-14T23:54:22Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the whole dividing into path selection properties, protocol selection properties, intents and protocol properties is rather historic, than making sense at all.\r\nIn my world, we have four Dimensions in which we can divide up ~~properties~~ parameters:\r\n\r\n1. Data Type\r\n   - Int/Enum\r\n      - Protocol Properties\r\n      - Content Properties\r\n      - Intents\r\n   - Preference Enum\r\n      - Preferences\r\n2. Strength of Expression\r\n   - advisory\r\n      - Intents \r\n      - Preferences with avoid/prefer preference \r\n      - Protocol Properties\r\n      - Content Properties\r\n   - mandatory\r\n      - Preferences with require/prohibit preference\r\n      - Protocol Properties\r\n      - Content Properties\r\n3. Effected Subject\r\n   - Protocol Selection\r\n      - Preferences\r\n      - Intents\r\n   - Protocol Parameters\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Intents\r\n   - Path Selection (read MPTCP subflow)\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Intents\r\n   - Path Selection (read MPTCP segment to subflow assignment)\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Content Properties\r\n      - Intents\r\n   - Content Transmission\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Intents\r\n4. Time of use\r\n   - Pre-Establishment\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Intents\r\n   - Establishment\r\n      - Preferences\r\n      - Protocol Properties\r\n      - Intents\r\n   - Content Send\r\n      - Preferences\r\n      - Content Properties\r\n      - Protocol Properties\r\n      - Intents\r\n\r\nMixing these dimensions in terminology is bound to fail (as we currently try to do).\r\nStill working out how and where to fix this",
          "createdAt": "2018-02-15T10:58:37Z",
          "updatedAt": "2018-02-15T12:52:04Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First consequences:\r\n- get rid of differentiating between Path Selection and Protocol Selection properties\r\n- rename Path Selection and Protocol Selection properties to Preferences\r\n- remove the Preference parameter from Protocol properties and Intents\r\n- Make calls for Transport and Send Properties roughly the same",
          "createdAt": "2018-02-15T12:56:35Z",
          "updatedAt": "2018-02-15T12:56:35Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> remove the Preference parameter from Protocol properties and Intents\r\n\r\nwait, why? Whether or not a parameter is preferred (or avoided, or required, or prohibited) is orthogonal to how we talk about them, or am I missing something here?",
          "createdAt": "2018-02-15T12:58:45Z",
          "updatedAt": "2018-02-15T12:58:45Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Look at #protocol-props \u2013 there is nothin to require/prefer/avoid/prohibt",
          "createdAt": "2018-02-15T13:02:32Z",
          "updatedAt": "2018-02-15T13:02:32Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ahhh okay, got it.",
          "createdAt": "2018-02-15T13:05:36Z",
          "updatedAt": "2018-02-15T13:05:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I had a brief look at the branch here, and I'm very confused about what you're trying to do here.\r\n\r\n7.1.4.1. seems unnecessary as a send parameter; the length of the Content gives the size to be sent. *Maybe* you could tell the transport the size of the message it should expect to receive based on a given send, but I'm not sure I know what a transport will do with it\r\n\r\n7.1.4.2. is similarly odd; certainly this is a property of multiple sends, not a single one?\r\n\r\n7.1.4.3. seems to be an alternate expression of Lifetime.\r\n\r\n7.1.4.4. seems to be an alternate expression of path selection property.\r\n\r\nI think we should probably take a step back here, and instead of starting from an attempt to map Socket Intents concepts directly into this document, attempt to see what concepts in Socket Intents are missing from the API, and how those can best be added in keeping with the architecture (and can be implemented using transport services described in 8095 and the upcoming security properties doc). In any case I don't think this will converge before -00, so let's take the time pressure off and mark it post-London...",
          "createdAt": "2018-02-15T13:32:27Z",
          "updatedAt": "2018-02-15T13:32:27Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was \"just\" a copy an paste and is fixed now.\r\n\r\nMost work went into re-structuring and fixing terminology to harmonise Sent and Trasnport Parameter concepts.\r\nI will file a PR today and remove the post-London milestone for from this ticket. \r\n\r\nI am fine with a partial merge and a new post-London issues for discussing Send Parameter Intents.",
          "createdAt": "2018-02-15T14:53:44Z",
          "updatedAt": "2018-02-15T14:53:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is closeable with the merge of #48, yes?",
          "createdAt": "2018-02-19T12:19:49Z",
          "updatedAt": "2018-02-19T12:19:49Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Most things discussed here are addressed with merge #48 - remaining things are post-London and covered by issue #38",
          "createdAt": "2018-02-19T13:29:13Z",
          "updatedAt": "2018-02-19T13:29:13Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyOTY0NTQ0NDQ=",
      "title": "Rewrite Interface Types to be useful and implementable",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/35",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "We should be a bit more specific about how an application is supposed to interact with path selection properties. Do we want to bind this to a world in which the system specifies a set of interface type labels and the application has to choose, or is there some other approach here?",
      "createdAt": "2018-02-12T17:09:50Z",
      "updatedAt": "2018-06-09T12:12:01Z",
      "closedAt": "2018-06-09T12:12:01Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, one approach is to indeed have enumerations of path types and services that are allowed. To give the example of how we do this:\r\n\r\n- Require/Prohibit/etc \"interface name\" like \"en0\". This sucks, but is on occasion necessary if you need to be really specific as an application.\r\n\r\n- Require/Prohibit/etc \"interface type\", which is \"Wi-Fi\", \"Wired Ethernet\", \"Cellular\", \"Loopback\"; with subtypes for \"Peer-to-Peer Wi-Fi\", etc.\r\n\r\n- Require/Prohibit/etc \"service\", \"PvD\" or what we call a \"network agent\". This can be a class of a network service like \"VPN\", \"Proxy\",  etc, or a specific instance of a VPN, etc.\r\n\r\nThat last category allows a fairly extensible set of options. I think in general, this area should take lessons from the PvD work. See: https://tools.ietf.org/html/draft-kline-mif-mpvd-api-reqs-00",
          "createdAt": "2018-02-13T18:55:46Z",
          "updatedAt": "2018-02-13T18:55:46Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "do we need to assign someone to write text for this for the -00 milestone, or can we come back to this after London?",
          "createdAt": "2018-02-15T13:34:08Z",
          "updatedAt": "2018-02-15T13:34:08Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am fine with moving this to post-London",
          "createdAt": "2018-02-15T15:00:08Z",
          "updatedAt": "2018-02-15T15:00:08Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think we need to address what I think is a basic issue in the API draft. The current text seems to suggest the App signals specific characteristics of the App across the API. I have problems with this - the experience from RSVP, etc - is that Apps seldom understand how to express themselves regarding their own behaviour. Instead, I would advocate that we explicitly focus on what they want from the network path: \r\n\r\nExamples I suggest are helpful include: an abstract treatment based on a PHB; a minimum PMTU; a preference for lower latency rather than throughput; a need for no cost... etc.\r\nExamples I would argue against: A need for a specific transmission rate; understanding of the size of a transfer at the time the connection is made; ... etc.\r\n",
          "createdAt": "2018-02-21T09:41:55Z",
          "updatedAt": "2018-02-21T09:41:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for specifying requirements of paths and protocols, rather than properties of an application. Any time we've attempted to implement the items you mention as the \"argue against\", they've been dead ends that have either been misused or deprecated.",
          "createdAt": "2018-02-21T16:08:55Z",
          "updatedAt": "2018-02-21T16:08:55Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Lets look how many use cases for this stay when you add support for requesting explicit pvds\r\n",
          "createdAt": "2018-03-21T17:03:55Z",
          "updatedAt": "2018-03-21T17:03:55Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly: As discussed during the 16 May interim, Types should definitely be system-specific. Specific interface names and specific PvDs are definitely useful, but are probably also too system-specific to be able to generalize.",
          "createdAt": "2018-05-16T15:19:48Z",
          "updatedAt": "2018-05-16T15:21:48Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#181 closed this",
          "createdAt": "2018-06-09T12:12:01Z",
          "updatedAt": "2018-06-09T12:12:01Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWUyOTY0NTUyMTA=",
      "title": "Design API for UDP lite (and similar protocols if there are any)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/36",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "\u00a75.2.1 defines \"Control checksum coverage...\" (from minset) as a transport selection property, but there is no support for this in \u00a77 Sending. Need to figure out how to reconcile this.",
      "createdAt": "2018-02-12T17:12:08Z",
      "updatedAt": "2018-02-16T10:58:47Z",
      "closedAt": "2018-02-14T15:32:03Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems to me that this is a different kind of unreliability. Lifetime lets some Content be marked as \"I don't care if it gets there because I have my own application-layer method for dealing with it if it doesn't\". This per-Send parameter would say, in essence, \"this part of the Content can even get scrambled because I have my own application-layer method for dealing with *that*\"\r\n\r\nUDP-Lite is a weird animal, though, and I'm not sure how much complexity we need to add to the API to accomodate it.",
          "createdAt": "2018-02-12T21:59:02Z",
          "updatedAt": "2018-02-12T21:59:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This checksum stuff is in \u00a77.1.6, by the ugly name of \"Checksum\" because I thought that we can come up with something better than \"integrity\", and in the meantime, let's just call it checksum.\r\n\r\nI agree that this relates to (Un)reliability, but I believe adding this to \"Lifetime\" just ends up making things more complex than if we have it as a separate send property. As for UDP-Lite being weird and this being worth it or not, I don't think this is much complexity to add, and anyway just an optional thing to configure for folks who want. UDP-Lite may be \"weird\" because people don't use it, they don't even try to, because the interface doesn't offer it, and because no app even tries to use it, it may seem like a useless protocol .... hmmm, does this sound familiar?  :-)   yes it's the same circular dependency problem that's at the roots of the whole TAPS stuff - this problem is all over the place. So if our goal is to offer deployability of transport features that people may not get to use today, we have to start by adding them to the API.",
          "createdAt": "2018-02-13T23:06:34Z",
          "updatedAt": "2018-02-13T23:06:34Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah, trying to make lifetime cover this would be wrong.\r\n\r\nMy \"UDP Lite is a weird animal\" is less of a comment on the service it provides (marginal improvement of loss rates in those environments where L2 doesn't have a checksum and/or RTX facility and L1 is noisy... itself a rare circumstance, but I suppose it's useful where that circumstance does hold) and more on *how* it provides it (i.e., it's a hack). \r\n\r\nThe generic send parameter here would be \"corruption tolerance\" over a *portion* of a Content, with the added caveat that UDP Lite that portion must be at the *end* of the content. A Send Parameter that says \"it's okay to break the last N bytes\" of the content would map to the UDP Lite implementation nicely, but it's not clear to me that it would *ever* be implemented by anything other than UDP Lite.",
          "createdAt": "2018-02-13T23:38:00Z",
          "updatedAt": "2018-02-13T23:38:00Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's in \u00a77.1.6 is good enough for now; we can revisit in the -01 rev.",
          "createdAt": "2018-02-14T15:32:03Z",
          "updatedAt": "2018-02-14T15:32:03Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed or not, I do want to answer because this is one of *my* favorite topics   :-)   so I think the checksum length field is hacky, but it can work - there are cases of audio codecs that align with this kind of setup. Anyway, disabling the checksum altogether can be more useful. About this being a rare occurrence, I have a fun fact to share: Mattia Rossi, whom I think you know too?  measured this for WiFi in his master thesis with me - he hacked the driver to disable the link layer CRC, and found a whopping 2 or 3 packets with errors in a couple of thousands (something in that order). Yet, there are tests that others made, with much happier results - I think the bottom line is, it heavily depends on the link layer.\r\n\r\nWas this relevant? No sir... but I couldn't stop myself  :-)",
          "createdAt": "2018-02-15T00:05:03Z",
          "updatedAt": "2018-02-15T00:05:03Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Was this relevant? No sir... but I couldn't stop myself :-)\r\n\r\nI learned something, so.\r\n\r\n> I think the bottom line is, it heavily depends on the link layer.\r\n\r\nAgreed, when you need it, you really do need it. \r\n\r\n\"Disable completely or not\" is a good first pass solution.\r\n\r\nFor maximum generality, you'd be able to mark arbitrary byte ranges for checksum coverage (or, looking further ahead, cryptographic integrity / confidentiality coverage). But UDP-lite can't implement that, and it may be impossible to implement the general case efficiently.",
          "createdAt": "2018-02-15T12:37:04Z",
          "updatedAt": "2018-02-15T12:37:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I'm not sure I like the \"either clean because we remove the hacky stuff\" or \"clean because we made it more general\" approach. Case 1 may make the API \"lame\" - I see it as a problem if we sell this as a general thing atop Internet protocols, but if you want to do cool stuff, you really need to use the protocols directly. Case 2 doesn't map onto any existing protocol for now, which may not be a problem, but I can't see this worth the added complexity (because, indeed, defining arbitrary byte ranges can become a quite complex thing to add to the API).  So, I'd like to keep it as it is, with the checksum length adjustable.",
          "createdAt": "2018-02-15T16:19:36Z",
          "updatedAt": "2018-02-15T16:19:36Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Being able to support https://tools.ietf.org/html/rfc4867#section-3.6.1 seems a useful goal for a UDP-lite API.",
          "createdAt": "2018-02-16T10:58:47Z",
          "updatedAt": "2018-02-16T10:58:47Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUyOTY0NTc5NzI=",
      "title": "Make some choices about \u00a75.2.1 Transport Selection Parameters",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/37",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "Do all of the transport selection parameters in \u00a75.2.1 need to be listed in the proposed standard interface? Discuss.",
      "createdAt": "2018-02-12T17:20:47Z",
      "updatedAt": "2018-12-04T12:22:10Z",
      "closedAt": "2018-12-04T12:22:10Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure about the following ones:\r\n- Suggest a timeout to the peer\r\n- Notification of special errors (excessive retransmissions, ICMP error message arrival)\r\n\r\nI wonder if \"suggest a timeout to the peer\" is something that should be dealt with inside a transport system (if at all), not by the application on top. From RFC 5482: \"Decreasing the user timeouts allows busy servers to explicitly notify their clients that they will maintain the connection state only for a short time without connectivity.\"\r\n\r\nSince we maintain a higher level \"connection\" concept, a transport system could just take care of re-connecting in case it would get such a notification, and not bother the application with it.\r\n\r\nDoes that sound reasonable?\r\n\r\n\r\nThe second, well ... is anybody *really* going to pick a protocol because it gives you richer error messages than another one?\r\n",
          "createdAt": "2018-02-13T23:18:37Z",
          "updatedAt": "2018-02-13T23:18:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm answering myself (rather than editing, because maybe these thoughts are helpful to others too): about error messages, sure they are helpful, at least for applications doing PMTUD. If we don't want this, we have to abstract it away and provide the right hooks for people doing PMTUD - I think this is a possible discussion for the next draft version.\r\n\r\nAbout the timeout thing, because this comes from minset, I thought, if this is not needed then there must be something wrong in minset... so I checked: both this, and the other timeout configuration parameter are functional because \"this is closely related to potentially assumed reliable data delivery.\"  I think this is right - for applications for which the notion of a \"connection\" is the same as the transport protocol's notion of a connection. But we provide something higher-level here... so we can offer such timeout primitives to apps, at least a local one - yet we may not care about offering these transport timeout primitives to applications at all, and deal with them inside the Transport System.\r\n\r\nMy conclusion is: keeping a local timeout decision as a \"protocol property\" (which applies after selection, and may or may not be handed down 1:1 by the transport system!) makes sense, as we have it, in section 5.2.2 - it's just about \"our\" connections, not about the actual transport protocol's connections.\r\n\r\nBecause we deal with transport connections below the API, we can then delete the protocol properties \"Set timeout to suggest to the peer\", \"Set retransmissions before 'Excessive Retransmissions' \" (which isn't semantically hugely different from a timeout), and the protocol selection property \"Suggest a timeout to the peer\".\r\n\r\nThoughts?",
          "createdAt": "2018-02-13T23:54:37Z",
          "updatedAt": "2018-02-13T23:54:37Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Since we maintain a higher level \"connection\" concept, a transport system could just take care of re-connecting in case it would get such a notification, and not bother the application with it.\r\n\r\nSounds alright to me, as long as the application is at least notified in this case. I initially read \"not bother the application with it\" to mean that the application wouldn't be notified, but perhaps I misunderstood.\r\n\r\nI think the point from minset is right: Timeouts are closely related to assumed reliability. Not just about whether the data will eventually reach the application at the remote endpoint, but there's also an assumption about the stability of the connection. So we have to think about our definition of \"reliability\" here.\r\nIn the current API we define \"Reliable Data Transfer\" to include \"being notified when a Connection is closed or aborted\". Does this mean \"notify when the TCP connection breaks, but reestablish it\"? Always, or just for some connections or in some applications where it makes sense?\r\nI think the Intent \"Disruption Resilience\" relates to this - does terminating the, e.g., TCP connection result in application failure or not?\r\n\r\nNow, about keeping the \"Suggest timeout to the peer\" option in this API: Intuitively I'd be okay with just letting the application set a local timeout and then maybe having a failover if the application is terminated from the other end, so I'd be fine with the changes that Michael proposes.",
          "createdAt": "2018-02-14T11:32:25Z",
          "updatedAt": "2018-02-14T11:32:25Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Since we maintain a higher level \"connection\" concept, a transport system could just take care of \r\n> re-connecting in case it would get such a notification, and not bother the application with it.\r\n\r\nIn the general case you can not just reconnect, you have no corresponding state on the other end at the taps-level and you do not know what the application is doing? I have no idea what a local timeout on the taps connection level really means here? I could imagine setting timers for how long you want to wait for a given event or something like that, but for the timers in question here I think they need to map to the protocol timers or I am not sure what they mean. How would this local timer be defined? ",
          "createdAt": "2018-02-14T16:10:24Z",
          "updatedAt": "2018-02-14T16:10:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmmm. Maybe I'm inventing too much stuff here. So yes, just re-connecting can work or not...  this depends on the application on the other side. The timers may or may not have to related to protocol timers - this depends on whether we want to support a \"retransmission count\" timeout. Anyway, I suggest to leave this as it is for now but maybe discuss in London if there can be a cleaner, more uniform way to handle these things, for v1.",
          "createdAt": "2018-02-14T16:59:53Z",
          "updatedAt": "2018-02-14T16:59:53Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also #109 and #110 ",
          "createdAt": "2018-02-27T12:04:41Z",
          "updatedAt": "2018-02-27T12:04:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Revisit after #153 closes.",
          "createdAt": "2018-03-21T16:57:30Z",
          "updatedAt": "2018-03-21T16:57:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I note that the restructuring in #153 has eliminated my question about notification about soft errors - it's no longer available for a preconnection (\"will you need soft errors?\" - that sort of thing), and that was a reasonable decision. So only the \"suggest timeout to the peer\" thing remains.",
          "createdAt": "2018-11-04T17:31:46Z",
          "updatedAt": "2018-11-04T17:31:46Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUyOTY0OTYxMzk=",
      "title": "Path Selection Properties vs. Connection Migration and Multipath",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/38",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "When thinking about connection migration and multipath, I disagree that Path Selection Properties can not be changed later on. The question is whether a change to the ~~Transport Parameters~~ Path Selection Properties should trigger connection migration or whether another mechanism is needed.",
      "createdAt": "2018-02-12T19:29:34Z",
      "updatedAt": "2018-12-13T11:48:15Z",
      "closedAt": "2018-12-13T11:48:15Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO: nope, don't do this.\r\n\r\nA key consideration here is the architecture for multipath: is a multipath connection implemented as a single, multiple-path aware Protocol Stack, or can a TAPS system cobble multipath together out of disparate Protocol Stacks? We went around and around on this point in Post Sockets and decided to punt, though MP transport protocols *really* do need to be linked to each other for transmission scheduling to work well, so on further reflection I'm in favor of the former answer.\r\n\r\nThis indicates to me that any \"automagic\" connection migration done by the TAPS system in reaction to changing selection properties of any kind is a bad idea, since doing it right would require the TAPS implementation itself to have its own migration logic separate from and in addition to the Protocol Stack's own migration.\r\n\r\ntl;dr if the application's requirements change dynamically to the point that the criteria for selecting a protocol stack have changed, that's an application level event and the application should have direct control of it through re-initiation or re-rendezvous.",
          "createdAt": "2018-02-12T21:55:15Z",
          "updatedAt": "2018-02-12T21:55:15Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I think we all agree that we don't want to change Protocol Selection Properties after establishment\r\n- We might want to change/provide additional Path Selection Parameter to achieve two things\r\n   - Assign contents to paths within a connection\r\n   - Migrate a connection to a different path\r\n\r\nLet me refine my initial question: \r\n- Which one of the two things above should we support\r\n- Should the API look like changing Transport Parameters or be something else",
          "createdAt": "2018-02-13T07:59:43Z",
          "updatedAt": "2018-02-13T07:59:43Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok. thanks for the reframing, I get the question now. \r\n\r\nWhich do we want to suport?\r\n\r\n> Assign contents to paths within a connection\r\n\r\nIMO we absolutely want to do this. In an earlier revision of Post Sockets, one of the main reasons to get a Path object was to pass it to ~Carrier~Connection.Send in order to force a ~Message~Content to be sent down a given Path.\r\n\r\n(I'll go ahead and register @mwelzl's probable objection here: no existing API to an mutlipath transport protocol allows you to do this, yet, although some of the work I know is being done on MPQUIC variants will. In any case, I think we absoultely want to do this, so we should specify it, and show how it could be done in the implementation draft)\r\n\r\n> Migrate a connection to a different path\r\n\r\nWe should absolutely support migration, but it's not clear to me that the application needs to be involved directly in migration in the common case. i.e., I don't see why the application doesn't just supply some path selection parameters, and when new paths become available, the system chooses to add and/or migrate paths depending on the patjh selection properties it already has. \r\n\r\nWhen the application really needs to be in charge of a migration, because different paths are bound in some way to the semantics of the application itself, then ISTM that's a new Initiate().",
          "createdAt": "2018-02-13T09:37:21Z",
          "updatedAt": "2018-02-13T09:37:21Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two few quick comments on these points:\r\n\r\n> Assign contents to paths within a connection\r\n\r\nI don't know why you would/should do that. If you e.g. use MPTCP but you only want to use one path then use TCP instead. Using multipath protocols only makes sense if you actually want to use multiple paths; this can be simultaneously, as fallback, or in migration situations.\r\n\r\n> Migrate a connection to a different path\r\n\r\nI think here the migration question is a transport problem, however, you might need application input to figure out which paths to establish at all and how/when to use them (simultaneously, fallback, make-before-break, or I guess make-after-break would be possible as well). However these are protocol parameters which are only applicable to protocols that support multipath.\r\n",
          "createdAt": "2018-02-13T11:05:37Z",
          "updatedAt": "2018-02-13T11:05:37Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Assign contents to paths within a connection\r\n\r\nI think our API design should support this or at least not prevent an implementation from doing this. Right now, usually there are only two paths and multipath protocols aren't yet widely used. But who knows how this might change in the future? I could imagine a scenario where most clients by default use 3 network interfaces in parallel and an application really wants to avoid scheduling huge objects over one of them, but not care much otherwise. I would like this to be possible with our API.\r\n\r\n> If you e.g. use MPTCP but you only want to use one path then use TCP instead.\r\n\r\nBut does the application necessarily tell us through the API whether it wants to use multiple paths, e.g., through the transport parameters? Right now, it doesn't. Should it? Maybe in a way similar to my suggestion below.\r\n\r\n> Migrate a connection to a different path\r\n\r\nI like Mirja's categorization of how to use multiple paths (simultaneously, fallback, make-before-break, or I guess make-after-break would be possible as well -- and perhaps also \"do not use multiple paths\"?) and I think the application should be able to specify this as another Transport Parameter. This way, it can influence how migration happens, but does not have to be involved in the actual migration.",
          "createdAt": "2018-02-13T14:40:02Z",
          "updatedAt": "2018-02-13T14:40:02Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mirja's suggestion of how to handle multipath policy after connection is exactly right, in my opinion. We've been working with multipath APIs for several years now and have deployed it quite widely for our internal services. There are better are worse ways to doing this, and I know from experience that getting involved in managing the interfaces and interface types as a maintenance API is extremely hard to get right. You may disagree, but I would strongly urge that we leave the path selection properties in Pre-Establishment for v1 (London). We can always add, but we should be careful not to add complexity where it will hurt us, especially when we have experience to tell us that certain parts are hard.\r\n\r\nThe generic transport parameter we expose for multipath policy is an enum of values: Handover (only switch paths when you're losing the first one), Interactive (usually use the main one, but retransmit or failover to secondary paths when the first isn't responsive enough), and Aggregation (simultaneous use for improving bandwidth). This set of options at a minimum must be expressible in the API. I don't think we need to go beyond this for v1.",
          "createdAt": "2018-02-13T15:29:28Z",
          "updatedAt": "2018-02-13T15:29:28Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am working on a pull request to address Issue #34 and #38 by re-shaping the Transport and Send Parameters and reorganising the Parameters. \r\n\r\n- I want Application Intents as Send Parameters be part in v1 \u2013 they can be used as input for, e.g., an MPTCP segment scheduler\r\n- I don't want to include application based segment scheduling in v1",
          "createdAt": "2018-02-13T16:48:32Z",
          "updatedAt": "2018-02-13T16:48:32Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree we should leave the path selection properties in Pre-Establishment for v1. Any Send Parameters that are related only to paths selection should be left out I think. We should really try to focus on a minimal set to start with. ",
          "createdAt": "2018-02-14T15:43:48Z",
          "updatedAt": "2018-02-14T15:43:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Anna that Send Parameters for the purposes of path selection are *not* in scope for v1. While we have experience with multipath protocols, having different chunks of data have different path selection properties is not a feature I am aware of being implemented anywhere at this time. Based on the architectural principles we began with, we should not be adding knobs for features that are not used at this time. We can always add this later if it becomes a reality.",
          "createdAt": "2018-02-14T16:41:12Z",
          "updatedAt": "2018-02-14T16:41:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We implemented per-chunk path selection in our Socket Intents Prototype (based on connection pools, but should work the same with MPTCP). This was the thing where BSD Sockets got really ugly.\r\n\r\nMy fear is that focusing too much on a minimal set might lead us to something that will be insufficient later on.\r\n\r\nIn the harmonized-parameters branch, I incorporated path selection hints into the Send Properties. As long as we keep Send Properties flexible, e.g. use key/value pairs and not a static list of Properties, we can add them now or later, whatever helps pushing the transport interface.\r\nIts not consistent enough for a push request yet, but should be ready for discussion sometimes tomorrow.",
          "createdAt": "2018-02-14T19:00:41Z",
          "updatedAt": "2018-02-14T19:00:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few points:\r\n- Not having this be part of v1 should be fine. We can always add things.\r\n- I agree that it sounds interesting to play with per-chunk path selection, but the fact that we can implement it as an experiment doesn't justify inclusion. I was referring to experience deploying with real applications at a large scale, which we have with MPTCP, but not with per-chunk routing in MPTCP.\r\n- We SHOULD NOT be recommending that APIs give Key/Value pair APIs for properties. That's a language choice, and is very very ugly in some languages. We should instead specify that the list should be extensible. The only case we need to avoid is a statically sized struct. An object with properties that can be extended easily is sufficient, and better for type safety than key/values.",
          "createdAt": "2018-02-14T19:16:49Z",
          "updatedAt": "2018-02-14T19:16:49Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We can always add things.\r\n\r\non that point, I think we-the-editors need to get together fairly early next week and try to get -00 revs of these documents out. In doing so, we'll need to pull out anything in the API without backing in the architecture and implementation drafts, with the intention to keep the discussion going (indeed, we should probably start moving said discussion onto taps@ietf.org) for an eventual -01. \r\n\r\nSo, I'm milestoning this discussion post-London.\r\n\r\n> I agree that it sounds interesting to play with per-chunk path selection\r\n\r\nas do I; indeed, any implementation of this we do will have Paths as a first-class manipulable object accessible via Connection. Path awareness and path control in the current Internet architecture is, however, an area of open research (this is indeed why we'd add it to our implementation, `#include <panrg_advertisement.txt>`), so I'm not sure the concept needs to show up in the standards track version of the API.\r\n\r\nIndeed, the initial work we've done on it in SCION suggests that path selection as a send property in the transport-to-application interface for any other than (1) debug tooling in path-aware networks, (2)  specialized applications in which the application layer protocol is actually performing transmission control itself (this is sometimes the case in SCION for purely accidental reasons), or (3) demonstrations of how cool our multipath stuff is. The path properties really are more useful for (future) path-aware transport protocols to make scheduling decisions based on higher-order requirements (transport and send parameters) passed down by the application.",
          "createdAt": "2018-02-14T19:38:57Z",
          "updatedAt": "2018-02-14T19:38:57Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am fine with moving this into post-london milestone and remove the path properties from the send parameters in the parameter harmonising PR I'll file tomorrow.\r\n\r\nI still want to keep a few Application Intents and Protocol Parameters in there \u2013 the first should do no harm, the second is deployed today with SCTP.\r\n\r\n@britram does intents based per-content path selection performed by an allication-external local-policy fall in any of your three categories? This is what we did.",
          "createdAt": "2018-02-14T19:53:12Z",
          "updatedAt": "2018-02-14T19:53:12Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": " > intents based per-content path selection performed by an application-external local-policy\r\n\r\nkinda sounds like (2), unless you did it for demo purposes, in which case it's clearly (3). :) Although I could see some network architectures where you might want application-layer semantics to be reflected in which devices certain packets pass on the way out of the network. That's still a very specialized application.\r\n\r\nWe want to a be in a place where the application doesn't need to muck about with the details of the path in order to get the multipath service it wants; we'd rather have a set of semantics meaningful to the application that allows a path-aware transport protocol to make good choices on the application's behalf. I agree that until we get there, we need to hand this control across the interface, because there are precisely zero good path-aware transport protocols (MPTCP is a start, but its goals are hardcoded). But just because we need that interface to help us to develop those transports doesn't mean that part of it needs to be standardized at this time.",
          "createdAt": "2018-02-14T20:27:15Z",
          "updatedAt": "2018-02-14T20:27:15Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I have read thius thread and I think this drfat needs to leave the path selection properties in Pre-Establishment state - It's always possible to be more exotic and there are clearly cases where this will in future be useful. However, I am really keen to avoid making this API byzantine in complexity, and this is an area where I fear this is great PhD material and poor standards.",
          "createdAt": "2018-02-21T12:10:05Z",
          "updatedAt": "2018-02-21T12:10:05Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I came to the conclusion that this kind of functionality is best capsuled either in a connection pool (see Issue #266) or in some migrate/re-initiate call for most practical use cases.\r\n\r\nClosing this issue in favour of #266 and #270",
          "createdAt": "2018-12-13T11:48:15Z",
          "updatedAt": "2018-12-13T11:48:15Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUyOTY1Mzk3MzU=",
      "title": "Harmonize Action, Object, and parameter usage and naming",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/39",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram",
        "mwelzl"
      ],
      "labels": [
        "API",
        "review"
      ],
      "body": "Review the use of notation in the API doc before final submission and unify it stylistically.",
      "createdAt": "2018-02-12T22:00:33Z",
      "updatedAt": "2018-03-01T13:11:10Z",
      "closedAt": "2018-03-01T13:11:10Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #125",
          "createdAt": "2018-03-01T13:11:10Z",
          "updatedAt": "2018-03-01T13:11:10Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUyOTY3MTk4NDQ=",
      "title": "[architecture/\u00a73.1] Common APIs for common features",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/40",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Section 3.1 of the architecture draft says:\r\n\r\n```\r\n   Any Transport Services API must expose the basic set of transport\r\n   networking features.  This implies, at a minimum, the ability to use\r\n   the equivalent of both TCP and UDP socket interfaces.\r\n```\r\n\r\nShould \"expose the basic set\" be \"expose the distilled minimal set of features offered by transport protocols [I-D.ietf-taps-minset]\" or is the basic set intended to be different?\r\n\r\nI also suggest removing \"This implies, at minimum, the ability to use the equivalent of both TCP and UDP socket interfaces\" since it's covered in Section 3.3.",
      "createdAt": "2018-02-13T12:28:12Z",
      "updatedAt": "2018-02-13T15:38:20Z",
      "closedAt": "2018-02-13T15:38:20Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair point that the TCP/UDP coverage is already specified in 3.3. I'll remove it in 3.1.\r\n\r\nAnd yes, the basic set is the minimal set (and if there's any difference, let's edit the minimal set)",
          "createdAt": "2018-02-13T15:20:33Z",
          "updatedAt": "2018-02-13T15:20:33Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm working on this now, so if there's agreement I can make the edits.",
          "createdAt": "2018-02-13T15:23:09Z",
          "updatedAt": "2018-02-13T15:23:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would be great, thanks!",
          "createdAt": "2018-02-13T15:23:49Z",
          "updatedAt": "2018-02-13T15:23:49Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUyOTY3MjIzNjA=",
      "title": "[architecture/\u00a73.3] basic transport protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/41",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "In section 3.3 of architecture \"all implementations should offer sufficient APIs to use basic transport protocols like TCP and UDP\", should this be \"...to use the distilled minimal set of features offered by transport protocols [I-D.ietf-taps-minset]\"?\r\n\r\nWe should be consistent about what's the base set of protocols (see also #40)",
      "createdAt": "2018-02-13T12:37:38Z",
      "updatedAt": "2018-02-13T15:39:02Z",
      "closedAt": "2018-02-13T15:39:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this is referring to minset, however, I was trying to capture what came up several times in discussion that it should be clear that this encompasses TCP and UDP. Mentioning TCP to allay the concerns that this interface could only be for higher-level framing, and mentioning UDP to allay the concern that unconnected datagram interfaces are not considered. How about mentioning both, i.e.: \"this is minset, which by the way covers the same thing you're used to in TCP and UDP sockets, plus more\".",
          "createdAt": "2018-02-13T15:22:49Z",
          "updatedAt": "2018-02-13T15:22:49Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, makes sense.",
          "createdAt": "2018-02-13T15:24:08Z",
          "updatedAt": "2018-02-13T15:24:08Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUyOTY3NzMzMzQ=",
      "title": "Types: Connection vs Connectable",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/42",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "The API and architecture conflate the concepts of a Connection and a Connectable. These are distinct, and the allowable operations on each are different. They should be represented by two different types in the API and architecture. This is a problem with BSD Sockets, and something we should avoid in the transport services architecture.\r\n\r\nA `Connection` is something on which you can send data; something that has active protocol state. It supports operations such as `send()` and `close()`, and generates events such as `Received<>`. \r\n\r\nA `Connectable` is something that can be used to generate a `Connection`. It doesn't have an active transport protocol. It supports operations such as `setParameters()` or `connect()` (the latter being a method that consumes a `Connectable` and returns a `Connection` object). \r\n\r\nThese are logically different types, and should be represented as such. It doesn't make sense to call `send()` on a `Connectable` or `setParemeters()` on a `Connection`, for example. \r\n\r\nIn pre-establishment, we work with `Connectable` objects. Establishment then becomes the process of generating a `Connection` from a `Connectable`. Once we have a `Connection`, we're in the data transfer phase. \r\n\r\nDiscuss.",
      "createdAt": "2018-02-13T15:16:28Z",
      "updatedAt": "2018-02-16T23:46:19Z",
      "closedAt": "2018-02-16T23:46:19Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an architecture standpoint, I really like this.\r\n\r\nFrom an API-weirdness standpoint, I have to think about it for a bit before I decide whether I like it or not... You're right that this is a bit of ugliness we inherited from socket(), and I think I've internalized it so much that anything else seems odd.\r\n\r\n(For some reason, the name \"Connectable\" really puts me off -- it feels like an extremely cheap, plasticky, off-brand, not-really-compatible-with-Lego building toy. Maybe we should call it a connection specifier? (And leave it to the Java implementation to call it a ConnectionFactory for idiom-compatibility ;) )",
          "createdAt": "2018-02-13T16:25:55Z",
          "updatedAt": "2018-02-13T16:26:06Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`Listener` is a ConnectionFactory :-) `Connectable` is something a little different: it doesn't create connections, it gets turned into a connection.\r\n\r\nAnd, yeah, I'm open to suggestions for a better name, but let's paint the bike shed after we agree that we want a bike shed.",
          "createdAt": "2018-02-13T16:32:04Z",
          "updatedAt": "2018-02-13T16:32:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm pretty sure I'll admit I want a bike shed tomorrow.",
          "createdAt": "2018-02-13T16:33:46Z",
          "updatedAt": "2018-02-13T16:33:46Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And a pony. Don't forget the pony.",
          "createdAt": "2018-02-13T16:34:57Z",
          "updatedAt": "2018-02-13T16:34:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that a pre-established connection is a quite different beast for interaction from the established connection. However, for API and implementation purposes, I think separating the objects themselves, rather than just separating out what the API contract is at a given point, may be problematic and limiting.\r\n\r\nThe way I think about it, which is my biased-by-sockets view likely, is:\r\n\r\n- As you specify your local & remote endpoints, and preferences/parameters, there is no Connection yet, just the endpoints and parameters.\r\n- When you create the Connection, you create it with the endpoints and parameters; from that point on, those are immutable.\r\n- When you call Initiate(), you essentially wait for Ready before expecting any ability to read and write\r\n\r\nHowever, fast open (and just being efficient) caused us to allow sending and receiving prior to the Connection state becoming Ready. This allows fast open protocols to get sends early, but it also is beneficial for performance to pre-schedule your sends and receive callbacks, rather than waiting for a Ready event (which may require thread hops, etc).\r\n\r\nIf there's a one-to-one correspondence between a Connectable and what ultimately becomes a Connection (despite the fact that there may be many candidate transport stacks in the establishment phase), I'd rather have a single handle in the API.",
          "createdAt": "2018-02-13T17:42:52Z",
          "updatedAt": "2018-02-13T17:42:52Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To some extent, the Connectable/Connection split in the API looks like a good idea all the pre-establishment things you can do on a Connection look like method calls, and calling these methods after establishment is a runtime error:\r\n\r\n```go\r\nConnection := NewConnection()\r\n\r\nConnection.SetRemoteEndpoint(remote) // implied by \u00a75.1, which I'm not a fan of, after applying #43\r\nConnection.SetLocalEndpoint(local) // ditto\r\n\r\nConnection.Prefer(SomeTransportParameter) // see discussion in #34\r\nConnection.Avoid(SomeOtherParameter)\r\nConnection.Require(AThirdParameter)\r\n\r\nConnection.Initiate() // and you can only ever do this once\r\n```\r\n\r\nIf you're one of those Haskell strong-typing type people, this is a cardinal sin. \r\n\r\nWith a language that has the same features as the one we're assuming with our notation (something Go-like, without either method signature munging or optional named arguments), you could do something completely different:\r\n\r\n```go\r\nparameters := NewTransportParameters().Prefer(x).Avoid(y).Require(z)\r\nsecurity := NewSecurityParameters().AddIdentity(x).AddPrivateKey(y)\r\nremote := NewRemote().WithName(\"www.foobar.com\").WithService(\"https\")\r\nlocal := NewLocal().OnNamedInterface(\"en1\")\r\n\r\nConnection := NewConnection(parameters, security, remote, local)\r\n```\r\n\r\ni.e., the Connectable becomes the set of (mutable, and copied into the connection as opposed to referenced by it) specifiers, and the Connection itself loses all its icky \"you can't do these things after connecting\" actions.\r\n\r\nActually, while writing this, I've decided this is the pony in the bike shed that I want.",
          "createdAt": "2018-02-13T19:37:24Z",
          "updatedAt": "2018-02-14T14:09:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this bike shed so much I painted it myself: see [the postsocket API spec in Golang](https://github.com/mami-project/postsocket/blob/master/api.go), now ported over to this terminology.\r\n\r\n(This isn't complete; specifically, it needs more godoc, there are some security parameters fixmes, the parameter enums aren't there, and termination isn't done. But it's a start, and I'm swapping this out for the day...)",
          "createdAt": "2018-02-14T10:47:46Z",
          "updatedAt": "2018-02-14T10:47:46Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Colin because I think we still need an object we can work on in the pre-establishment phase which could actually trigger some preparation actions. Brian, in your example implementation I think that is what you need the Rendezvous for but their might be even more things you'd like to do in future (e.g. crypto-sep like pre-loading of security context).\r\n\r\nMaybe that would look like this:\r\n``` \r\nConnectable := new Connectable(parameters, security, remote, local)\r\nif (Connectable.rendezvous()==true)\r\n  Connection := Connectable.initiateConnection() \r\n```\r\n\r\nNot sure if that makes sense, but others are welcome to propose something else!",
          "createdAt": "2018-02-14T12:26:08Z",
          "updatedAt": "2018-02-14T12:27:09Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah, I'm not *quite* sure yet how Rendezvous fits into all this (paging @csperkins to go have a look at #6 :wink:)... but the fact that we seem to be converging on the point that Remotes and Locals are probably separate (see #43) and they themselves can be bound to some underlying context allows preparation to happen before `Initiate()` or `Rendezvous()` is called... \r\n\r\nIt seems like what we need for that case is some way to tell the pre-establishment Objects how they're likely to be used together. Grouping them into a Connectable would indeed be one way to do that, but there are others as well. For example, giving a Remote a pointer to a set of transport parametersat creation  (i.e. `Remote := NewRemote(TransportParameters)` in our notation) would be sufficient for resolution. Indeed, remotes for rendezvous probably need some information about discovery and relay servers, so that might be enough of a hint...\r\n\r\nCryptosep is different; SecurityParameters already has a way to preshare a key, and we should probably add a way to save/restore resumption parameters as well. \r\n\r\n",
          "createdAt": "2018-02-14T12:34:09Z",
          "updatedAt": "2018-02-14T12:34:09Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For both, rendezvous and crypto-preload you need to know the remote and the local as well as some of the parameters as this restricts which protocols you may use later. SecurityParameters allow you to set the key if you already know the key in the application, it does not trigger to pre-negoatiate crypto context because you already know that you are planning sooner or later to talk to a certain server. \r\n\r\nBtw. I still don't see where such long term state is stored in the current architecture. I still think there is something missing here but that's probably a different issue.",
          "createdAt": "2018-02-14T12:51:11Z",
          "updatedAt": "2018-02-14T12:51:11Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram The potential issue with this style of API is that there's no way to refer to the `Connectable`, i.e., the equivalent of an instantiated but unbound and unconnected socket. That might not matter. Or, we might specify that the above code is a convenience shortcut for (switching to Rust syntax):\r\n```rust\r\nlet parameters = TransportParameters::new().prefer(x).avoid(y).require(z);\r\nlet security   = SecurityParameters::new().add_identity(x).add_private_key(y);\r\nlet remote     = Remote::with_name(\"www.foobar.com\").with_service(\"https\");\r\nlet local      = Local::on_named_interface(\"en1\");\r\n\r\nlet connectable = Connectable::new(parameters, security, remote, local);\r\nlet connection  = Connection::from_connectable(connectable);\r\n```\r\ni.e., the `Connection` type has two constructors, one that takes a `Connectable`, and one that takes the parameters you'd use to create a `Connectable`. This gives the option of using `Connectable` where it matters, but doesn't require it.\r\n\r\n@tfpauly That there might not be a one-to-one correspondence between a `Connectable` and what ultimately becomes a `Connection` is part of my motivation for this. To implement ICE, for example, you might get the candidates as a list of `Connectable` objects, pass a representation of that list to your peer via the signalling protocol, then if the call is accepted tell the stack to do the connection racing for each `Connectable` in turn.",
          "createdAt": "2018-02-14T13:37:04Z",
          "updatedAt": "2018-02-14T13:37:04Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I got distracted in the middle of writing my comment, and more appeared... #6 is one of the reasons I want separate `Connection` and `Connectable`.",
          "createdAt": "2018-02-14T13:39:57Z",
          "updatedAt": "2018-02-14T13:39:57Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For both, rendezvous and crypto-preload you need to know the remote *and the local*\r\n\r\nHm. So Locals are a little weird in this API. The set of paths and interfaces you'll use for an eventual Initiate()/Rendezvous() are influenced by the Transport Parameters as well as the Local.\r\n\r\nYou really need a Local for Listen() (and probably Rendezvous() as well), since servers really do need to control what they speak, how, and where. For an Initiate(), at least, you'll probably always use a default Local and let the Transport Parameters do the work.\r\n\r\nI hadn't thought about crypto pre-establishment. You're right, there you need the security parameters (which were bound to Local in Post, but have been separated out now), maybe a Local, and a Remote...\r\n\r\n> Btw. I still don't see where such long term state is stored in the current architecture. I still think there is something missing here but that's probably a different issue.\r\n\r\n...which is called an Association. :) \r\n\r\nIIRC from Cambridge we (maybe implicitly) decided this was something the implementation would have to do on its own, and not an architectural concept. I think you're right, we might have been wrong. I'll file an issue.",
          "createdAt": "2018-02-14T13:48:42Z",
          "updatedAt": "2018-02-14T13:48:42Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We're all getting distracted it seems. :)\r\n\r\n>> The potential issue with this style of API is that there's no way to refer to the Connectable, i.e., the equivalent of an instantiated but unbound and unconnected socket.\r\n\r\nYep. I was trying to decide whether it was okay to model this as a bunch of parameters/remotes/locals bound to the underlying Context that maybe know about each other, or do we want to just bind these all up in one thing (\"ConnectionSpecifier\")?\r\n\r\nIt seems like this is most useful when it also (optionally) contains remembered or preloaded state about past interactions using the same parameters for the pair of endpoints; in other words, as @mirjak points out, it feels like we're reinventing Post's Association.",
          "createdAt": "2018-02-14T14:12:14Z",
          "updatedAt": "2018-02-14T14:12:14Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure `Connectable` is the same thing as Post's Association; it seems more ephemeral than that. I could certainly imagine some sort of association cache could be used to derive the parameters for a Connectable.",
          "createdAt": "2018-02-14T14:33:54Z",
          "updatedAt": "2018-02-14T14:33:54Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this a practical or mainly conceptual issue? The conceptual difference seems clear, but as we want to send on the Connectable before Initiate for the 0-rtt case things anyway gets conceptually messy, so then maybe it is not worth the separation. If it is needed to get the ICE scenario working that seems like a different thing. But then we need to be able to send on multiple Connectables at once or?",
          "createdAt": "2018-02-14T15:20:49Z",
          "updatedAt": "2018-02-14T15:20:49Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The conceptual reason to split the pre-establishment and establishment objects is that it's ugly to have things which mutate and lose methods through that mutation. (The practical reason to do this is that it leads to buggy code, I guess)\r\n\r\nThe practical reason to store this in a single object, as opposed to just keeping them separate and only bringing them into a Connection when you're ready to initiate the connection as I propose above, is that the runtime might want to know which remote is going to be used with which transport and security parameters to \"pre-flight\" connection establishment.\r\n\r\nOf course, you can also achieve this by using the API as above, then creating a Connection, but not initiating or listening on it; the Connection still has \"connected\" and \"not connected\" states, but remains immutable.\r\n\r\n",
          "createdAt": "2018-02-14T15:30:11Z",
          "updatedAt": "2018-02-14T15:30:11Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I don't think we want to send on a `Connectable` for the 0-rtt case. Once the object is in the state where you can send data, even 0-rtt data, you have a `Connection`. \r\n\r\nFor ICE, I think we need the ability to query the possible candidates that you can connect on. That is, to get a set of `Connectable` objects that we can later pass to `initiate()` to tell it to start connection racing. The reason we need to expose the connectables is that you need to pass the list of candidates to the peer via the signalling protocol, potentially long before starting the connection racing (indeed, if you're doing ICE for SIP and the call is declined you may never initiate the connections, but you still need the set of connectables).",
          "createdAt": "2018-02-14T16:23:10Z",
          "updatedAt": "2018-02-14T16:23:10Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll prepare a pull request to make this concrete, but looking at my schedule for the week this won't be until Friday at the earliest.",
          "createdAt": "2018-02-14T16:25:56Z",
          "updatedAt": "2018-02-14T16:25:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins, thanks for the explanation regarding the one-to-one question. So, if I understand correctly, the point you're making is that there many be many Connectables for a single ultimate Connection\u2014essentially, the Connectable is a way to represent a cohesive set of connection possibilities (endpoints + parameters).\r\n\r\nI think that makes more sense than what my original impression was. We've had some use cases in our implementation to do a similar thing, and way we've done that is to define an array of transformations within the parameters object; an example of a transformation would be \"try Remote B instead of Remote A, and when you do, also use Properties B\". I agree that it's cleaner to have potentially separate objects to represent the options here.\r\n\r\nFor a case in which there is only a single connectable set of Remote + Local + Properties, I'd like to ensure that it is still easy for an application to create a Connection somewhat directly (a convenience initializer to instantiate a Connection with the components of a single Connectable, rather than having to create a Connectable just to immediately create a single Connection from it). Giving a set of Connectable options would be the more full and advanced approach. Is that fine with everyone?\r\n\r\nI'd also like to see Initiate() remain on the Connection object, since it seems that we really want the flow to be:\r\n- Create set of N Connectables (sets of endpoints and properties)\r\n- Create a Connection using one or more Connectables as the ones it wants to actively try\r\n- Initiate the Connection, which starts racing",
          "createdAt": "2018-02-14T16:38:14Z",
          "updatedAt": "2018-02-14T16:38:14Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly makes sense to me",
          "createdAt": "2018-02-14T17:29:52Z",
          "updatedAt": "2018-02-14T17:29:52Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I really like where all of this is going",
          "createdAt": "2018-02-14T17:35:29Z",
          "updatedAt": "2018-02-14T17:35:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly @csperkins thanks for this exchange, I understand the concept now, and I think it's the right way to go.\r\n\r\nAlas, I'm going to have to bikeshed on the name, I'm afraid. I can't not dislike \"Connectable\".\r\n\r\nConnectionSpecifier (which will invariably become ConnSpec for short)? ConnectionTemplate (ugh)? Preconnection? \r\n\r\n(Will keep updating the API sketch, to reflect this, in the meantime)",
          "createdAt": "2018-02-14T19:16:07Z",
          "updatedAt": "2018-02-14T19:17:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, naming.\r\n\r\nI like Template best of the options here. It's kind of the bundle of Properties, but that's already used. Prototype? ",
          "createdAt": "2018-02-14T19:18:37Z",
          "updatedAt": "2018-02-14T19:18:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Template will confuse the C++ people, though that might be a feature.",
          "createdAt": "2018-02-14T19:51:53Z",
          "updatedAt": "2018-02-14T19:51:53Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm writing up the (full, general) interface for this in the Go sketch now. The slice-of-Connectables  thing makes this not very pretty at all (i'm calling Connectable `ConnectionSpecifier` here, and `TransportContext` is the toplevel)\r\n\r\n```go\r\ntype TransportContext interface {\r\n  NewTransportParameters() TransportParameters\r\n  NewSecurityParameters() SecurityParameters\r\n  NewRemote() Remote\r\n  NewLocal() Local\r\n  DefaultSendParameters() SendParameters\r\n\r\n  NewConnectionSpecifier(rem Remote, loc Local, tp TransportParameters, sp SecurityParameters) ConnectionSpecifier\r\n\r\n  Initiate(ch ConnectionHandler, specs []ConnectionSpecifier) (Connection, error)\r\n  InitialSend(ch ConnectionHandler, specs []ConnectionSpecifier, content interface{}, ) (Connection, error)\r\n  Rendezvous(ch ConnectionHandler, specs []ConnectionSpecifier) (Connection, error)\r\n  Listen(ch ConnectionHandler, specs []ConnectionSpecifier) (Connection, error)\r\n}\r\n\r\ntype Connection interface {\r\n  Send(c interface{}, sp SendParameters) error\r\n  Clone() (Connection, error)\r\n}\r\n\r\ntype ConnectionHandler struct {\r\n  Ready    func(conn Connection, ante Connection)\r\n  Received func(content Content, conn Connection)\r\n  Sent     func(conn Connection, contentref interface{})\r\n  Expired  func(conn Connection, contentref interface{})\r\n  Error    func(conn Connection, contentref interface{}, err error)\r\n  Frame    func(content interface{}) ([]byte, error)\r\n  Deframe  func(in io.Reader) (Content, error)\r\n}\r\n\r\n```\r\n\r\nSince the `[]ConnectionSpecifier` -- the group of all possible combinations of remote/local/params -- is the thing you actually want to invoke the Initiate (etc.) actions on, it probably makes sense to make that high-level, instead (and now we need a better name)\r\n\r\n```go\r\nNewConnectionSpecifierSet() ConnectionSpecifierSet\r\ntype ConnectionSpecifierSet interface{\r\n  AddSpecifier(rem Remote, loc Local, tp TransportParameters, sp SecurityParameters)\r\n  Initiate(ch ConnectionHandler) Connection\r\n  InitialSend(ch ConnectionHandler, content interface{}, sp SendParameters) Connection\r\n  Rendezvous(ch ConnectionHandler) Connection\r\n  Listen(ch ConnectionHandler) Connection\r\n}\r\n\r\n```\r\n\r\nThat `InitialSend` ugliness is there because there's no such thing as a Connection that isn't either setting up, connected, or closed -- this API has the advantage that you don't have magic morphing states. Of course, you can get rid of it by moving all of the state calls back into the Connection itself, and the Connection itself then becomes the natural container for the connection specifier set; i.e., exactly what this issue started off saying we don't want. But it's IMO aesthetically nicer.\r\n\r\n```go\r\ntype TransportContext interface {\r\n  NewTransportParameters() TransportParameters\r\n  NewSecurityParameters() SecurityParameters\r\n  NewRemote() Remote\r\n  NewLocal() Local\r\n  DefaultSendParameters() SendParameters\r\n\r\n  NewConnection(ch ConnectionHandler) Connection\r\n}\r\n\r\ntype Connection interface{\r\n  AddSpecifier(rem Remote, loc Local, tp TransportParameters, sp SecurityParameters)\r\n  Initiate()\r\n  Rendezvous()\r\n  Listen()\r\n  Send(c interface{}, sp SendParameters) error\r\n  Clone() (Connection, error)\r\n}\r\n```\r\n\r\nI don't like the type-uncleanliness of this. But I suspect we might be rediscovering why sockets have the same kind of type uncleanliness.",
          "createdAt": "2018-02-14T22:35:18Z",
          "updatedAt": "2018-02-14T22:35:18Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One more try to make this prettier then I'm done for the night:\r\n\r\n```go\r\ntype TransportContext interface {\r\n  NewTransportParameters() TransportParameters\r\n  NewSecurityParameters() SecurityParameters\r\n  NewRemote() Remote\r\n  NewLocal() Local\r\n  DefaultSendParameters() SendParameters\r\n\r\n  // with explicit preconnection: start doing things you might need to do for this set of params. \r\n  // you need at least one, so you can't create an empty Preconnection\r\n  Preconnect(ch ConnectionHandler, rem Remote, loc Local, tp TransportParameters, sp SecurityParameters) Preconnection\r\n  \r\n  // \"shortcuts\" for use without preconnection\r\n  Initiate(ch ConnectionHandler, rem Remote, loc Local, tp TransportParameters, sp SecurityParameters) Connection\r\n  Rendezvous(ch ConnectionHandler, rem Remote, loc Local, tp TransportParameters, sp SecurityParameters) Connection\r\n  Listen(ch ConnectionHandler, loc Local, tp TransportParameters, sp SecurityParameters) Connection\r\n}\r\n\r\ntype Preconnection interface{\r\n  AddSpecifier(rem Remote, loc Local, tp TransportParameters, sp SecurityParameters)\r\n  Initiate() Connection\r\n  InitialSend(content interface{}, SendParameters sp) Connection\r\n  Rendezvous() Connection\r\n  Listen() Connection\r\n}\r\n\r\ntype Connection {\r\n  Send(c interface{}, sp SendParameters) error\r\n  Clone() (Connection, error)\r\n}\r\n```\r\n\r\nActually, that's not that bad. I think I can live with that.",
          "createdAt": "2018-02-14T22:41:18Z",
          "updatedAt": "2018-02-14T22:41:18Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that is what we want or need, however, Colin, correct me if I'm wrong! I don't think you would give multiple <Local,Remote,Parameter> inputs to the Preconnection. Instead if you e.g. call Preconnection.Rendezvous() this could internally create multiple connections (not sure if they would even needed to be returned/exposed to the app or not). If you then call Preconnection.Initiate() this returns you exactly one oft theses connections that have been reestablished. At least that was my thinking...\r\n\r\nRegarding naming, I guess I'll nominate \"Preconnection\" :-)",
          "createdAt": "2018-02-15T18:05:04Z",
          "updatedAt": "2018-02-15T18:05:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Preconnection is what I've settled on in the API sketch, because `Preconnect()` is quite descriptive of what's actually happening.",
          "createdAt": "2018-02-15T18:36:41Z",
          "updatedAt": "2018-02-15T18:36:41Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWUyOTY3OTI1MDc=",
      "title": "Types: local and remote endpoints",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/43",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "One of the things Post Sockets did was to separate `Local` and `Remote` into distinct types, rather than having a single `Endpoint` type. I think this is a useful distinction, that we should re-introduce it into the Transport Services API, since the two types are not interchangeable in the API calls. \r\n\r\nExamples:\r\n* In Section 5, the `NewConnection()` call doesn't take two `Endpoints`, it takes a `Local` and a `Remote`.\r\n* In Section 5.1, the allowable operations on `localSpecifier` are different to those on `remoteSpecifier` (the interface can be specified for the local, but not for the remote). \r\n\r\nI'm not much tied to the names, but I think it important that we distinguish logically separate types in the API and architecture. \r\n\r\nDiscuss.",
      "createdAt": "2018-02-13T16:06:42Z",
      "updatedAt": "2018-02-23T20:32:11Z",
      "closedAt": "2018-02-23T20:32:11Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I noticed this in \u00a75.1 too, and agree we should separate these back out.\r\n\r\nWe should also make it clear that, for the most part, Local specifiers are most useful in server contexts -- where you really do care which specific ports and addresses are -- while in client contexts it's more useful to let the path selection properties fetch you a reasonable Local.",
          "createdAt": "2018-02-13T16:09:02Z",
          "updatedAt": "2018-02-13T16:09:02Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the architecture perspective, I still find it useful to have a superclass concept for the subclasses of Local and Remote. How about in the architecture, we leave Endpoint, but add Local and Remote and types of endpoints, and let the API reflect that distinction?",
          "createdAt": "2018-02-13T16:17:15Z",
          "updatedAt": "2018-02-13T16:17:15Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When writing $5.1, I first had them separate but soon realised that all operations I wrote can be applied to both.\r\nFor those who disagree at first glance, keep in mind that even SetInterface on RemoteEndpoints has its use for link-local and interface-local communication.\r\n\r\nWhether we say Local and RemoteEndpoints are subclasses of Endpoint or they are the same Class used in different ways I don't care. I just don't want to duplicate common functionality.",
          "createdAt": "2018-02-14T10:36:37Z",
          "updatedAt": "2018-02-14T10:36:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> but soon realised that all operations I wrote can be applied to both\r\n\r\nso this gets into a philosophy-of-languages discussion pretty quickly, which I'd like to avoid, but simply because two things have the same action does not mean they are the same kind of thing. \r\n\r\nFirst, local and remote resolution happen completely differently -- although Locals must also keep around all their unresolved information in case the device roams onto a different network and new local endpoints/interfaces/addresses become available dynamically. The system might want (need) to know whether an Endpoint is intended for Local or Remote use before it's bound to a Connection (see #42 for why this is necessary) for resolution hinting purposes.\r\n\r\nSecond, the contracts for multiple value usage of Locals and Remotes are different; multivalue Locals mean \"try all of these on Initiate; listen on all of these on Listen\", while multivalue Remotes mean \"here is your candidate space\".\r\n\r\nThird, they're not even really the same thing from a ducktyping perspective: I would argue (and do in the [present API sketch](https://github.com/mami-project/postsocket/blob/master/api.go)) that `.WithInterface()` really doesn't belong on Remote at all.",
          "createdAt": "2018-02-14T10:55:18Z",
          "updatedAt": "2018-02-14T10:55:31Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - you convinced me about the first two \u2013 most operations do completely different things.\r\n\r\nOn the third one, I disagree.  When I want to reach a host on its link-local address reachable via en0, the following is semantically right:\r\n\r\n~~~\r\nre := Remote()\r\nre.withAddress(fe80::dead:beef)\r\nre.withInterface(en0)\r\ncon := Connection(nil, re, parameters)\r\n~~~\r\n\r\nThis becomes obvious, when I do the same, but instead of specifying the address and interface, I use a bonjour based host name. \r\nThe interface for the LL address comes from bonjour and thus is part of the remote, not the local endpoint specifier.",
          "createdAt": "2018-02-14T11:21:21Z",
          "updatedAt": "2018-02-14T11:21:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not an interface, that's an IPv6 Scope ID, which is properly treated as part of the address.",
          "createdAt": "2018-02-14T12:07:27Z",
          "updatedAt": "2018-02-14T12:07:27Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Question is what would be implemented in the endpoint superclass that is applicable to both local and remote? I don't see anything here. @tfpauly , do you have further insights?",
          "createdAt": "2018-02-14T12:44:51Z",
          "updatedAt": "2018-02-14T12:44:51Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram That depends how you define the address or address representation. \r\n\r\nMost implementations differentiate between scope-id (equals interface index) and interface name.\r\n\r\n- If we explicitly define address to include address to include the scope ID which can be represented by an interface name, I am fine to remove withInterface from the remote address.\r\n- otherwise, we should rename withInterface to withScope and accept interface Names as scopes\r\n\r\nnot sure if we are already in the implementation\u2026",
          "createdAt": "2018-02-14T12:57:21Z",
          "updatedAt": "2018-02-14T12:57:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> That depends how you define the address or address representation.\r\n\r\nIt's pretty clearly part of the address. [RFC4007](https://datatracker.ietf.org/doc/RFC4007). Whether that's a bug in most implementations or a bug in IPv6 is an exercise for the reader :grin:",
          "createdAt": "2018-02-14T13:49:07Z",
          "updatedAt": "2018-02-14T13:49:07Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(FWIW: https://golang.org/pkg/net/#IPAddr )",
          "createdAt": "2018-02-14T13:49:50Z",
          "updatedAt": "2018-02-14T13:49:50Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak I think there are parts of Endpoint that are in the superclass\u2014they may seem rather trivial, but they're useful for implementations to deal with.\r\n\r\nEssentially, we need a type to represent either an Address + Port, a Hostname + Port, a DNS Service Name, etc. Being able to have a base class that can be used for comparison, etc, is very useful\u2014is this local endpoint actually the same as this other remote endpoint, because I'm going over loopback or something similar.\r\n\r\nAlso, while the case of a IPv6 scope ID is not really an interface being added to an endpoint, but a property of the address itself, we do in fact have cases in which we tag endpoints with the interfaces (or PvDs) that they are relevant on. This is mainly useful for locally discovered DNS services. I can resolve a service like \"Tommy's Tunes._music._tcp.local.\", and get multiple Hostname + Port results, each that was resolved locally to a different interface, and which will ultimately use a different address. So, tagging an interface isn't really an operation we let the application do when creating connections, but it can happen internally during the course of resolution.",
          "createdAt": "2018-02-14T17:43:36Z",
          "updatedAt": "2018-02-14T17:43:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "question then is, do we explicitly expose that superclass relationship in the API, or do we let the implementation figure that out on its own?\r\n\r\n(In the current Go sketch, it's obvious that you could/ should share much of the low-level implementation, even having Local and Remote just be interface-mediated views on the same underlying struct type, but that's just an artifact of how Go does interface typing)",
          "createdAt": "2018-02-14T19:41:47Z",
          "updatedAt": "2018-02-14T19:41:47Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the only common feature is that `Local` and `Remote` can be compared, then I'd argue that we should just document that and leave it to the implementation how it's implemented. If there are API calls that can take or return _either_ a `Local` or a `Remote` then we should likely mandate a common supertype.",
          "createdAt": "2018-02-14T20:24:38Z",
          "updatedAt": "2018-02-14T20:24:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not just comparison, though. Unless we expect people to use sockaddr structs (please no) and direct hostname strings and port integers, we need some wrapper type to hold the contents of endpoint names and addresses.",
          "createdAt": "2018-02-14T20:26:57Z",
          "updatedAt": "2018-02-14T20:26:57Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To me this sounds like we sounds have Local and Remote as the architecture object and the common superclass is just an implementation detail...",
          "createdAt": "2018-02-15T17:54:48Z",
          "updatedAt": "2018-02-15T17:54:48Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWUyOTcwNTAzNTY=",
      "title": "Add an appendix with an API sketch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/44",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Finish https://github.com/mami-project/postsocket/blob/master/api.go, strip the comments, and add it to the document as an appendix to show how this would actually look in a real language.",
      "createdAt": "2018-02-14T10:48:43Z",
      "updatedAt": "2018-02-15T20:21:42Z",
      "closedAt": "2018-02-15T20:21:41Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is done, with docs at https://godoc.org/github.com/mami-project/postsocket",
          "createdAt": "2018-02-15T20:15:12Z",
          "updatedAt": "2018-02-15T20:15:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUyOTcxMDc3NTY=",
      "title": "Do we need to make state storage explicit in the architecture and API?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/45",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "britram"
      ],
      "labels": [
        "API",
        "Architecture",
        "ready for text"
      ],
      "body": "Post Sockets had an Association concept, which contained all the information about a pair of endpoints, including security parameters, cached security state, cached path state information, and so on. ISTM that we implicitly decided that this was implementation-specific in the Cambridge meeting (though it lived on in the architecture as Association Cache in \u00a74.2).\r\n\r\nIt turns out that the Connectable proposed by @csperkins in #42 shares enough of its properties with the non-cacheable bits of an Association that we might want to make this an explicit object in the API again. \r\n\r\nDiscuss.",
      "createdAt": "2018-02-14T14:07:32Z",
      "updatedAt": "2019-11-20T06:06:13Z",
      "closedAt": "2019-11-20T06:06:13Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should leave this out for v1, I think it is a whole other discussion. On the taps-level there is nothing on the other end so I find it confusing to talk about a pair of endpoints. I am not sure where the term Association Cache came from, but can we call it just Cache or at least something other than Association Cache? I find the term Association very confusing both because it seem to imply a taps counterpart on the other side and because connection and association are very similar to me (just depends on if one use TCP or SCTP :) ). The cache can contain many things, some of them related to a remote endpoint some of them not.",
          "createdAt": "2018-02-14T14:47:49Z",
          "updatedAt": "2018-02-14T14:47:49Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok, punting to post-London",
          "createdAt": "2018-02-14T15:23:52Z",
          "updatedAt": "2018-02-14T15:23:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Grabbing this one, as I've been working with the association concept a bunch recently, so I'd like to take a stab at editing the text.",
          "createdAt": "2018-05-16T02:08:17Z",
          "updatedAt": "2018-05-16T02:08:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I'm thinking we should punt this out to -02, that OK with you?",
          "createdAt": "2018-06-27T14:35:15Z",
          "updatedAt": "2018-06-27T14:35:15Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly Yep. basically at this point I'm thinking that -01 is going to be #200 and #201 and we're done.",
          "createdAt": "2018-06-27T16:38:25Z",
          "updatedAt": "2018-06-27T16:38:25Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping @tfpauly would you like to take a crack at this for pre-Bangkok?",
          "createdAt": "2018-10-07T10:26:01Z",
          "updatedAt": "2018-10-07T10:26:01Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram Yes, that sounds good",
          "createdAt": "2018-10-08T15:26:59Z",
          "updatedAt": "2018-10-08T15:26:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly shall we wait for this before submitting the next rev (deadline Monday)?",
          "createdAt": "2018-10-19T09:27:42Z",
          "updatedAt": "2018-10-19T09:27:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I'll try to get something out today; if I don't, then we can skip.",
          "createdAt": "2018-10-19T14:18:24Z",
          "updatedAt": "2018-10-19T14:18:24Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see discussion on #244 -- I think we (y'all ;) ) should spend some time on this in Bangkok, then take another pass on writing up the consensus that falls out of that.",
          "createdAt": "2018-10-22T08:21:59Z",
          "updatedAt": "2018-10-22T08:21:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see discussion on #244 -- I think we (y'all ;) ) should spend some time on this in Bangkok, then take another pass on writing up the consensus that falls out of that.",
          "createdAt": "2018-10-22T08:23:52Z",
          "updatedAt": "2018-10-22T08:23:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Call the connection group a connection context instead?",
          "createdAt": "2019-03-25T11:50:42Z",
          "updatedAt": "2019-03-25T11:50:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Create explicit context to hand to preconnect",
          "createdAt": "2019-03-25T11:52:12Z",
          "updatedAt": "2019-03-25T11:52:12Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not passing any context puts you in the implicit context",
          "createdAt": "2019-03-25T11:52:29Z",
          "updatedAt": "2019-03-25T11:52:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On review, this should have been closed with #294 -- closing.",
          "createdAt": "2019-11-20T06:06:13Z",
          "updatedAt": "2019-11-20T06:06:13Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWUyOTcyODYzOTg=",
      "title": "How to set / query protocol properties after establishment",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/46",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Hi,\r\n\r\nThis needs text - the fact that one can change properties in established state is somewhat hidden in the API doc, but it IS reflected in table A2 here:\r\nhttps://taps-api.github.io/drafts/draft-trammell-taps-interface.html#rfc.appendix.A.2\r\n\r\nI can't even find a suitable empty section in the implementation draft. Even the \"maintenance\" section: https://taps-api.github.io/drafts/draft-brunstrom-taps-impl.html#implementing-maintenance-events  seems to be about something else. If that's ok, I'll create a section and write text on how to implement the protocol properties in established state.",
      "createdAt": "2018-02-14T23:48:07Z",
      "updatedAt": "2018-02-16T21:45:00Z",
      "closedAt": "2018-02-16T21:45:00Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For me, querying properties after establishment clearly belongs in a \"Maintenance\" section, perhaps a different subheading than the Maintenance events, so the top-level heading could just be \"Implementing Maintenance\". But those parts could also be merged later, I think.\r\nThe API draft probably needs a \"Maintenance\" section as well, see #29.",
          "createdAt": "2018-02-15T10:56:47Z",
          "updatedAt": "2018-02-15T10:56:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "note that this and #29 almost seem like duplicates of each other, so @mwelzl please make sure you're not hacking on the same stuff right now -- @theri notes in #29 that she's writing a section too...",
          "createdAt": "2018-02-15T13:19:14Z",
          "updatedAt": "2018-02-15T13:19:14Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One is API (mine), one is Implementation (Michael's). I think we just have to make sure they match later\r\nand I'm not planning to come up with anything radically new there.",
          "createdAt": "2018-02-15T13:37:24Z",
          "updatedAt": "2018-02-15T13:37:24Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ahhhhh i missed the tags. sorry, thanks, carry on... :)",
          "createdAt": "2018-02-15T13:38:11Z",
          "updatedAt": "2018-02-15T13:38:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Querying is kinda trivial except for the size of a message before even connecting, but that's not in scope of this issue (\"after establishment\"). Setting, I just did (as a subsection of maintenance as suggested by @theri), so I'm done and I close this.",
          "createdAt": "2018-02-16T21:45:00Z",
          "updatedAt": "2018-02-16T21:45:00Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUyOTc0ODk3MTU=",
      "title": "Inform Application about TransportStack and Pseudo-Transports",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/47",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri",
        "philsbln"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This is a fork of what is left from #27.\r\n\r\nProtocol Selection and Connection racing  lead to different stacks.\r\nThe application needs to be able to introspect what it actually used to connect and whether a pseudo-transport like HTTP is provided by the transport system.\r\n\r\n- Where is the best place to inform the application? Possible Places:\r\n   - Only allow introspection on the Connection\r\n   - Pass it to the Ready / ConnectionReceived event\r\n   - Make it part of receive \r\n- If pseudo-transport are more than framers, how to extract the protocol information?",
      "createdAt": "2018-02-15T15:35:45Z",
      "updatedAt": "2018-02-21T20:21:26Z",
      "closedAt": "2018-02-21T20:21:26Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I think there are MANY things that an application may want to ask about. The easiest and most flexible way to handle this seems to me to just offer a \"status\" primitive that's associated with the Connection, and that an app can call whenever it wants, in whichever phase it want. \"Status\" returns a data structure. We can define the minimum contents of this data structure as a list somewhere. We can start by including the chosen protocol, the chosen interface, ...    does this make sense?",
          "createdAt": "2018-02-15T23:05:18Z",
          "updatedAt": "2018-02-15T23:05:18Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having a \"Status\" primitive sounds good to me, though Connection.getProperties() in Section 9 (Maintenance) goes in the same direction.\r\nPre-Establishment, \"Status\" could return that the Connection is not opened yet, maybe the TransportParameters, and perhaps some Protocol Stacks that might be tried later. I think we need these Protocol Stacks here already, because otherwise I don't know how an application can query \"Maximum Content Size Before Connection Establishment\". I suggested having such a list of protocols available in the Implementation draft in \u00a73.1, because the implementation should realize as early as possible if there are no protocols that it can try, e.g., due to impossible requirements from the application.\r\nOn Initiate(), it could return something on the Candidates that are being gathered and raced, but not sure how much we want to expose to the application there - maybe just the \"phase\" that the implementation is currently in (i.e., Gathering or Racing in progress)? I'm sure there can also be such as status label after Listen() or Rendezvous().\r\nAnd then finally after a Ready<> event, the application can query the actually chosen Protocol Stack, which I called Protocol Stack Instance in Appendix A.2, which is bound to the Connection, and also the Connection's Path(s).\r\nWe could pass this information also in the Ready<> Event, I think, to make it more convenient for applications that care, but maybe that's too much. I definitely wouldn't make it part of every Receive.",
          "createdAt": "2018-02-16T09:54:43Z",
          "updatedAt": "2018-02-16T09:54:43Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like we all agree on a general direction. (Just had a phone call with @theri)\r\n\r\n- We should have a ``Connection.GetStatus()`` call that returns some Object to introspect the status of the connection\r\n- We should also have a ``Connection.GetParameters()`` call that just returns the ConnectionParameters Object\r\n- Maybe rename the *Maintenance* section into *Introspection*\r\n- Adding the Status Object to Receive or Ready events seems superficial, because we have a connection reference there and  can all getStatus on it.\r\n\r\nI think we can wait with writing the API part after @mwelzl has finished the corresponding part in the Implementation. @theri and I can do this together.\r\n\r\nFinal Question: is this for London or post-London?",
          "createdAt": "2018-02-16T11:17:01Z",
          "updatedAt": "2018-02-16T11:17:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think a first stab should be for London; and I don't care at all about the name (FWIW, Connection.getProperties sounds better to me than \"Status\").\r\n\r\nWhat I do think is that we shouldn't have separate calls but just one which, as Theresa suggests, will be able to return much less information in pre-establishment (i.e., I don't think we should have a separate call \"just returning the ConnectionParameters object\" - let's rather have one that generally gives us everything an app may possibly want to know, I can't see any negative sides to this and it seems simpler).\r\n\r\nAbout what exactly we offer with \"getProperties\" (can we agree on that as a name?), I think we should, for once, really begin small: what's the absolute minimum that we think applications should be able to learn per phase?    I think this is a very obvious case for implementations going beyond the standard - surely implementers will just dump whatever they think is useful for app programmers here. And that should be fine!  The more the merrier!  What we need to do is to ensure that they don't miss including the things that we write up.",
          "createdAt": "2018-02-16T11:55:44Z",
          "updatedAt": "2018-02-16T11:55:44Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alright, the \"Status\" can just be one property that the application can get using Connection.getProperties() then.\r\nOther things the application can get are the Transport Parameters that it specified in the beginning, the Protocol Features of the actually chosen protocols, and the Protocol Properties we define in 5.2.2. I think the question of what exactly the application can query and when is also answered in Appendix A.2. Agree that there can be more, e.g. Path Properties, but at the moment I don't see that we have to standardize these Path Properties, at least not pre-London.\r\nAbout renaming the section to Introspection I'm not sure - doesn't that imply read-only? But the application can also set Protocol Properties on the connection. Perhaps a call for this should be included in that section as well.",
          "createdAt": "2018-02-16T12:53:06Z",
          "updatedAt": "2018-02-16T12:53:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I just agree 100% with everything @theri wrote here",
          "createdAt": "2018-02-16T12:56:15Z",
          "updatedAt": "2018-02-16T12:56:15Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- We need to model ConnectionProperties then, including\r\n   - reference to ConnectionProperties\r\n   - reference to ProtocolStack (and model Pseudo-Transport there)\r\n- I think we do not need a separate call to set ProtocolProperties \u2013 modifying the TransportParameters object accessible through the ConnectionProperties should be sufficient.\r\n- Keeping PathProperties for post-London is fine with me",
          "createdAt": "2018-02-16T13:03:14Z",
          "updatedAt": "2018-02-16T13:03:14Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For me, Introspection doesn't necessarily mean read-only. \"Introspection\" or \"Reflection\" is commonly used to describe the programming language feature that lets programs muck around with the language internals, so this \r\n\r\nI also agree that we should specify *what* the minimum set of information the API must make available, though not necessarily *how* that should be represented (since sometimes this will be determined by the language/platform idioms). @theri's suggestion here seems good to me (though, echoing @philsbln, I do think we need at least to allow the application to see the selected stack instance(s) in the established phase.)",
          "createdAt": "2018-02-16T14:06:39Z",
          "updatedAt": "2018-02-16T14:06:51Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Feel free to comment or extend, and/or close this issue.",
          "createdAt": "2018-02-16T16:57:52Z",
          "updatedAt": "2018-02-16T16:57:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "- Can we just call the section \u201cSetting and Querying of Properties\u201d? (this comment is also Issue: API section 9 title #54)",
          "createdAt": "2018-02-21T12:46:10Z",
          "updatedAt": "2018-02-21T13:31:17Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me, i.e., yes we can rename it. I agree it's clearer that way.",
          "createdAt": "2018-02-21T14:15:50Z",
          "updatedAt": "2018-02-21T14:16:42Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Oh - and I agree with one call to get the conenction infromation.\r\nI think we should specify the first parameter as the state of the conenction.\r\nThe rest I think we need to keep simple to start with.",
          "createdAt": "2018-02-21T15:59:10Z",
          "updatedAt": "2018-02-21T15:59:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this seems done to me...",
          "createdAt": "2018-02-21T20:21:26Z",
          "updatedAt": "2018-02-21T20:21:26Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWUyOTg5MTE2MTM=",
      "title": "Do we need an indication that the application will not send any further data but is still willing to receive data (aka EndOfData())?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/53",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "As discussed with PR #49 we need to decide (post-London) if we want an EndOfData() call. It was noted that this is not supported by all protocols and that TCP's close() mixes things up wrongly. Therefore EndOfData() must be separate from Close() and might not have any effect if not supported by a certain protocol.",
      "createdAt": "2018-02-21T10:17:09Z",
      "updatedAt": "2018-06-01T12:02:23Z",
      "closedAt": "2018-06-01T12:02:23Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "My first reaction is that close and abort are the correct primitives here. \r\n\r\nDrilling into to details (TCP, SCTP/UDP, etc) is unlikely to be a useful thing in this spec. If we were to specify the semantics correctly, we do not need an additional primative. My fealing is probably flavoured by the belief that applications should anyway decide at a higher level that they have finished communication before they issue close, and not rely on a callback to do this  - anything left in the transport on calling close is unlikely to make it to the endpoint.",
          "createdAt": "2018-02-21T15:54:52Z",
          "updatedAt": "2018-02-21T15:54:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Gorry that we can just use Close and Abort as top level Connection API calls.\r\n\r\nHowever, for Send(), I currently pass { Content, Metadata, isComplete, Callback } as parameters. The isComplete indicates if the Content is a full chunk for a message. When used over a streaming protocol like TCP directly, TCP can choose to interpret this as an indication to send a FIN. That replaces the notion of write-close for us.",
          "createdAt": "2018-02-21T16:43:41Z",
          "updatedAt": "2018-02-21T16:43:41Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Aha - the ability to {open,send,close} in one call is probably useful.",
          "createdAt": "2018-02-21T17:06:24Z",
          "updatedAt": "2018-02-21T17:06:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But the description \"open, send, close\" doesn't capture what this issue is about: \"... will not send any further data but is still willing to receive data\". write-close per se isn't a problem, but the \"still receive\" part is problematic. I also don't understand Mirja's statement that TCP's close \"mixes things up wrongly\" - I think TCP, and perhaps only TCP, gives you exactly what you want (\"...will not send any further data but is still willing to receive\"). SCTP is a counter-example, as it doesn't support half-closed connections, and the same is probably true for streams that are used as connections.\r\n\r\nAnyway: if we want to support \"will not send any further data but is still willing to receive\", we need to understand how this should work. I can imagine that, with a protocol that doesn't support half-closed connections, the transport system sends, remembers (above the transport) that the application is done sending, and the connection is kept open so the application can still receive, until .... when?  Who truly closes the connection, when? The other side?  I think that makes it application specific. I think it would work like that with web servers, though.",
          "createdAt": "2018-02-25T13:13:07Z",
          "updatedAt": "2018-02-25T13:13:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to resurrect this for discussion in -01.",
          "createdAt": "2018-05-16T02:12:50Z",
          "updatedAt": "2018-05-16T02:12:50Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The place I'm currently at with how to express sending a half-close is this:\r\n- Mark a property on the Message that it is the \"final\" message\r\n- Once that Message has been completely sent, the application has indicated it is done sending on that connection\r\n- Marking \"final\" on a Message's context implies that you want this message to be last if there is any sorting to do for niceness/priority/etc.\r\n- When receiving Messages, the receiver similarly can check the \"final\" property of the received Message to see if this is the last message that will be received\r\n\r\nThis allows the API to work just fine with TCP FINs, but also has the nice property of allowing many messages to be sent and received over a connection, while providing a way to signal that a set of Messages is complete.",
          "createdAt": "2018-05-16T02:20:46Z",
          "updatedAt": "2018-05-16T02:20:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing now that the PR is merged ",
          "createdAt": "2018-06-01T12:02:23Z",
          "updatedAt": "2018-06-01T12:02:23Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWUyOTg5NDMwNDI=",
      "title": "API section 9 title",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/54",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "9. Introspection\r\n- I really don\u2019t like the title /9. Introspection/\r\n- It does not tell me what this is.\r\n- Can we please just call it \u201cSetting and Query of Properties\u201d?\r\n",
      "createdAt": "2018-02-21T12:00:30Z",
      "updatedAt": "2018-02-21T14:34:46Z",
      "closedAt": "2018-02-21T14:32:32Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I kind of like Introspection, but ok.",
          "createdAt": "2018-02-21T14:32:41Z",
          "updatedAt": "2018-02-21T14:32:41Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 21/02/2018, 14:32, Brian Trammell wrote:\n>\n> I kind of like Introspection, but ok.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/54#issuecomment-367344579>, \n> or mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1kmUw-_r5dBUZ9n1iZmvuf54Ze4loks5tXCkKgaJpZM4SNhGD>.\n>\n:-)\n\nGorry\n\n",
          "createdAt": "2018-02-21T14:34:46Z",
          "updatedAt": "2018-02-21T14:34:46Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWUyOTg5NDM1ODQ=",
      "title": "API Section: 8.1. Application-Layer Back-Pressure at the Receiver",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/55",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "This text /Implementations of this interface must provide some way for the application to indicate that it is temporarily not ready to receive new Content. Since the mechanisms of event handling are implementation-platform specific, this document does not specify the exact nature of this interface./\r\n\r\n- I believe this is actually an example of a function that is provided by an APP. I really suggest we should avoid providing \u201chooks\u201d for APP signalling in the transport. That\u2019s been proposed in many transport systems in the past \u2026 and it often ends up messy. I\u2019d advocate telling the APP to implement the function itself!\r\n- Backpressure (flow control) is a classic example of what can be hard to realise, X.25, ATM, and more recently HTTP all tried and failed to make this a deadlock-free useful function!\r\n- I suggest we discuss this or remove it from the draft.",
      "createdAt": "2018-02-21T12:02:07Z",
      "updatedAt": "2018-02-26T22:00:26Z",
      "closedAt": "2018-02-26T22:00:26Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this text should be removed. The application should not indicate that it is not able to receive content\u2014that seems to imply sort of blocking semantics.\r\n\r\nThe way I prefer to think of it is simply that, in order to provide natural back pressure between the stack and the app, the act of Receiving is a \"pull\" model, rather than a \"push\" model. The application pulls up data from the stack to receive as necessary, by scheduling a callback to receive content in. The stack does not simply deliver content into a recurring callback over and over (which eliminates back pressure). While the act of scheduling the receive callback (to \"pull\") does indicate that the application is no longer unable to receive, this is a difference from explicitly indicating when it is not able to receive.",
          "createdAt": "2018-02-21T16:12:32Z",
          "updatedAt": "2018-02-21T16:12:32Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this implies making the Receive<> event special, in that you need to re-register for it each time... Okay, I buy that, will make this change in my omnibus edit pass (hopefully tomorrow, running out of time a bit...)",
          "createdAt": "2018-02-21T20:15:39Z",
          "updatedAt": "2018-02-21T20:15:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's no less special than a callback event for Send completion. \r\n\r\nFor Sending, you get a Send Complete event for *that* particular Send. It won't fire magically, it's one-to-one with each call to Send().\r\n\r\nEach call to Receive can/should be decorated with constraints on the read\u2014only read up to this much, or make sure you read a complete message/chunk/frame. So, the completion for the receive matches what was requested. For our implementation, there is a callback block that can be different for each invocation of Receive() in case it needs to go to a different codepath.\r\n\r\nEssentially, any event needs to have a contract of how it can repeat. For memory management reasons, it's important to know that there is a one-to-one call-to-callback correspondence if you want to allocate something in the call, and free it in the callback; or that an event can fire any number of times, which requires different handling.",
          "createdAt": "2018-02-21T20:20:25Z",
          "updatedAt": "2018-02-21T20:20:25Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWUyOTg5NDc1OTI=",
      "title": "API section 5.1 no example of the \u201ctransport-agnostic\u201d mode",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/56",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": " I think the current example misses the \u201ctransport-agnostic\u201d mode, so I think we need a simple further example that includes more than \u201cremoteSpecifier.withService(\"https\u201d)\u201d.\r\n",
      "createdAt": "2018-02-21T12:15:58Z",
      "updatedAt": "2018-10-07T10:30:25Z",
      "closedAt": "2018-10-07T10:30:25Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually, there seem to be examples without a service specifier; can you be more specific as to what you'd like to see here? (In any case, this doesn't seem blocking for -00)",
          "createdAt": "2018-02-26T16:47:00Z",
          "updatedAt": "2018-02-26T16:47:00Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair closing as inactive +  not-sure-what-the-problem-is, please reopen if you disagree.",
          "createdAt": "2018-10-07T10:30:25Z",
          "updatedAt": "2018-10-07T10:30:25Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWUyOTg5NDgxMTY=",
      "title": "API Section 5.2.1: Wording NiT",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/57",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "/Not all transport protocols work on all paths. /\r\n- seem untrue, I think the point is that /there could be paths over which some transport protocols are unable to operate, or remote endpoints that support only specific network addresses or transports/.",
      "createdAt": "2018-02-21T12:17:52Z",
      "updatedAt": "2018-02-21T14:13:29Z",
      "closedAt": "2018-02-21T14:13:29Z",
      "comments": []
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWUyOTg5NDg1Nzk=",
      "title": "Section 5.2.1. Choice of Title: Transport Preferences",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/58",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "\r\n(1) I think this function can also express a requirement, and I suspect this is also the case here, since I think you can prohibit certain types of interface/path, or require a corporate network PvD, or \u2026  etc. Is this actually the case - can we say so?\r\n(2) I think if (1) is true, \u201cpreferences\u201d is a rather weak word to describe what can be requirements. We suggested \u201cproperties\u201d, but maybe that is thought of as something else. If we need to, can we say \"Transport Preferences and Requirements\"?\r\n",
      "createdAt": "2018-02-21T12:19:28Z",
      "updatedAt": "2018-02-26T22:00:26Z",
      "closedAt": "2018-02-26T22:00:26Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(1) These are indeed both preferences and requirements (as is clear from the preference levels table after the first three paragraphs).\r\n(2) I'm not really inclined to change the title, though... the construct \"Preferences and Requirements\" would for parallelism have to be repeated throughout the text, which is a little clunky, and these really are preferences in the sense of a set of things the application expresses to the interface... sometimes that preference is \"I don't want connectivity if you can't give me these properties.\"",
          "createdAt": "2018-02-21T14:18:43Z",
          "updatedAt": "2018-02-21T14:18:43Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, these properties can be something the application Requires, Prefers, [wants to] Avoid, or Prohibits. \r\nI think we were discussing an \"umbrella term\" for these preference levels in #28, since \"Priorities\" does not work, but so far failed to come up with a better term than Preferences.\r\nI agree with Brian that always naming two of these levels, or even more, will get too clunky.",
          "createdAt": "2018-02-21T14:22:16Z",
          "updatedAt": "2018-02-21T14:22:16Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK, I agree that.\r\n\r\nCould you add a single opening sentence in this subsection that says this contains bothe preferences and requirements. That almost certainly would have avoided my comment:-)",
          "createdAt": "2018-02-21T14:29:00Z",
          "updatedAt": "2018-02-21T14:29:00Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to making it clear that there are preferences and requirements.\r\n\r\nI do find it a bit odd to have Transport Preferences include Path Properties and Protocol Properties\u2014the architecture separates those out, since they are used by the implementation pretty differently, and it may make sense to eventually have different sub-categories here. I guess I'm not sure what the \"Transport\" part is referring to: the transport protocol behavior, or the network-as-a-transport.",
          "createdAt": "2018-02-21T16:18:39Z",
          "updatedAt": "2018-02-21T16:18:46Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think at this point it potentially refers to both. Some preferences may indeed influence both, such as specifying multipath behavior (failover VS use in parallel etc), or Intents. But I agree that most Transport Preferences can be neatly sorted into either Protocol or Path selection properties and the draft should reflect this somehow, maybe by re-introducing separate headings. But then naming the third \"May be both\" category can get awkward...",
          "createdAt": "2018-02-21T16:25:10Z",
          "updatedAt": "2018-02-21T16:25:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we don't want an \"Ambiguous\" category. Perhaps just naming this differently than \"Transport\" would be useful.",
          "createdAt": "2018-02-21T16:54:51Z",
          "updatedAt": "2018-02-21T16:54:51Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why are we not sticking to the terminology agreed on in the architecture draft? Most of the terminology for pre-establishment in the API draft seems to be out of sync to me? What is called Transport Preferences is mostly what we have referred to as Protocol Selection Properties in the architecture + a few Path Selection Properties. Why not use that agreed on terminology and get rid of all other new inventions? We know some properties will influence both path and protocol selection, but agreed they could still be mapped to their main topic (Alternatively we need to rework the architecture document, but that would not be my preference.)",
          "createdAt": "2018-02-21T18:06:54Z",
          "updatedAt": "2018-02-21T18:06:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the sections in the architecture are fairly simple to explain and list here, and we can move out anything that doesn't fit to the appendix for now.",
          "createdAt": "2018-02-21T18:15:37Z",
          "updatedAt": "2018-02-21T18:15:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...okay, so what's the suggested change to the section now? Rename \"transport preferences\" to \"protocol and path selection properties\", make it clear earlier that these cover preferences and requirements (keeping the require/prefer/avoid/prohibit terminology\")...anything else?",
          "createdAt": "2018-02-21T19:42:16Z",
          "updatedAt": "2018-02-21T19:42:16Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "That would sound good to me. \r\n- If the open sentences start to explain what comes in the section, I'd think it would be lovely;-)\r\nA good phrase from the Arch reads: ... Path Selection Properties, Protocol Selection Properties, and Specific Protocol Properties influence the choice of transport that a Connection will use.",
          "createdAt": "2018-02-21T19:49:39Z",
          "updatedAt": "2018-02-21T19:49:39Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good! Not sure if we want to separate Path Selection Properties and Protocol Selection Properties into separate subsections or not? Perhaps it depends on how many we have in the end. ",
          "createdAt": "2018-02-21T21:59:23Z",
          "updatedAt": "2018-02-21T21:59:23Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would not separate them again as the distinction between Path Selection Properties and Protocol Selection Properties is not sharp.\r\n\r\nThe distinction between Transport Preferences and Intents/Protocol Properties was made based on their type \u2013 whether they are a preference (require/prefer/don't care/avoid/prohibit) or something else (Boolean/Enum/Int) \u2013 which is a different perspective than the one in the architecture.\r\nI choose the term \"Preferences\" because I still see this as a level of preference including \"I'd rather not communicate if by xxx is met / not met\", but I am not bound to that term.\r\n\r\nThis was the least weird/contradictory/overlapping categorisation I found for the given set of properties.",
          "createdAt": "2018-02-23T19:44:54Z",
          "updatedAt": "2018-02-23T19:44:54Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "agree that protocol and path properties cannot be separated. However, one way to make this section less weird would be to move the *protocol properties* out of preconnection, as @mwelzl suggests in #69. On editing to make this happen as part of the sweep, I'm coming to agree with him, so we'll try that out...",
          "createdAt": "2018-02-26T15:42:56Z",
          "updatedAt": "2018-02-26T15:42:56Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is fine to have them in preconnection, but as a different beast \u2013 so having Intents and Preferences to drive the path and protocol selection magic (and defaults for the protocol paramters) and Protocol Parameters that get applied once an applicable protocol was selected.\r\n\r\nThis divide can be copied into the message api later to allow per-message path selection",
          "createdAt": "2018-02-26T16:01:30Z",
          "updatedAt": "2018-02-26T16:01:30Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can not move the protocol properties out of preconnection. A protocol property such as Reliable Data Transfer for instance is a Protocol Selection Property and cannot be moved out. We have Protocol Selection Properties and Path Selection Properties drive the path and protocol selection, otherwise the architecture doc needs to change. If we cannot separate them just call the section Path and Protocol Selection Properties. ",
          "createdAt": "2018-02-26T16:56:45Z",
          "updatedAt": "2018-02-26T16:56:45Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The terminology collision is leading to problems here; see https://taps-api.github.io/drafts/bht-editorial-00/draft-trammell-taps-interface.html#rfc.section.9.1 for the protocol properties (not the protocol and path selection properties) that have been moved out of pre-establishment (but, as noted, can still be given during pre-establishment to pre-configure candidate Protocol Stacks)",
          "createdAt": "2018-02-26T16:58:53Z",
          "updatedAt": "2018-02-26T16:58:53Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moving the protocol properties out I think works ok as long as the protocol and path selection properties stays. But the use of the word parameters is very confusing. The name of 5.2 should then be specifying Transport Properties and we should stick to properties when talking about path and protocol properties. For instance: \r\n\"A Preconnection object holds **parameters** reflecting the application\u2019s requirements and preferences for the transport. These include protocol and path selection **parameters**...\"\r\nshould be\r\n\"A Preconnection object holds **properties** reflecting the application\u2019s requirements and preferences for the transport. These include protocol and path selection **properties**...\"\r\nSimilar cleaning needed throughout.",
          "createdAt": "2018-02-26T17:23:20Z",
          "updatedAt": "2018-02-26T17:23:20Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWUyOTg5NDkwMDM=",
      "title": "Section 5.2.3 -  Can the communicated Intents be profiles of abstract intents?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/59",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "\r\nWhen we worked on the NEAT architecture, it was clear that this type of function could be communicated via the API from the App, but in some cases the App may not wish a detailed spec and simply indicate a profile (naming a collection of the things it needs), allowing a policy to be instantiated that implements the actual control over which candidate paths to allow. For example, \u201cuse my corporate network\u201d, \u201cdo not bill me for this\u201d, to give very high-level examples that may match to actual requirements about whether public wifi is acceptable. My point here is that I would like to see two things:\r\n** The ability to express abstractly what is needed. \r\n** The ability to make that concrete in a policy.",
      "createdAt": "2018-02-21T12:20:41Z",
      "updatedAt": "2018-10-07T10:26:51Z",
      "closedAt": "2018-10-07T10:26:50Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd also like to see these things. I don't think we're there yet, and I don't think we'll get there this week. :) Pushing to post-London.",
          "createdAt": "2018-02-21T14:20:21Z",
          "updatedAt": "2018-02-21T14:20:21Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that these kinds of Intents/Profiles are useful. I would argue that these should go along with configuration rather than being used as parameter in the Transport API. Still there has to be some way to match different profiles within an application to the configuration.",
          "createdAt": "2018-02-24T13:46:56Z",
          "updatedAt": "2018-02-24T13:46:56Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To discuss in person in Montreal",
          "createdAt": "2018-05-16T15:32:42Z",
          "updatedAt": "2018-05-16T15:32:42Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair closing this as OBE, please re-open if you disagree.",
          "createdAt": "2018-10-07T10:26:50Z",
          "updatedAt": "2018-10-07T10:26:50Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWUyOTg5NTEwNTk=",
      "title": "API Section 5.2: Discuss types of Intents we want to standardise",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/60",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "I think the following ser of related comments all concern the QoS-focus of the current text. When we discussed the formation of TAPS we decided - correctly I believe - to leave QoS out of scope, and I think this implies avoiding that the API communicates what the APP is doing, and rather communicates what the APP need/expects from the network.\r\n\r\n\u2014\r\n5.2.3.1. Traffic Category\r\n I don\u2019t recall discussing this, and I do not think this should be included. I really do not agree with this. I think we should restructure this as an expectation of what the network path needs to provide. Saying it is \u201cquery\u201d and then discovering there are 500,000 queries per second isn\u2019t helpful. Saying it is \u201cbulk\u201d is wrong - what is bulk to one app may be interactive to another, etc.\r\n\r\nThis I really believe needs to be expressed in terms of \u201clow-latency\u201d, \u201cmaximise-throughput\u201d, etc. Things that are basic path capabilities.\r\n-  I don\u2019t recall discussing these below, and I do not think this should be included.:\r\n\r\n/5.2.3.2. Size to be Sent / Received\r\nThis Intent specifies what the application expects the size of a transfer to be. It is a numeric property and given in Bytes./\r\n- My starting point is to say \u201cthe app often does not know this\u201d and even when it does, this is often not a useful property. \r\n\r\n/5.2.3.3. Duration\r\nThis Intent specifies what the application expects the lifetime of a transfer to be. It is a numeric property and given in milliseconds./\r\n- I am OK with the concept, although I really dislike numeric parameters. Is it possible to express this as a boolean? - Maybe no, because the app has a specific deadline in mind?\r\n- If this can\u2019t be a boolean, can it be modified by the app as a connection proceeds? (If that is the case, I\u2019d argue this should be anticipated end-time, rather than duration. The duration makes very little sense once the call us on-going.\r\n\r\n/5.2.3.6. Cost Preferences/\r\n- I can see how the proposed format for this property provides extra detail, but I believe this us problematic for a basic TAPS API.\r\n- I suggest we replace this with something boolean - perhaps just the first /Avoid transports associated with monetary cost/ \u2026 the more depth we express in the basic API, the more problematic it is to resolve what the application is asking for against what it does and to associate a correct policy with conflicting parameters. I suggest the policy engine can more easily match this.\r\n- The example below tries to show why I would push hard on not having a Qos_style request\" with a numeric parameter:\r\n\"Consider an APP that actually knows something about the size of the objects at the point the client makes a request. And consider a network, say, that supports PvD where you know the RTT and some notion of the local path characteristics. The TAPS system can choose to use one interface rather than another.\r\n\r\nI think the idea of switching on the \"suggested\" size of the transfer could be wrong. My take is that the APP should identify it prefers low-latency rather than high-thgroughput (a binary quantity) for any short transactional objects. That is a concrete thing to request from the network. \r\n\r\nEven if the connection is cloned/maintained for other purposes that property remains valid for all connections that are in a group.. \r\n\r\nI also like that if an APP asks for a policy trade-off it necessarilly will benefit or loose based on whether the connection usage matches what you request. You can't game that, which you could if say \"I want to mov 20KB\" and actually send \"64KB\" but know that some other app asks for \"32KB\" and that you may win in this case... etc etc.\r\n\r\nI'd propose we carefully review the text in this section",
      "createdAt": "2018-02-21T12:27:19Z",
      "updatedAt": "2018-10-07T10:59:56Z",
      "closedAt": "2018-10-07T10:59:56Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm preparing for my big edit pass, and I continue to have concerns about how a lot of the QoS-focused Intents stuff fits into the interface at this level. My current thinking (which I guess I should file an issue for) is that we should create a \"Potential Extensions\" appendix that points out that one of the nice things about the framework we have (with transport and path prefs to bind prefs on a per-Connection basis and send parameters to bind prefs on a per-Content basis) is that we have what is (IMO anyway) the minimal and correct set of extension points, where you could add functionality to the base standard. For -00 I'm inclined to push everything we don't have consensus on (most of the Intents, per-Content Priority/Niceness) into this appendix, which gives us the ability to have these discussions with the wider WG, without losing the work we've done on integrating them so far.",
          "createdAt": "2018-02-21T14:24:35Z",
          "updatedAt": "2018-02-21T14:24:35Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Yes. That could be a good solution for me - I think we should **ONLY** include the stuff we really agree upon in the body. However, creating an appendix for us to disucss more is good for me, because to me there are two things here:\r\n- The socket intents work bubbles up useful ways you can judge what helps the app\r\n- This document needs to find a \"idiot-proof\" way of passing sufficient useful info across the API.\r\n- For some items - these two are subtley different.",
          "createdAt": "2018-02-21T14:32:46Z",
          "updatedAt": "2018-02-21T14:32:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we should definitely push anything iffy to the appendix, especially QoS. \r\n\r\nThe things I see as solid that we can leave for now are especially ones with very deterministic path selection implications: \"no metered/expensive\" (but not the other balance/optimize cost options), require/prohibit/prefer interface types, allow 0-RTT.",
          "createdAt": "2018-02-21T16:31:16Z",
          "updatedAt": "2018-02-21T16:31:16Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whatever is left should not be called Application Intents, but rather moved to Path Selection Properties or Protocol Selection Properties I think.",
          "createdAt": "2018-02-21T18:12:57Z",
          "updatedAt": "2018-02-21T18:12:57Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And removing to appendix sounds good.",
          "createdAt": "2018-02-21T18:14:00Z",
          "updatedAt": "2018-02-21T18:14:00Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree to not include QoS in the body of the draft. However, Intents are not QoS, as the current Section 5.2.3 already reflects. Rather, they specify exactly what Gorry proposes in the initial post, as an Intent \"[\u2026] communicates what the APP need/expects from the network.\" It is possible to map some Intents to DSCP, such as the Category, or Timeliness of, e.g., \"Interactive\" or \"Background\", which also goes back to the \"Capacity Profile\" in Minset. However, Philipp and I think that Intents are much more, e.g., inputs to Path Selection and protocol configuration.\r\nFor example, we use Size to be Received as a Path Selection Property in our prototype, and Bitrate to be sent can inform protocol configuration, which would make it a generic protocol property, I think. Also, Cost Preference can be a Path Selection Property that maps to our preferences scheme of (Require/Prefer/)Avoid/Prohibit (Of course Require and Prefer do not make sense here, but as the table in Appendix B.1 shows, not all Properties make sense with all preference levels).\r\nWe are currently working on a section in the Implementation draft that clarifies these potential uses. Unfortunately we haven't been able to finalize it yet due to teaching duties or illness. ",
          "createdAt": "2018-02-22T15:11:36Z",
          "updatedAt": "2018-02-22T15:11:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, now, as my fever lowers, let me comment on this.\r\n\r\nFirst, I think this needs a bit clarification: All four Intents @gorryfair criticised in his initial post were primarily meant as path selection properties (also I believe the make good input into protocol selection as well as protocol tuning), not as QoS style labels.\r\n\r\nNow some clarifications to the individual intents\r\n- *5.2.3.1. Traffic Category* is more or less equivalent to the Capacity profile from minset. \r\n   It is not fool-proof, but gives some hints whether to optimise for latency or bandwidth and how to do local buffering. Even if a have 10000 small queries, this is different from transferring a 1GB blob that is only useful once fully transferred and the transport system my choose paths and protocols differently for them.\r\n   Yes, we may need some discussion about the levels.\r\n   We are more than happy to provide usages for the implementation draft.\r\n- *5.2.3.2. Size to be Sent / Received*\r\n   If an app does not know these values, it won't set these Intents. (We have more properties that at not used in the majority of cases, i.e., that is not an argument)\r\n   In cases like MPEG-DASH / adaptive HTTP streaming, this information is known and this makes up a hell lot of traffic. \r\n   We find this property extremely useful for path selection: when we have bandwidth and RTT estimates, we have an idea which path will be faster (for web traffic, this is often the lowest latency path, not the highest bandwidth path). But without knowing latency and RTT, the app does not know whether the transfer will be latency or bandwidth limited. The OS has at least enough data to apply heuristics. \r\n   Same is true for multipath negotiation: We don't need to try to negotiate MPTCP and additional paths if we are done after 10kb anyway.\r\n   I agree there are some problems how this combines with cloning and connection groups. I have an idea how to solve this, but not for London, as this requires the introduction of connection pools.\r\n- *5.2.3.3. Duration*\r\n   I guess this is _one_ way how to represent the duration of a connection, another one can be an enum like \"short-lived/long-lived\" - this can also be derived from Size to be Sent / Received or by other means\r\n- *5.2.3.6. Cost Preferences*\r\n   From my perspective, a boolean is not enough to provide hints to the transport system as the property set by the application will be interpreted by the transport system based on user configuration.\r\n",
          "createdAt": "2018-02-23T16:41:17Z",
          "updatedAt": "2018-02-23T16:41:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few scattered comments about this thread:\r\n\r\n1) The general idea of moving things to the appendix for -00: I think that's the right approach. This discussion is already at the level at which, I believe, we should discuss these matters: how exactly are we going to use these API elements, what exactly are we going to do with them. Such text should go into the implementation draft, and this text can then be input for a discussion to decide which of the intents should, for -01, be removed, remain in the appendix, or moved to the front.\r\n\r\n2) I don't think we should even have this kind of discussion for stuff from minset. There are clear arguments for why all of them should be supported, in minset - and so, the \"traffic category\" intent (based on the minset \"capacity profile\") should really remain in place.\r\n\r\n3) @britram : about one specific item - you wrote \"For -00 I'm inclined to push everything we don't have consensus on (most of the Intents, per-Content Priority/Niceness) into this appendix\"  -  I believe that you and I didn't have  consensus for a while on per-content priority / niceness because I didn't understand your idea of using multi-streaming to implement this. Now that I get it, I think it's a great idea and would clearly work, and so I think we DO have consensus on this one.",
          "createdAt": "2018-02-25T14:34:20Z",
          "updatedAt": "2018-02-25T14:34:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl ack. you'd almost convinced me it was a boutique enough feature to leave out for now. :) FWIW we (the SCION people) have been thinking of it primarily in terms of multipath architectures, not multistreaming, but both give you the degree of freedom you need to make it a meaningful signal.",
          "createdAt": "2018-02-25T22:30:38Z",
          "updatedAt": "2018-02-25T22:30:38Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I started getting second thoughts about this some hours ago, on the plane (on the way back from holiday - i.e. I'm back online) - because this needs something on the receiver side to know what you're doing, when doing multistreaming (*not* multipath). E.g., mixing connection-to-stream-mapping with this makes it really confusing: if a receiver expects 2 streams, but gets data on 4, what is it supposed to do? Streams 3 and 4 are different priorities for stream 2, or 1, or what?  So... I think this CAN be implemented but it can also make things rather complex. Anyway, my suggestion is to leave it in - and indeed, the multipath case is much easier.",
          "createdAt": "2018-02-25T23:15:05Z",
          "updatedAt": "2018-02-25T23:15:05Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm digging into this now for -00; see #69 for discussion on how I plan to resolve",
          "createdAt": "2018-02-26T11:57:59Z",
          "updatedAt": "2018-02-26T11:57:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri to review (and possibly fold into #59...?)",
          "createdAt": "2018-05-16T15:37:16Z",
          "updatedAt": "2018-05-16T15:37:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The profiles in #59, the [generic properties](https://datatracker.ietf.org/doc/slides-102-taps-4-an-abstract-application-layer-interface-to-transport-services-properties/) and the intents discussed here are three different variants to approach the same problem:\r\n\r\n   How to specify properties at different levels of abstraction\r\n\r\nI guess we have to find a nice way to sort all of them, but I guess neither the perspective of this issue nor the one in #59 seems right to me. I am re-adding the discuss-label, but request to jointly discuss it with #59 and the generic properties.",
          "createdAt": "2018-09-04T13:27:18Z",
          "updatedAt": "2018-09-04T13:27:18Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ISTM (and maybe I'm projecting here) that we're converging on the following:\r\n\r\n1. Capacity profile probably makes sense to pull into the TAPS API, since it can map deterministically to both transmission scheduling actions as well as signaling (DSCP) and path/stack selection, even it if is very difficult to define in a not-application-specific way. I'm working on this in #142 today.\r\n\r\n2. Other higher-level Intents are not as deterministic: to the best of our knowledge, there is still research to be done to determine the best way to implement them. It's therefore probably best to support Intents in an API that sits on top of the TAPS API, not the TAPS API itself. (It does seem to me that work on this higher-level API could happen in TAPS under the same charter item that covers the architecure/interface work, but IMO we should direct our efforts to get the three adopted documents out the door first).\r\n\r\n3. The key determining factor for whether something belongs in this level of the API is (and I think I'm paraphrasing @mwelzl here) is: can the transport stack or the application do something unambiguous with the information it gets across the interface, and is the implementation of a given feature obvious and deterministic.\r\n\r\nI'd suggest the following resolution to this issue and #59, then:\r\n\r\nLet's close the big \"what part of Intents comes into the API\" discussion, and re-open discussion on a per-property and/or per-feature basis, using the dividing line in (3) above to make the choice.",
          "createdAt": "2018-10-07T10:59:56Z",
          "updatedAt": "2018-10-07T10:59:56Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUyOTg5NTE1ODg=",
      "title": "API section 6.1 - describing candidate transports during racing?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/61",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This text: /Once Initiate is called, the candidate Protocol Stack(s) may cause one or more transport-layer connections to be created to the specified remote endpoint./\r\n- I thought these would be  / one or more candidate transport-layer connections/.\r\n- \u2026because to me, at this stage, the connections may or not complete. Am I correct?",
      "createdAt": "2018-02-21T12:29:03Z",
      "updatedAt": "2018-02-21T14:26:19Z",
      "closedAt": "2018-02-21T14:26:19Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUyOTg5NTE5NzA=",
      "title": "API Section 6.1: NiTs",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/62",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "6.1\r\n/The caller may immediately begin sending Content on the Connection (see Section 7) after calling Initate(), though it may wait for one of the following events before doing so./\r\n- I would like to see a note on idempotence added here, especially when racing multiple (different) candidates - the data sent may not be delivered, or may be delivered more than once.\r\n\u2014\r\n6.1\r\n/An InitiateError occurs either when the set of local and remote specifiers a/\r\n- what is a /specifier/ here? (could we use this one of the existing terms?)",
      "createdAt": "2018-02-21T12:30:18Z",
      "updatedAt": "2018-02-21T14:30:01Z",
      "closedAt": "2018-02-21T14:30:01Z",
      "comments": []
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUyOTg5NTI0ODY=",
      "title": "API Section 6.3 - \"Rendezvoused\" - can we have another word please ???",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/63",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\r\n/Preconnection -> Rendezvoused<Connection>/\r\n- I really dislike the term /Rendezvoused/ - to me that really offends my sense of language. Can we used /RendezvousDone/ or anything else?\r\n",
      "createdAt": "2018-02-21T12:32:09Z",
      "updatedAt": "2018-02-21T14:30:55Z",
      "closedAt": "2018-02-21T14:30:55Z",
      "comments": []
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWUyOTg5NTM0ODA=",
      "title": "API Section 6.4: Cloning versus groups of Connections?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/64",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "\r\nI'm curious about whether cloning is the correct way to go:\r\n\r\nMaybe (I don't know) the concept of cloning could fit well with postsockets and less well with NEAT.? - NEAT does have the concept of combining flows into a group - and relative priorities within the group, etc. So is this actually the way we need to go? (and then they can share attributes)\r\n- I'm worried about how cloning before a race works after racing the candidates, and after it has found candidates, I am not sure all the parameters can then be copied. \r\n\r\nI see you can likely do some of these things if the connections are within an SCTP association, or a QUIC session, but the present description seems very linked to these transports. \r\n\r\nBasically can cloning  be implemented? And haow is racing handled?\r\n",
      "createdAt": "2018-02-21T12:35:52Z",
      "updatedAt": "2018-04-11T20:22:11Z",
      "closedAt": "2018-04-11T20:22:10Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you elaborate a bit your concerns about implementability? The implementation of clone() seems pretty straightforward to me:\r\n\r\n* An established Connection has a set of properties (retained by reference or by value from its Preconnection, perhaps with certain of the properties and preferences collapsed). \r\n\r\n* If the Connection's selected candidate Protocol Stack is multistreaming, and additional streams are available, a new stream is created. If it is not multistreaming, then a new connection is created (perhaps using the post-race properties, maybe by starting over from the retained Preconnection -- that really seems like an implementation choice)\r\n\r\n* When a new stream is created/opened/first used by the remote endpoint, a new Connection is cloned off the/a Connection associated with another stream; this is experienced by the \"passively cloning\" application as a Ready<> event.\r\n\r\nOkay, cloning a connection that is still racing seems like it could be difficult to get right. The easy implementation is to basically buffer any sends (within the API) on these cloned connections until the \"master\" (i.e. first opened) connection is established well enough to understand whether multistreaming is available. It's not clear to me that the less easy implementations will perform better in any other than pathological cases.",
          "createdAt": "2018-02-21T14:42:55Z",
          "updatedAt": "2018-02-21T14:42:55Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(From a finishing-the-edit-pass standpoint, I'm inclined to stay with cloning for London; we can revisit this discussion for -01)",
          "createdAt": "2018-02-21T14:44:06Z",
          "updatedAt": "2018-02-21T14:44:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So... your different perspective may be that you see \"cloning\" as some way to abstract multistreaming. Hence my comment \"I see you can likely do some of these things if the connections are within an SCTP association, or a QUIC session, but the present description seems very linked to these transports.\"\r\n\r\nBut you are also able to group multiple connections without multistreaming. Sharing the way they encode DCSPs in a PHB group, TCB-like congestion state, flow labels, etc - this doesn't imply a multi-streaming solution - but it does give relative priority and some notion of shared transport function.  That's more what I was thinking, and is nearer what we decided to implement.\r\n\r\nUnsure what others think on this.",
          "createdAt": "2018-02-21T14:50:59Z",
          "updatedAt": "2018-02-21T14:50:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So it seems natural to me that a clone of a connection maintains some relationship with its antecedents, and therefore naturally forms a group, whether that group be bound in the same underlying protocol stack or not. If we want to add connection groups to the `clone()` concept that seems perfectly reasonable to me.\r\n\r\nThe \"connection group\" concept as in NEAT, with an id as a reference (at least as I understand it from Michael's comments on it) seems very `setsockopt()`-like to me, but I can't really explain my aesthetic aversion to it in detail at the moment.",
          "createdAt": "2018-02-21T15:03:16Z",
          "updatedAt": "2018-02-21T15:03:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also share the concern that using group IDs as the primary entrance to multiplexing gets pretty sockopt-like. One concern could be that if I'm in an application that's using a global networking context, I'm not sure who's maintaining this group ID namespace, and two pieces of code within the same process could overlap.\r\n\r\nCloning makes it very explicit that you can multiplex explicitly with another Connection when you already have a handle to the other/original Connection.\r\n\r\nEither way, I think can leave Clone for now, and continue the discussion, since this is all very interesting :)",
          "createdAt": "2018-02-21T16:35:02Z",
          "updatedAt": "2018-02-21T16:35:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My view is: whether the functionality of grouping is exposed as a group ID or via \"clone\" is just syntactical sugar. I don't see this or that way as better, and it's all the same to me - irrespective of whether we're talking about multiple streams of an association or connections that share the same DSCP or whatever.  One important thing that shouldn't be lost is that they are \"entangled\", i.e. changing parameters on one changes the other - because that's inevitable in the mux case, and so in any other cases of grouping it must be implemented below the API for consistency.",
          "createdAt": "2018-02-22T23:56:34Z",
          "updatedAt": "2018-02-22T23:56:34Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess we will need two kinds of connection groups: \r\n- one that represents multi-streaming connections\r\n- one that represents connection pools between the same endpoints\r\n\r\nAlso resulting in two different clone calls. Not sure how to avoid them to be mixed up easily.",
          "createdAt": "2018-02-24T10:11:53Z",
          "updatedAt": "2018-02-24T10:11:53Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whaaat???  Noooo!   Why???",
          "createdAt": "2018-02-24T10:17:18Z",
          "updatedAt": "2018-02-24T10:17:18Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When you want to do per-message path selection, you can do this in two ways:\r\n- Make different connections over different paths an assign messages to the connections\r\n- Make one multi-path multi-streaming connection and assign messages to path.\r\n\r\nBoth should be supported by a transport system without making life too miserable for the application.\r\n\r\nIn addition, connection pools are a so widely used pattern in modern transport systems that we should also include them. I guess most applications that call ``clone`` just want \"something\" between the same endpoints (that does not suffer hidden head-of-line blocking), not necessarily multi-streams of the same connection.\r\n\r\nBut that is definitely a discussion we should have in London.",
          "createdAt": "2018-02-24T10:53:41Z",
          "updatedAt": "2018-02-24T10:53:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My argument in minset, and many many conversations preceding the minset document, has always been that there is no reason whatsoever to *not* use multi-streaming when you can, except for the behavior that the API exposes: \"entanglement\", i.e. changing parameters on one connection affects the other when they are streams of an association. I argue that you only don't want multi-streaming if you don't want that - else, there should be no reason ever to choose multiple connections.\r\n\r\nAnother reason can be that the congestion control of multiple connections is more aggressive than a single one - but that's exactly why I wouldn't want to expose this!  I don't think this is a reasonable decision for an *application* to make!",
          "createdAt": "2018-02-25T13:22:32Z",
          "updatedAt": "2018-02-25T13:22:32Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Small clarification: I see connection pooling not as an replacement for multi-streaming \u2013 both are orthogonal. Whether a connection pool represents a bunch of open TCP connections between two endpoints or a single QUIC connection does not matter to the application.\r\nThe difference ist that a connection pool can hold connections between the same endpoints, but with different parameters, our connection group can't.",
          "createdAt": "2018-02-25T18:11:31Z",
          "updatedAt": "2018-02-25T18:11:31Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current text has a problem in that the entanglement has been extended to the closing of the Connection. \"closing one of them also closes all others\". Closing is not the same as changing parameters and should not be tied together. This is also inconsistent with what we have in the implementation draft and needs to be removed.",
          "createdAt": "2018-02-25T19:57:06Z",
          "updatedAt": "2018-02-25T19:57:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, sorry, that was a bug. Fixed!",
          "createdAt": "2018-02-25T23:29:23Z",
          "updatedAt": "2018-02-25T23:29:23Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Decided at side meeting in London: remove `Clone()` from `Preconnection`, rename \"Multiplex Connections\" to \"Multistream Connections in Group\" or \"Clonable\".  Cloning is just for multiplexed streams, because load balancers suck. Cloning attempts may error out.\r\n\r\n",
          "createdAt": "2018-03-21T16:45:49Z",
          "updatedAt": "2018-03-21T16:53:46Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWUyOTg5NTQ0NTY=",
      "title": "API Section 7.1: Which items should we specify?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/65",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "I am really unsure I believe the transport should specify - see notes below:\r\n\r\n/7.1.1.7. Immediate Acknowledgement /\r\n- I suggest this is the wrong approach. I suggest the APP should ask for \u201clow latency\u201d and the stack should figure this out with respect to the protocols it is using. To me this seems like a direct protocol specific optimisation. How you do this in TCP v SCTP v foo-over-UDP all seem different, and unnecessary to expose for a generic interface.\r\n/7.1.1.8. Send Bitrate/\r\n- I vote to remove this for the reason above.\r\n\r\n/7.1.1.9. Timeliness/\r\nThis specifies what delay characteristics the applications prefers for the given content. It provides hints for the transport system whether to optimize for low latency or other criteria and set the DSCP flags for packets used to transmit the content.\r\n- - - -\r\n/Stream/\r\n- I vote to simplify this to Boolean.\r\n",
      "createdAt": "2018-02-21T12:39:21Z",
      "updatedAt": "2018-04-11T13:09:42Z",
      "closedAt": "2018-04-11T13:09:41Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> /Stream/  I vote to simplify this to Boolean.\r\n\r\n.. which \"Stream\"?\r\n",
          "createdAt": "2018-02-21T14:46:02Z",
          "updatedAt": "2018-02-21T14:46:02Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "/Stream:\r\nDelay and packet delay variation should be kept as low as possible\r\nInteractive:\r\nDelay should be kept as low as possible, but some variation is tolerable\r\nTransfer:\r\nDelay and packet delay variation should be reasonable, but are not critical\r\nBackground:\r\nDelay and packet delay variation is no concern\r\nThe default is \u201cTransfer\u201d./\r\n-My suggested boolean is /low-latency/.\r\n- You could say this should be /low-latency/ \r\n- maybe also /low-jitter/, however, I'm not sure the endpoint typically finds low-jitter an easy quantity to race... the latter could be better handled by setting a PHB, for those networks that know how to use DSCPs.",
          "createdAt": "2018-02-21T14:56:17Z",
          "updatedAt": "2018-02-21T14:56:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AH, ok.\r\n\r\nYeah this seems way easier to implement as a low-lat bool.\r\n\r\n> I'm not sure the endpoint typically finds low-jitter an easy quantity to race\r\n\r\nWe probably shouldn't race metrics we can't even agree on a standard definition of. :)\r\n\r\n",
          "createdAt": "2018-02-21T15:04:21Z",
          "updatedAt": "2018-02-21T15:04:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't like the term Stream here at all; quite confusing.\r\n\r\nAs a reference, what we have in our implementation for this (and we use as already-public API) is an enum of Service Class fields, which are explicitly defined for use in on-device AQM queues for relative prioritization:\r\n- Best Effort (default)\r\n- Background (assumed to be bulk or opportunistic)\r\n- Interactive Video\r\n- Interactive Voice\r\n\r\nThese don't imply traffic pattern at all, like query/response, or streaming, etc, just the buckets we should use for queuing.\r\n\r\nAlso, +1 for the bool for low-latency (separately)",
          "createdAt": "2018-02-21T16:40:53Z",
          "updatedAt": "2018-02-21T16:40:53Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll place a marker here to add a low-latency bool and move \"timeliness\" to an appendix...",
          "createdAt": "2018-02-21T16:46:58Z",
          "updatedAt": "2018-02-21T16:46:58Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A low-latency bool doesn't cut it as a replacement for \"timeliness\" - we also need to represent LBE. I think Gorry suggested the low latency bool as a replacement for the immediate ack thing (which makes sense to me).",
          "createdAt": "2018-02-22T23:49:16Z",
          "updatedAt": "2018-02-22T23:49:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @tfpauly and @mwelzl arguments \u2013 I think we will need timeliness with changed levels.\r\n\r\nWe can save level-debate for post-london.",
          "createdAt": "2018-02-23T15:35:31Z",
          "updatedAt": "2018-02-23T15:35:31Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Actually, on timeliness:  I am quite OK with intended completion time. That is a connection value that an app can update in future also, if it has need. That's not the same as low-latency.\r\n\r\nGorry\r\n",
          "createdAt": "2018-02-23T16:43:18Z",
          "updatedAt": "2018-02-23T16:43:18Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - then we are talking about two different things here\r\n- ``timeliness`` == ``capacity profile`` \r\n- ``duration`` == ``completion time``\r\n\r\nSeems like we need to name and describe them better\r\n",
          "createdAt": "2018-02-24T10:00:23Z",
          "updatedAt": "2018-02-24T10:00:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with this assessment",
          "createdAt": "2018-02-25T13:18:47Z",
          "updatedAt": "2018-02-25T13:18:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Capacity Profile (and Instantaneous Capacity Profile for the send param) are what these are called in my editorial pass. I'm not extremely happy with them. I moved Duration to appendix A for now to move back out post-London. Shall we close this one out in favor of #90 for continued discussion?",
          "createdAt": "2018-02-26T16:50:38Z",
          "updatedAt": "2018-02-26T16:50:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "delayed close, go to #90 for more.",
          "createdAt": "2018-04-11T13:09:41Z",
          "updatedAt": "2018-04-11T13:09:41Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUyOTg5NTQ4MzE=",
      "title": "API Section 8: Metadata can be more than logging and debugging...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/66",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Text: /The Content may also contain metadata from protocols in the Protocol Stack for logging and debugging purposes. In particular, when this information is available, the value of the Explicit Congestion Notification (ECN) field is contained in such metadata./\r\n- I think ECN or IP options and maybe some other metadata are not only for \u201clogging and debugging purposes\u201d. Therefore, I think this first sentence needs to also indicate the metadata can be used by applications that implement protocol functions  above the transport. You can (if you wish) quote UDP Guidelines to suggest this may be necessary for some datagram functions, but that it is general desirable to use standard transport functions when these can provide the desired functionality!",
      "createdAt": "2018-02-21T12:40:38Z",
      "updatedAt": "2018-02-21T14:48:23Z",
      "closedAt": "2018-02-21T14:48:23Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWUyOTkwMzU0ODE=",
      "title": "Section 5.2.2. Should mention properties for specific protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/68",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Section 5.2.2. of the API should include the concept from the architecture of Specific Protocol Properties. I think expecting that all of these timeout/etc values should be the same no matter what protocol is selected is limiting, and a bit naive. I know as an application, for example, that I may need to do more keep alive activity to make NATs happy for UDP-based protocols than for TCP-based protocols (where are you, PLUS?!). \r\n\r\nJust a quick paragraph to indicate that the API can allow protocol-specific options to tune based on what is ultimately selected would be good.",
      "createdAt": "2018-02-21T16:22:13Z",
      "updatedAt": "2018-02-21T19:18:14Z",
      "closedAt": "2018-02-21T19:18:14Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "let's race candidate authors for this paragraph ;)\r\n\r\n> where are you, PLUS?!\r\n\r\nthose who do not charter working groups for good ideas are doomed to forever reinvent them poorly.",
          "createdAt": "2018-02-21T16:50:48Z",
          "updatedAt": "2018-02-21T16:50:48Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is 5.2.2 supposed to be the Specific Protocol Properties section? This section also seems to be a mix of things right now. I think this needs to be fixed as part of a bigger rework of section 5.2.",
          "createdAt": "2018-02-21T18:09:08Z",
          "updatedAt": "2018-02-21T18:09:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Check out my pull request\u2014I switch the text to talking about the architecture concepts of Generic Protocol Properties and Specific Protocol Properties.",
          "createdAt": "2018-02-21T18:16:27Z",
          "updatedAt": "2018-02-21T18:16:27Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is better, but just a partial fix. I think we should get rid of the term Transport Preferences and the content of 5.2.1 and 5.2.2 needs to be reshuffled. Most of what is in 5.2.1 reads as protocol properties to me so I do not understand the current split.",
          "createdAt": "2018-02-21T18:37:36Z",
          "updatedAt": "2018-02-21T18:37:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fine with me. We could merge this PR in, and then as Brian does a pass, we can clean the rest up.",
          "createdAt": "2018-02-21T18:39:28Z",
          "updatedAt": "2018-02-21T18:39:28Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUyOTkwNDYwMjM=",
      "title": "Sweep properties/features without group consensus to a new Appendix A",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/69",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "During my final editorial review pre-00, I'll take everything we're still discussing into a new Appendix A, with some text along the lines \"an advantage of this framework is it has extension points for properties and preferences beyond those in the proposed standard interface; here are some potential properties and preferences that we have some design and implementation experience with that may prove useful, and may be added to the core interface in future revisions of this document.\"",
      "createdAt": "2018-02-21T16:49:30Z",
      "updatedAt": "2018-02-26T22:00:26Z",
      "closedAt": "2018-02-26T22:00:26Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So far, tracking the discussion in #60, I propose the following:\r\n\r\n- Everything in section 5.2.3 goes into Appendix A, except:\r\n\r\n  - Traffic Category which gets lifted up into Transport Preferences (and possibly renamed Capacity Profile by reference to Minset), with additional language that (1) the only useful preference level is Prefer and (2) in addition to being used to select transports, it can also be used to configure selected transports for e.g. DSCP marking.\r\n\r\n- The Immediate boolean send property gets removed to the appendix in favor of disabling Nagle via Traffic Category.\r\n\r\n(I might have more to propose after sweeping these)",
          "createdAt": "2018-02-26T12:05:41Z",
          "updatedAt": "2018-02-26T12:06:09Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(On rewriting Traffic Category as a path/protocol preference, it's not clear to me what the stack is supposed do with any of these other than the interactive/default/bulk classes. I'm leaving Stream/Constant Rate but I'm not sure what to say about it. We can fix this post-00)",
          "createdAt": "2018-02-26T12:20:15Z",
          "updatedAt": "2018-02-26T12:20:15Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We are currently writing the implementation part for all Intents \u2013 text for that will appear in the intents-implementation branch in the next days",
          "createdAt": "2018-02-26T12:40:40Z",
          "updatedAt": "2018-02-26T12:40:40Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we ended up with a confusion due to renaming: I thought that the thing that is based on the minset \"capacity profile\" is \"timeliness\", not \"traffic category\". And why remove Immediate?\r\n\r\nActually:\r\n\r\n- an app needs a way to say that we require low latency, even at the cost of more overhead. That can be Nagle-like Message bundling, or other things (e.g. see issue #90). Because this request may (as in the case of Message bundling) be necessary for a message, I think it would be good to keep \"Immediate\".\r\n\r\n- removing this from the minset capacity profile, it only covers table 1 in draft-ietf-tsvwg-rtcweb-qos-18. I think we want applications to be able to choose cells in this table, *somehow*. I don't know how to do this most cleanly; for version -00, maybe we could simply point at this draft and say that the \"Traffic Category\" would choose cells in this table?  Or some such solution...",
          "createdAt": "2018-02-26T12:42:56Z",
          "updatedAt": "2018-02-26T12:42:56Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we ended up with a confusion due to renaming: I thought that the thing that is based on the minset \"capacity profile\" is \"timeliness\", not \"traffic category\r\n\r\naaaah right. yep that makes more sense.\r\n\r\n>  And why remove Immediate?\r\n\r\nbecause capacity profile \"Interactive\" does this for you on a per connection basis?",
          "createdAt": "2018-02-26T12:56:20Z",
          "updatedAt": "2018-02-26T12:56:20Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm. Controlling bundling is a per-message thing in SCTP, whereas TCP's Nagle is time-based. We could argue whether this should be kept per message or not... I'm not 100% sure that binding this to a message is indeed important to anyone.\r\n\r\n=> I'm fine with your decision. Let's only have this per message once we've convinced ourselves that doing this per-message really matters.",
          "createdAt": "2018-02-26T13:11:06Z",
          "updatedAt": "2018-02-26T13:11:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More issues in the current text:\r\n\r\nSection 5.2.1 Transport Preferences:\r\nIf you agree with my conclusion in issue #90, then the item \"Request not to delay acknowledgment of Content\" should be removed here.\r\n\r\nSection 5.2.2. Protocol Properties:\r\nThis text:\r\n\"Set timeout for aborting Connection establishment: This numeric property specifies how long to wait before aborting a Connection attempt. It is given in seconds.\"\r\nshould be:\r\n\"Set timeout for aborting Connection: This numeric property specifies how long to wait before aborting a Connection (including a Connection attempt). It is given in seconds.\"\r\n\r\nThis is important because section 9 points back at this section, stating that these Properties can be configured later. So to have a configurable Connection timeout, this text must be about the Connection, not just the Connection attempt.\r\n\r\nThe timeout of the Connection attempt itself is also discussed in minset; I removed it as a separately configurable thing even in minset because this is really just about *when* to configure the timeout. Because an app can change it later, it can control both the establishment timeout and the connection timeout with this single Property.",
          "createdAt": "2018-02-26T13:19:01Z",
          "updatedAt": "2018-02-26T13:19:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "*all* of the timeout stuff here is IMO underspecified --  transport protocols have various timeouts in various states, and stuffing them all behind one generic parameter seems optimistic. I'd thought that \"Establishment Timeout\" was sufficiently specified to leave it in, but if you now say that we need to replace establishment with... what, RTO timeout? heartbeat timeout?, then that seems underspecified to me now too.\r\n\r\nI was just debating whether to sweep all the timeout stuff into Appendix A pending a resolution.",
          "createdAt": "2018-02-26T13:22:01Z",
          "updatedAt": "2018-02-26T13:22:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RTO timeout, the application shouldn't care about. Heartbeat timeout, the application shouldn't care about (at least when I'm thinking of SCTP heartbeats ... depends on your use case I guess).\r\n\r\nThe application should only care about a Connection timeout, and then there are two phases here:\r\n1) establishment,\r\n2) being connected\r\n... and we can distinguish between these two via the time of using the call.\r\n\r\nWhat else is really missing?",
          "createdAt": "2018-02-26T13:27:18Z",
          "updatedAt": "2018-02-26T13:27:18Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so I'm not clear what the \"being connected\" timeout is -- is this an idle timeout, i.e. an assumption that the other side has dropped state so we should too?",
          "createdAt": "2018-02-26T13:53:20Z",
          "updatedAt": "2018-02-26T13:53:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually, with respect to \u00a79, the following:\r\n\r\n> Protocol Properties of the protocols in use, once the Connection has been established. These properties correspond to the properties given Section 5.2.2 and can be set and queried.\r\n\r\nis, IMO, not something we have consensus on. At least, I don't thing we should limit the Generic and Specific Protocol Properties to *only* those which are safe to change after establishment. I'd keep this \"establishment\" timeout, then remove it from the set of settable properties.",
          "createdAt": "2018-02-26T13:56:38Z",
          "updatedAt": "2018-02-26T13:56:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Indeed, I think we should fix this by removing \"can be set\" here, and noting that certain specific properties may be settable after establishment but only on a Protocol Stack and Property specific basis)",
          "createdAt": "2018-02-26T13:57:27Z",
          "updatedAt": "2018-02-26T13:57:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, about the \"being connected\" timeout: this is not an idle timeout. In case of TCP, it's the User Timeout - which is typically more than the RTO; it's TCP re-trying and re-trying ... until this timeout expires. Hence, in TCP, at least according to the RFC, you can only change it when you send something (or with \"open\"). In SCTP, heartbeats are used to check for this timeout, so you can change it at any time. The way I described this in RFC 8303 / pass 2 (section 4.1), it can be issued at any time and will only take effect for TCP upon the next \"send\" call.",
          "createdAt": "2018-02-26T14:04:20Z",
          "updatedAt": "2018-02-26T14:04:20Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About \u00a79, this whole current structure is currently messy - I think a clean approach would be to separate ALL Connection properties out from the current structure and not make them a part of Pre-Establishment, and then, in Pre-Establishment, say that the following ones (with a list) can be changed on Pre-Establishment. Or maybe say that \"as many as possible should be set on pre-establishment\".\r\n\r\nHowever, it's a fact that most can be changed later. So this:\r\n\r\n> (Indeed, I think we should fix this by removing \"can be set\" here, and noting that certain specific properties may be settable after establishment but only on a Protocol Stack and Property specific basis)\r\n\r\nseems very wrong to me. You CAN change the minimum checksum requirement of an ongoing connection. You CAN change the scheduler. Why would you want to take all this functionality away?\r\n\r\nI also don't know what \"settable on a Protocol Stack and Property specific basis\" means -- e.g., you can change the checksum requirement and if the transport system uses TCP, nothing happens. That's the normal fallback logic from minset.",
          "createdAt": "2018-02-26T14:12:44Z",
          "updatedAt": "2018-02-26T14:13:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The list in 5.2.2 contains one item that really can only be queried: \"Maximum Content Size Before Connection Establishment\". So it has to be taken out of this list and written separately. Else, the list seems to completely cover the list from minset, except that \"capacity profile\" is missing.\r\n\r\nAlso, later, on an ongoing connection, it should be possible to query:\r\n   o  The maximum message size that may be sent without fragmentation,\r\n      in bytes (or \"not available\")\r\n   o  The maximum transport message size that can be sent, in bytes (or\r\n      \"not available\")\r\n   o  The maximum transport message size that can be received, in bytes\r\n      (or \"not available\")",
          "createdAt": "2018-02-26T14:21:47Z",
          "updatedAt": "2018-02-26T14:21:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Someone has written this paragraph in 5.2.2 which I also don't agree with:\r\n\r\n***\r\nIn order to specify Specific Protocol Properties, the application can attach a set of options to the Preconnection object, associated with a specific protocol. For example, the application could specify a set of TCP Options to use if and only if TCP is selected by the system, including options such as the Maximum Segment Size (MSS), and options around Acknowledgement Stretching. Such properties should not be assumed to apply across different protocols, but must be possible to specify if required by the application.\r\n***\r\n\r\nThis invites protocol-dependent implementations... I can see that some folks may want to support such things, but at least in a PS document we shouldn't say \"must be possible to specify if required by the application\": what exactly must be possible to specify? All possible TCP options?  Also, \"options around Acknowledgement Stretching\" is a vague statement, what exactly is this even about?",
          "createdAt": "2018-02-26T14:31:36Z",
          "updatedAt": "2018-02-26T14:31:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I'm pretty sure I wrote that text, and that is both aligned with the architecture document, and absolutely critical to have Specific Protocol Properties.\r\n\r\nProtocol specific options are designed in such a way that they don't necessarily restrict the choice of protocol selection, but when a protocol is selected, we use the correct options around a given protocol. If you don't offer that capability, I assure you that many/most applications will choose not to use the API, since it would strictly offer fewer protocol features than sockets.\r\n\r\nWe're not enumerating the options here\u2014so effectively, it is left as an exercise to the reader to fill out the list. But the importance of telling them where to put the options, and not just saying \"must be possible to specify\", is that the options need to be communicated as \"if you use [TCP], then set option [TCP-MSS]\", not just marking [TCP-MSS] on the top level of the properties, and constraining the protocol selection to TCP only.\r\n\r\nFor the examples, I was choosing some arbitrary socket options. The one I was referring to with ack stretching is TCP_SENDMOREACKS, which is a pretty specific TCP-socket-API behavior that we're not planning on carrying into generic protocol options. Feel free to choose another one.",
          "createdAt": "2018-02-26T15:08:39Z",
          "updatedAt": "2018-02-26T15:08:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Else, the list seems to completely cover the list from minset, except that \"capacity profile\" is missing.\r\n\r\nSo I've currently written Capacity Profile as a Transport Preference, not a Protocol Parameter, since a particular capacity profile may also be used in path and/or protocol selection.",
          "createdAt": "2018-02-26T15:19:10Z",
          "updatedAt": "2018-02-26T15:19:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In order to specify Specific Protocol Properties, the application can attach a set of options to the Preconnection object, associated with a specific protocol. For example, the application could specify a set of TCP Options to use if and only if TCP is selected by the system, including options such as the Maximum Segment Size (MSS), and options around Acknowledgement Stretching. Such properties should not be assumed to apply across different protocols, but must be possible to specify if required by the application.\r\n\r\nI think this was @tfpauly (*on actually reading the whole thread, what @tfpauly said*) -- and yes, I thought you might disagree with it. :smile:\r\n\r\nISTM the reality of the situation is you will *always* need an out to specifically configure the details of certain parts of the stack, especially on the server side where these things might actually matter. The only question is whether we acknowledge this reality in the architecture and API and create a bin for them, or ignore this reality and have every implementation hack their specific protocol properties in anyway.",
          "createdAt": "2018-02-26T15:23:31Z",
          "updatedAt": "2018-02-26T15:24:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> About \u00a79, this whole current structure is currently messy\r\n\r\nagreed, and I think your proposed remedy (to split protocol properties out of pre-establishment, possibly up into \u00a79) and to refer forward to them from there is the right way to go. My queue of pending edits is pretty deep so I might leave this one for you (@mwelzl) to do though.",
          "createdAt": "2018-02-26T15:27:08Z",
          "updatedAt": "2018-02-26T15:27:08Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1) About @tfpauly 's paragraph, I see that point and ok, I'm convinced - we don't want to end up with \"clean but lame\".  But we should at least not say \"must be possible to specify\". About the examples, I think we should not have the ACK stretching thing because it's not related to standards. Finding examples is hard - because if I think it's something an application should care about, I would have written it as such in minset and we'd be discussing it in a different context here already  :-) Maybe we really shouldn't have any examples. Let me propose an update for this text:\r\n\r\n***\r\nIn order to specify Specific Protocol Properties, Transport System implementations MAY offer applications to attach a set of options to the Preconnection object, associated with a specific protocol. For example, an application could specify a set of TCP Options to use if and only if TCP is selected by the system. Such properties MUST NOT be assumed to apply across different protocols.\r\n***\r\n\r\n2) @britram - about \"Capacity Profile as a Transport Preference\", okay, but how do you then change the DSCP on a Connection?\r\n\r\n3) @britram - regarding the messy structure related to \u00a79 and the bit you want to leave to me: ACK !  But I'm keeping my hands off right now, of course. Maybe I can do this tonight, when you're done with your pass?!",
          "createdAt": "2018-02-26T15:37:56Z",
          "updatedAt": "2018-02-26T15:37:56Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": " \r\n> regarding the messy structure related to \u00a79 and the bit you want to leave to me...\r\n\r\nI think I fixed \u00a79, no worries. \r\n\r\n> about \"Capacity Profile as a Transport Preference\", okay, but how do you then change the DSCP on a Connection?\r\n\r\nThat is a very good question...\r\n\r\nSo one of the keys to fixing the messy structure of \u00a79 is the observation that the set of Protocol Properties we enumerate in the current \u00a75.2.2 can't really productively be used in protocol or path selection -- basically, allowing you to specify these in preconnection allows you to tweak them before turning up any candidates. Capacity Profile is weird, in that it is potentially useful in protocol and path selection as well as in scheduling afterward. I'm not sure how to do later DSCP manipulation, other than via Send Properties.",
          "createdAt": "2018-02-26T16:10:11Z",
          "updatedAt": "2018-02-26T16:10:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...following up, Capacity Profile is also a send property (as Timeliness); we can simply leave it there and refer back to the transport parameter.",
          "createdAt": "2018-02-26T16:32:45Z",
          "updatedAt": "2018-02-26T16:32:45Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWUyOTkyOTQyMDU=",
      "title": "Only object-based or -oriented transport APIs?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/72",
      "state": "CLOSED",
      "author": "karlgrin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "I have not been involved in the discussions than precedes the transport API, however, I still wonder if this api is only to be applicable to object-based and -oriented  programming languages such as Go, C++, C# etc. and not procedural such as C. When reading the architecture and interface I-Ds, it seems as a not altogether straightforward task to realize this in a procedural language.",
      "createdAt": "2018-02-22T10:15:34Z",
      "updatedAt": "2018-02-23T09:42:58Z",
      "closedAt": "2018-02-23T09:42:58Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see the issue. Certainly the language of the documents is aimed at more modern languages. This is on purpose. Part of the reason we need to move on from sockets is that they're rooted in a 1970s-era synchronous mindset.\r\n\r\nIt's the asynchronicity that makes the API harder to implement in straight C89, not the object orientedness. Object.Action(Arguments) is basically just syntactic sugar for Action(Object, Parameters); indeed, see how methods are defined in Python or Go for an illustration. (And even if you want polymorphic objects in C, you can implement them yourself with typed function pointers.)\r\n\r\nSupport for asynchronicity in C requires external libraries, though. Indeed, the reason the abstract API talks in fuzzy terms about \"Events\" is to avoid making any restriction about which patterns for implementing asynchronicity in such languages are allowed by the abstract API.\r\n",
          "createdAt": "2018-02-22T12:56:07Z",
          "updatedAt": "2018-02-22T12:56:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think that the API does work in C, as long as you assume some model for asynchronous event delivery. The \"objects\" can just be typedef'ed structs, hopefully with some rudimentary reference count and locking. There are several options for the eventing library; for example, the one we use on Darwin-based platforms (libdispatch, also available for Linux) is aimed at C primarily.",
          "createdAt": "2018-02-22T15:44:35Z",
          "updatedAt": "2018-02-22T15:44:35Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reference counting? Locking? Man you really want to take all the fun out of C don't you? ;)",
          "createdAt": "2018-02-22T15:45:37Z",
          "updatedAt": "2018-02-22T15:45:37Z"
        },
        {
          "author": "karlgrin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly @britram: Let's close this issue. Seems that there are solutions for procedural languages such as C as well.",
          "createdAt": "2018-02-23T09:42:58Z",
          "updatedAt": "2018-02-23T09:42:58Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWUyOTk3Nzg1NDE=",
      "title": "Arch & Background Section: 1,2 - Editorial",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/73",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "/even when the functions are analogous./\r\n- I am not sure what this is hinting at, maybe we could use simpler language? \r\n---\r\n/This variety can lead to confusion when trying to define the fundamental commonalities between APIs and distill the nuanced differences./\r\n\r\nI understood second read, but I did find it unnecessarily hard to parse, and simpler language would have been easier. \r\n\r\nI found the Background section a over-excited about how e approached the problem, rather than what we had to offer the reader. What I am trying to say is: I think it would help to say that a higher-level richer API is useful and why. One way is to move the text directly below.\r\n\r\nThis I think could usefully appear earlier in this document:\r\n/The goal of the Transport Services architecture is to redefine the interface between applications and transports in a way that allows the transport layer to evolve and improve without fundamentally changing the contract with the application. This requires a careful consideration of how to expose the capabilities of protocols./\r\n- I'd prefer this text to also assert that the higher layer interface /can enable the network to bring more context allowing the stack to making decisions about which transport protocols, options and paths are used to try to connect to a specific endpoint. /",
      "createdAt": "2018-02-23T16:54:52Z",
      "updatedAt": "2018-02-24T13:22:48Z",
      "closedAt": "2018-02-24T13:22:48Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed the first two points about text in the introduction.\r\n\r\nFor the point about background, and the goal statement, we do have some explanation of the goal in the Introduction. You are correct that the background is very much about the process, and that was the intention, at least for this first round of the draft to make sure the WG knew where this stood in comparison to the rest of the work.\r\n\r\nMy intent was:\r\n\r\n1. Introduction covers the fact that we need a common architecture for transport interfaces, and that this interface is meant to allow transport protocol evolution and development. Mentions the relationship with two other documents.\r\n2. Background goes back to explain where this work came from.\r\n3. Design principles covers the heart of the approach, taking the basic idea stated in the introduction and adding flesh to it",
          "createdAt": "2018-02-23T22:57:37Z",
          "updatedAt": "2018-02-23T22:57:37Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think the current text is good enough to go forward. ",
          "createdAt": "2018-02-24T13:22:48Z",
          "updatedAt": "2018-02-24T13:22:48Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUyOTk3ODUwNTc=",
      "title": "Arch Section 3: NiT",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/74",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "\r\n/ it can use these protocols across multiple networks /\r\n- Maybe, but a network is not the same as a transport path, and I think the key point here is that it can operate across different paths.\r\n--\r\n/addresses for a peer /\r\n- To simplify things, I'd prefer /remote endpoint/. that way we can introduce the concept of an endpoint early.",
      "createdAt": "2018-02-23T17:14:26Z",
      "updatedAt": "2018-02-23T18:51:00Z",
      "closedAt": "2018-02-23T18:51:00Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in architecture text",
          "createdAt": "2018-02-23T18:51:00Z",
          "updatedAt": "2018-02-23T18:51:00Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUyOTk3ODU0NDU=",
      "title": "Section 3.2:  NiTS",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/75",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "\r\n/protocols in order to /\r\n- remove /in order/ since this isn't quite what was intended.\r\n- This is true of most (all?) uses of this term.\r\n----\r\n/on the other hand/ - appears but isn't actually describing two viewpoints, so the construct should be deleted.\r\n---\r\n/changes on peers./\r\n- do we have to call them /peers/ could we call them /remote endpoints/ or something like that?\r\n---\r\nI support Michael that Figure 1 needs to say /establishment/ clearly.\r\n---\r\nI do not know what is intended by /object/ in this figure. We have a transport entity in NEAT is this the same?, or is it a data structure ot something else? I think anyway we need to introduce this term here.\r\n---\r\n/knobs that apply across multiple transports/\r\n- could that be\r\n/knobs that are applicable to multiple transports/\r\n- or similar?\r\n---\r\n/ defines the set of properties that an application may be notified of during the lifetime of transport objects. These may also provide opportunities for the application to interact with the underlying transport./\r\n- I'm not sure I see it quite like that, could it be said:\r\n/ defines the set of properties about which an application can receive notifications during the lifetime of transport objects. Events can also provide opportunities for the application to interact with the underlying transport./\r\n---\r\n- what does this mean? /interact with the underlying transport/\r\n- I could guess, but I'm not sure Could someone fix this?\r\n---\r\n",
      "createdAt": "2018-02-23T17:15:41Z",
      "updatedAt": "2018-02-23T18:52:27Z",
      "closedAt": "2018-02-23T18:52:27Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in text. Added establishment to the diagram. Renamed Object to Basic Objects, which is the section defined below. Link added in text.",
          "createdAt": "2018-02-23T18:52:27Z",
          "updatedAt": "2018-02-23T18:52:27Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWUyOTk3ODU2NjI=",
      "title": "Arch: Termination",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/76",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "Do I understand Termination? (section 3.2)\r\n- To me this also includes how the remote endpoint discovers a graceful or premature end to the connection? - which implies the transition, is termination the correct word, or is this \"terminated\". ",
      "createdAt": "2018-02-23T17:16:19Z",
      "updatedAt": "2018-02-23T19:14:02Z",
      "closedAt": "2018-02-23T19:14:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a bit confused by this comment: the name of the Phase/Category of the architecture is Termination, by which the Application can gracefully or non-gracefully Terminate the Connections, after which point they are Terminated. It seems like the label for the category, like Establishment, is Termination.",
          "createdAt": "2018-02-23T18:47:53Z",
          "updatedAt": "2018-02-23T18:47:53Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK - let's forget this comment and see how it all reads.",
          "createdAt": "2018-02-23T19:14:02Z",
          "updatedAt": "2018-02-23T19:14:02Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWUyOTk3ODYxNzg=",
      "title": "Arch Section 4: NiTs",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/77",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "4.4.1:\r\n/that Connection will use/\r\n- insert /a/ before /connection/\r\n---\r\nI'm not hugely keen on /peer/ in this:\r\n/Remote Endpoint: The Remote Endpoint represents the application\u2019s name for a peer that can participate in a transport connection. For example, a DNS name for the peer./\r\n- can we be simpler?\r\n---\r\n/This is critical to allow compatibility with Protocol Properties on peers./\r\n- I don't know what that means. I agree with the remainder of this para.\r\n--- ",
      "createdAt": "2018-02-23T17:17:51Z",
      "updatedAt": "2018-02-24T13:21:04Z",
      "closedAt": "2018-02-24T13:21:03Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed, other than Peer, since I couldn't come up with a better phrasing yet.",
          "createdAt": "2018-02-23T19:22:55Z",
          "updatedAt": "2018-02-23T19:22:55Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This should not hold us back from publishing -00 draft. SO I am closing this.",
          "createdAt": "2018-02-24T13:21:03Z",
          "updatedAt": "2018-02-24T13:21:03Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWUyOTk3ODYzNzg=",
      "title": "Path selection properties (may be similar to Anna's comment)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/78",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "I am not sure why the path selection properties are constrained in this way. The NEAT architecture allows non-local path information to be also used - such as the learned PMTU, or information learned through a PvD mechanism. I think this is important to include and that we should not constrain the system to local functions. But maybe I am misreading this? - since \"throughput\" and \"latency\" surely are discovered characteristics?\r\n- I think I would be happier to explicitly give examples of characteristics that are configured locally, or are learned about a path. ",
      "createdAt": "2018-02-23T17:18:30Z",
      "updatedAt": "2018-02-23T19:23:05Z",
      "closedAt": "2018-02-23T19:23:05Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that path selection is based on both locally known and discovered properties, so this should be clear about that. However, since this is describing application-set constraints and preferences, the application may not be able to rely on the discovery of the remote properties getting results. I'll rework the text a bit.",
          "createdAt": "2018-02-23T19:10:06Z",
          "updatedAt": "2018-02-23T19:10:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm sure reworking will fix :-)",
          "createdAt": "2018-02-23T19:16:17Z",
          "updatedAt": "2018-02-23T19:16:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in text with PMTU example.",
          "createdAt": "2018-02-23T19:23:05Z",
          "updatedAt": "2018-02-23T19:23:05Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUyOTk3ODY3ODY=",
      "title": "Replace Content with Message",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/79",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly",
        "csperkins",
        "britram"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "I am not hugely sold on the definition of /Content: A Content object/. I struggled in NEAT with the best word, and we eventually decided on /data block/. That's not perfect, but it at least keeps away from the notion of content delivery networks, and various other uses of the word \"Content\". \r\n\r\nCan we *please* reconsider this? ",
      "createdAt": "2018-02-23T17:19:49Z",
      "updatedAt": "2018-02-26T22:17:49Z",
      "closedAt": "2018-02-26T22:00:26Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, we can reconsider. Data Block is one option; we could also just do Data, but then the singular chunk is more awkward.\r\n\r\nSome test phrases:\r\n- \"a given Connection is ready to send and/or receive Content\"\r\n- \"a given Connection is ready to send and/or receive Data Blocks\"\r\n- \"a given Connection is ready to send and/or receive Data\"\r\n\r\nYeah, I don't like making this seem like a Content Delivery Network, but when this does get applied to protocols like QUIC and HTTP/2 as a transport, then there are instances in which this is the Content portion of the Header/Content divide.\r\n\r\nAny other votes from the group?",
          "createdAt": "2018-02-23T19:17:11Z",
          "updatedAt": "2018-02-23T19:17:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "&lt;whispers> message",
          "createdAt": "2018-02-23T20:31:51Z",
          "updatedAt": "2018-02-23T20:32:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I mean, message works nicely\u2014other than the fact that it's a bit awkward when describing incomplete message content.",
          "createdAt": "2018-02-23T20:48:21Z",
          "updatedAt": "2018-02-23T20:48:21Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hard to come up with a good term for this one. In the test phrases above I think Data works quite well, but I am not sure it will in all situations.",
          "createdAt": "2018-02-23T21:49:11Z",
          "updatedAt": "2018-02-23T21:49:11Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suggested \"data block\" or \"data\", but I really would not have questioned \"message\". ",
          "createdAt": "2018-02-24T07:58:40Z",
          "updatedAt": "2018-02-24T07:58:40Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With our Socket Intents work, we started at \"object\" and finally came to \"message\". A message can easily be spread across several PUDs for transmission. If re-assembly fails, we end up with partial messages.",
          "createdAt": "2018-02-24T09:51:54Z",
          "updatedAt": "2018-02-24T09:51:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One comment on the relationship between Message and Content: if we do Message as the main architecture concept (which I'm fine with to be clear), I can imagine that implementations or APIs can still refer to the \"content of the message\" as opposed to metadata about the message\u2014for example, when I receive a UDP packet as a Message, the content is the interior payload of the datagram, but my metadata includes the ECN flags received on the packet. Does that sound good?",
          "createdAt": "2018-02-24T18:05:42Z",
          "updatedAt": "2018-02-24T18:05:42Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Foe me trhat would be fine ((... we could people thinking about the content of messages, or content messages, etc - but at least we don't have \"content of content\" etc ;-) ))",
          "createdAt": "2018-02-24T18:26:15Z",
          "updatedAt": "2018-02-24T18:26:15Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#85 does this for Architecture; we still need to make this change in API (and make sure it carries forward into Implementation as necessary)",
          "createdAt": "2018-02-25T21:50:42Z",
          "updatedAt": "2018-02-25T21:50:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, needed for API as well. I already modified Implementation for this.",
          "createdAt": "2018-02-25T22:02:25Z",
          "updatedAt": "2018-02-25T22:02:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram, as you're updating the API document with Message, make sure to make it clear that a single Send() or Receive() does not need to correspond in all cases to a complete Message, and that the Message's content is passed or delivered, along with an indication of whether this Message is now complete. I'm referencing this in the implementation for TCP and protocols with very long frames, so it needs to be reflected cleanly in the API too.",
          "createdAt": "2018-02-25T22:15:46Z",
          "updatedAt": "2018-02-25T22:15:46Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly ACK. Not having to make the distinction was one of the nice things about \"Content\", but we should be explicit about partials in the API anyway.",
          "createdAt": "2018-02-25T22:18:24Z",
          "updatedAt": "2018-02-25T22:18:24Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "my current proposal for -00 is to acknowledge it both on send and receive, and to punt on the details as implementation-specific.",
          "createdAt": "2018-02-26T16:26:41Z",
          "updatedAt": "2018-02-26T16:26:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The details of what \"complete\" means for a Message is certainly implementation-determined; as long as there's a flag in the Send() call, and in the Message Received callback, that's fine.",
          "createdAt": "2018-02-26T16:32:19Z",
          "updatedAt": "2018-02-26T16:32:19Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So did changing the name from Content to Message now change the semantic of things? I thought we were using the AFra-Bytestream concept from minset with the Framer as a convenience, but I do not understand how it maps to the partial messages? ",
          "createdAt": "2018-02-26T17:08:12Z",
          "updatedAt": "2018-02-26T17:08:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hope not. I think it's fine (and good!) for the send call to have a flag, and for the receive call to have a flag - so an app CAN be informed about a complete message arriving, when the receiving transport system knows that it is indeed complete.\r\n\r\nHowever, the transport system doesn't automatically guarantee to the sender that the receiver will be informed about the end of the message that the sender signifies with the flag.\r\n\r\nIn other words: I had an issue with text in the postsockets document that talked about messages, which indicated a guarantee that these messages will be transferred as such. I don't have an issue with flags in send and receive that MAY work (but are not guaranteed to always work).",
          "createdAt": "2018-02-26T17:35:08Z",
          "updatedAt": "2018-02-26T17:35:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The flag for a Message being complete is purely local to an implementation:\r\n\r\n- If you use TCP, or some long frames, you can send Message data and not be complete; and you'll only send a FIN, or whatever end-of-frame marker you have when you send data with the complete flag. If the frame needs length-value, it will wait until you mark complete.\r\n- If you use UDP, if you don't mark your Message as complete, the implementation would pend up data for the Message and wait til its complete before sending the datagram out.\r\n\r\n- If you use TCP, or some long frames, when you receive, the complete flag indicates whether or not this was a FIN or the end of your frame. Since the Message could be gigabytes long, you can't just wait to deliver all at once sometimes.\r\n- For UDP, Messages will be complete when received by default, but I can request to only receive two bytes at a time or something, and get delivered little chunks until the datagram is completely read.",
          "createdAt": "2018-02-26T17:41:01Z",
          "updatedAt": "2018-02-26T17:41:01Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But how do I send multiple messages over a TCP connection, this is the part I do not understand also from the implementation draft. I do not know what is underneath, so I send a bunch of messages on a connection and if it is TCP is gets sent as a stream of bytes and if it is SCTP it gets sent as a sequence of messages? Or I am only allowed to send one message over a TCP connection?",
          "createdAt": "2018-02-26T17:57:28Z",
          "updatedAt": "2018-02-26T17:57:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can't send multiple Messages on a TCP stream without using a framing protocol on top of TCP; you can, of course, send multiple pieces of Message content, and mark the final one as the Message being complete. There is only one sensible Message per direction in TCP.",
          "createdAt": "2018-02-26T18:02:37Z",
          "updatedAt": "2018-02-26T18:02:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As things are now, the application can't know that there is only TCP, and the transport system doesn't know whether a framing protocol is used. So, when a message is complete, the sender must be allowed to say that it's complete, whenever it wants. As you said this is local, and that shouldn't be a problem. When there is a framing protocol, there is no need for the transport system to convey \"end of message\" via TCP, so there is no problem if this is ignored.\r\n\r\nI find the logic of \"one message = one TCP connection\" disturbing. If I send 50 short messages, do I risk getting connections permanently opened and torn down because my \"end of message\" becomes a FIN? That doesn't sound like a good idea and it doesn't make much sense to me (e.g., it wrecks congestion control).",
          "createdAt": "2018-02-26T18:14:06Z",
          "updatedAt": "2018-02-26T18:14:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, you should not be sending 50 short messages on a single connection. That would cause a lot of havoc on the connection.\r\n\r\nThis really isn't a problem if we're looking at falling back between equivalent protocols. The protocols that will make sense to an application need to have equivalent contracts if they aren't rewriting any code. So, I can use the same code for TCP or TLS over TCP or a QUIC Stream etc, since those all look the same. But if I'm writing discrete messages that are very short on a connection, I need a protocol that supports that\u2014my use case here is IKE sending short messages either over UDP or over Length-Value frames on TCP (RFC8229). HTTP messages over TLS or QUIC or whatever also are equivalent.",
          "createdAt": "2018-02-26T18:17:49Z",
          "updatedAt": "2018-02-26T18:18:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see why 50 short messages on a single connection would cause a problem. It really shouldn't! What if I'm writing a game that only needs one connection and sends many small updates over it?\r\n\r\nSo if you implement IKE over the transport system, IKE is understood (can be parsed) from the receiver side data stream, even if you hand it over as individual data blocks - you don't need to tell the receiver-side IKE instance where its message ends. Where's the problem?\r\n\r\nI don't understand what this has to do with \"end of message = FIN\" and why anyone would need that. It doesn't make sense to me and sounds like unnecessary trouble.",
          "createdAt": "2018-02-26T18:24:54Z",
          "updatedAt": "2018-02-26T18:24:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "50 short messages is fine, if the protocol knows what a message is. And you could have a degenerate \"framer\" over TCP which doesn't add any bytes to indicate length or framing and just puts the Message content down in bytes\u2014essentially, ignore any completion markers. But it should also be possible to communicate over a stream or long message: \"I was writing a long gigabyte message, and now I'm done\".",
          "createdAt": "2018-02-26T18:29:00Z",
          "updatedAt": "2018-02-26T18:29:00Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm. Sure. And if an app wants to make absolutely sure this \"...long gigabyte message, and now I'm done\" information reaches the other end, it can always use Close.",
          "createdAt": "2018-02-26T18:32:33Z",
          "updatedAt": "2018-02-26T18:32:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, that works for TCP, but say I have a framing protocol on top of TCP\u2014HTTP for example, and I'm doing pipelining of messages. I can still have mega-byte or giga-byte long messages that I send in multiple chunks on this Connection, and the completion bit tells the protocol when the HTTP request is done, and we need to start the headers for the next one.",
          "createdAt": "2018-02-26T18:34:46Z",
          "updatedAt": "2018-02-26T18:34:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure!  No problem in this case either",
          "createdAt": "2018-02-26T19:00:37Z",
          "updatedAt": "2018-02-26T19:00:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... but there is text along these lines that doesn't sound right to me in the implementation draft, section 5.1.1. This:\r\n\r\n***\r\nThe effect of the application sending a Message is determined by the top-level protocol in the established Protocol Stack. That is, if the top-level protocol provides an abstraction of framed messages over a connection, the application will be able to send multiple Messages on that connection, even if the framing protocol is built on a byte-stream protocol like TCP.\r\n***\r\n\r\n...sounds as if the top-level protocol is inside the transport system and that top-level protocol must provide framed messages, or else multiple messages can not be sent over a byte-stream protocol like TCP.  However: it's nice if there is a framing protocol like HTTP or whatever on top of your internal stack, but it should also be possible to send multiple messages just over TCP. This shouldn't be a problem as long as my receiver-side application can detect where messages begin and end.",
          "createdAt": "2018-02-26T19:53:06Z",
          "updatedAt": "2018-02-26T19:53:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that what you're describing is the \"degenerate framing protocol\" that I referred to earlier\u2014yes, we can let something just write on the stream, but either:\r\n- You have actual boundaries that can be detected, in which case we call this a framing protocol (may be very very simple)\r\n- You don't have any on-the-wire detectable boundaries, in which case you can have a degenerate framer that just lays down the content of the Message without boundaries. You can do this, but it's a bit silly. Or you can just treat the stream as one big message if you want.",
          "createdAt": "2018-02-26T20:29:34Z",
          "updatedAt": "2018-02-26T20:29:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When you say \"can be detected, in which case we call this a framing protocol\", can that be outside the transport system or not? My complaint is about the text sounding as if the framing protocol must be inside the transport system. With what I call an \"Application-Framed Bytestream\", a sender-side application simply hands over messages, and as long as the receiver-side *application* (all outside the transport system!) is able to detect them, these messages can go over e.g. SCTP, where they can arrive out-of-order, or TCP, where they will arrive in-order, without requiring any special intervention - it's always the same receive call. You may receive your messages in parts but they are in-order \"inside\" (of course) and you (the receiver-side app) can detect where they end.",
          "createdAt": "2018-02-26T21:38:57Z",
          "updatedAt": "2018-02-26T21:38:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl By \"can be detected\", I meant \"is represented in the on-the-wire format such that both the local and remote endpoints are explicitly communicating this message boundary\", like HTTP or SCTP. If you just lay the bytes out in TCP without any other encoding, you're doing Message boundaries that only make sense to one end (which can be okay, but is a bit degenerate).",
          "createdAt": "2018-02-26T21:48:44Z",
          "updatedAt": "2018-02-26T21:48:44Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly perhaps we're finally on the same page: yes I mean a case where only one end (the sender side) *of the transport system* knowing about the message boundaries in case of TCP, but *the application* on top knows the boundaries, on both the sender and receiver side.\r\n\r\nThe point of my presentations and text about the \"Application-Framed Bytestream\" was that this is enough: you can do everything you want with this, you don't actually need anything else. And it makes ideas like informing the receiver app about partial message reception unnecessary. The idea is that the receiver only accepts data blocks until it sees a message boundary that it knows about - then it has a complete message.",
          "createdAt": "2018-02-26T22:17:48Z",
          "updatedAt": "2018-02-26T22:17:48Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWUyOTk3ODcwMTY=",
      "title": "ARCh: Content-related actions...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/80",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "/This should deliver a useful error to the application./\r\n- I understand what was intended, but errors are not usually useful in a sense. Should this be:\r\n/This should deliver an error that the application is able to utilise./\r\n---\r\n/Content Received: A Content Received event delivers received content to the application, based on a Receive action. This may include an error if the action failed./\r\n- I don't yet understand the error part to this. ",
      "createdAt": "2018-02-23T17:20:31Z",
      "updatedAt": "2018-02-23T19:23:19Z",
      "closedAt": "2018-02-23T19:23:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed, and clarified the receive error.",
          "createdAt": "2018-02-23T19:23:19Z",
          "updatedAt": "2018-02-23T19:23:19Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWUyOTk3ODczNzU=",
      "title": "Arch: an indication that Content has been acknowledged by a peer",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/81",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "The text describes and event: /an indication that Content has been acknowledged by a peer./\r\n- I don't agree/understand, in the way I see this, the sender should receive the signal as soon as the content leaves the interface, it shouldn't delay to wait and see if the data went through the network - I actually think this idea of per-layer ACKs is dangerous. If an app wishes to know the data has made it, then it should add PDUs to the remote endpoint to ask that, not trust the transport with that responsibility. Many TCP-based apps have fallen foul of assumptions about what happens with data received by the remote stack. I'd like to see that removed as a feature. ",
      "createdAt": "2018-02-23T17:21:46Z",
      "updatedAt": "2018-02-23T19:23:24Z",
      "closedAt": "2018-02-23T19:23:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good, agreed.",
          "createdAt": "2018-02-23T19:21:13Z",
          "updatedAt": "2018-02-23T19:21:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Removed!",
          "createdAt": "2018-02-23T19:23:23Z",
          "updatedAt": "2018-02-23T19:23:23Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWUyOTk3ODc1ODk=",
      "title": "Arch: All references informative?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/82",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "help wanted"
      ],
      "body": "I think all currently cited drafts are Informative to this document! ",
      "createdAt": "2018-02-23T17:22:24Z",
      "updatedAt": "2018-02-23T18:52:40Z",
      "closedAt": "2018-02-23T18:52:40Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed they are. Fixed.",
          "createdAt": "2018-02-23T18:52:40Z",
          "updatedAt": "2018-02-23T18:52:40Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWUyOTk3ODc4NzY=",
      "title": "GF Author block details",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/83",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "admin stuff"
      ],
      "body": "My full author block is below, can someone edit this in next pass please for me in Arch and  API:\r\n\r\n   Godred Fairhurst\r\n   University of Aberdeen\r\n   Department of Engineering\r\n   Fraser Noble Building\r\n   Aberdeen, AB24 3UE\r\n   Scotland\r\n\r\n   Email: gorry@erg.abdn.ac.uk\r\n   URI:   http://www.erg.abdn.ac.uk/",
      "createdAt": "2018-02-23T17:23:19Z",
      "updatedAt": "2018-02-23T18:17:27Z",
      "closedAt": "2018-02-23T18:17:27Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated!",
          "createdAt": "2018-02-23T18:17:27Z",
          "updatedAt": "2018-02-23T18:17:27Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWUyOTk5NDE0MjI=",
      "title": "ARCH: RFC 2119 language used.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/84",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Section 4.1.1 contains some text that looks like RFC Requirements, but we don't say this as a requirements docment. And we don't include the boilerplate explaining RFC2119.\r\n\r\nMy Recommendation: I'd be happy enough to see this section just use lower case keywords. There's a few of these across the document describing the way it should work which currently look non-normative to me. We could always revisit this in a later revision if there is agreement that we should include RFC2119 keywords, but then we need to carefully review each usage:-).\r\n\r\nHowever..., the Security Considerations still uses normative language. My hope is these could also be lower case?",
      "createdAt": "2018-02-24T13:32:31Z",
      "updatedAt": "2018-02-24T18:03:18Z",
      "closedAt": "2018-02-24T18:03:17Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good call. We may want to add some back later, but we don't need it now!",
          "createdAt": "2018-02-24T18:03:17Z",
          "updatedAt": "2018-02-24T18:03:17Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWUzMDAwNDg3MjU=",
      "title": "Unable to compile draft-brunstrom-taps-impl",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/86",
      "state": "CLOSED",
      "author": "karlgrin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "admin stuff"
      ],
      "body": "@mwelzl could you please make sure that your latest revision of the implementation draft compiles.",
      "createdAt": "2018-02-25T18:25:36Z",
      "updatedAt": "2018-02-26T00:02:49Z",
      "closedAt": "2018-02-25T21:58:24Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed compilation for now, but I had to remove Michael as an author. I tried many variations, but the xml output was always invalid?",
          "createdAt": "2018-02-25T21:58:24Z",
          "updatedAt": "2018-02-25T21:58:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Very sorry! I fixed this now (I insist on co-authorship  :-D  ) - I think it came from copy+pasting, the block said that I'm an editor... maybe that didn't work out.",
          "createdAt": "2018-02-25T23:44:54Z",
          "updatedAt": "2018-02-25T23:44:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl Great! Yes, you indeed should be an author. =) I felt bad for removing you, but it wasn't building. I event removed the editor line, but that didn't make a difference. Glad it's cleared up now.",
          "createdAt": "2018-02-25T23:47:35Z",
          "updatedAt": "2018-02-25T23:47:35Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Never mind  :)   I hope it doesn't only compile on my system now...  but here things seem fine",
          "createdAt": "2018-02-25T23:50:00Z",
          "updatedAt": "2018-02-25T23:50:00Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Checked it on my system, and it compiles now.",
          "createdAt": "2018-02-25T23:54:15Z",
          "updatedAt": "2018-02-25T23:54:15Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume we both have a Mac  :-)  :-)",
          "createdAt": "2018-02-26T00:02:49Z",
          "updatedAt": "2018-02-26T00:02:49Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWUzMDAwNTE2NjA=",
      "title": "Rename Association cache",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/87",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "In Figure 1 and 4.2 we use the term Association Cache. I think this name is too narrow and confusing and it is not aligned with what we have in the implementation draft. I suggest renaming this to Cached State or Protocol and Performance Caches. The text in 4.2 can borrow from the implementation draft and be updated to:\r\n\"Beyond a single Connection's lifetime, it is useful for an implementation to keep state and history. This cached state can help improve future Connection establishment due to re-using results and credentials, and favoring paths and protocols that performed well in the past. It can include DNS results, TLS session state, previous success and quality of transport protocols over certain paths.\"",
      "createdAt": "2018-02-25T19:04:07Z",
      "updatedAt": "2018-02-25T22:09:14Z",
      "closedAt": "2018-02-25T22:09:14Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated in architecture to Cached State to be consistent",
          "createdAt": "2018-02-25T22:09:14Z",
          "updatedAt": "2018-02-25T22:09:14Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzMDAwNTI4MTM=",
      "title": "Consistency of Design Principles",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/88",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "The architecture draft has a number of design principles listed (the ones discussed in Cambridge). The API draft has a another set of design principles listed. When reading both drafts as I just did, this is quite confusing. Do we need design principles in the API draft or they should all move to the architecture draft? Some of the design principles in the API draft are perhaps more detailed which could be an argument to keep them in the API draft, but then I think we should at least make sure to include all design principles from the architecture draft that applies to the API also in the API draft. Right now we have only one of them which is strange.  ",
      "createdAt": "2018-02-25T19:19:37Z",
      "updatedAt": "2018-02-26T22:00:26Z",
      "closedAt": "2018-02-26T22:00:26Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO the principles in the Architecture document are primary. The list in API as it stands is largely inherited from Post Sockets. Though the list of principles in the API is more detailed (and I think we need more detailed principles for the API), it should refer back more concretely to the arch principles. I'll do this in my early-week edit pass.",
          "createdAt": "2018-02-25T22:03:02Z",
          "updatedAt": "2018-02-25T22:03:02Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. So, can we leave the architecture list as-is, and maybe re-name the section in the API?",
          "createdAt": "2018-02-25T22:03:30Z",
          "updatedAt": "2018-02-25T22:03:30Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Open to suggestions for naming (I would have just called it \"Interface Design Principles\")... API section will have to expand a little from its current bullet-list to base itself on arch principles.",
          "createdAt": "2018-02-25T22:19:54Z",
          "updatedAt": "2018-02-25T22:19:54Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWUzMDAwNTcyNTA=",
      "title": "4.2. Protocol Stack should be Protocol Stack Instance?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/89",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "In Figure 1 we use Protocol Stack Instance in Section 4.2 we use Protocol Stack. We should be consistent. So one place needs to be updated. Protocol Stack Instance seems right to me.",
      "createdAt": "2018-02-25T20:18:11Z",
      "updatedAt": "2018-02-26T09:45:05Z",
      "closedAt": "2018-02-26T09:45:05Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At least right now, we use Protocol Stack in the text for the architecture and implementation drafts\u2014adding Instance (while correct) gets a bit wordy in my opinion, and any singular Stack is an instance. I'll update the figure.",
          "createdAt": "2018-02-25T22:05:38Z",
          "updatedAt": "2018-02-25T22:05:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated",
          "createdAt": "2018-02-25T22:08:37Z",
          "updatedAt": "2018-02-25T22:08:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this needs to happen in the api doc too",
          "createdAt": "2018-02-25T22:24:42Z",
          "updatedAt": "2018-02-25T22:24:42Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually not really; carry on.",
          "createdAt": "2018-02-26T09:45:05Z",
          "updatedAt": "2018-02-26T09:45:05Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWUzMDAwNzM2NTI=",
      "title": "Semantics of \"low latency\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/90",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "In issue #65, we discussed that \"Immediate Acknowledgement\" (from SCTP) is a bit too protocol-specific and could maybe be called \"low latency\", allowing the stack to automatically turn this on \"under the hood\".\r\n\r\nI think the only use case for this is when an application executes tight control over the send buffer, and wants to be able to change what it hands over to the transport system at the last minute - then, it is probably good to know ASAP when a particular Message has really arrived at the receiver.\r\nThis would be an application that requires low latency.\r\n\r\nThe API currently has another send parameter called \"immediate\". This would turn off the Nagle algorithm, for example - it represents a wish to send stuff fast, possibly at the cost of wasting capacity  (more header overhead, or other things).\r\n\r\nI don't think that an application that needs \"immediate\" would always also need \"immediate acknowledgement\" or vice versa - these seem to be two different things.\r\n\r\nShould we have two boolean send parameters for these two types of requests?\r\n\"Prefer low latency\" (to trade against capacity) and \"ACK ASAP\" ?",
      "createdAt": "2018-02-25T23:42:52Z",
      "updatedAt": "2018-09-12T14:19:48Z",
      "closedAt": "2018-04-23T11:52:04Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'd suggest that when you say \"the only use case for this is\", you're starying to make me think this is a very specific application use.  The immediate stuff in SCTP was a very specific use. I'm quite OK with believing other use-cases exist, what I'd question is whether this specific feature needs to be in a generic API?",
          "createdAt": "2018-02-26T08:52:35Z",
          "updatedAt": "2018-02-26T08:52:35Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In SCTP, there were SCTP-internal reasons AND there was the app reason: https://tools.ietf.org/html/rfc7053#section-4.1    I now wonder whether this is something that COULD somehow be handled internally in the transport system, or if we need to expose a flag to enable this kind of thing. I'll follow up with emails.",
          "createdAt": "2018-02-26T10:27:04Z",
          "updatedAt": "2018-02-26T10:44:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TL;DR: I thought more about this. I started to write an email, and writing made me think deeper and understand better. I conclude that, whether to get ACKs back immediately or not is also just a matter of trading latency against overhead, and indeed one \"low latency\" bit is enough. Actually we don't need an extra bit because this is already covered by the message property \"Immediate\" (which is about, e.g., disabling Nagle - but the point is that these things go together: lower latency at the cost of overhead).\r\n\r\nBelow, I describe the background for my conclusion. It would be good if someone could check it for potential logical errors.\r\n\r\nTommy once described Apple's model of buffer control to me as follows:\r\n\r\n***\r\nI consider TCP_NOTSENT_LOWAT to be an implementation detail of the sockets API, and not really the right model here. \r\nThe backpressure we have is based on the asynchronous callback. Nothing is blocking.\r\nIf the application wants to slow down the generation of its content based on back pressure from the stack, it should wait to generate another send based on the callback to the previous send being fired. However, you may enqueue multiple sends back to back, since the data may already be generated. This gives all of the capabilities of back pressure, without blocking, or forcing it.\r\n***\r\n\r\nI think this approach is just right. What this doesn't discuss, however, is how to *configure* the low water mark of TCP - and I think an efficient implementation of a transport system would statically configure it as low as possible, such that most buffering happens inside the transport system, not in TCP, and the application does get maximum control over it via the Sent callbacks.\r\n\r\nNow, turn to SCTP as a model. ACK-immediately just means that, in case of reliable transfer, SCTP can delete stuff from its own retransmit buffer faster (In SCTP, and only SCTP, this directly concerns the application because SCTP's \"sender dry event\" concerns both unsent and unacknowledged data). So if the transport system would want to keep SCTP's send buffer small, it could turn on \"ACK-immediately\", at the cost of overhead (more ACKs on the backward path), but because \"sender dry\" isn't what we should expose to the application (BECAUSE it mixes the unsent and unack'ed data buffer, and because it fires when it's too late anyway - the buffer really is at 0), we also shouldn't expose control over ACK-immediately.",
          "createdAt": "2018-02-26T11:04:09Z",
          "updatedAt": "2018-02-26T11:05:50Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is on the list to resolve for ietf-00 (which may or may not be intentional). I think the action here is to replace the _Immediate Acknowledg(e)ment_ send property with an _Low Latency_ send property with more or less the same semantics as the _Immediate_ send property (which I thought was still there, but appears to have been removed...? oops, someone!).\r\n\r\nAn open question is whether or not we also need a protocol selection property for low latency, which (1) verifies that the underlying protocol actually supports control over Nagle-like functionality and (2) can be used to set _Low Latency_ by default.\r\n\r\nAny takers (@mwelzl @tfpauly?)... I could probably take a crack at this tomorrow...\r\n\r\n",
          "createdAt": "2018-04-16T09:02:38Z",
          "updatedAt": "2018-04-16T09:02:38Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I like the name \"Immediate\" as a send property very much (because it conveys a meaning that we can't guarantee), but other than that I think you're right - we just need to convey \"low latency\" somehow and remove the \"immediate ack\" stuff. I don't think we need a protocol selection property for it.",
          "createdAt": "2018-04-16T09:35:41Z",
          "updatedAt": "2018-04-16T09:35:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to \"Immediate\" not being the right name.\r\n\r\nAh, okay, I see what happened. The _Immediate_ send property was subsumed into the (terribly named) _Instantaneous Capacity Profile_, and _Low Latency_ in the protocol selection properties was subsumed into _Capacity Profile_.\r\n\r\nIf we keep _Capacity Profile_, then, the only action here is to remove _Immediate Acknowledgement_, and note that such functionality is implied by the _Low Latency_ capacity profile. I'm leaning toward doing that for this issue, then starting a new issue for an (ietf-01) decision on what to do about _Capacity Profile_... is that good?",
          "createdAt": "2018-04-17T07:47:02Z",
          "updatedAt": "2018-04-17T07:47:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems this has converged a long time ago... I'll remove the property about this from section A.1.3.  That it's still there is just an oversight, I believe.",
          "createdAt": "2018-09-12T14:19:48Z",
          "updatedAt": "2018-09-12T14:19:48Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWUzMDAwNzk5NTc=",
      "title": "Submit -00 of Architecture Draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/91",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "We're planning on submitting the architecture draft first (if there are no major objections) to get it available for people to start looking at, and because it's the most ready at this point.\r\n\r\nI'm planning on submitting by end-of-day Monday 2/26. If anyone has any nits or last changes, please let me know. We can, of course, update if we need further reconciliation with the other drafts before the submission deadline!",
      "createdAt": "2018-02-26T00:59:03Z",
      "updatedAt": "2018-02-26T22:15:20Z",
      "closedAt": "2018-02-26T22:15:19Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I gave this a careful read now and I like it a lot!\r\n\r\nI have fixed some (truly tiny) nits; there are three bigger things that I didn't touch:\r\n\r\n1) it's strange that the abstract appears again as the first paragraph of the intro. I think this can safely be removed.\r\n\r\n2) I think you wanted to avoid the use of \"TAPS\", but (only!) in the security considerations section, it's all over the place. I didn't want to mess with this text, but I think this would be good to update too.\r\n\r\n3) I think it's not really correct to represent Connection Groups as an implementation concept only, as we do expose such groups too. However, not everything that the API does must be described in this architecture document, and I wouldn't know how / where to put it without making things uglier than they need to be.  I just wanted to note this issue here, but I think it's safe to ignore (at least for -00).",
          "createdAt": "2018-02-26T12:09:31Z",
          "updatedAt": "2018-02-26T12:09:31Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl Thanks! Addressed nits 1 & 2; we can move 3 around in the future, as you say.",
          "createdAt": "2018-02-26T16:12:56Z",
          "updatedAt": "2018-02-26T16:12:56Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I now also made it to the end of my read through (too many interruptions) . I also like it! \r\nFiled a separate issue for the last inconsistency I detected around the term Policy System. ",
          "createdAt": "2018-02-26T20:17:03Z",
          "updatedAt": "2018-02-26T20:17:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, @abrunstrom. Addressed your issue!",
          "createdAt": "2018-02-26T20:40:37Z",
          "updatedAt": "2018-02-26T20:40:37Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly Thanks, looks good!",
          "createdAt": "2018-02-26T20:46:03Z",
          "updatedAt": "2018-02-26T20:46:03Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ship it.",
          "createdAt": "2018-02-26T20:54:57Z",
          "updatedAt": "2018-02-26T20:54:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See: https://datatracker.ietf.org/doc/draft-pauly-taps-arch/",
          "createdAt": "2018-02-26T22:15:19Z",
          "updatedAt": "2018-02-26T22:15:19Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWUzMDAyMDQ3MjY=",
      "title": "Write \u00a711 on error handling",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/92",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-26T11:38:10Z",
      "updatedAt": "2018-02-26T19:41:48Z",
      "closedAt": "2018-02-26T19:41:48Z",
      "comments": []
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWUzMDAyMDY3OTI=",
      "title": "Write \u00a74: API summary",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/93",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-26T11:45:20Z",
      "updatedAt": "2018-02-27T14:20:30Z",
      "closedAt": "2018-02-27T14:20:30Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWUzMDAyMDcxNTg=",
      "title": "Address sending/receiving of partial Messages in \u00a77 / \u00a78",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/94",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2018-02-26T11:46:38Z",
      "updatedAt": "2018-02-26T17:06:33Z",
      "closedAt": "2018-02-26T17:06:32Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWUzMDAyMzY3MDE=",
      "title": "Work out the relationship between Connection Groups and Preconnection",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/95",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "We create Connection Groups via `Clone().`\r\n\r\nIt would be nice to be able to create groups during pre-establishment.\r\n\r\nBut you need a Connection to `Clone()` a connection.\r\n\r\nThere are a few possible syntaxes to use here, we should pick one. For now, will drop mention of being able to clone in pre-establishment.",
      "createdAt": "2018-02-26T13:22:41Z",
      "updatedAt": "2018-02-27T14:20:42Z",
      "closedAt": "2018-02-27T14:20:42Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "or simply add the Clone() command to a PreConnection object too?",
          "createdAt": "2018-02-26T13:28:02Z",
          "updatedAt": "2018-02-26T13:28:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah that's probably simplest. need to think a bit about how the dynamics of that would work (is Clone() just Initiate() with the implication you'll clone the initiated thing? is Clone() of a Preconnection that's already been consumed just a Clone() on the resulting Connection?_",
          "createdAt": "2018-02-26T22:07:21Z",
          "updatedAt": "2018-02-26T22:07:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, can we say that cloning a preconnection doesn't do anything but create a new preconnection instance, and in line with the \"entanglement\" that we have for groups in general, if one of them gets connected, this also turns all its clones from preconnections into connections?",
          "createdAt": "2018-02-26T22:34:36Z",
          "updatedAt": "2018-02-26T22:34:36Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having `Clone()` on a `Preconnection` generate another `Preconnection` that's entangled with the original makes sense. I'm not sure calling `Initiated()` on one of the cloned `Preconnection` objects should force the others to connect though \u2013 I'd rather expect it to mean that when the others are initiated, they instantiate as a sub-flow on the existing connection group. \r\n\r\nThat is, I think it makes sense to be able to instantiate a connection while retaining a reference to a `Preconnection` that _could_ become a sub-flow within that connection, but doesn't have to do so.",
          "createdAt": "2018-02-26T23:22:54Z",
          "updatedAt": "2018-02-26T23:22:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not sure calling Initiated() on one of the cloned Preconnection objects should force the others to connect though \u2013 I'd rather expect it to mean that when the others are initiated, they instantiate as a sub-flow on the existing connection group.\r\n\r\nWhether a connection is a sub-flow or not should be hidden to the application; ideally, it should be a sub-flow (you mean stream, I guess?) when possible, but otherwise, what would be bad about automatically initiating for clones too just for consistency?  As an app programmer, if you don't want this, don't clone...",
          "createdAt": "2018-02-26T23:31:43Z",
          "updatedAt": "2018-02-26T23:31:43Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you clone, then when you initiate the clone you get a stream rather than a new connection, I agree. But, I don't see we can force the clone to connect just because the master stream does. \r\n\r\nPartly this is an API thing. If I `clone()` a `Preconnection` and get a new `Preconnection` object, I don't see how the API can force the new `Preconnection` to automatically change type to `Connection`. But, partly, it also matches protocol semantics: I have something that _could_ become a stream, but that doesn't mean I want to be become a stream _now_ just because I initiated the underlying connection.",
          "createdAt": "2018-02-26T23:36:45Z",
          "updatedAt": "2018-02-26T23:36:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About this:\r\n> But, I don't see we can force the clone to connect just because the master stream does.\r\n> Partly this is an API thing. If I clone() a Preconnection and get a new Preconnection object, I don't see how the API can force the new Preconnection to automatically change type to Connection. \r\n\r\nI don't understand why this can't or shouldn't be done - but maybe this is something about the underlying p2p semantics that I miss.\r\n\r\nAbout this:\r\n> I have something that could become a stream, but that doesn't mean I want to be become a stream now just because I initiated the underlying connection.\r\n\r\nI wonder, what's the problem with this being a stream right away?  What's the disadvantage of immediately connecting?\r\n\r\nI can only think of \"you may want this to have different properties than the original Preconnection object\", but in this case, you just don't want to use Clone().\r\n\r\nI'm probably missing something and I don't have a strong opinion about this, though.",
          "createdAt": "2018-02-26T23:42:50Z",
          "updatedAt": "2018-02-26T23:42:50Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's nothing about underlying p2p semantics, but more how to programming API works. If I write code that looks something like:\r\n``` Rust\r\nlet a = Preconnection::new();  // a is a Preconnection\r\nlet b = a.clone();             // b is a Preconnection, entangled with a\r\nlet c = a.Initiate();          // c is a Connection; a is consumed and goes out of scope\r\n```\r\nthen the type of `b` shouldn't change just because I called a method on `a`.\r\n\r\nSecondly, the disadvantage of immediately connecting is that I use resources on the connection. It allocates a stream identifier, for example. I may not want to do that just yet, because I don't know for sure if this stream will be needed, and there might be a finite number of streams that can be created. ",
          "createdAt": "2018-02-26T23:50:06Z",
          "updatedAt": "2018-02-26T23:50:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I see, you're thinking real object orientation here. In C this wouldn't matter. Either way there's some awkwardness to \"entanglement\" (hence the choice of an awkward word for it): if you change parameters on one of the \"connections\", it affects others too (because they may really only be streams of a single association).\r\n\r\nLet's assume that they don't auto-initiate: couldn't this cause inconsistencies?  I connect a, but not yet b; I change properties of b => normally, these would automatically change for a too...  but now a is connected, yet b is not...  maybe that's okay, but I have a feeling that this is asking for trouble.",
          "createdAt": "2018-02-27T00:03:24Z",
          "updatedAt": "2018-02-27T00:03:24Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd assume that there would be limits on what properties of a clone you can change once the original has been connected. Returning an error (\"can't change property X on clone of connection\") seems, to me, a less surprising operation than having cloned preconnections auto-connect.",
          "createdAt": "2018-02-27T00:14:41Z",
          "updatedAt": "2018-02-27T00:14:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oh, i agree!  that\u2019s the best way to do it!\n\nSent from my iPhone\n\n> On 27 Feb 2018, at 01:14, Colin Perkins <notifications@github.com> wrote:\n> \n> I'd assume that there would be limits on what properties of a clone you can change once the original has been connected. Returning an error (\"can't change property X on clone of connection\") seems, to me, a less surprising operation than having cloned preconnections auto-connect.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-02-27T00:21:46Z",
          "updatedAt": "2018-02-27T00:21:46Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "all this sounds eminently reasonable to me, and can easily be done for -00. moving to london (not yet assigning to self though, working on #93 and #101...",
          "createdAt": "2018-02-27T09:36:06Z",
          "updatedAt": "2018-02-27T09:36:06Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "making progress today (yay!) so this one's mine...",
          "createdAt": "2018-02-27T10:10:04Z",
          "updatedAt": "2018-02-27T10:10:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks!!",
          "createdAt": "2018-02-27T10:15:37Z",
          "updatedAt": "2018-02-27T10:15:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "working on this, I note another problem: we now have positive linear Priorities over connection groups, and inverse discrete Niceness over individual messages. This is gratuitously inconsistent. I'm writing this up as Niceness for now. Speak up if you really, really hate this.",
          "createdAt": "2018-02-27T10:34:13Z",
          "updatedAt": "2018-02-27T10:34:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I speak up just to say I don't care. To me the Niceness stuff isn't nearly as intuitive as priorities, but this is just a matter of taste and doesn't matter. Syntactical sugar: if I'll ever write an implementation against this interface I'll add a shim that inverts the numbers  :-)",
          "createdAt": "2018-02-27T10:38:07Z",
          "updatedAt": "2018-02-27T10:38:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with @mwelzl \u2013 it doesn't matter which we pick, but we should be consistent.",
          "createdAt": "2018-02-27T10:39:33Z",
          "updatedAt": "2018-02-27T10:39:33Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzMDAzMzA2NjU=",
      "title": "Missing text for Fig.2",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/97",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "There is no mentioning of Figure 2 in the text. Perhaps add before the figure something like:\r\nThe diagram below provides a high-level view of the actions taken during the life time of a connection.",
      "createdAt": "2018-02-26T17:38:31Z",
      "updatedAt": "2018-02-26T17:56:26Z",
      "closedAt": "2018-02-26T17:56:26Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added text.",
          "createdAt": "2018-02-26T17:56:26Z",
          "updatedAt": "2018-02-26T17:56:26Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWUzMDAzMzI4MDA=",
      "title": "Connection group is broader concept",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/98",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "In 4.2 the concept of Connection Group is broader than just for multiplexing protocols. Suggest to adjust text to:\r\n\r\nConnection Group: a Connections Group is a set of Connections that share all properties. For multiplexing transport protocols, the Connections in a Connection Group can be multiplexed together.",
      "createdAt": "2018-02-26T17:45:18Z",
      "updatedAt": "2018-02-26T17:56:18Z",
      "closedAt": "2018-02-26T17:56:18Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks! Used your text.",
          "createdAt": "2018-02-26T17:56:18Z",
          "updatedAt": "2018-02-26T17:56:18Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWUzMDAzNzk0Mzc=",
      "title": "Inconsistent use of System Policy",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/100",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "Implementation"
      ],
      "body": "In 4.2 of the architecture draft, System Policy is defined as the algorithm used to identify candidates and do racing based on the provided connection properties. \r\nIn the implementation draft, system policy is an input to the algorithm.\r\n\r\nThe definition in the implementation draft is more natural to me, system policy is an input. One solution could be to use the term Policy System rather than System Policy in the architecture draft and update the description to something like:\r\n\r\nPolicy System : A Transport Service Policy System defines the algorithm used to combine and reconcile connection properties from the application with dynamic system policy and implementation defaults to determine how it will gather candidate paths and protocols ({{gathering}}) and race the candidates during establishment ({{racing}}).\r\n\r\nOnce the text for the architecture draft is set, minor tweaks can be applied to the implementation draft to conform.",
      "createdAt": "2018-02-26T20:12:28Z",
      "updatedAt": "2018-02-26T20:40:14Z",
      "closedAt": "2018-02-26T20:40:14Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think System Policy should refer to the part of the Operating System or TAPS System that controls which paths are allowed for what operations. So yes, system policy is an input. I'd rather just re-work the architecture draft here to match the implementation.",
          "createdAt": "2018-02-26T20:31:40Z",
          "updatedAt": "2018-02-26T20:31:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated definition to be more inline with the usage in the implementation draft!",
          "createdAt": "2018-02-26T20:40:14Z",
          "updatedAt": "2018-02-26T20:40:14Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWUzMDA1NTE4ODQ=",
      "title": "Clear out editor's notes for -00 submission",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/101",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "There are still a few `\\[EDITOR'S NOTE`s and similar scattered throughout the document. Find them and fix them, or move them to post-London issues.",
      "createdAt": "2018-02-27T09:26:42Z",
      "updatedAt": "2018-02-27T14:20:30Z",
      "closedAt": "2018-02-27T14:20:30Z",
      "comments": []
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUzMDA1NTk1ODU=",
      "title": "Be explicit about when name resolution occurs",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/102",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Since the initiation of name resolution may leak information about the interests of an application's user, which may be privacy-sensitive, applications should have explicit control over when name resolution occurs. At the same time, a lot of the latency savings of an API that splits Connection and Preconnection comes from being aggressive about early resolution. We should find a consistent and predictable way to reconcile this.",
      "createdAt": "2018-02-27T09:50:31Z",
      "updatedAt": "2018-09-03T15:03:56Z",
      "closedAt": "2018-09-03T15:03:56Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Applications need to be able to give information to the system about whether resolution is allowed to happen before `Initiate()`. Suggestion is to default to no resolution in preconnection, to allow application to override for low connection latency (and to explain the default).\r\n\r\nWe also need the ability to do explicit resolution of an Endpoint.",
          "createdAt": "2018-05-16T15:48:04Z",
          "updatedAt": "2018-05-16T15:48:04Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzMDA1NjI3MTY=",
      "title": "Evaluate the applicability of \u00a76.3 to ICE-like protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/103",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API"
      ],
      "body": "editor's note from pre-00:\r\n\r\n> This API is sufficient for TCP-style simultaneous open, but should be considered experimental for ICE-like protocols.\r\n\r\nThis didn't seem like something we need in -00, so opening this issue to make sure it doesn't get lost...",
      "createdAt": "2018-02-27T09:59:14Z",
      "updatedAt": "2019-03-25T11:56:18Z",
      "closedAt": "2019-03-25T11:55:44Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins is there a chance we can get to this in the next week or so, or shall we push it to ietf-01?",
          "createdAt": "2018-04-11T13:10:40Z",
          "updatedAt": "2018-04-11T13:10:40Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think push it to the ietf-01 milestone. If we're prioritising work in this space, #127 is more urgent.",
          "createdAt": "2018-04-12T09:07:19Z",
          "updatedAt": "2018-04-12T09:10:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Side meeting: closing until we have a need to change this",
          "createdAt": "2019-03-25T11:55:44Z",
          "updatedAt": "2019-03-25T11:55:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this actually seems done in the document",
          "createdAt": "2019-03-25T11:56:18Z",
          "updatedAt": "2019-03-25T11:56:18Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUzMDA1NjQ1ODE=",
      "title": "Cut appendix C",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/104",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "The current appendix C \"Transport Parameters\" discusses:\r\n\r\n- details of which transport and path selection properties can take which preference levels\r\n- details of how querying of transport parameters and properties works\r\n\r\nIt's not currently up to date with -00. \r\n\r\nThe former set of restrictions already appears in \u00a75.2, which relaxes some of the restrictions but points out that applications should take care to select consistent preferences while implementations should fail early on inconsistent application preferences, which would seem to be an appropriate level of detail for -00.\r\n\r\nThe latter content appears in \u00a79 in abbreviated form.\r\n\r\nI think we can cut this for -00; objections? @mwelzl, @theri, @philsbln, opinions?",
      "createdAt": "2018-02-27T10:04:42Z",
      "updatedAt": "2018-02-27T16:06:00Z",
      "closedAt": "2018-02-27T16:05:59Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes... I like the idea of these tables at the end to summarize what is written earlier, but then (as has happened) these tables can get out of sync, so I think it's easier to include them later, not while things are changing. Right now I agree that the mismatch makes things quite confusing.",
          "createdAt": "2018-02-27T10:21:18Z",
          "updatedAt": "2018-02-27T10:21:18Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the tables were helpful to illustrate some concept around the properties, but for the current version of the draft, having the restrictions in \u00a75.2 and the content in \u00a79 work for me.\r\n\r\nTwo points from the appendix which are still missing in the main text IMO:\r\n\r\n- Transport Features are expressed in the same vocabulary as Protocol Selection Properties, but have a Boolean value expressing whether a Protocol Stack support the given Transport Feature or not. (Add to \u00a79)\r\n- Note that it is possible that the Protocol Stack Instances actually chosen by the transport system do not fully reflect the Transport Parameters that were originally set. For example, a certain Protocol Selection Property that an application specified as Preferred may not actually be present in the chosen Protocol Stack Instances because none of the currently available transport protocols had this feature. (Add to either \u00a75.2 or \u00a79... I'd say \u00a79 is better.)",
          "createdAt": "2018-02-27T12:22:10Z",
          "updatedAt": "2018-02-27T12:22:10Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWUzMDA1OTk1MzY=",
      "title": "API 5.2 Connection Groups",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/108",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "The API document says:\r\n```\r\n* Efficient use of Connection Groups:\r\n  This boolean property specifies whether an\r\n  application considers it useful to create Connection Groups, e.g. to\r\n  explicitly prioritize between Connections within a Connection Group. This\r\n  property will tend to select multistreaming transport protocols, which can\r\n  multiplex Connections into a Connection Group over a single flow. This is not\r\n  a strict requirement. The default is to not have this option.\r\n```\r\nI'm not sure I follow this. The text doesn't seem to match the option name: it isn't saying use connection groups efficiently or not, it's specifying whether connection groups can be used at all. It's also not clear why prioritisation is given as an example. \r\n\r\nWould it be clearer written something more like the following?\r\n```\r\n* Multiplex connections:\r\n  This boolean property specifies that the application would prefer multiple\r\n  Connections between the same endpoints to be treated as a Connection\r\n  Group and multiplexed onto a single underlying transport connection where\r\n  possible, for reasons of efficiency. This is not a strict requirement. The \r\n  default is to not have this option.\r\n```",
      "createdAt": "2018-02-27T11:49:43Z",
      "updatedAt": "2018-02-27T17:16:53Z",
      "closedAt": "2018-02-27T17:16:53Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yep. Although you *still* have to explicitly entangle connections by cloning them if you want them to be guaranteed to be within a connection group.",
          "createdAt": "2018-02-27T17:06:07Z",
          "updatedAt": "2018-02-27T17:06:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...which makes me question why we need this parameter?",
          "createdAt": "2018-02-27T17:10:39Z",
          "updatedAt": "2018-02-27T17:10:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To explicitly prefer multistreaming protocols during selection, because you wrote your app to clone connections instead of cloning preconnections.",
          "createdAt": "2018-02-27T17:12:33Z",
          "updatedAt": "2018-02-27T17:12:33Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(see #118)",
          "createdAt": "2018-02-27T17:13:08Z",
          "updatedAt": "2018-02-27T17:13:08Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWUzMDA2MDA1Nzk=",
      "title": "API 5.2 Connection timeout",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/109",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This API says:\r\n```\r\n* Suggest a timeout to the Remote Endpoint:\r\n  This boolean property specifies whether an application considers it\r\n  useful to propose a timeout until the connection is assumed to be lost.\r\n  This property applies to Connections and Connection Groups. This is not a\r\n  strict requirement. The default is to have this option.\r\n```\r\nNeed to clarify if this is a timeout for connection establishment (i.e., how long should the endpoint wait before declaring that `Initiate()` failed), or it it's a timeout for data transfer after a connection has been established?",
      "createdAt": "2018-02-27T11:53:19Z",
      "updatedAt": "2018-12-12T10:40:33Z",
      "closedAt": "2018-12-12T10:40:32Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Before you do Initiate, it's the timeout for establishment. After the connection has been established, it's the timeout for data transfer. It was my idea that one notion of a timeout is enough - you will never need both in parallel for the same Connection or Preconnection.",
          "createdAt": "2018-02-27T13:06:59Z",
          "updatedAt": "2018-02-27T13:06:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Those seem like two very different timeouts, and ones for which the application may have very different tolerances. \r\n\r\nPersonally, I\u2019ve been averse to giving timeout knobs in general, since choosing good timeouts is hard, and a knob makes developers think they need to turn it. Most of the time, no timeout is best (talk to Stuart). Beyond that, any establishment or receive timeout can just as easily be implemented in the application as they wait for their Ready or Receive Complete event. This knob is a convenience to re-arm a timer, not really a transport service itself. ",
          "createdAt": "2018-02-27T14:44:36Z",
          "updatedAt": "2018-02-27T14:44:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Move to Appendix A, then?",
          "createdAt": "2018-02-27T14:54:14Z",
          "updatedAt": "2018-02-27T14:54:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that these timeout values may be quite different; maybe merging them into only one parameter wasn't a good idea.\r\n\r\nAbout this:\r\n> Personally, I\u2019ve been averse to giving timeout knobs in general, since choosing good timeouts is hard, and a knob makes developers think they need to turn it. Most of the time, no timeout is best (talk to Stuart). Beyond that, any establishment or receive timeout can just as easily be implemented in the application as they wait for their Ready or Receive Complete event. This knob is a convenience to re-arm a timer, not really a transport service itself.\r\n\r\nLet me try to understand this: do you mean to say that the TCP User Timeout should simply be set to a huge number, large enough to basically never fire, and then it's up to the application to decide when to give up?\r\n\r\nI'd have to think about this... note that this comes via the TCP RFCs => RFC 8303 => minset path, it's not my invention.",
          "createdAt": "2018-02-27T14:59:59Z",
          "updatedAt": "2018-02-27T14:59:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I'm not arguing against TCP having a timeout option, but the discussion of this option in the API\u2014especially as a one top-level, cross protocol, all-encompassing timeout\u2014was going in a direction of adding timeouts where we wouldn't otherwise have them. If we had a timeout on overall connection establishment, from Initiate() to Ready(), then that's trying to set a timeout not just on TCP, but on DNS, racing, proxies, TLS, and who knows what else. I tend to see the timeout value as a specific protocol option if anything; sure, you can set a timer on any protocol you want, but is that really a benefit to the application? If a protocol behaves differently than TCP in the future with regards to how it acknowledges data, should setting the TCP User Timeout for how long data can be un-acked apply to this future transport, or are we starting to ossify it?",
          "createdAt": "2018-02-27T15:43:12Z",
          "updatedAt": "2018-02-27T15:43:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly : first, I didn't think about the timeout being so all-encompassing (DNS, racing, etc.) - but you're right, the way we have it, it becomes like that, and this sure sounds like a horrible idea. So I agree that this should only be a specific protocol option if anything.\r\n\r\nRegarding \"if anything\", I understand your arguments and tend to agree with them, too. However, I'm just a little careful about things coming from minset - I think that we must have sound arguments to remove them, of the style \"functionality XY covers this, and it can be dealt with inside the transport system because ...\". After all, the UTO exists for a reason...\r\n\r\nNoticing your thumb up for @britram 's suggestion to move this to appendix A, I think we're all in agreement on this approach for now.",
          "createdAt": "2018-02-27T16:24:32Z",
          "updatedAt": "2018-02-27T16:25:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, totally fine with this being in Appendix A for now. Definitely merits more discussion.",
          "createdAt": "2018-02-27T16:42:26Z",
          "updatedAt": "2018-02-27T16:42:26Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see #117",
          "createdAt": "2018-02-27T17:02:36Z",
          "updatedAt": "2018-02-27T17:02:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(mutating this issue to be the place to discuss these options)",
          "createdAt": "2018-02-27T17:16:13Z",
          "updatedAt": "2018-02-27T17:16:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems we must discuss this more for a different type of timeout. Right now, we have, as the only generic thing: \"Timeout for aborting Connection\". The description says: \"This property specifies how long to wait before aborting a Connection during establishment, or before deciding that a Connection has failed after establishment.\"\r\n\r\nThe \"during establishment\" part is awkward: as @tfpauly said above, these are quite different timeouts, where the application may have different tolerances.\r\n\r\nFrom minset (see appendix C), we need to support:\r\n\"Specify number of attempts and/or timeout for the first establishment message:\"\r\n\r\n... and it seems to me to be a reasonable thing to add - sure, the default should be large enough for all these fun types of racing to take place, but if an application is very intolerant of waiting to get a connection, it should be able to say so, right?\r\n\r\nSo my proposal is to remove the \"during establishment\" text from \"Timeout for aborting Connection\", and add \"Timeout for aborting Connection establishment\" (I think number of attempts isn't necessary and just gets silly as a generic thing when we're in fact trying multiple interfaces and protocols), with the description \"This property specifies how long to wait before aborting a Connection during establishment.\"",
          "createdAt": "2018-12-04T12:21:09Z",
          "updatedAt": "2018-12-04T12:21:09Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWUzMDA2MDA5OTQ=",
      "title": "API 5.2 \"Notification of special errors\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/110",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "What makes these errors \"special\"? It seems a strange term to use, and the meaning is unclear.",
      "createdAt": "2018-02-27T11:54:44Z",
      "updatedAt": "2018-02-28T09:54:20Z",
      "closedAt": "2018-02-28T09:54:20Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't write this, but I think it was an effort to lump together, from minset, two quite different types of errors:  1) notification of excessive retransmissions; 2) notification of icmp error message arrival.  Any suggestions for a common term?",
          "createdAt": "2018-02-27T13:16:08Z",
          "updatedAt": "2018-02-27T13:16:08Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If it's just those two types of errors, we can probably just list them...",
          "createdAt": "2018-02-27T15:36:21Z",
          "updatedAt": "2018-02-27T15:36:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...which is what I did in minset  :)",
          "createdAt": "2018-02-27T16:00:51Z",
          "updatedAt": "2018-02-27T16:00:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so the suggestion is to split these out into two protocol selection properties?",
          "createdAt": "2018-02-27T17:18:48Z",
          "updatedAt": "2018-02-27T17:18:48Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, I think so",
          "createdAt": "2018-02-27T17:22:01Z",
          "updatedAt": "2018-02-27T17:22:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "all right then, see #119 ",
          "createdAt": "2018-02-27T17:31:15Z",
          "updatedAt": "2018-02-27T17:31:15Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWUzMDA2MDI0Nzg=",
      "title": "API 5.2 Capacity Profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/111",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API"
      ],
      "body": "For the Constant Rate capacity profile, should we state that this implies that the connection will fail if there is insufficient capacity? (i.e., you're requesting a circuit breaker rather than congestion control)",
      "createdAt": "2018-02-27T11:59:51Z",
      "updatedAt": "2018-02-28T19:16:40Z",
      "closedAt": "2018-02-28T19:16:40Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "may fail instead of will fail, but yeah, this seems sensible.",
          "createdAt": "2018-02-27T14:22:15Z",
          "updatedAt": "2018-02-27T14:22:15Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWUzMDA2MDUzNTg=",
      "title": "API: How to specify idempotent data?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/112",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins",
        "britram"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "How is idempotent data, to be send in the zero-RTT connection establishment, specified?\r\n\r\nThe Use 0-RTT session establishment with an idempotent Message property \"specifies whether an application would like to supply a Message to the transport protocol before Connection establishment\" which suggests the idempotent message is set on the `Preconnection` and used later when the `Connection` is established, but it might be more natural to specify the idempotent data as a parameter to `Initiate()`/`Rendezvous()`?",
      "createdAt": "2018-02-27T12:09:57Z",
      "updatedAt": "2018-10-07T10:31:18Z",
      "closedAt": "2018-10-07T10:31:17Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This also relates to Section 7, which says:\r\n```\r\nIf Send is called on a Connection which has not yet been established, an\r\nInitiate action will be implicitly performed simultaneously with the Send.\r\nUsed together with the Idempotent property (see {{send-idempotent}}), this can\r\nbe used to send data during establishment for 0-RTT session resumption on\r\nProtocol Stacks that support it.\r\n```\r\nThis seems incompatible with the `Preconnection`/`Connection` split, since the only way to get a `Connection` on which to call `send()` is by calling `Initiate()`, `Listen()`, or `Rendezvous()`, which starts the process of establishing the connection.\r\n\r\n(Edit: and section 7.1.1.4)",
          "createdAt": "2018-02-27T12:20:55Z",
          "updatedAt": "2018-02-27T12:22:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "paging @tfpauly to discuss the pros and cons of the Apple and Linux approaches to TFO...",
          "createdAt": "2018-02-27T14:23:01Z",
          "updatedAt": "2018-02-27T14:23:01Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are three top-level approaches that we\u2019ve used/tried:\r\n1. Mark fast open in parameters (Preconnection) such that connect() (Initiate) becomes a fake action, and you then send after that, and the first send kicks off the real Initiate. \r\n2. Add your initial fast-open data to the parameters (Preconnection), such that it\u2019s already known by the time Initiate is called. \r\n3. Allow marking sends as idempotent, and allow enqueuing sends after create and before start. \r\n\r\n(1) gets tricky if you want to monitor when connections actually complete, because they\u2019re marked as Connected/Ready too early. This is a bad application contract, especially when there\u2019s racing involved. \r\n\r\n(2) is not great since it requires an entirely new way of specifying data that isn\u2019t Send(). \r\n\r\nNeither (1) nor (2) clearly support sending multiple chunks of idempotent data into the stack as fast open data. \r\n\r\nThus, we chose (3). \r\n\r\nHowever, Preconnection has certainly messed this up a bit. My suggestion is to no longer take Preconnection as an argument to Initiate(), but instead use a NewConnection(Preconnection) -> Initiate() pattern, which you can insert Sends in between. There are many other reasons to do this as well\u2014if I want to set my callbacks for events for this connection, etc, in languages like C that\u2019s a lot easier if I can call create() and then set my event handlers, and then start once those are set. \r\n\r\nNote: I already removed the text in the architecture that referred to Preconnection being passed to calls like Initiate and Listen, since that was API, not architecture, and since I didn\u2019t quite agree :) \r\n",
          "createdAt": "2018-02-27T14:36:53Z",
          "updatedAt": "2018-02-27T14:36:53Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So you create a `Connection` from a `Preconnection`, then call `Initiate()` on the `Connection`? That would work, provided we're clear when the parameters of that connection lock in (when it's created or when it's initiated)",
          "createdAt": "2018-02-27T15:44:13Z",
          "updatedAt": "2018-02-27T15:44:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the parameters from the Preconnection are immutable once the Connection is created.",
          "createdAt": "2018-02-27T15:53:23Z",
          "updatedAt": "2018-02-27T15:53:23Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, makes sense. I'll put a pull request together to address this (although it'll most likely be tomorrow now)",
          "createdAt": "2018-02-27T17:01:59Z",
          "updatedAt": "2018-02-27T17:01:59Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I created a branch to implement the change to create a `Connection` from a `Preconnection`, then call `Initiate()` on the `Connection`, rather than `Preconnection.Initiate() -> Connection`. However, I'm increasingly unconvinced this is the right approach. The `Preconnection.Initiate()` approach:\r\n\r\n- Gives a much clearer split between the phases\r\n- Makes it clearer what parameters affect connection establishment and which affect ongoing connections (i.e., we don't have to specify the effect of setting connection properties on a connection that has been created but not established)\r\n- Makes it clearer how `Rendezvous()` works, in particular around resolving candidates\r\n- Prevents the `NewConnection()`, `send()`, `Listen()` error case, since you can't call `Send()` on a `Preconnection`\r\n- And, in strongly typed implementations, can prevent errors due to trying to call `Initiate()`, `Listen()`, or `Rendezvous()` more than once on a `Connection`, forgetting to call them, or calling `Send()`/`Receive()` on an unestablished connection \u2013 having taught introductory networking recently, these are all common bugs, and can be made compile time errors if we get the `Preconnection`/`Connection` split right.\r\n\r\nSo, please review the branch, but I don't think we should merge it. Rather, I think the right way to handle idempotent data is to add an optional idempotent `Message` to `Initiate()` and `Rendezvous()`. Event handlers seem like something that should be specified on initiate, etc., too.\r\n\r\n",
          "createdAt": "2018-02-28T20:31:52Z",
          "updatedAt": "2018-02-28T20:31:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins That's not exactly how I imagined the flow being allowed\u2014I don't think we should allow Connection to turn into a Listen or Rendezvous, etc. A listener vends Connections, for example, and isn't a Listen itself.\r\n\r\nI was thinking that with the current terminology, Preconnection could Create an outbound connection, which could be initiated later. The interaction with listen taking a preconnection would be the same as it is today.\r\n\r\nPerhaps instead we can just change the terms here, and add an equivalent of a \"start\"/\"resume\" for the objects. Thus, we would have:\r\n\r\nPreconnection.Initiate() -> Connection (not started)\r\nConnection.SetEventHandler(...)\r\nConnection.Send(Message)\r\nConnection.Start()\r\n\r\nAnd for listening,\r\n\r\nPreconnection.Listen() -> Listener (not started)\r\nListener.SetNewConnectionHandler(...)\r\nListener.Start()\r\n\r\nThis is pretty much how our implementation works today.",
          "createdAt": "2018-02-28T20:49:31Z",
          "updatedAt": "2018-02-28T20:49:31Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins I really don't like the model of adding many optional parameters to Initiate to handle the various callbacks or extra data that might need to be sent\u2014this list will continually grow and shrink, and most languages don't cleanly support having a single symbol/function/method support an extensible list of parameters. These items also don't belong on the preconnection, since I should be able to have the same Preconnection across many connections to make them look similar, without requiring the same part of the app to handle their events, and to have the same initial data.",
          "createdAt": "2018-02-28T20:52:23Z",
          "updatedAt": "2018-02-28T20:52:23Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly hm. from an API expressiveness standpoint, I'm not wild about this.\r\n\r\nMetacomment: I think we need to meet in person to converge on this. Can we stay with what we have (which gets a little twitchy with more than one Message on 0RTT), keep @csperkins' branch, and defer to post-London?",
          "createdAt": "2018-02-28T23:02:11Z",
          "updatedAt": "2018-02-28T23:02:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram Sure, I'm fine to defer to converge more. Specifically, what's the issue from the API expressiveness issue? Is it that you'd prefer to have a single call that takes all possible parameters and initial work to schedule? \r\n\r\nWe actually did start with that for our APIs in Objective-C, but moved to the delayed start model to better support languages like C, and to make it cleaner to be clear about which events you want to handle, and who handles them. It allows someone to create a Connection from a Preconnection with certain setup, and then hand it to another part of the app/framework to in turn use it and schedule the event handlers on it. If you require all of that to be fore-known (both the properties of the connection AND the runtime \"who gets this callback\" state), it's more limiting, since where the events get delivered is not really a fundamental property. This isn't an issue in languages that support an arbitrary number of event watchers without registering, etc, but that's not true across all languages.",
          "createdAt": "2018-02-28T23:09:33Z",
          "updatedAt": "2018-02-28T23:09:33Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I updated the branch, to sketch out how this might look. I don't think it's too bad now.",
          "createdAt": "2018-02-28T23:17:20Z",
          "updatedAt": "2018-02-28T23:17:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i should have said elegance instead of expressiveness; it's late. I really don't like the idea, aesthetically, that every connection has a two-phase startup `preconnection.Initiate().Start()`, more or less just to support the (uncommon) case where you want to send more than one idempotent message per RTT.\r\n\r\nIt seems to me we have two overarching design goals (at least, I do):\r\n\r\n- The common case (\"I don't care, just send my damn packets\") should be as easy or easier to deal with in the transport services API as it is in the sockets API.\r\n- Code written to the common case should benefit from advanced features in shiny new protocols (e.g. 0RTT) by default if possible.\r\n\r\n0RTT is a special snowflake here, because it actually changes the _order_ of operations at startup, and maybe we can't get away from leaking that complexity into the don't care case. But it'd be neat if we could find a way to make send-on-initiate work via a protocol (selection) property *anyway*.",
          "createdAt": "2018-02-28T23:19:17Z",
          "updatedAt": "2018-02-28T23:19:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins I opened this as #124 so we can comment on the details of the wording over there.",
          "createdAt": "2018-02-28T23:20:43Z",
          "updatedAt": "2018-02-28T23:20:43Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "discussion continues in #124, propose to defer after -00 and tag this post-London if no objections...",
          "createdAt": "2018-03-01T10:12:08Z",
          "updatedAt": "2018-03-01T10:12:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Expanding from my last thought on #124, here's what I think my current proposal for this is, designed to let application developers not really care all that much about 0RTT but still get benefits from it when available:\r\n\r\n- Setting a protocol selection property that prefers 0RTT-capable transports changes the semantics of `Initiate()` and `Send()`: an `Initiate()` will be delayed until either:\r\n   - an initial `Send()` call, in order to allow idempotent send on startup; or\r\n   - a (fairly aggressively short) timeout, selected such that if the `Send()` doesn't happen until after the timeout, then the sender is so overloaded or otherwise slow that it wouldn't realize any material speedup from cutting an RTT out of establishment.\r\n- This allows 0RTT for one message. An application that wants to bundle multiple Messages into a single 0RTT flight can set a new third state on the `Immediate` send parameter (or a new send parameter that is mutually exclusive with `Immediate`, doesn't matter). When `!Immediate` is set, a Message will be held until the *following* Message on send; during 0RTT this will mean (explicitly) that the Initiate should also be delayed until the end of the `!Immediate` run.\r\n- All this behavior can be overridden with an `InitiateNow()` call, or with an `Immediate` parameter on `Initiate()` (which would default to false).\r\n\r\nI can write this up in more detail in an alternate PR (after submitting -00) if y'all don't think it's insane.",
          "createdAt": "2018-03-01T13:07:33Z",
          "updatedAt": "2018-03-01T13:07:33Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That could work for `Initiate()`, although I'm not sure I like the invisible change in semantics, but I don't think it works for `Rendezvous()`. The approach in #124 has the advantage of having very similar APIs for zero-RTT data for both `Initiate()` and `Rendezvous()`.",
          "createdAt": "2018-03-01T13:21:07Z",
          "updatedAt": "2018-03-01T13:21:07Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you walk me through why it doesn't work for `Rendezvous()`? (Are you somehow callable at the moment?)",
          "createdAt": "2018-03-01T13:22:48Z",
          "updatedAt": "2018-03-01T13:22:48Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think it works for `Rendezvous()` because there's no `Connection` to call `Send()` on until the rendezvous has completed, and by then it's too late for zero-RTT. \r\n\r\n(At home due to a snow day, but Skype me if a call is useful)",
          "createdAt": "2018-03-01T13:27:01Z",
          "updatedAt": "2018-03-01T13:27:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(for posterity, I'm going to go off and think about how my suggestion above might work in a non ugly way with Rendezvous, and if I get time before London, write that up in *another* PR targeted to land in this branch)",
          "createdAt": "2018-03-01T20:38:37Z",
          "updatedAt": "2018-03-01T20:38:52Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For in-person discussion in Montreal; we should turn the suggestions in this issue and in #124 into a message to the list.",
          "createdAt": "2018-05-16T15:58:09Z",
          "updatedAt": "2018-05-16T15:58:09Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins and @britram go into the thunderdome first week of June.",
          "createdAt": "2018-05-16T16:00:11Z",
          "updatedAt": "2018-05-16T16:00:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this was closed by #214, bikeshedding is now in #224 ",
          "createdAt": "2018-10-07T10:31:17Z",
          "updatedAt": "2018-10-07T10:31:17Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUzMDA2MDcxNzk=",
      "title": "API 7: maximum message size",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/113",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins",
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "Section 7 of the API says: \"Messages may be arbitrarily large; however, there may be system and Protocol Stack dependent limits on the size of a data object which can be transmitted atomically\". Some protocols have a limit on the maximum message size, not just the maximum size that can be can transmitted atomically. The draft should mention that.",
      "createdAt": "2018-02-27T12:16:20Z",
      "updatedAt": "2018-03-01T12:56:10Z",
      "closedAt": "2018-03-01T12:56:10Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's the readable property \"Maximum non-partial Message size on send\" in section 9.1. Maybe the text here should refer to this section...",
          "createdAt": "2018-02-27T13:08:26Z",
          "updatedAt": "2018-02-27T13:08:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I read \"Maximum non-partial Message size on send\" as the message could be larger than that, but would then have to be delivered in pieces. Some protocols have an absolute maximum message size.",
          "createdAt": "2018-02-27T15:35:12Z",
          "updatedAt": "2018-02-27T15:35:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the \"partial\" bit makes it a bit confusing (I'm not a fan of that either - in minset it was phrased as \"The maximum transport message size that can be sent, in bytes\"); however, we also have another readable property that's quite explicitly about fragmentation in \u00a79.1:\r\n\r\n\"Maximum Message size before fragmentation or segmentation: This numeric property, if applicable, represents the maximum Message size that can be sent without incurring network-layer fragmentation and/or transport layer segmentation at the sender. This property is read-only.\"\r\n\r\nso in context, I think it's clear enough?",
          "createdAt": "2018-02-27T15:59:50Z",
          "updatedAt": "2018-02-27T15:59:50Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins is there an action for -00 here?",
          "createdAt": "2018-03-01T10:17:59Z",
          "updatedAt": "2018-03-01T10:17:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's just drop the \"non-partial\" bit. I think it only adds confusion. I did a search for \"non-partial\" in the text; there are 6 matches. I think all of these 6 instances could safely be removed and would only make things clearer.",
          "createdAt": "2018-03-01T10:41:17Z",
          "updatedAt": "2018-03-01T10:41:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM (for -00; I think we should do a more rigorous review of the terminology and operation of partial/full Messages post-London). Can you make this change in your editorial pass PR?",
          "createdAt": "2018-03-01T11:33:56Z",
          "updatedAt": "2018-03-01T11:33:56Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I was hoping to get to it today, yes.",
          "createdAt": "2018-03-01T11:37:59Z",
          "updatedAt": "2018-03-01T11:37:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just did it, but not in the PR: I finished the PR, then saw this, then decided to update the master instead (this is not a very disruptive change for sure), and THEN remembered that PRs can simply be updated... oh well. Anyway, fixed!",
          "createdAt": "2018-03-01T11:40:29Z",
          "updatedAt": "2018-03-01T11:40:29Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clearly, git is for less childish people than me... after seeing that I close an issue and someone re-opens it, I'm waaaaay to tempted to close it again just for the heck of it!  :-D",
          "createdAt": "2018-03-01T11:45:49Z",
          "updatedAt": "2018-03-01T11:45:49Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "wait, what just happened here?",
          "createdAt": "2018-03-01T11:45:51Z",
          "updatedAt": "2018-03-01T11:45:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, seriously: I don't know why @csperkins re-opened: I think he thought you're talking to him, but I believe you talked to me?  I did the update and I do think the case is closed; I think the right thing to do is for @csperkins to leave the issue open if he's not happy with only removing \"non-partial\" and wants this to be even clearer.",
          "createdAt": "2018-03-01T11:47:32Z",
          "updatedAt": "2018-03-01T11:47:32Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I've also been leaving issues open until the PRs fixing them land, since issues should reflect the state of master. But yeah, I think we're just confused.)",
          "createdAt": "2018-03-01T11:49:07Z",
          "updatedAt": "2018-03-01T11:49:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I reopened because I don't think this is addressed yet. PR incoming.",
          "createdAt": "2018-03-01T11:54:56Z",
          "updatedAt": "2018-03-01T11:54:56Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWUzMDA2MTA3MjY=",
      "title": "Cut appendix B",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/114",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "Appendix B of the API draft provides a sample concrete definition of the API, written in Go. Having concrete examples of the API is clearly useful, but I question whether this draft is the right place for them, since we don't want to bless a particular API variant. Suggest this appendix be moved to either the implementation draft, or a separate example API implementation draft.",
      "createdAt": "2018-02-27T12:28:41Z",
      "updatedAt": "2018-02-27T16:06:00Z",
      "closedAt": "2018-02-27T16:06:00Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intention here is to show that the API is reasonably expressible and expressive in at least one modern language. I'd be more than happy to replace it with links to the code and documentation for now though. (Eventually, *examples* would be more useful than the sketch though.)",
          "createdAt": "2018-02-27T14:25:26Z",
          "updatedAt": "2018-02-27T14:25:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram makes sense.",
          "createdAt": "2018-02-27T15:40:31Z",
          "updatedAt": "2018-02-27T15:40:31Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWUzMDA5NjIzMjY=",
      "title": "add maxLength to Receive() in \u00a78",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/120",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "as suggested in the discussion on #107 ",
      "createdAt": "2018-02-28T10:05:00Z",
      "updatedAt": "2018-02-28T10:32:38Z",
      "closedAt": "2018-02-28T10:32:38Z",
      "comments": []
    },
    {
      "number": 127,
      "id": "MDU6SXNzdWUzMDEzOTc0MTM=",
      "title": "Impl: generalise \u00a74 to incorporate \u00a710",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/127",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "discuss"
      ],
      "body": "The rendezvous and discovery steps described in Section 10 for peer-to-peer connection establishment are a generalisation of those in Section 4. Need to discuss in London how we can combine these as a single algorithm that works for both cases.",
      "createdAt": "2018-03-01T13:05:54Z",
      "updatedAt": "2019-03-25T11:56:42Z",
      "closedAt": "2019-03-25T11:56:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as OBE",
          "createdAt": "2019-03-25T11:56:42Z",
          "updatedAt": "2019-03-25T11:56:42Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWUzMDE1MDk3NDI=",
      "title": "Submit Implementation -00",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/129",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Issue to track submitting -00 draft of implementation. We need to:\r\n\r\n- Sweep the remaining issues for sections that need more text\r\n- Nits\r\n- Editorial review for flow, etc.",
      "createdAt": "2018-03-01T18:25:12Z",
      "updatedAt": "2019-03-05T21:58:44Z",
      "closedAt": "2018-03-05T18:28:49Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would it be possible to still merge the intents-implementation branch #122 for -00, please? \r\nWe moved the Intents to the Appendix as requested and we think we addressed all the blocking comments. However, I have to admit that the web interface for that Pull Request is a bit confusing for me, so I may have missed something...",
          "createdAt": "2018-03-01T18:44:53Z",
          "updatedAt": "2018-03-01T18:44:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, sure we can definitely merge that first! I'll get to reviewing that today, and will merge/edit as needed.",
          "createdAt": "2018-03-01T19:02:02Z",
          "updatedAt": "2018-03-01T19:02:02Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged, and finished writing remaining issues. We now need to the passes for nits and editorial review.",
          "createdAt": "2018-03-02T02:33:54Z",
          "updatedAt": "2018-03-02T02:33:54Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks @tfpauly for filling the remaining issues! I will go through the whole document tomorrow and polish nits and anything else I find. (Just back from project meeting last night and fully booked today unfortunately.)",
          "createdAt": "2018-03-02T13:42:22Z",
          "updatedAt": "2018-03-02T13:42:22Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Did not make it through the whole document tonight, will continue tomorrow.",
          "createdAt": "2018-03-04T00:48:23Z",
          "updatedAt": "2018-03-04T00:48:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good. Anna, can you do the submission when ready?",
          "createdAt": "2018-03-04T02:15:45Z",
          "updatedAt": "2018-03-04T02:15:45Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I can do that. Do you also want to review it before I submit?",
          "createdAt": "2018-03-04T18:41:08Z",
          "updatedAt": "2018-03-04T18:41:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll edit if I see things that are particularly off, but I'm not going to have too much time before the deadline. Please feel free to take the editing from here!",
          "createdAt": "2018-03-04T20:45:11Z",
          "updatedAt": "2018-03-04T20:45:11Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok! I have now completed my editing pass. I think it is fine for -00. I will submit it tomorrow, in case anyone has last comments.",
          "createdAt": "2018-03-04T23:59:57Z",
          "updatedAt": "2018-03-04T23:59:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me! Ship it.",
          "createdAt": "2018-03-05T17:05:32Z",
          "updatedAt": "2018-03-05T17:05:32Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://datatracker.ietf.org/doc/draft-brunstrom-taps-impl/",
          "createdAt": "2018-03-05T18:28:49Z",
          "updatedAt": "2018-03-05T18:28:49Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWUzMDIwMzYxMzE=",
      "title": "Introduction: text refers to interface before it is introduced",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/130",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-03T22:02:17Z",
      "updatedAt": "2018-03-03T22:07:55Z",
      "closedAt": "2018-03-03T22:07:55Z",
      "comments": []
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWUzMDIwNDQ1NDI=",
      "title": "Pre-Establishment: text incomplete and parts of it not belonging in this section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/131",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-04T00:19:16Z",
      "updatedAt": "2018-03-04T00:21:19Z",
      "closedAt": "2018-03-04T00:21:19Z",
      "comments": []
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWUzMDIxMDk5Mjc=",
      "title": "Sections 4.5.1 and 9.4 not fully aligned.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/132",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-04T18:42:15Z",
      "updatedAt": "2018-03-04T23:24:57Z",
      "closedAt": "2018-03-04T23:24:57Z",
      "comments": []
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWUzMDIxMDk5ODY=",
      "title": "Section 4.6 not fully aligned with API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/133",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-04T18:43:01Z",
      "updatedAt": "2018-03-04T23:24:41Z",
      "closedAt": "2018-03-04T23:24:41Z",
      "comments": []
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWUzMDIxMzM4ODQ=",
      "title": "Section 6.2 out of sync with API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/134",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-04T23:26:08Z",
      "updatedAt": "2018-03-04T23:31:35Z",
      "closedAt": "2018-03-04T23:31:35Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text about notifying the application about path changes in Section 6.2 is out of synch with the API as there is no mechanism for this available. I have removed this text for now.",
          "createdAt": "2018-03-04T23:29:53Z",
          "updatedAt": "2018-03-04T23:29:53Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWUzMDIxMzQ3OTM=",
      "title": "Section 5.1.1.3 does not match API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/135",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2018-03-04T23:38:20Z",
      "updatedAt": "2018-03-04T23:46:42Z",
      "closedAt": "2018-03-04T23:46:42Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 5.1.1.3 on Batching Sends is out of synch with the API. It says that \"the application should have a way to indicate a batch of Send actions\", but we do currently not have support for this in the API. I am taking the section out for now to make things consistent. It can be added again later. ",
          "createdAt": "2018-03-04T23:42:08Z",
          "updatedAt": "2018-03-04T23:42:08Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWUzMDIxMzY1NDQ=",
      "title": "Re-add batching Send operations to API and Implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/136",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "In aligning the implementation with the API for the initial draft, we removed this text since we still need text in the API:\r\n\r\n#### Batching Sends\r\n\r\nSince sending a Message may involve a context switch between the application and the transport system, sending patterns that involve multiple small Messages can incur high overhead if each needs to be enqueued separately. To avoid this, the application should have a way to indicate a batch of Send actions, during which time the implementation will hold off on processing Messages until the batch is complete. This can also help context switches when enqueuing data in the interface driver if the operation can be batched.",
      "createdAt": "2018-03-05T00:01:28Z",
      "updatedAt": "2018-04-23T11:53:09Z",
      "closedAt": "2018-04-23T11:53:09Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This seems equivalent to the idea of PUSH in existing systems and would make sense for lots of short write calls.",
          "createdAt": "2018-03-11T08:29:39Z",
          "updatedAt": "2018-03-11T08:29:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1.\r\n\r\nThe higher-level question here is how to support high-performance applications. Send batching is one thing you can do here. Receive batching would be another obvious one. Zero-copy is another, though that's probably so tied to implementation and platform that it's not useful to standardize. But there should be some way for this interface to coexist with it...",
          "createdAt": "2018-03-20T10:56:17Z",
          "updatedAt": "2018-03-20T10:56:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me too",
          "createdAt": "2018-03-20T11:04:46Z",
          "updatedAt": "2018-03-20T11:04:46Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 \r\n\r\nIn my opinion, support for high-performance applications is nothing we can add to the API, but rather something we must sure to not prevent or make hard to implement.\r\nSo we should ask ourselves for every point in the API \"can this be implemented zero-copy\" or \"can an implementation batch this\" \u2013 if the answer is no, we have to fix that.",
          "createdAt": "2018-03-20T11:43:30Z",
          "updatedAt": "2018-03-20T11:43:30Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this one seems to have consensus and does not seem to be too much work. @tfpauly, if you can get a PR in in the next week or so let's ship it with ietf-00...",
          "createdAt": "2018-04-11T13:11:39Z",
          "updatedAt": "2018-04-11T13:11:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll try to get this in soon!",
          "createdAt": "2018-04-11T16:16:31Z",
          "updatedAt": "2018-04-11T16:16:31Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed with merge of #171 ",
          "createdAt": "2018-04-23T11:52:47Z",
          "updatedAt": "2018-04-23T11:52:47Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWUzMDQxMzk2NDE=",
      "title": "TAPS Architecture - second para of section 3",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/137",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "The sentence reads:\r\n   Beyond these, if the API\r\n   for the system remains the same over time, new protocols and features\r\n   may be added to the system's implementation without requiring\r\n   significant changes in applications for adoption.\r\nHowever, this kind of suggests that some small change is needed to apps. That's not necessarilly true, and I think the key point is the converse (i.e, 3.1 below). Can I suggest:\r\n   Beyond these, if the API\r\n   for the system remains the same over time, new protocols and features\r\n   may be added to the system's implementation without requiring\r\n   changes in applications for adoption. \r\n",
      "createdAt": "2018-03-11T08:20:17Z",
      "updatedAt": "2018-04-20T06:49:24Z",
      "closedAt": "2018-04-20T06:49:24Z",
      "comments": []
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWUzMDQxNDAwNzA=",
      "title": "Architecture: Security Considerations - Expand acconyms",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/138",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture",
        "admin stuff"
      ],
      "body": "The Sec Con section contains a large number of unexpanded abbreviations. Compared to the remainder of the document this requires much more knowledge of these terms, suggest we expand them here.",
      "createdAt": "2018-03-11T08:28:14Z",
      "updatedAt": "2018-04-20T06:49:24Z",
      "closedAt": "2018-04-20T06:49:24Z",
      "comments": []
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWUzMDQxNDA4NTI=",
      "title": "overstatement?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/139",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "The text says:\r\n   It\r\n   would not be an overstatement to say that this simple API is the\r\n   reason the Internet won the protocol wars of the 1980s.  \r\nI think this is just an opinion: claiming this is the ONE reason, is an overstatement. When I was on the \"other side\" of this as an X.25 developer, the API was not the reason. The killer pain was the \"congestion experienced\" clearing message that caused spiralling complexity in how to realise the equivalent of source quench. I'm not convinced this is the ONE reason - I'm content it is A key reason.",
      "createdAt": "2018-03-11T08:41:21Z",
      "updatedAt": "2018-04-11T12:37:10Z",
      "closedAt": "2018-04-11T12:37:10Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "agreed, will fix",
          "createdAt": "2018-03-20T10:07:40Z",
          "updatedAt": "2018-03-20T10:07:40Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWUzMDQxNzAzOTg=",
      "title": "NiTs in API document",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/140",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "If somone agrees with these please add, otherwise let's discuss:-).\r\n\r\n---\r\n- a hard to parse sentence\r\nOLD:\r\nsimilarly, as errors, just as any other Events,\r\nNEW:\r\nsimilarly. Errors, just as any other Events,\r\nor\r\n/similarly, because Errors, just as any other Events,/\r\n---\r\n- To me this seems like an odd style for a RFC.\r\nOLD:\r\n   We begin with the architectural design principles defined in\r\n   [TAPS-ARCH]; from these, we derive and elaborate a set of principles\r\n   on which the design of the interface is based.\r\nNEW\r\n   This section begins with the architectural \r\n    design principles defined in\r\n   [TAPS-ARCH]; these are used to derive the elaborate \r\n   a set of principles\r\n   on which the design of the interface is based.\r\n- Question is /elaborate/ the best word really? Is /complete/ or /detailed/\r\n  or /concrete/ more commonly understood?\r\n---\r\nSection does not contain an RFC2119 boilerplate para, yet the ID uses RFC2119 language later. (did we plan not to use RFC2119 keywords in section 5 - wand 5.3)\r\n---\r\nOLD:\r\ncan be cloned, in order to establish\r\nNEW:\r\ncan be cloned to establish\r\n- Rationale, because a reader COULD read this as implying ordering and the phrase /in order/ is not necessary to comprehend the sentence.\r\n---\r\nOLD:\r\n   developers should reduce inconsistency by only using the most\r\nNEW:\r\n   developers ought to reduce inconsistency by only using the most\r\n- I\u2019d prefer to avoid using /should/ at all here to remove any chance\r\nof misunderstanding as a requirement.\r\n---\r\nOLD:\r\n   The multiple identifiers\r\n   refer to the same endpoint.\r\nNEW:\r\n   The multiple identifiers\r\n   refer to the same transport endpoint.\r\n- actually this is a little confusing, since they are actually different network layer endpoints. I think we need to say transport explicitly.\r\n---\r\nTEXT:\r\n  Note that it is possible for a set\r\n- To me this should be a new para, it is a new thought.\r\n---\r\nOLD:\r\n   Implementations of this interface should also raise\r\n   errors in configuration as early as possible, to help ensure these\r\n   inconsistencies are caught early in the development process.\r\nNEW:\r\n   Implementations of this interface should also raise any\r\n   errors in configuration as early as possible, to help ensure these\r\n   inconsistencies are caught early in the development process.\r\n- add \u201cany\u201d, because the implementations aren\u2019t intended just to make errors.\r\n---\r\nOLD:\r\n   An implementation of this interface must provide sensible defaults\r\nNEW:\r\n   An implementation of this interface needs provide sensible defaults\r\n---\r\nOLD:\r\n      Reliable Data Transfer: This boolean property specifies whether\r\n      the application needs the transport protocol to ensure that data\r\n      that data is received completely and without corruption on the other side\r\nNEW:\r\n      Reliable Data Transfer: This boolean property specifies whether\r\n      the application wishes to use a transport protocol that provides\r\n      mechanisms to help ensure that all data is received and without \r\n      corruption on the other side\r\n- I\u2019ll argue that /needs/ is actually misleading and wrong. An Internet transport can not make such promises, and we shouldn\u2019t encourage it to think so - the app is responsible for the data. I\u2019d be even happier with better text that avoids saying the transport is solely responsible for correctness.",
      "createdAt": "2018-03-11T16:08:51Z",
      "updatedAt": "2018-04-11T12:37:10Z",
      "closedAt": "2018-04-11T12:37:10Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will also cite 2119 and 8174 on ambiguity of 2119 keywords. We'll need to do a pass on these keywords before final publication.",
          "createdAt": "2018-04-11T12:16:04Z",
          "updatedAt": "2018-04-11T12:16:04Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWUzMDQxNzA1NzE=",
      "title": "informing an app about ICMP",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/141",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "TEXT:\r\n      informed when an ICMP error message arrives.\r\n- I think this is OK. but is this intended to be for soft-errors, since hard-errors break the connection? I think I get this, although some transports obvioulsy \"eat\" the ICMP packets they receive, and many ICMP messages have no meaning to an app, but some can be important. Tell me more please...\r\n",
      "createdAt": "2018-03-11T16:10:59Z",
      "updatedAt": "2018-04-12T09:18:32Z",
      "closedAt": "2018-04-12T09:18:31Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this comes from minset - and so it\u2019s based on the rfc \u201csoft error\u201d text. true, no guarantee that you get it.\n\n\nSent from my iPhone\n\n> On 11 Mar 2018, at 17:11, Gorry Fairhurst <notifications@github.com> wrote:\n> \n> TEXT:\n> informed when an ICMP error message arrives.\n> \n> I think this is OK. but is this intended to be for soft-errors, since hard-errors break the connection? I think I get this, although some transports obvioulsy \"eat\" the ICMP packets they receive, and many ICMP messages have no meaning to an app, but some can be important. Tell me more please...\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-03-11T17:39:55Z",
          "updatedAt": "2018-03-11T17:39:55Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So, maybe the next rev of  text should just say this and it will be fine.",
          "createdAt": "2018-03-11T18:57:35Z",
          "updatedAt": "2018-03-11T18:57:35Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWUzMDQxNzA4NTk=",
      "title": "Clean up Capacity Profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/142",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "TEXT:\r\n      application's expectation of the dominating traffic pattern for...\r\n\r\n- I am calling this out in case I think different to others... and then I want to discuss, but it could also be that this was an oversight on which we alreday agree... either way there's a lot of comment here on just a few words.\r\n\r\n- I really do not like this. To me this is expressing QoS properties, and I think this is the wrong way to do this. I\u2019d be OK if the application instructs the network to use a particular treatment. When an endpoint requests a treatment, the network can either treat it in a default way, or give it the treatment it requests. If the application sends data incompatible with the treatment, then the performance observed may suffer - but that is exactly correct because that is how the application asked its data to be treated. I'd for example prefer:\r\n     application\u2019s expectation of the treatment the network should provide for...\r\n\r\nI am really against the application trying to label it\u2019s data as being of some type (which I think this part currently does). To me, a QoS framework on the other hand, sets certain parameters in the network and then \u201clabels\u201d the flows in some way to use them. That\u2019s a different approach, and one that demands more support from the network.\r\n- Similarly, I did not like:\r\n     The application is not interactive.  \r\n- I\u2019d prefer:\r\n     The application does not wish traffic to be treated as interactive.  \r\n  ... or something alike.\r\n",
      "createdAt": "2018-03-11T16:14:18Z",
      "updatedAt": "2018-10-16T10:51:32Z",
      "closedAt": "2018-10-16T10:51:32Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The application labeling what they are going to do and that traffic pattern they expect is one of the key ideas of the original Socket Intents work. It allows optimizing locally for the expected pattern in a way that is impossible without. \r\n - This kind of information is intended to be used for path, endpoint, and protocol selection logic.\r\n - This information may also be used to automatically derive defaults for protocol parameters.\r\n - This information is _not_ intended to be used for polarization or for QoS labeling.\r\n\r\nI guess we must include this as a clear warning to make sure it is not mixed up with QoS.\r\n\r\nFor your example: \"The application is not interactive.\" is easy for a developer.\r\nWhat it really states: \"The programmer opening this socket suggests that latency and bandwidth variations will most likely have no observable user impact\" \u2013 therefore the OS might, when combined with other hints like Resilience and Traffic Category, establish the connection over an unstable, but high bandwidth path.",
          "createdAt": "2018-03-20T11:37:26Z",
          "updatedAt": "2018-03-20T11:37:26Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One concrete proposal (around the table in London):\r\n\r\nReplace \"Capacity Profile\" and \"Instantaneous Capacity Profile\" with a three-state variable for traffic classification which can be used for DSCP marking and local AQM:\r\n\r\n1. Default\r\n2. Scavenger\r\n3. Low-latency\r\n\r\nThe principle is that the traffic classification must always be deterministically implementable on some path. This tends to map to the usable parts of DiffServ. See also https://tools.ietf.org/html/rfc7657",
          "createdAt": "2018-03-21T15:54:40Z",
          "updatedAt": "2018-03-21T15:59:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the choice, but let's not think about this in terms of DSCP marking. As I said at the meeting, DSCP marking can take more values that we may want to offer ( table 1 in https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18 ) - but these choices map onto other decisions for a whole connection, e.g. turning Nagle on/off, etc. etc. .... sure they CAN affect DSCPs values too, depending on what the system does. I think a reasonable implementation choice would be to let them affect DSCP values in addition to other things, but let a possible per-message DSCP choice overrule this 1-out-of-3 choice here.",
          "createdAt": "2018-03-21T18:21:15Z",
          "updatedAt": "2018-03-21T18:21:15Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Yes - I'm OK with each of these three (and also more if we choose carefully) - but I do agree that an App *CAN* also set a DCSP value that overrides the default. That's important.",
          "createdAt": "2018-03-21T18:29:36Z",
          "updatedAt": "2018-03-21T18:29:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer a mixture of @britram and @mwelzl suggestions.\r\n\r\n   0. Default \r\n   1. Low-latency data / Interactive data\r\n   2. Audio\r\n   3. Interactive Video with or without Audio\r\n   4. Non-Interactive Video with or without Audio\r\n   5. Scavenger\r\n\r\nWhich is really close to the proposal @tfpauly made.",
          "createdAt": "2018-03-21T19:02:53Z",
          "updatedAt": "2018-03-21T19:02:53Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "You've named these by application-type;-).\r\nSo what are the properties of the service being offered for 2,3,4?\r\n\r\nGorry",
          "createdAt": "2018-03-21T19:11:11Z",
          "updatedAt": "2018-03-21T19:11:11Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I will dig for some words to suggest for the treatments\n\nGorry\n\n> On 21 Mar 2018, at 19:02, Philipp S. Tiesel <notifications@github.com> wrote:\n> \n> I would prefer a mixture of @britram and @mwelzl suggestions.\n> \n> Default\n> Low-latency data / Interactive data\n> Audio\n> Interactive Video with or without Audio\n> Non-Interactive Video with or without Audio\n> Scavenger\n> Which is really close to the proposal @tfpauly made.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-03-21T20:10:23Z",
          "updatedAt": "2018-03-21T20:10:23Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "To try some words for the treatments (this maybe is not so easy):\r\n\r\n1.  Low-latency / Interactive data   (for example could be EF PHB, AC_VO)\r\n2. MM Streaming  (for example could be AF3n PHB, AC_VI)\r\n3. Low Latency Data   (for example could be AF2n PHB. AC_VI)\r\n4. High Throughput Data (for example could be AF2n PHB, AC_BE)\r\n5. Default (for example could be BE PHB, AC_BE)\r\n6. Scavenger (for example could be LE PHB, AC_BK)\r\n\r\nSuggestions only for AC's (they probably should not appear in a RFC), but probably should just point to RFC 8325.\r\n\r\nGorry",
          "createdAt": "2018-03-22T13:59:51Z",
          "updatedAt": "2018-03-22T13:59:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed when #233 merged",
          "createdAt": "2018-10-16T10:51:32Z",
          "updatedAt": "2018-10-16T10:51:32Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWUzMDcxNTQzOTA=",
      "title": "Section 5.2. Nits: Clarify how boolean properties and preferences belong together",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/144",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "When reading the Specifying Transport Parameters section, I got confused by \"boolean properties\" that are \"strict / non-strict requirements\" and when preferences apply.\r\n\r\nWe should fix this by making clear that these  \"boolean\" properties are be used with preferences.",
      "createdAt": "2018-03-21T08:30:00Z",
      "updatedAt": "2018-03-22T16:56:22Z",
      "closedAt": "2018-03-22T16:56:22Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will be fixed with Issue #153 - closing as duplicate right now",
          "createdAt": "2018-03-22T16:56:22Z",
          "updatedAt": "2018-03-22T16:56:22Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWUzMDcxOTI0Mjc=",
      "title": "Draft should point at implementations somewhere",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/145",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "I think it would be useful to somewhere (appendix?) include a sentence like: \"Many of the mechanisms described in this document are implemented by the open-source NEAT library, which is available from [NEAT github]\u00a0and described in [NEAT commag paper]\".\r\n\r\nAnd, if there could also be more such statements (from Apple about Apple's implementation, from socket intents about their implementation, ..) that would be fantastic, I think.\r\n",
      "createdAt": "2018-03-21T10:40:02Z",
      "updatedAt": "2019-11-22T01:28:01Z",
      "closedAt": "2019-11-22T01:28:01Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a clarification because @philsbln had this on his slides today: this one isn't really anything worth discussing, I meant it just as a \"to do item\" for myself. Sorry if that was bad github style...",
          "createdAt": "2019-07-22T19:18:32Z",
          "updatedAt": "2019-07-22T19:18:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made a start for this as a new appendix to the implementation draft, which I pushed directly to the master. Rather than discussing things in a PR, people should just fix / amend text related to their own implementation directly as they see fit and push these changes to master, I'd say.\r\n\r\nI'm leaving this issue open so it stays noticed - but I'd say: as soon as the @tfpauly is happy with the Network.Framework part, he should comment here; as soon as the TU Berlin team is happy with the PyTAPS part, they should comment here. As soon as we have both comments, this should be closed (unless there are more implementations to report about, of course!!!).",
          "createdAt": "2019-10-21T13:50:54Z",
          "updatedAt": "2019-10-30T11:27:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @mwelzl - I think the PyTAPS part is fine for now. I'll update it in case of significant changes.\r\nHowever, I'm wondering if \"above\" TCP, UDP, TLS is actually the right word - I would have used \"on top of\"? But perhaps that's a matter of taste.",
          "createdAt": "2019-10-30T15:00:23Z",
          "updatedAt": "2019-10-30T15:00:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fine for me either way!",
          "createdAt": "2019-10-30T15:03:59Z",
          "updatedAt": "2019-10-30T15:03:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added our implementation details with c54cd80",
          "createdAt": "2019-11-22T01:27:58Z",
          "updatedAt": "2019-11-22T01:27:58Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWUzMDcxOTg3OTc=",
      "title": "Send Properties: Per-send or per-message?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/146",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Should we specify in the API more clearly if properties around sending apply more to the Send() operation or the Message itself?\r\n\r\nIn my implementation, I'm treating things like \"Idempotent\" as per-send, since I could technically have a bit of a message at the beginning I want to do 0-RTT with, but the rest of the data may not be fully idempotent.\r\n\r\nHowever, ordering and reliability (and likely niceness) is a property of the entire Message, and so if I'm sending a Message in multiple Send()s, we want the same properties across all calls.",
      "createdAt": "2018-03-21T11:00:20Z",
      "updatedAt": "2018-07-04T09:19:00Z",
      "closedAt": "2018-07-04T09:19:00Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Message properties are: niceness, ordering/antecedents, etc, etc\r\nSend properties are: end-of-message, end-of-connection, etc.",
          "createdAt": "2018-03-21T16:03:35Z",
          "updatedAt": "2018-03-21T16:03:35Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That introduces a third kind of properties \u2013 do we want this kind of complexity?\r\n\r\nIn my opinion, we should only have Send Properties. Whether they can be applied to partial messages is transport-protocol and implementation specific. So if your TCP stream is a single message (no framers/de-framers), one can indeed only mark the first part as idempotent.\r\nThe consequence is that we need to think about when this will raise an error.",
          "createdAt": "2018-04-18T09:33:43Z",
          "updatedAt": "2018-04-18T09:33:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd say it should be per-message, not per-send, and I also agree that we should keep things simple. In particular, from Tommy, \r\n\r\n> \"Idempotent\" as per-send, since I could technically have a bit of a message at the beginning I want to do 0-RTT with, but the rest of the data may not be fully idempotent.\r\n\r\nsounds really messy to me!  Why not have two separate messages instead, an idempotent one and a non-idempotent one? What's the argument for dividing a message into two separate parts with different properties?",
          "createdAt": "2018-05-02T12:41:30Z",
          "updatedAt": "2018-05-02T12:41:30Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As long as we treat TCP streams as a large message, we need to support Send Properties on partial messages, e.g., for 0-RTT",
          "createdAt": "2018-05-15T15:10:40Z",
          "updatedAt": "2018-05-15T15:10:40Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i thought this tcp-stream=message idea was finally behind us??  that was agreed between tommy and me in london, at least\n\nSent from my iPhone\n\n> On 15 May 2018, at 17:10, Philipp S. Tiesel <notifications@github.com> wrote:\n> \n> As long as we treat TCP streams as a large message, we need to support Send Properties on partial messages, e.g., for 0-RTT\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-05-15T15:42:51Z",
          "updatedAt": "2018-05-15T15:42:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "for bookkeeping purposes: ISTM that #200 addresses this one, too.",
          "createdAt": "2018-06-25T08:53:11Z",
          "updatedAt": "2018-06-25T08:53:11Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As far as I am concerned, #200 and #201 seem to have fixed this issue.",
          "createdAt": "2018-07-04T09:03:45Z",
          "updatedAt": "2018-07-04T09:03:45Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #200 and #201",
          "createdAt": "2018-07-04T09:18:58Z",
          "updatedAt": "2018-07-04T09:18:58Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWUzMDcyODQyNDE=",
      "title": "Issues to consider (Handley)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/147",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Input from Mark Handley, distributed with permission:\r\n\r\n> Hi Aaron, Colin,\r\n> \r\n> As I mentioned, I'm playing with ideas for a new TCP-replacement transport protocol at the moment.  It doesn't really have a name right now, but lets call it NeoTCP.  Likely it won't go anywhere, but some of the ideas differ a bit from other transport protocols, so may serve as a useful test for the TAPS API.  \r\n> \r\n> 1.  Pre-authentication.  I want to put the ssh server on my home machine on the Internet without it being constantly attacked with password guessing attacks.  NeoTCP implements very simple pre-authentication, where my laptop and my home machine share a secret.  When connecting, the client sends the pair  (nonce, Hash(nonce, secret)).  The server won't send a syn/ack equivalent unless the secret match one of the secrets from its cache.    \r\n> \r\n> 2.  Source-spoofing protection.  NeoTCP supports the equivalent of SYN cookies, but with a 4-way handshake to avoid the potential deadlock associated with SYN cookies.  I'm also playing with the idea of allowing middleboxes to interpose a challenge in response to the SYN, and when the challenge response arrives from the client, only then is the packet passed through to the actual server, and the handshake continues.  I'm not clear yet if including middleboxes in some way impacts the API.\r\n> \r\n> 3.  Encryption.  Goal is to do tcpcrypt-like encryption, but provide hooks to higher layers so they can do whatever full authentication that particular application needs.\r\n> \r\n> 4.  Redirect.  Redirecting connections is a very common application-layer function, but really you would prefer to redirect before you've set up a connection.  Such redirection obviously needs some form of authentication (maybe this contradicts 3 - not clear where I'm going on this yet).   What would the API be for a redirect server? It's not a full server;  it listens, but simply sends stateless syn/ack redirects, rather than accept connections.   \r\n> \r\n> 5. Acking.  NeoTCP supports multi-path using two sequence spaces - subflow packet sequence numbers and data sequence numbers like MPTCP.  Unlike MPTCP, the data sequence number ack indicates the receiving application received the packet (with MPTCP, it only indicates reception by the receiving stack.\r\n> \r\n> 6. Pulling.  NeoTCP takes some lessons from NDP, and is a receiver-driven protocol.  When several senders are sending to one receiver, this allows the receiver to choose precisely which senders to pull packets from at any time.  This generalizes the QUIC/HTTP2 priorities to now support multiple different senders.  You can use this to do aggregate congestion control for incoming traffic, avoiding self-congestion.  It's up to the receiving application to determine priorities, and to the transport to decide how to use those priorities.\r\n> \r\n> 7.  Close is a total mess with TCP.  It's even worse with a user-space protocol - your application may quit when close returns; data may not have been received yet and needs retransmitting, but there's no-one left to do it.   By default, with NDP close won't return until the receiving application has received sent data.   Obviously you need some way to avoid deadlock when the receiver died; that timeout is application specific.\r\n> \r\n> 8. Finally, we've done a lot of work over the last couple of years on understanding MPTCP for web traffic.  It's ugly. You have a whole load of short objects, and the application has a priority order for them.  But the paths may have very different latency.  If you send any packet from the highest priority object on the high latency path, you can delay the object significantly, and it can really hurt the overall page load time, as other requests get stalled waiting for that object.  The best you can do is to run a per-packet scheduler, and ask the question \"if I send the next packet from this object on the higher latency path, will it arrive after the rest of the object sent on the lower latency path?\" If the answer is yes, you shouldn't send that packet on the higher latency path.  Next you have to consider the second highest priority object, and ask if you should instead send a packet from that object on the higher latency path.  You should, if will arrive before both the highest priority object and all the rest of the second highest priority object. If not, you shouldn't, and you should consider the third highest priority object, and so on.  Obviously, this is complicated.  At the very least, the transport protocol needs to know which packets are from which object, and what those object priorities are.  At the receiver, objects may arrive out of order, but packets within an object must be in-order.\r\n> \r\n> There are probably more things, but that's what comes to mind right now.\r\n> \r\n> Mark",
      "createdAt": "2018-03-21T15:05:25Z",
      "updatedAt": "2019-03-25T12:03:14Z",
      "closedAt": "2019-03-25T12:03:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "FWIW, I reached out to Mark to inquire about items 1-4, but did not hear back. @csperkins would you be willing and able to follow up?",
          "createdAt": "2018-05-16T14:19:09Z",
          "updatedAt": "2018-05-16T14:19:09Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood to split this into multiple issues",
          "createdAt": "2018-05-16T16:03:54Z",
          "updatedAt": "2018-05-16T16:03:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few comments:\r\n\r\n5. is probably irrelevant for the API.\r\n\r\n6. is interesting, and I think that this is already possible via our concept of grouping and prioritization between grouped connections. I'm quite sure I would have spoken up otherwise - I was careful about it myself because I also believe in congestion control coupling for flows from different sources, see:\r\nhttp://heim.ifi.uio.no/~michawe/research/publications/ctrltcp-infocom-gi-2018.pdf\r\n\r\n7. be that as it may, we are anyway limited to quite restrictive semantics as they must be the smallest common denominator of underlying transports that become \"connections\", including streams of a transport association. So I think this item is also irrelevant.\r\n\r\n(Most of?) the others are bigger discussions...\r\n",
          "createdAt": "2019-01-08T13:07:52Z",
          "updatedAt": "2019-01-08T13:07:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "My thoughts would be to close this. It's useful to have looked through these, but I am not convinced we should pursue these in TAPS.\r\n\r\nGorry",
          "createdAt": "2019-01-08T13:25:35Z",
          "updatedAt": "2019-01-08T13:25:35Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For most of the stuff (except 8) I have a rough idea how to extend TAPS to support these without changing any calls/semantics.\r\nI don't think we need to actually address these in the draft, but we should collect these questions and exercise the \"could this be added\" task again before submitting the final version.",
          "createdAt": "2019-01-09T20:01:51Z",
          "updatedAt": "2019-01-09T20:01:51Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some thoughts on these:\r\n\r\n1. This looks like extra parameters we'd pass to a `Preconnection`\r\n2. This looks like it can be handled internally to the transport during connection setup\r\n3. This requires an authentication callback into the application during connection setup, but probably so do many security protocols since identity is often tied to application semantics. We need to support the concept.\r\n4. Excepting possible authentication callbacks, this looks to be something that can be hidden within the connection setup operation.\r\n5. Affects when ACKs are delivered by the protocol, but not clear an API issue? Or if it is, it's additional metadata attached to a receiver callback.\r\n6. We need to ensure we can specify priorities on connections at the receiver. Not sure our preferences are flexible enough to signal?\r\n7. Doesn't seem to affect the API, except for perhaps the timing of the Closed callback.\r\n8. Requires an API that allows prioritisation of data on different sub-flows, which we have. Given that, if you have a multipath transport you can be as smart or as dumb as you like the in scheduler, but it's not visible in the API.\r\n\r\nI think we should review this again later, but it looks like we're probably flexible enough in the API we have to support all of these, with at most some quite minor additions.",
          "createdAt": "2019-01-15T15:50:51Z",
          "updatedAt": "2019-01-15T15:50:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Side meeting: after discussion, we believe the architecture covers these with enough flexibility for future expansion.",
          "createdAt": "2019-03-25T12:03:13Z",
          "updatedAt": "2019-03-25T12:03:13Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "MDU6SXNzdWUzMDcyODkzMzM=",
      "title": "API: Add text for sending partial messages",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/148",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Send needs to take:\r\n- Data \r\n- Which message (message object contains message properties)\r\n- Flags: end-of-message, end-of-connection-send",
      "createdAt": "2018-03-21T15:16:57Z",
      "updatedAt": "2018-06-27T14:33:24Z",
      "closedAt": "2018-06-27T14:33:24Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is data separate to the message?",
          "createdAt": "2018-03-21T15:30:50Z",
          "updatedAt": "2018-03-21T15:30:50Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly: would you like to take a swing at this one? (or alternately, can we call it an ietf-01 thing?)",
          "createdAt": "2018-04-11T13:24:47Z",
          "updatedAt": "2018-04-11T13:25:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Timing out. ietf-01 it is.",
          "createdAt": "2018-04-30T10:14:54Z",
          "updatedAt": "2018-04-30T10:14:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the expected receive behavior - can an application also receive partial messages?\r\n\r\nI'm asking because SCTP has this ability, and then needed to include means to inform the receiver that message delivery has been aborted (when not transmitting reliably and a message fragment is missing)\r\n\r\n=> this is a path of complexity that I think we shouldn't take, just for the sake of allowing large messages to be transferred as such. The alternative is to force them to be small...",
          "createdAt": "2018-05-16T16:44:54Z",
          "updatedAt": "2018-05-16T16:44:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, receiving needs to also support partial messages. That's really quite essential. If you don't allow this, you limit the size of all messages.\r\n\r\nI'll send out a PR\u2014it's not too complicated, and both sending and receiving should be equivalent!",
          "createdAt": "2018-05-16T17:59:22Z",
          "updatedAt": "2018-05-16T17:59:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought so (about receiving). So how do you handle a missing partial message? Do you assume that the app can always be told?  I\u2019m trying to remember, but there was a problem with this...\n\nSent from my iPhone\n\n> On 16 May 2018, at 19:59, Tommy Pauly <notifications@github.com> wrote:\n> \n> Yes, receiving needs to also support partial messages. That's really quite essential. If you don't allow this, you limit the size of all messages.\n> \n> I'll send out a PR\u2014it's not too complicated, and both sending and receiving should be equivalent!\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-05-16T18:08:54Z",
          "updatedAt": "2018-05-16T18:08:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another problem with this: receiver-side HOL blocking between streams. One stream gets a very long message, all the others get blocked. If you allow very large messages, SCTP needs to use NDATA to deal with this (which internally divides the messages). I think that's absolutely fair to expect, as this is really the right way to handle this. How does QUIC handle very large messages? Does it divide them, or will it get HOL blocking delay?\r\n\r\nIf all protocols that we'll use divide large messages into smaller chunks for prioritization and avoiding HOL delay between streams, than maybe this is a non-problem. Else - I'm just saying, a simple way around all of this is to put a small upper bound on the size of a message that we support. Or we document the risk...",
          "createdAt": "2018-05-16T18:59:11Z",
          "updatedAt": "2018-05-16T18:59:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I'm not sure what the concern is for a missing partial message. When you receive, you get two pieces of information: the newly received data, and the associated Message object. If you could only receive part of the message (it's not complete), you will be able to check that this isn't the entire Message, and you'll be able to call receive on the connection again to get more data, which may be for the same Message. If there's an error before being able to receive the entire message, you'll get an error in the receive call letting you know that message was incomplete.\r\n\r\nYou don't need HOL blocking if each receive callback tells you which message the data is associated with.",
          "createdAt": "2018-05-16T20:01:23Z",
          "updatedAt": "2018-05-16T20:01:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, about HOL blocking:\r\n\r\nI'll conclude: this is okay; it assumes that the transport below does the right thing, but I think that makes sense to assume.\r\n\r\nJust to explain what I mean: with SCTP, and without NDATA (interleaving - a pretty new feature, RFC 8260), receive calls would *always* only give you data from the same message until you finally have it complete. That produces HOL blocking, and I believe it was done to simplify the app's life on the receiver side.\r\n\r\nBut I think SCTP-before-NDATA isn't good behavior, and I believe QUIC would do the right thing too, so I think what you propose is fine.",
          "createdAt": "2018-05-17T06:31:11Z",
          "updatedAt": "2018-05-17T06:31:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Second, about a missing partial message:\r\n\r\n> If you could only receive part of the message (it's not complete), you will be able to check that this isn't the entire Message, and you'll be able to call receive on the connection again to get more data, which may be for the same Message.\r\n\r\nSo let's assume that we have an unreliable transport below, to which we hand partial messages, and some of them never make it. The receiver only gets parts 1 and 3, but part 2 will never arrive. Is this a case that we want to consider? We'd have to document that the receiver's deframer must be able to correctly detect such cases.\r\n\r\nOr do you assume that the underlying transport would always ensure that all parts of a message arrive, or else tell the receiver-side transport system about it? Then we'll at least need a signal to the application to forward that information, to tell it that a message is incomplete.",
          "createdAt": "2018-05-17T06:38:21Z",
          "updatedAt": "2018-05-17T06:38:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #200 ",
          "createdAt": "2018-06-27T14:33:24Z",
          "updatedAt": "2018-06-27T14:33:24Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWUzMDcyOTU4MjU=",
      "title": "Handling conflicts among path/protocol selection properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/149",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri",
        "tfpauly"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "See thread at https://mailarchive.ietf.org/arch/msg/taps/i8Ax-WqOoOg4obYU8MgBzb0F3oc\r\n\r\nSuggested resolution: implementation must have a deterministic tiebreaker, current recommendation is that path properties take precedence. API should note expected behavior. There should be additional text on candidate selection and ordering.",
      "createdAt": "2018-03-21T15:31:54Z",
      "updatedAt": "2018-04-20T13:45:37Z",
      "closedAt": "2018-04-20T13:45:37Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Give example for path candidate gathering and sorting (get selection properties, get available paths in system preferred order, walk through them cancelling out the prohibited ones, and ranking preferences; get ultimate list). Do the same for protocols likely.",
          "createdAt": "2018-03-21T15:35:53Z",
          "updatedAt": "2018-03-21T15:35:53Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added text to API and Implementation drafts on branch \"conflicting-policies\".\r\nAPI has an example, implementation still needs one. Feel free to add, otherwise I'll come back to it later today or tomorrow.",
          "createdAt": "2018-04-17T07:28:16Z",
          "updatedAt": "2018-04-17T07:28:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess that works for -00\r\n\r\nFor -01, we might want to integrate the resolution a little bit more into the decision process. ",
          "createdAt": "2018-04-18T09:14:05Z",
          "updatedAt": "2018-04-18T09:14:05Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved by PR #167",
          "createdAt": "2018-04-20T13:45:37Z",
          "updatedAt": "2018-04-20T13:45:37Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWUzMDczMDI3ODA=",
      "title": "Add Unidirectional Streams for Multicast / Source and Sink support ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/150",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "We need unidirectional connections. You know, for multicast. And ICN. And unidirectional streaming protocols.",
      "createdAt": "2018-03-21T15:47:13Z",
      "updatedAt": "2019-11-22T02:02:07Z",
      "closedAt": "2019-11-22T02:01:57Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a dup of #170, which has more discussion",
          "createdAt": "2018-05-16T16:03:02Z",
          "updatedAt": "2018-05-16T16:03:02Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am re-opening this ticket as #170 only dealt with unidirectional streams in unicast context (added with PR #191):\r\n\r\nCurrent status:\r\n - The current model for unidirectional streams supports half-closed connections and QUIC style unidirectional streams so far.\r\n - We don't know yet whether it is sufficient to have can_read/can_write property on the connection level to model unidirectional connections\r\n - We don't have pre-connection methods to create multicast sessions yet\r\n",
          "createdAt": "2018-06-06T11:07:21Z",
          "updatedAt": "2018-06-06T11:07:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "there's a selection property for this, tagged discuss, which we haven't discussed yet. I'm moving this down to the appendix as part of my restructuring in my work on #208 ",
          "createdAt": "2018-10-16T09:54:01Z",
          "updatedAt": "2018-10-16T09:54:01Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If help is still wanted here, I'm maybe up for an attempt or 2 at adding multicast support.\r\nHas there been some prior discussion I can review about rough ideas on pre-connection methods for multicast sessions, or should I just try making something up?",
          "createdAt": "2019-02-21T23:29:30Z",
          "updatedAt": "2019-02-21T23:29:30Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #380",
          "createdAt": "2019-11-22T02:01:57Z",
          "updatedAt": "2019-11-22T02:02:07Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWUzMDczMTIxOTQ=",
      "title": "Add Delivered event?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/151",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "From a comment at IETF101:\r\n\r\nThe `Sent<>` event fires when a message has been sent (i.e., passed down to the underlying protocol stack, or passed through that stack to the kernel.) For stacks that can support it, `Delivered<>` should fire when the traffic has been positively acknowledged by the other side.\r\n\r\nWhether acknowledgements can be signaled should also be a protocol selection property.",
      "createdAt": "2018-03-21T16:07:33Z",
      "updatedAt": "2018-10-07T10:42:43Z",
      "closedAt": "2018-10-07T10:42:43Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I note that this also relates to item 5 in #147, which is about delivering not only to the stack, but to the app.\r\n\r\nCan someone explain to me what the point of this is? Both for the one here, and the one in #147?\r\nWhat confuses me is: once a protocol would ACK something, it would have it inside its own send buffer, and that takes it out of the control of the application - so what's an application supposed to do with this information?  (and is it maybe only the information in #147 that is really useful?)",
          "createdAt": "2018-05-16T16:32:16Z",
          "updatedAt": "2018-05-16T16:32:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I asked a similar question on London and got at least three people shouting \"no - don't do that\" at me\u2026 with different arguments.\r\nIn my opinion, delivery events are definitely not in a minimal functionality set, but useful if available.\r\n\r\nIf we want to be forward-compatible to such transports, we should define multiple events:\r\n - Sent (handed over to transport system)\r\n - Acknowledged (received by the remote transport system)\r\n - Delivered (handed over to the remote application)\r\n\r\nI guess the real discussion is how much research/forward compatibility to add to the API.\r\nMy current feeling is that the authors try to minimize functionality, while external feedback is to add features that can be implemented using today's protocols (like the Acknowledged message and some transport automation features) or which might come soon as experimental protocols.\r\nMaybe we really need three sets of functionality:\r\n 1. Minimal (every TAPS system must implement)\r\n 2. Standard (usable today, every TAPS system on a reasonably powerful platform should implement)\r\n 3. Experimental (experimental stuff / forward compatibility that might be implemented and that we don't want to break/accidentally prevent in the API design)\r\n\r\nFrom my perspective, Delivered is clearly in 3, Acknowledged is less useful, but could be in 2",
          "createdAt": "2018-05-18T11:54:01Z",
          "updatedAt": "2018-05-18T11:54:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to see a good argument for usefulness for everything we add. I think \"Sent\" is settled - this relates to controlling the send buffer and is clearly necessary for applications that want to have control over what they send as long as possible.\r\n\r\nFor \"Acknowledged\" and \"Delivered\", why are they useful at all? What are examples of what an application can do with this information?   Sorry, maybe I'm missing a big obvious piece here!",
          "createdAt": "2018-05-18T11:58:13Z",
          "updatedAt": "2018-05-18T11:58:13Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm still quite concerned about this primitive - it seems to create cases where someone coding could believe a message has been delivered to an App because the transport tells it something. That I think is bad. The App should use it's own protocol to decide the data has reached the remote. I could see corner cases where someone may wish to invent a new protocol that does remote buffer management, but really having seen several of these in the past - I'd need strong proof that this was a general need and had significant advantage - if it's buffer management, I'd prefer the sender to express the \"use case\" to the stack and the stack manage this, not some application-visible signal.",
          "createdAt": "2018-05-18T13:18:20Z",
          "updatedAt": "2018-05-18T13:18:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that a delivered event doesn't seem like a good idea. If nothing else, it can end up breaking a truly end-to-end model. How does the TAPS system know that the data really was delivered? To whom was it delivered? Even if the protocol has ack'ed data, how do we know that wasn't just a proxy that read the data? Etc, etc. At the end of the data, data being consumed by whoever the application thinks of as the remote endpoint is a matter that can only be decided by the application based on some higher level of signaling.",
          "createdAt": "2018-05-18T21:26:53Z",
          "updatedAt": "2018-05-18T21:26:53Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree to @gorryfair that we need to make clear that `sent` does really mean nothing but somehow handled by the local transport system.\r\n\r\nWhether to include `acknowledged` and `delivered` really depends on what we see as our goal: Is it to build a flexible API for what is available today or to design for the mid-term future. If the target is the latter, we should at least include `acknowledged`, as it is implementable on top of TCP and allows the application to estimate the bytes in flight for buffer- and rate limit.\r\n\r\nI fear that we will get a lot feedback stuff we could enable (like `acknowledged` and `delivered`) and should find a way to deal with it in a way that we can acknowledge this stuff and show that the TAPS API can be extended to incorporate these features if needed in the future. ",
          "createdAt": "2018-05-22T09:19:21Z",
          "updatedAt": "2018-05-22T09:19:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For buffer limiting, we have what we need already using the Sent callback. I can see the possibility of optimizing things based on an estimate of the packets in flight... but I'm sceptical about this being the right design - are you going to let applications do things that we'd better do inside the transport system?  E.g. if you're thinking of interface choice / load balancing decisions based on the packets in flight, isn't this something that the transport system should do, not the application?\r\n\r\nPlus, at least according to the spec, this is *not* implementable on top of TCP. There may be implementations that allow it but it's not spec'ed as a standard behavior.",
          "createdAt": "2018-05-22T10:42:14Z",
          "updatedAt": "2018-05-22T10:42:14Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing with apparent consensus not to do this.",
          "createdAt": "2018-10-07T10:42:43Z",
          "updatedAt": "2018-10-07T10:42:43Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWUzMDczMTMyMjU=",
      "title": "Synchronize security properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/152",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "API"
      ],
      "body": "Security properties should be synchronized with (the next rev of) https://tools.ietf.org/html/draft-pauly-taps-transport-security",
      "createdAt": "2018-03-21T16:10:02Z",
      "updatedAt": "2018-06-27T13:21:45Z",
      "closedAt": "2018-06-27T13:21:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Addressed by #197.",
          "createdAt": "2018-06-27T13:21:44Z",
          "updatedAt": "2018-06-27T13:21:44Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWUzMDczMTc4ODA=",
      "title": "Restructure Transport Parameters Section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/153",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri",
        "philsbln"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "We have Protocol Selection Properties and Path Selection Properties (\u00a75.2 of -00), General Protocol Properties and Specific Protocol Properties (\u00a79.1), Transport Features and Path Properties (mentioned in \u00a79), Security Properties (\u00a75.3), Message Properties (called Send Properties in \u00a77.1), unless I'm forgetting some. \r\n\r\n- We definitely need to **restructure** the API draft.\r\nI propose that these Properties all go in the same Section (former \u00a79, maybe move it up in the draft more).\r\n- Perhaps we may need to **rename** some of them, to reduce confusion, and make sure our descriptions are clear enough.\r\n- We need to make clear **when** which of these properties can be specified and when they become immutable.",
      "createdAt": "2018-03-21T16:20:02Z",
      "updatedAt": "2018-07-02T07:20:18Z",
      "closedAt": "2018-07-02T07:20:18Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also consider if Transport Parameters and Security Parameters are good names when we look over the terminology/structure.",
          "createdAt": "2018-03-21T17:05:16Z",
          "updatedAt": "2018-03-21T17:05:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In addition to the todos raised by @theri, we also need to fix and define data types taken by the properties.\r\n - Most of the `boolean` typed properties are actually preferences\r\n - Moving the somehow-displaced definition of preferences and making this a type definition should help\r\n\r\nGetting types/categories of parameters right might also be a first step to an IANA registry ",
          "createdAt": "2018-03-22T17:02:36Z",
          "updatedAt": "2018-03-22T17:02:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The front matter also has become tediously long as it defines a lot of things inclunding \r\n - data types (cross check with #173) \r\n - how preferences work\r\n - interaction between path- and protocol selections\r\n\r\nWe need to better separate it",
          "createdAt": "2018-04-20T14:00:45Z",
          "updatedAt": "2018-04-20T14:00:45Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rough agenda: \r\n1. first propose a categorization for the different kinds of parameters to the list\r\n2. Make a PR based on the outcome",
          "createdAt": "2018-05-16T16:10:44Z",
          "updatedAt": "2018-05-16T16:10:44Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Philipp and I just discussed the following regarding the conceptual organisation of \"Properties\" or \u201cParameters\u201d. The goal to reduce complexity and to avoid confusion:\r\n\r\n- Everything should be named either \"Properties\" or \"Parameters\". We should agree on one of these synonyms, not mix them. We prefer \"Properties\".\r\n\r\n- Properties apply on a Connection _logical or_ a Message. So we have Connection Properties and Message Properties (see #146 for a discussion - The \"Send Parameters\u201d in the current API would then be renamed to Message Properties (and some may apply on partial messages).\r\n\r\n- Open question: As some Properties might applicable to both a Connection and a Message, @philsbln sees the distinction between (Selection Properties/Intents/Protocol Properties) and between (Message Properties/Connection Properties) as orthogonal . @theri thinks that Selection Properties, Intents, and Protocol Properties are Connection Properties, and that Message Properties should be a category separate from them, as per-Message Path Selection is out of scope for this draft.\r\n\r\n- Open question: It might make sense to include Security Parameters. However, we are not sure whether to rename them to \"Security Properties\u201d as this diverged from the naming in TLS.\r\n\r\n- Properties can be either\r\n  - Selection Properties (which are preferences for or against protocol and path features and help the Transport System choose a protocol or path),\r\n  - Intents (which give advisory information on a communication, e.g. an expected capacity profile), or\r\n  - Protocol Properties (which instruct the Transport System to configure a protocol once it has been chosen). [@philsbln most message properties also go here]\r\n\r\n- Open question: Whether Intents (properties which have effects after some interpretation) are included in Selection Properties or should be a separate category.  (@theri thinks they don't need distinguishing, @philsbln wants to consider them being separate categories).\r\n\r\n- Protocol Properties can be either generic or specific.\r\n\r\nFrom this, we would derive the following categorization that are applicable to Connections:\r\n\r\n- (Protocol and Path) Selection Properties\r\n- Intents (may be included in Selection Properties)\r\n- Protocol Properties\r\n  - Generic\r\n  - Protocol Specific\r\n- Security Properties?\r\n\r\nIn addition, some Protocol Properties and Intents are also applicable to messages, and there are Message Properties.\r\n\r\nDo you agree with the conceptual categorization?\r\nDo you have other suggestions for the naming?\r\n\r\nOnce we all agree on the categorization and naming, @philsbln and @theri will prepare a Pull Request with a document structure that reflects the categorization.",
          "createdAt": "2018-05-25T11:56:21Z",
          "updatedAt": "2018-05-25T11:56:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That proposal sounds very good to me. I'm definitely in favor of having fewer terms!\r\n\r\nAbout some of your open questions above:\r\n\r\n> Open question: As some Properties might applicable to both a Connection and a Message, @philsbln sees the distinction between (Selection Properties/Intents/Protocol Properties) and between (Message Properties/Connection Properties) as orthogonal . @theri thinks that Selection Properties, Intents, and Protocol Properties are Connection Properties, and that Message Properties should be a category separate from them, as per-Message Path Selection is out of scope for this draft.\r\n\r\nJust on the basis of what's written here (maybe there's a deeper reason that I'm missing?), I agree with @theri .\r\n\r\n> Open question: Whether Intents (properties which have effects after some interpretation) are included in Selection Properties or should be a separate category. (@theri thinks they don't need distinguishing, @philsbln wants to consider them being separate categories).\r\n\r\nAgain I lean towards agreement with @theri but wonder if I'm missing something: what would be the motivation to call Intents something else - what makes them different?\r\n",
          "createdAt": "2018-05-28T06:38:35Z",
          "updatedAt": "2018-05-28T06:38:35Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that IMC is done I can stop ignoring everyone else. Thanks for putting this proposal together, it's definitely moving in the right direction.\r\n\r\n> Everything should be named either \"Properties\" or \"Parameters\". We should agree on one of these synonyms, not mix them. We prefer \"Properties\".\r\n\r\n+1 to properties.\r\n\r\n> Properties apply on a Connection logical or a Message. So we have Connection Properties and Message Properties (see #146 for a discussion - The \"Send Parameters\u201d in the current API would then be renamed to Message Properties (and some may apply on partial messages).\r\n\r\nYep, deferring later discussion on what the bounds of a logical connection are.\r\n\r\n> Open question: As some Properties might applicable to both a Connection and a Message, @philsbln sees the distinction between (Selection Properties/Intents/Protocol Properties) and between (Message Properties/Connection Properties) as orthogonal . @theri thinks that Selection Properties, Intents, and Protocol Properties are Connection Properties, and that Message Properties should be a category separate from them, as per-Message Path Selection is out of scope for this draft.\r\n\r\nI agree with @theri and @mwelzl here: the message/connection split seems to be more natural from an API client point of view. The client always knows the difference between a message and a connection, while the selection versus runtime split is somewhat more nebulous.\r\n\r\n> Open question: It might make sense to include Security Parameters. However, we are not sure whether to rename them to \"Security Properties\u201d as this diverged from the naming in TLS.\r\n\r\n\"Security Properties\" is wrong: this has a meaning in cryptographic protocol circles, and refers to the services a protocol delivers to its upper layer. \"Security Parameters\" is also wrong, as it has a specific meaning in TLS-adjacent contexts, and that meaning is subtly different from what these should be in a TAPS context (\"security parameters\" in TLS-ese is really something like \"specific protocol properties\" in the current document's terminology bound to TLS). Perhaps we can fix this by no longer treating security like a special snowflake, and making security-relevant protocol properties just be connection properties?\r\n\r\n> Protocol Properties can be either generic or specific.\r\n\r\nOpen question: does this also imply that *message* properties can be generic or specific?",
          "createdAt": "2018-05-28T08:14:06Z",
          "updatedAt": "2018-05-28T08:14:06Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have thought a lot about the Properties duplicated between Message and Connection properties and it seems there is no really nice solution.\r\n\r\nMy idea why I want Message/Connection/Selection/Protocol Properties as some kind of label (and not as hierarchy) may become clearer by looking at a [Venn Diagram of Property types](https://github.com/taps-api/drafts/blob/properties/properties-venn.svg) the way I have them in mind. This assumes we want to be forward-compatible to per-message path selection, e.g., as optimization for multi-path-multi-streaming protocols like SCTP.\r\n\r\nStill, even in this subset thingy, not all properties can be put in a single bucket.",
          "createdAt": "2018-05-28T14:46:00Z",
          "updatedAt": "2018-05-28T14:46:00Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I think we want as much as possible to relate to a message. Some things can't, because they're only bound to time (when was the call made). Then there are mixtures, where we want to allow them to be per message because some protocols support this, but we can't guarantee.\r\n\r\nTake Nagle. It gets activated when you make the call, and it will affect what TCP has in the buffer then. There's no way to guarantee that Nagle activation / deactivation is truly tied to a specific message. In SCTP however, message bundling is a message property.\r\n\r\nSo in conclusion it's good to allow for this to be a message property, for the transport system to try to make the best use of Nagle such that it affects the message that we asked for if possible, and for the API description to include a general disclaimer saying \"Depending on the underlying protocol, it cannot always be guaranteed that message properties truly bind to a particular message.\"\r\n\r\nIs this very problematic as a generic statement for all message properties? Else we need to limit it to certain properties only.",
          "createdAt": "2018-05-29T09:12:05Z",
          "updatedAt": "2018-05-29T09:12:05Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About the Connection/Message Property split:\r\nI agree that there's some Properties that can apply to both a Connection and a Message, as shown nicely in @philsbln's Venn diagram. Our current API draft also reflects this by duplicating \"Capacity Profile\" and \"Instantaneous Capacity Profile\" as both a Connection and a Message Property.\r\nIf we sort such properties into either category, for me this does not mean that they can not be set in the other category. For example, if \"Nagle\" was a Message Property, it could also be set on the Connection, e.g., as a default for all messages. We could annotate the individual Message Properties with \"can also be set on the Connection\", and vice versa. Of course, we would bias the application's choice of where to set it by putting the property in one category in the draft, but for me this would still be the way to go.\r\nAlternatively, I think to match @philsbln's suggestion we would just have a list of, e.g., Protocol Properties, and then label each property with \"can be set on a Message\", \"can be set on a Connection\", \"can be set on both a Message and a Connection\". Maybe this would suggest more flexibility to the application programmer of where to specify it.\r\nSo basically I think this is about how strongly and in what way we reflect or emphasize the Message/Property split in the document.\r\n\r\nI understand @mwelzl's comment to be already about how to sort a property into either Message or Connection property, but I think \"Nagle\" can really apply to both. Is this \"Immediate Acknowledgement\" or something else?\r\n\r\n> \"Depending on the underlying protocol, it cannot always be guaranteed that message properties truly bind to a particular message.\"\r\n> Is this very problematic as a generic statement for all message properties? Else we need to limit it to certain properties only.\r\n\r\nI think most Message Properties do bind to a particular message and that it's pretty important to \"guarantee\" it by API contract, like Idempotent, Lifetime, Niceness. But yes, for other properties it makes sense to include such a statement.\r\n\r\n> Open question: does this also imply that message properties can be generic or specific?\r\n\r\nSo far, to me all Message Properties look generic, but yes, perhaps there could be specific Message Properties as well.",
          "createdAt": "2018-05-29T09:46:20Z",
          "updatedAt": "2018-05-29T09:47:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right - I thought that saying this for all is too generic. Lifetime and Niceness, well ... but Idempotence should definitely be guaranteed per message. So it's a statement that applies to some but not all properties.\r\n\r\nAbout offering properties for connections and messages: I think we should simplify. Simplifying as much as we can is really important IMO.\r\n\r\nFor everything that is bound to a message, I don't see any point in *additionally* offering it per connection. In an implementation, if you want to keep the property for more than one message, just keep it set in your data structure defining all the per-message properties.\r\n\r\nSo, in the interest of simplification and text length, rather than \"can be set on a Message\", \"can be set on a Connection\", \"can be set on both a Message and a Connection\", I'd have per-message properties only, and then a few that apply to a connection only.\r\n\r\nAbout Nagle: this is not \"immediate ACK\", it's coincides with what we currently call the send parameter \"Immediate\". It's about waiting to be able to send a larger packet vs. sending stuff out ASAP. So the \"Immediate\" send parameter is an example of a parameter description that would need such a disclaimer - just that it's not necessary because it's not formulated as a guarantee. This is good enough as it is.",
          "createdAt": "2018-05-29T10:05:22Z",
          "updatedAt": "2018-05-29T10:05:22Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @mwelzl that for the sake of simplicity, we should not make all message properties also connection properties (which is in-line with my [venn diagram](https://github.com/taps-api/drafts/blob/properties/properties-venn.svg)).\r\n\r\nI also see that there are some properties that come as a team: a Message Property and a Preference-Type Protocol Selection Property whether to support the Message Property. As this is a common pattern, we should make this a part of the property structure\r\n\r\nFor the case of TCP Nagle: I guess \"Immediate Send\" is a good message property to capture it, but might also implied by some Intents",
          "createdAt": "2018-05-29T13:41:47Z",
          "updatedAt": "2018-05-29T13:41:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For everything that is bound to a message, I don't see any point in additionally offering it per connection.\r\n\r\nIt depends on what you're offering. Is it:\r\n\r\n- a per-connection default which message properties can override; or\r\n- a protocol selection property that tells the connection racing machinery that it intends to send messages with that property, and that protocols guaranteeing them are preferred (or, in the case of oddly strict application developers, required). \r\n\r\nIf it's the former, I agree with @mwelzl that this doesn't belong in the core API (though I can see most programming environments atop TAPS providing a way to bind default send properties to a connection as syntactic sugar, just to make the API less scary to its users). The latter is something I really think we do need (although very friendly programming environments could also provide static code analyzers to fill out protocol selection properties based on the message properties used).",
          "createdAt": "2018-05-30T12:29:53Z",
          "updatedAt": "2018-05-30T12:29:53Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is the former, and I can live with not having that in the API document, as long as nothing prevents an implementation from binding default Message Properties (not send ;) ) to a Connection.\r\n\r\nProtocol Selection Properties, for me, clearly apply only to (future) Connections, not to Messages.",
          "createdAt": "2018-05-30T13:31:37Z",
          "updatedAt": "2018-05-30T13:31:37Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Waiting for #181 to land before making a PR as this involves moving a lot of text",
          "createdAt": "2018-06-08T13:04:58Z",
          "updatedAt": "2018-06-08T13:04:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#181 merged, this can go ahead now yes? (I'll also remove the discuss label, since we should hold that for stuff we want on the WG agenda for now)\r\n",
          "createdAt": "2018-06-20T14:38:20Z",
          "updatedAt": "2018-06-20T14:38:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Started working on it in the properties branch \u2013 @britram you can take a look at it if you like.\r\n\r\nTurned out that the restructuring made a serious amount of inconsistencies visible. Some we could fix, some that will need discussion. We should have a PR by Tuesday, but it will still have a serious amount of visible problems left (what were in the document before, but hard to spot)",
          "createdAt": "2018-06-24T20:41:25Z",
          "updatedAt": "2018-06-24T20:41:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi,\r\n\r\nI'd indeed appreciate if this would happen by Tuesday - I was planning to do some work this week and I'm delaying it because it probably depends on this PR - e.g. issue #159 ",
          "createdAt": "2018-06-25T11:37:43Z",
          "updatedAt": "2018-06-25T11:37:43Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWUzMDczMjI3OTg=",
      "title": "Structure of implementation draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/154",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "adventureloop"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Review structure. What fits in pre-establishment. Relation system policy - cached state. Generalizes #127 ",
      "createdAt": "2018-03-21T16:31:55Z",
      "updatedAt": "2019-11-22T01:29:29Z",
      "closedAt": "2019-11-22T01:29:28Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in Singapore, we'll have more structure comments later, but we've done a lot of changes since then.",
          "createdAt": "2019-11-22T01:29:28Z",
          "updatedAt": "2019-11-22T01:29:28Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWUzMDc4MzI5MDA=",
      "title": "Need relative ordering of API events",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/155",
      "state": "CLOSED",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [
        "adventureloop",
        "britram"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "The API document needs to specify the relative timing and ordering (i.e., for appropriate thread models, the threading properties) of events.\r\n\r\nE.g., I think it should be guaranteed that a connection's Received<> event isn't called until its initiating event (Connected<>, ConnectionReceived<>, or RendezvousDone<>) has finished processing; and only one Received<> event is invoked at a time for a given connection, with the events being invoked with the appropriate logical order is required by the connection semantics.\r\n\r\nSimilarly, only one of a connection's Sent<> events should be invoked at a time.  However, I don't think there needs to be any restriction against Sent<> and Received<> being invoked simultaneously on the same connection.\r\n\r\nNo other events should be received for a connection after Closed<> or ConnectionError<>.\r\n\r\nFor different connections, It should be allowed for their events to be invoked simultaneously, even if the connections are entangled with each other.",
      "createdAt": "2018-03-22T22:10:19Z",
      "updatedAt": "2018-07-16T15:51:06Z",
      "closedAt": "2018-07-16T15:51:06Z",
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "One particular consideration that came up in the May 16th call is that this last event (presumably Closed<> or ConnectionError<> or Aborted<> or whatever) needs to be enqueued to be executed after previous callbacks complete, rather than being executed synchronously on the stack of another callback.",
          "createdAt": "2018-05-16T16:29:06Z",
          "updatedAt": "2018-05-16T16:29:06Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #195 ",
          "createdAt": "2018-07-16T15:51:06Z",
          "updatedAt": "2018-07-16T15:51:06Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWUzMDc4MzUwNTk=",
      "title": "API needs a way to know that Close() or Abort() are done",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/156",
      "state": "CLOSED",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [
        "adventureloop"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "An application needs a way to know when its Close() or Abort() call is complete, guaranteeing it won't receive any further events on the connection and all current event processing is done.  This is necessary so the application can clean up any application state related to the connection.\r\n\r\nNote that in a multi-threaded environment, events can be executing on other threads at the same time that the Close() or Abort() call is called; in addition, an application can potentially call Close() or Abort() from within an event processing function itself.",
      "createdAt": "2018-03-22T22:19:11Z",
      "updatedAt": "2018-07-16T15:51:35Z",
      "closedAt": "2018-07-16T15:51:35Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intention (in the API) is that the Closed<> and Aborted<> events fire after these are complete, whether the close or abort was locally or remotely initiated.",
          "createdAt": "2018-04-11T12:05:22Z",
          "updatedAt": "2018-04-11T12:05:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #195",
          "createdAt": "2018-07-16T15:51:35Z",
          "updatedAt": "2018-07-16T15:51:35Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWUzMDc4MzYxODM=",
      "title": "API needs a way to cancel Preconnection.Listen()",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/157",
      "state": "CLOSED",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [
        "adventureloop",
        "britram"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "As far as I can tell there's no way for an application to indicate that it wants to stop listening for an incoming connection.\r\n\r\nAs with my #156, this will need a way to know that it's complete, in case there's a race with Preconnection -> ConnectionReceived<> on another thread.",
      "createdAt": "2018-03-22T22:23:37Z",
      "updatedAt": "2018-07-16T15:50:42Z",
      "closedAt": "2018-07-16T15:50:42Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #195",
          "createdAt": "2018-07-16T15:50:42Z",
          "updatedAt": "2018-07-16T15:50:42Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWUzMDc5MjQ5NDM=",
      "title": "Congestion control",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/158",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "We need to distinguish between sending unreliably, but congestion controlled, and sending unreliably without congestion control (the application must know if it has to perform congestion control or not). This should influence at least the protocol and path selection properties.",
      "createdAt": "2018-03-23T07:17:35Z",
      "updatedAt": "2018-06-09T12:13:00Z",
      "closedAt": "2018-06-09T12:13:00Z",
      "comments": []
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWUzMDc5MjU0ODM=",
      "title": "Mapping of path and protocol selection properties to a decision in the code",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/159",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "E.g. 5.1.1.1 explains how to implement send parameters from the API draft, but there's no text explaining how the path and protocol selection properties map to a decision in the code.",
      "createdAt": "2018-03-23T07:20:30Z",
      "updatedAt": "2019-01-04T12:26:03Z",
      "closedAt": "2019-01-04T12:26:03Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Either this text was written after, or I had missed it: there is text already, not listing all properties but giving some examples, which, I think, is just the right way to do it.\r\n\r\nI'm working on a PR that updates the draft, and with it, also this text, to be more in line with the recent API, but either way this issue can be closed.",
          "createdAt": "2019-01-04T12:26:03Z",
          "updatedAt": "2019-01-04T12:26:03Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWUzMDkyOTAxNDE=",
      "title": "Dealing with threads  and concurrency",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/160",
      "state": "CLOSED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "#155 #156 and #157 all stem for considerations in multithreaded environments. \r\n\r\nNEAT handled multithreading by not doing it.  Concurrency had to happen at the context level. I would quite like to take that easy way out and force each context onto its own thread and make the application deal with locking. The implementation draft is probably the correct place for such text. \r\n\r\nAre there arguments for other implementations that lean the other way? ",
      "createdAt": "2018-03-28T09:34:41Z",
      "updatedAt": "2018-10-07T11:01:02Z",
      "closedAt": "2018-10-07T11:01:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an implementation perspective, I do strongly believe that efficiency is served best by having a single threading context for a networking stack context. You may have multiple contexts per process if you need very different threading properties, but most connections should be sharing the same thread. This also, as you mention, simplifies locking quite a bit.\r\n\r\nFor our implementation, we use a Grand Central Dispatch (lib dispatch) abstraction of a queue of work instead of a pthread, so there are good asynchronous block execution semantics, although things are still on effectively one thread.\r\n\r\nNot sure exactly how the text should be written here\u2014I don't want to get too platform specific, but we should be able to distill the general approach.",
          "createdAt": "2018-03-28T16:55:59Z",
          "updatedAt": "2018-03-28T16:55:59Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From our experience with adding concurrency to our socket intents prototype, introducing additional threading or new things that might block is extremely error-prone.\r\n\r\nWe should definitely consider some of the guarantees requested in #155 #156 and #157, but I don't want to suggest a specific threading model / automatic creation of threads.\r\n\r\nIf you already have a framework like GCD or libevent in place, it makes sense to integrate with those.\r\nI guess we should start with some requirements / limitations we know of, start implementing (including language bindings for multiple languages) and incrementally add lessons learned that are not specific to just a single language. ",
          "createdAt": "2018-04-18T12:49:21Z",
          "updatedAt": "2018-04-18T12:49:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wait for #155 #156 #157, and see if there is anything else we need in API and impl.",
          "createdAt": "2018-05-16T16:20:16Z",
          "updatedAt": "2018-05-16T16:20:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closing this as no further discussion after the constituent issues were closed.",
          "createdAt": "2018-10-07T11:01:02Z",
          "updatedAt": "2018-10-07T11:01:02Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWUzMDk2MzQ2Mjc=",
      "title": "NITS (Implementation) in draft-brunstrom-taps-impl-00",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/161",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "I forgot to upload these - but it would be helpful to fix these in the next rev (all textual):\r\n\r\n\u2014\r\nThe phrase below appears a little ambiguous, please reword:\r\nOLD:\r\nin which the necessary protocol\r\nhandshakes are conducted in order to select which set to use\r\n\r\nDoes this mean:\r\nin which an order is specified for the necessary protocol\r\nhandshakes to be conducted to elect which to use\r\nOR;\r\nin which the necessary protocol\r\nhandshakes are conducted so that it can select which set to use\r\n\u2014\r\nOLD:\r\ndelimeters\r\nNEW: \r\ndelimiters\r\n\u2014\r\nOLD:\r\nover to the Tranport\r\nNEW:\r\nover to the Transport\r\n\u2014\r\nOLD:\r\nAs explained in section Section 4.6,\r\nNEW:\r\nAs explained in Section 4.6,\r\n\u2014\r\nI did not understand this text, please rephrase:\r\nGathering locals is primarily an endpoint local operation\r\n",
      "createdAt": "2018-03-29T06:30:31Z",
      "updatedAt": "2018-08-27T13:10:12Z",
      "closedAt": "2018-08-27T13:10:12Z",
      "comments": []
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWUzMTQ2NDYwNTQ=",
      "title": "Fix Transport Parameters inconsistencies",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/165",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "This is a fork of Issue #153 \u2013 The part of it that does not need discussion.\r\n\r\n - Annotate \"data type\" for each Transport Parameter\r\n - Change \"boolean\" Protocol and Path Selection Parameters to type \"Preference\"\r\n - Remove editing artifacts",
      "createdAt": "2018-04-16T13:16:05Z",
      "updatedAt": "2018-04-23T11:51:39Z",
      "closedAt": "2018-04-23T11:51:39Z",
      "comments": []
    },
    {
      "number": 170,
      "id": "MDU6SXNzdWUzMTU0MDY4NjA=",
      "title": "Do we need support for unidirectional connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/170",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "As QUIC has unidirectional streams, we might want to be able to accommodate them in our transport API. Do we want to handle them fundamentally different from a half-closed connection?\r\nThis should match the decisions made in #53.",
      "createdAt": "2018-04-18T09:45:20Z",
      "updatedAt": "2018-06-06T11:09:01Z",
      "closedAt": "2018-06-06T11:01:18Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Side note: we don't support half-closed connections to begin with. As for unidirectional streams, is this the final decision in QUIC's design, or might it change?  I'd suggest postponing this until we can be sure.",
          "createdAt": "2018-05-02T12:34:15Z",
          "updatedAt": "2018-05-02T12:34:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl, regarding half-closed connections: we don't have any top-level state in the connection for being half-closed. However, being able to express that a message is final in a given direction when sending allows the same functionality. As I've discussed before, we absolutely need the ability to express sending a TCP FIN, but I whole-heartedly agree it doesn't need to be a top level concept.\r\n\r\nI think this is somewhat different from half-closing, since a unidirectional stream never allows sending on one end. You could imagine that it is a connection object that returns an error if you ever try to send on it, etc. If you wanted it to look like half-closing, you could open a connection (stream), and then mark it complete in a direction immediately? But that's a bit odd.",
          "createdAt": "2018-05-16T02:14:27Z",
          "updatedAt": "2018-05-16T02:14:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All ok, I agree with your suggestion to fin-mark a message\n\nSent from my iPhone\n\n> On 16 May 2018, at 04:14, Tommy Pauly <notifications@github.com> wrote:\n> \n> @mwelzl, regarding half-closed connections: we don't have any top-level state in the connection for being half-closed. However, being able to express that a message is final in a given direction when sending allows the same functionality. As I've discussed before, we absolutely need the ability to express sending a TCP FIN, but I whole-heartedly agree it doesn't need to be a top level concept.\n> \n> I think this is somewhat different from half-closing, since a unidirectional stream never allows sending on one end. You could imagine that it is a connection object that returns an error if you ever try to send on it, etc. If you wanted it to look like half-closing, you could open a connection (stream), and then mark it complete in a direction immediately? But that's a bit odd.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-05-16T05:07:33Z",
          "updatedAt": "2018-05-16T05:07:33Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agreee with @tfpauly regarding half-closed.\r\n\r\nMy suggestion is to explicitly state that connections can be uni- or bi-directional and to add a method to query that (can_send / can_recv). This aligns nicely with final messages after which can_send becomes false.\r\n\r\nI can do a PR for that.",
          "createdAt": "2018-05-16T10:12:56Z",
          "updatedAt": "2018-05-16T10:12:56Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks! I like this",
          "createdAt": "2018-05-16T10:21:58Z",
          "updatedAt": "2018-05-16T10:21:58Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still missing unidirectional stream for multicast. \u2013 please continue discussion of multicast aspects in #150\r\n\r\nThe connection properties (can send/receive data) are still a little under-specified -  please discuss in details in #190 \u2013 we should fix this together with #153.",
          "createdAt": "2018-06-06T11:09:00Z",
          "updatedAt": "2018-06-06T11:09:00Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWUzMTU1NjQyNjc=",
      "title": "Add architectural section on protocol equivalence as it pertains to racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/172",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "And add a subsection specifically for security protocols. Determining what security protocols (and configurations) are equivalent is nontrivial and incredibly important if we are to race, e.g., TLS and gQUIC. ",
      "createdAt": "2018-04-18T17:01:36Z",
      "updatedAt": "2018-06-27T13:21:04Z",
      "closedAt": "2018-06-27T13:21:04Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think the racing/gathering section needs a tiny little explanation text and this seems reasonable to add - if you add to this section, can you also make sure it mentions something of the terms \"policy\" and \"cached state\" as a part of this update?",
          "createdAt": "2018-06-01T08:40:44Z",
          "updatedAt": "2018-06-01T08:40:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@gorryfair yes, will do!",
          "createdAt": "2018-06-01T19:12:52Z",
          "updatedAt": "2018-06-01T19:12:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Addressed by #199.",
          "createdAt": "2018-06-27T13:21:04Z",
          "updatedAt": "2018-06-27T13:21:04Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWUzMTYyNzczNzU=",
      "title": "Define Transport and Send Parameter data types explicitly",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/173",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Transport and Send Parameter have different data types. These types are used in the document in a more or less intuitive way but are never defined explicitly.\r\n\r\nMay need a new section next to the pseudocode definition.",
      "createdAt": "2018-04-20T13:54:02Z",
      "updatedAt": "2018-07-18T22:41:24Z",
      "closedAt": "2018-07-18T22:41:24Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has been addressed in PR #201 ",
          "createdAt": "2018-07-18T22:41:24Z",
          "updatedAt": "2018-07-18T22:41:24Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWUzMTY3MDE4NTQ=",
      "title": "Do we need a \"send acknowledged\" event?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/174",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "The discussion about the \"immediate ACK\" in SCPT (issue #90) raises the question whether the application should be notified about the message being acknowledged.\r\nI guess this has to get along with a protocol selection property (require/prefer/ignore) but is hard to implement for protocols like TCP.",
      "createdAt": "2018-04-23T07:59:49Z",
      "updatedAt": "2018-09-12T14:44:18Z",
      "closedAt": "2018-05-02T12:02:25Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the short answer is \u00abno\u00bb - i\u2019ll try to explain soon\n\nSent from my iPhone\n\n> On 23 Apr 2018, at 09:59, Philipp S. Tiesel <notifications@github.com> wrote:\n> \n> The discussion about the \"immediate ACK\" in SCPT (issue #90) raises the question whether the application should be notified about the message being acknowledged.\n> I guess this has to get along with a protocol selection property (require/prefer/ignore) but is hard to implement for protocols like TCP.\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-04-23T08:23:42Z",
          "updatedAt": "2018-04-23T08:23:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My reaction speed is a far cry from \"soon\", sorry!!  Anyway, reading issue #90 again, I think I explained enough stuff in detail there: if we decide to leave buffer handling to the transport system (which I think we now decided), leading us to remove \"immediate ACK\", I can't see why we should have functionality to tell an app that a message has been ACKed. This is all a matter of transport-system internal buffer management, I'd say. On that basis I'm closing the issue - reopen it if you think I'm wrong.",
          "createdAt": "2018-05-02T12:01:54Z",
          "updatedAt": "2018-05-02T12:02:18Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When thinking about new transports, I think this might be a useful thing - but not for discussion now - re-opening it with milestone \"Science Fiction\"",
          "createdAt": "2018-09-12T14:44:18Z",
          "updatedAt": "2018-09-12T14:44:18Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWUzMTk0MjkzNzc=",
      "title": "Abstractify everything",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/176",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Make sure all the examples in the API and interface drafts use constants agnostic to argument type and syntax. From Dave Thaler:\r\n\r\nOn 2 May 2018, at 03:07, Dave Thaler <dthaler@microsoft.com> wrote:\r\n\r\n> I skimmed the TAPS interface draft.  I like that it aims to be an abstract, not concrete API.\r\n> But then it contains concrete examples that aren\u2019t explained or, in my view, useful.  E.g.:\r\n \r\n```\r\nSecurityParameters.AddSupportedGroup(22) // secp256k1\r\nSecurityParameters.AddCiphersuite(0xCCA9) // TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 SecurityParameters.AddSignatureAlgorithm(7) // ed25519\r\n```\r\n\r\n> Is less useful than a more abstract:\r\n\r\n``` \r\nSecurityParameters.AddSupportedGroup(secp256k1)\r\nSecurityParameters.AddCiphersuite(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)\r\nSecurityParameters.AddSignatureAlgorithm(ed25519)\r\n```\r\n> The latter is agnostic as to the argument type, and the comment syntax.",
      "createdAt": "2018-05-02T06:49:18Z",
      "updatedAt": "2018-06-27T13:20:45Z",
      "closedAt": "2018-06-27T13:20:44Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#197 will fix this when it lands",
          "createdAt": "2018-06-20T14:39:16Z",
          "updatedAt": "2018-06-20T14:39:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Addressed by #197.",
          "createdAt": "2018-06-27T13:20:44Z",
          "updatedAt": "2018-06-27T13:20:44Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWUzMjM2ODEwMjA=",
      "title": "Privacy considerations section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/177",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mirjak"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "Each document should have a privacy considerations section to discuss the tradeoffs inherent in the API.",
      "createdAt": "2018-05-16T15:49:04Z",
      "updatedAt": "2020-04-06T13:15:56Z",
      "closedAt": "2020-04-06T13:15:56Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hey @chris-wood any cycles for this before the BKK deadline?",
          "createdAt": "2018-10-07T11:01:27Z",
          "updatedAt": "2018-10-07T11:01:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Yes! Keep the pings coming.",
          "createdAt": "2018-10-08T01:28:26Z",
          "updatedAt": "2018-10-08T01:28:26Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Ping!  (post-bkk even!)",
          "createdAt": "2019-01-25T10:39:48Z",
          "updatedAt": "2019-01-25T10:39:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Pong! Will get to this ASAP.",
          "createdAt": "2019-02-07T15:33:03Z",
          "updatedAt": "2019-02-07T15:33:03Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "pingety pingety ping",
          "createdAt": "2019-07-22T18:05:23Z",
          "updatedAt": "2019-07-22T18:05:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When this is done, add a pointer from architecture to interface security considerations.",
          "createdAt": "2019-11-21T04:39:55Z",
          "updatedAt": "2019-11-21T04:39:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indicate that anything you pass to the API can go onto the wire, etc, etc.",
          "createdAt": "2020-01-24T16:20:32Z",
          "updatedAt": "2020-01-24T16:20:32Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\u00a75.1 of the API draft talks about when DNS resolution happens, which is a potential privacy issue to point to.",
          "createdAt": "2020-01-24T16:22:32Z",
          "updatedAt": "2020-01-24T16:22:32Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWUzMjM2ODE4MzY=",
      "title": "Architecture privacy and security considerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/178",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "Point to API and Implementation privacy considerations, and discuss security considerations behind architectural choices",
      "createdAt": "2018-05-16T15:51:00Z",
      "updatedAt": "2019-11-21T04:39:59Z",
      "closedAt": "2019-11-21T04:39:59Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Needs #177 ",
          "createdAt": "2019-03-25T12:14:16Z",
          "updatedAt": "2019-03-25T12:14:16Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWUzMjM2ODUwMjI=",
      "title": "Distinguish between early data and not (0RTT) on the receiver side?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/179",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-16T15:58:57Z",
      "updatedAt": "2018-06-20T14:57:26Z",
      "closedAt": "2018-06-20T14:57:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "I'll dig up relevant discussions from the TLS WG.",
          "createdAt": "2018-05-16T16:03:43Z",
          "updatedAt": "2018-05-16T16:03:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "See, e.g.: https://www.openssl.org/docs/man1.1.1/man3/SSL_read_early_data.html",
          "createdAt": "2018-06-18T03:33:32Z",
          "updatedAt": "2018-06-18T03:33:32Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like a good candidate for a read-only recv property\u2026",
          "createdAt": "2018-06-19T13:31:53Z",
          "updatedAt": "2018-06-19T13:31:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@philsbln Aren't all receives read-only?",
          "createdAt": "2018-06-19T17:42:06Z",
          "updatedAt": "2018-06-19T17:42:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Closed by #198.",
          "createdAt": "2018-06-20T14:57:26Z",
          "updatedAt": "2018-06-20T14:57:26Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWUzMjM5MTA5ODE=",
      "title": "Editorial NiTs in Implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/180",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "I found these minor NiTs in draft-brunstrom-taps-impl-00 while in London and forgot to post them. (Other items on my list appear to now have been resolved!! ... maybe there is just a little merit to delaying this?) - Gorry\r\n\u2014\r\nThe phrase below appears a little ambiguous:\r\n/in which the necessary protocol\r\n   handshakes are conducted in order to select which set to use/\r\n\r\nDoes this mean:\r\n/in which an order is specified for the necessary protocol\r\n   handshaking to elect which to use/\r\nOR;\r\n/in which the necessary protocol\r\n   handshaking is performed so that it can select which set to use/\r\n\u2014\r\nOLD:\r\ndelimeters \r\nNEW:\r\ndelimiters\r\n\u2014 \r\nOLD:\r\nover to the Tranport\r\nNEW:\r\nover to the Transport\r\n- added /s/\r\n\u2014\r\nOLD:\r\nAs explained in section Section 4.6,\r\nNEW:\r\nAs explained in Section 4.6,\r\n\u2014\r\nI did not understand the wording of this phrase:\r\nGathering locals is primarily an endpoint local operation\r\n",
      "createdAt": "2018-05-17T07:57:08Z",
      "updatedAt": "2018-08-31T14:23:15Z",
      "closedAt": "2018-08-31T14:23:15Z",
      "comments": []
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWUzMjY4NDcwMjU=",
      "title": "What is the point of the \"Closing\" state?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/182",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "Reading through the API, I noted that there is, amongst the various connection states, a state that is defined but never mentioned again in any of the drafts: \"Closing\".\r\n\r\nI am unclear how this state is useful to the application, and how an implementation would determine it.\r\n\r\nIf the connection is closed from the remote side, like a RST, then we'll move right to Closed. If the connection is closed from the local side, I guess we can move into the Closing state before getting an ack that the remote side knows that we've closed, but at that point, I'm not going to be able send or receive any more on the connection anyhow.\r\n\r\nDo we have a good use case for Closing? If so, can we get more text? If not, can we remove it?\r\n\r\nFor reference, we don't have any corresponding state in our implementation, and it's never come up as a need.",
      "createdAt": "2018-05-27T20:19:11Z",
      "updatedAt": "2019-01-25T13:15:33Z",
      "closedAt": "2019-01-25T13:15:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also don't see a good use case and would rather see it removed.\r\n\r\nI guess the only case worth even thinking about is the local close one. Here, our \"close\" semantics don't promise any use for any Closing state anyway, and since (as you say) you can't send or receive anymore on a closing connection, the only point is resource optimization - to avoid opening a new connection when we can wait until the previous one is closed, stuff like that. Even that idea creates a protocol dependency in the application (because some protocols will have delay on closing, but some will just terminate), which IMO makes the state a bad idea.\r\n",
          "createdAt": "2018-05-28T06:42:58Z",
          "updatedAt": "2018-05-28T06:42:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, if you wanted to know you were locally 'closing', you could just know that you called `close()` and haven't gotten the `closed` state yet.",
          "createdAt": "2018-05-28T18:05:21Z",
          "updatedAt": "2018-05-28T18:05:21Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So for me, the `closing`state is between someone called `close` and the sending of the `Closed` event \u2013 might be interesting for concurrent threads to not fall into race issues, but besides this not very useful.\r\n\r\nSide question: can I clean up all my connection related state in the `Closed` event handler and is the event guaranteed to fire eventually?",
          "createdAt": "2018-05-30T09:55:08Z",
          "updatedAt": "2018-05-30T09:55:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> might be interesting for concurrent threads to not fall into race issues\r\n\r\nThis seems implementation-internal, which indicates to me we can probably get rid of the state.\r\n\r\n> Side question: can I clean up all my connection related state in the Closed event handler and is the event guaranteed to fire eventually?\r\n\r\nI think that's a question for #155 / #156 which I haven't got around to thinking about yet.",
          "createdAt": "2018-05-30T12:40:48Z",
          "updatedAt": "2018-05-30T12:40:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln yes, that seems to be the only meaning of the \"closing\" state, but it doesn't really even provide any threading benefit. If you want to make sure that the connection has closed, just wait for the `closed` state\u2014anything after you invoke Close() before the transition to `closed` is effectively `closing`.\r\n\r\nWith regards to the question about the final event, I think there MUST be some final event that means that everything is cleaned up from the application's perspective so the memory can be released, etc. In the current model, `closed` seems to be that correct event. In our implementation, we call this `cancelled`, which only happens after the client of the API calls the `cancel`/`close` function, to distinguish from a remote-initiated close. So, to be most safe, you may want a state for invalidated/cancelled/never-delivering-any-events-again.",
          "createdAt": "2018-05-30T15:55:12Z",
          "updatedAt": "2018-05-30T15:55:12Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(catching-up on old discussions)\r\n\r\nI'm confused: we surely need a name for the time between calling `Close()` and getting the `Closed` event. What would this be, other than the `Closing` state? I don't understand how we can remove this.",
          "createdAt": "2018-06-08T14:23:29Z",
          "updatedAt": "2018-06-08T14:23:29Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @csperkins. Depending on the case, it may not map to much going on in code, you may just get an immediate \"Closed\" instead after calling Close() - but not always. So then, what's the reason to not give this time period a name, and what else is it but a state?",
          "createdAt": "2018-06-10T21:08:59Z",
          "updatedAt": "2018-06-10T21:08:59Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe we should add a hint to this state, that it is not particularly useful from a programmers perspective, but necessary in the presence of concurrency.",
          "createdAt": "2018-06-11T13:30:58Z",
          "updatedAt": "2018-06-11T13:30:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In #195, I've added a section on ordering of API events (please have a look at it). It talks about guarantees the API makes about which events must occur in which order, but it doesn't talk about guarantees the application must make in its ordering of operations. If we added this, we could talk about the state machine there.\r\n\r\nIt does seem to me that if we add such a discussion, that `Send()` after `Close()` is not allowed. This suggests that `Closing` is a state.",
          "createdAt": "2018-06-12T09:35:21Z",
          "updatedAt": "2018-06-12T09:35:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see a need to have a state be set to enforce that `Send()` must not be called after `Close()`.\r\n\r\nIf everything is an asynchronous operation, and states are signaled asynchronously, etc, then there still may be a race if you call `Close()` then `Send()` immediately; you most likely will not have received the state transition to `Closing` yet, but it's still an invalid sequence of calls, and the send should fail.\r\n\r\n@csperkins while I agree that closing is a state that may exist internally for *some* protocols, I don't see any value to delivering a signal to an application that they are in the closing state. That's an extra event delivery that necessitates to action and provides no new information. It also is a source of confusion if some protocols use a closing state, but others don't (because UDP should just go to `Closed` immediately).",
          "createdAt": "2018-06-12T16:47:11Z",
          "updatedAt": "2018-06-12T16:47:11Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @csperkins that conceptually you always pass through the Closing state after calling Close() and before receiving the Closed event, even if this transition may sometimes be practically immediate as when you use UDP. Even if you use UDP the TAPS system may need to perform some internal cleanup before triggering the Closed event though. \r\n\r\nI agree with @tfpauly that you do not need to signal that you are in the Closing state to the application, but I also do not see that this is suggested anywhere. If the application asks what state it is in, then Closing is a possible return value, but that does not create an extra event delivery? So I do not see that the Closing state causes any problem or extra overhead.",
          "createdAt": "2018-06-13T00:11:00Z",
          "updatedAt": "2018-06-13T00:11:00Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that state changes do need to be events signaled to the application. Knowing that a connection is ready should not be polled\u2014it is an event. Similar for closed, etc.  there should not be a special case for closing, but closing should not be a fired event at all!",
          "createdAt": "2018-06-13T03:50:36Z",
          "updatedAt": "2018-06-13T03:50:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not have a special case?  True, I struggle to imagine other state changes that an application doesn't care about, but so be it - \"closing\" is no less of a state just because it's not important enough to apps to be signalled to them.\r\n\r\n(side note: I tag this message as \"I offer my opinion but I also don't care much about this\")",
          "createdAt": "2018-06-13T06:55:50Z",
          "updatedAt": "2018-06-13T06:55:50Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why would we not signal `Closing<>` to the application? We need some signal that the stack is acting on the `close()` request, since this implies that events pertaining to an active connection will no longer be delivered and the application can free up those resources. Especially since, for some protocols, the `Closed<>` event could come some significant time after `Closing<>`.",
          "createdAt": "2018-06-13T11:50:01Z",
          "updatedAt": "2018-06-13T11:50:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Splitting this into `Closing<>` and `Closed<>` could simplify tge \r\n\r\nHowever, I'm a little confused about this: \r\n\r\n> since this implies that events pertaining to an active connection will no longer be delivered and the application can free up those resources.\r\n\r\n`Closing<>` happens after `Close()` is called, but before `Closed<>` happens. ISTM you can still receive things after `Closing<>` (i.e., there can still be events fired from pending receive calls), but is it legal to call `Send()` and `Receive()`?",
          "createdAt": "2018-06-13T13:03:39Z",
          "updatedAt": "2018-06-13T13:03:39Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram If I `write()` some data then call `close()`, when do I enter the closing state? \r\n\r\nThe `Closing<>` event could mean \"I got your close request, and will send any outstanding data then close the connection\" or it could mean \"I've send all outstanding data and am in the process of closing the connection\". If the former, I'd expect to get Message Sent events after `Closing<>`, if the latter I'd not expect such events. ",
          "createdAt": "2018-06-13T14:56:25Z",
          "updatedAt": "2018-06-13T14:56:25Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought you enter the Closing state immediately after calling Close() and you can no longer call Send() or Receive() after this point and a Closing<> event would have the former meaning (\"I got your close request, and will send any outstanding data then close the connection\"). That's why I did not see the need to signal this state transition to the application. I agree we need to signal the application when all outstanding data has been sent and resources can be freed. I thought this would be captured by the Closed<> event. But if the Closed<> event relies on the other end it may be good to separate them.\r\n\r\nIn relation to the need for signaling all state transitions, do we not have a similar situation for Establishing. The Establishing state is I assume entered when an application calls Initiate(), Listen() or Rendezvous(). We do not signal this state transition to the application as far as I understand. We signal when the connection is ready and we move to the Established state, correct?",
          "createdAt": "2018-06-16T16:40:15Z",
          "updatedAt": "2018-06-16T16:40:15Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Linking this to operation ordering as in #231 might make the whole concept of application-exposed connection state make more sense.",
          "createdAt": "2018-10-07T11:08:01Z",
          "updatedAt": "2018-10-07T11:08:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "having submitted #234, it's pretty clear that the Established and Closing states are identical from the application's standpoint with respect to which events are received.\r\n\r\nIt may be that Closing is simply equivalent to Established s.t. both \"can send\" and \"can receive\" are False. That raises the quesiton of whether or not we should split Established into four states:\r\n\r\n- Bidirectional\r\n- Send-Only\r\n- Receive-Only\r\n- Closing",
          "createdAt": "2018-10-07T13:12:30Z",
          "updatedAt": "2018-10-07T13:12:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see the point of this state split proposal - but if you like this better I don't mind it either.",
          "createdAt": "2018-10-08T10:11:10Z",
          "updatedAt": "2018-10-08T10:11:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I agree with the overall assessment that Closing is the same as Established, with the distinction that I/O doesn't work. There are other cases in which I/O may not work temporarily in the middle of a connection too, and I wonder if that should be related. For example, if you have a migratable protocol like MPTCP or QUIC, and you lose all interfaces, you can't actually send or receive for a time (although sends and receive calls may be buffered), and you may end up timing out and closing, or you may end up re-establishing over another link.",
          "createdAt": "2018-10-08T15:30:04Z",
          "updatedAt": "2018-10-08T15:30:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There are other cases in which I/O may not work temporarily in the middle of a connection too, and I wonder if that should be related.\r\n\r\nahhhh yep.\r\n\r\n\"no I/O available\" can actually happen for a range of stack/transport system implementation specific reasons, not just because it's closing, so I do think we need a state but it needs a different name. It also makes sense to keep \"can send\" and \"can receive\" separate read-only booleans, because they happen for different reasons which are not necessarily state-related. We have four states then:\r\n\r\n- Establishing: connection is not yet up and running; local allocation is complete and resolution/racing is in progress, or a listener is up and waiting for connections.\r\n- Established: connection is up and running and I/O is possible in at least one direction; there exists at least one transport stack attached to the connection\r\n- Dormant: the transport system is maintains state for a connection, but there exist no active transport stacks attached to the connection, and the transport system is not currently attempting to re-establish the connection. Modeling this probably goes hand in hand with the text for #45.\r\n- Closed: the transport system has shut down the connection; it is dead, and eligible for GC etc.",
          "createdAt": "2018-10-09T10:18:48Z",
          "updatedAt": "2018-10-09T10:18:48Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`Closing` and `Dormant` are different though: the connection doesn't come back from `Closing`, but it does from `Dormant`.\r\n\r\nAlso: is it `Dormant` or do we just transition back to `Establishing` in this case? Is it just for migration?",
          "createdAt": "2018-10-15T21:12:17Z",
          "updatedAt": "2018-10-15T21:12:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dormant might also happen in an environment where the transport system knows it can resume. Migration, yes, but maybe migration during sleep (i.e., you closed your laptop on a download then landed in another country and opened it again -- if the endpoints know about each other they can still resume).\r\n\r\nAs to whether Dormant isn't just Establishing, it depends on whether we need the application to distinguish between \"the transport system has at least one candidate it is racing, sends will be buffered and receives will queue\" and \"the transport system has no candidates, but attempts to send or receive may result in a transition to Establishing\". \r\n\r\nRereading what I wrote above, I think I got the equivalence between Dormant and Closing wrong -- they're actually totally separate. But I still don't think I see the utility of Closing on its own from a properties management standpoint-- you're Established, you Close (or the remote peer does), then you're Closed (and subject to GC if you're that sort of language :) ).",
          "createdAt": "2018-10-17T15:08:34Z",
          "updatedAt": "2018-10-17T15:08:34Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whether or not `Closing` has utility, it exists as a state: for many transports there is a time period between starting to tear down the connection, and having completed tearing down the connection. That's the `Closing` state, whether or not its useful. I don't see that pretending it doesn't exist is a good idea. \r\n",
          "createdAt": "2018-10-17T22:48:39Z",
          "updatedAt": "2018-10-17T22:48:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok i buy that.\r\n\r\nSo we have five: establishing, established, dormant (which might just be establishing), closing and closed (which act the same from the interface's standpoint, but are semantically different...)",
          "createdAt": "2018-10-18T10:40:46Z",
          "updatedAt": "2018-10-18T10:40:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems this discussion has concluded, without a need to add new text (because we have establishing, established, closing and closed already covered).",
          "createdAt": "2019-01-25T13:15:33Z",
          "updatedAt": "2019-01-25T13:15:33Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "MDU6SXNzdWUzMjgzMzc0ODM=",
      "title": "Replace long author lists with editors",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/184",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "admin stuff",
        "wontfix"
      ],
      "body": "The RFC Editor has become rather strict in implementing the 5 author limit for drafts:\r\n\r\nThis document has more than five authors listed, which is considered excessive under normal circumstances. If you plan to request publication as an RFC, this will require additional consideration by the stream manager (for example, the IESG), and publication may be declined unless sufficient justification is provided. See RFC 7322, section 4.1.1 for details.\r\n\r\nWe should update these for -01",
      "createdAt": "2018-06-01T00:06:32Z",
      "updatedAt": "2021-05-18T12:02:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In cases where one or two authors are collating stuff, then this is certainly correct. I'd need convincing this is true for at least some of the author list - in cases where more than 5 authors need to be in RFC-Ed review, I was always told the process could be over-ridden, where the author team needed that level of interaction with the process.",
          "createdAt": "2018-06-01T06:10:27Z",
          "updatedAt": "2018-06-01T06:10:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The phrasing in RFC 7322 is \"If there is a request for more than five authors, the stream-approving body needs to consider if one or two editors should have primary responsibility for this document, with the other individuals listed in the Contributors or Acknowledgements section.\"   - \"if there is a request ... needs to consider\" doesn't seem to me like a strict \"MUST be like that\", indeed.\r\n\r\nI'm also quite unhappy with the idea of moving to an editor - author mode. I think that for both the API and the implementation draft (I didn't really follow the arch. one), all authors have been making truly substantial contributions across the whole thing, more than just \"send me a few paragraphs and we'll include them\".",
          "createdAt": "2018-06-01T08:51:05Z",
          "updatedAt": "2018-06-01T08:51:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I don't see how having an editor-author model reduces the perceived contribution of the authors. For documents like those in the QUIC WG, there are many people I know who are extremely active as authors, who I recognize are primary contributors, despite not being editors.\r\n\r\nI raised this issue since its a point that Aaron brought up, and I agree that it gets fairly hard to read a document when the first page is half taken up with lines of names.",
          "createdAt": "2018-06-21T16:45:27Z",
          "updatedAt": "2018-06-21T16:45:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly - well I disagree about the first page being \"half taken up\" with this, and about the document getting hard to read; it also seems that the rule that Aaron was concerned about is not strict, plus it seems that the large majority of us is in favor of keeping it as-is.",
          "createdAt": "2018-06-21T17:08:14Z",
          "updatedAt": "2018-06-21T17:08:14Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still don't think this is the right thing to do. ",
          "createdAt": "2018-06-21T19:17:12Z",
          "updatedAt": "2018-06-21T19:17:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly For the academic contributors, author vs. being in the acknowledgment section often makes a big difference for internal and project evaluation \u2013 moving it (from an administrative perspective) from a project we get credit for to a fun/hobby project.",
          "createdAt": "2018-06-22T12:31:34Z",
          "updatedAt": "2018-06-22T12:31:34Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with @gorryfair, @mwelzl, and @philsbln: moving authors to a contributors section is problematic and suggests a lesser contribution",
          "createdAt": "2018-06-22T14:29:45Z",
          "updatedAt": "2018-06-22T14:29:45Z"
        },
        {
          "author": "adfalk",
          "authorAssociation": "NONE",
          "body": "In the last 10 years only 3 RFCs have been published with 10 authors.  We need to revisit this issue as support of the wg and the AD will be needed to request publication with an author list this long.",
          "createdAt": "2021-05-06T20:29:27Z",
          "updatedAt": "2021-05-06T20:29:27Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to draft a case here for others to look at and allow us to comment, if needed this can be into a PR.\r\n\r\nWhy do the core TAPS docments have a long author list?\r\n\r\nThe TAPS work on the three core API drafts has been a 7-year journey to make a new kind of specification - this is an API, and unlike many protocol specifications it actually requires a large team to closely work on this together. I believe there is a  very good case that this short series of specs are unique in several ways.\r\n\r\nThis is intended to be well-argued case for an exception - as permitted by the process - not a precedent:  Even it TAPS,m we\u2019d expect future documents to be focussed on parts of the stack (as was the case in early TAPS documents).\r\n\r\nFirst: it forms the first IETF transport API, something not previously published by the IETF. An integrated team-based approach was recognised as important from early in the document development and was discussed a number of times. The resulting team brought drew from several previous projects, important initial contributions from two EU projects (NEAT.MAMI), independent work at TU Berlin and Glasgow and independent work at Apple, and a small number of others. Each author continues to play a key part in shaping the way the final document is structured, while bringing necessarily expertise across a wide area of topics(see github activity, and IETF meetings\u2026 with 8 meetings per year with < 450 issues and over 300 PRs) to draw expertise on a wide range of subjects. Things have evolved many times, but this was essentially a team effort - not an editorial  process to draw together contributions.\r\n\r\nSecond, the topics span a very wide set of expertise - even for the IETF, and rather than make many documents, we purposely focussed on three closely linked documents to cover:\r\n* Understanding of applications use of transport\r\n* Architectural design\r\n* Privacy, Security and Policy in the stack\r\n* Trends in modern API and variations between programming languages, and use of callback, events, etc.\r\n* Detailed understanding of differences between the IETF transports\r\n* Understanding of STUN/ICE and Rendezvous\r\n* Understanding of NAT, details of using of IPv4 and IPv6\r\netc\r\n\r\nThird, as the document passes through IETF review, IESG review and RFC-Ed the present authors have a commitment and style of working that is effective and ensures that details are not overlooked. I don\u2019t think this close working is typical of the IETF process with which I am familiar, and likely is because of the nature of these specific specifications. I don\u2019t expect many IETF documents had such a breadth of expertise and were developed in this way, at least not within transport.\r\n\r\nOverall, this represents been a major investment by the entire author team. Normally the underpinning research contribution can be published in Journals, etc. However, in this case, people have been actively working on refining the spec for several years after their research to bring a consistent and new type of API to the IETF, and the final outcome is this spec. At least where I work, this contribution is only recognised by the University when I am an author (I personally do contribute to many, many, other documents at the IETF - I understand that these won\u2019t be counted by my employer, which is the way it is - however this is a core piece of work and it is very important to see this acknowledged.)\r\n\r\n.",
          "createdAt": "2021-05-12T12:30:29Z",
          "updatedAt": "2021-05-12T12:30:29Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to strongly support Gorry's points. These drafts are very much a team effort, with much closer and more sustained group effort than I've seen for many other drafts in the IETF. Changing the authorship at the last minute, to exclude people who've put tremendous effort into writing, checking, implementing, and testing these drafts is both ethically dubious and highly inappropriate. \r\n\r\nIf we want people from different backgrounds to participate in IETF, we need to give them incentives and credit when they do. For academics, that means authorship of the drafts they write. Like Gorry, I contribute to many IETF drafts \u2013 often without credit \u2013 because it's the right thing to do, to improve the Internet. I accept that as the nature of IETF work. But, when I've spent many years working on a set of drafts, helping fashion the design and writing extensive parts of the text, that needs to be acknowledged by co-authorship. ",
          "createdAt": "2021-05-12T12:53:41Z",
          "updatedAt": "2021-05-12T12:53:41Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that there are good reasons to keep a large author list. However, we should probably still review the author list before we submit. Can't remember how we actually \"distributed\" the authors when we moved away from the initial set of documents but not sure that still maps with the contributions each authors made on each document.",
          "createdAt": "2021-05-18T12:02:06Z",
          "updatedAt": "2021-05-18T12:02:06Z"
        }
      ]
    },
    {
      "number": 186,
      "id": "MDU6SXNzdWUzMjg0MDI0NDk=",
      "title": "Detailed read-through comments on API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/186",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "----\r\nSection: Low Latency: : \r\nI really dislike the term /bandwidth efficiency/ - because we are not talking here of bandwidth in MHz, and certainly of not how efficiently the bandwidth is used from a radio perspective. Could we say /efficiently of using the available capacity/?\r\n\r\nI also have problems undrestaing what was intended by /and delay variation/ - because it doesn\u2019t read correctly to me. What is intended?\r\n\r\nSection: Constant Rate: : \r\n- still dislike  /bandwidth efficiency/ - see above.\r\n---\r\n/rate adaptive/ should this be /rate-adaptive/ ?\r\n---\r\nSection: Scavenger/Bulk: : \r\n/for less-than-best-effort treatment, and so on./\r\n- can we explicitly point to the scavenger traffic class, rather than just the transport behaviour?\r\n\r\ne.g. add /or to assign the traffic to a lower effort service/ ??\r\n----\r\nShould we expand these abbreviations on first use?:\r\nNAT, ICE, STUN, SIP\r\n----\r\nSection: Connection Groups {#groups}\r\n- Could we consider removing the following clause ... I am not sure that I buy the specification text that reads:\r\n/An ideal transport system implementation would assign the Connection the capacity share (M-N) x C / M, where N is the Connection's Niceness value, M is the maximum Niceness value used by all Connections in the group and C is the total available capacity. /\r\n- I\u2019d prefer to feel comfortable that we have running code that does this - NEAT does not implement this approach, it could do something I am sure - but do we have to write this as if we specify this in the API?\r\n---\r\nI do not like the words /about capacity allocation/ --- my rationale is that this doesn\u2019t imply using an allocation method - I\u2019d much prefer /about the way capacity is shared/\r\n\r\nSimilarly: /exact capacity allocation/ -- I\u2019d prefer: /the way an implementation shares capacity/\r\n----\r\n/For example, infinite Lifetime is not possible on a Message over a Connection not providing reliability. /\r\n- This didn\u2019t read quite correct to me, is this better:\r\n/For example, it is not possible to set an infinite Lifetime for a Message over a Connection that does not provide reliability. /\r\nor\r\n/For example, a Connection must provide reliability to allow a Message to set an infinite Lifetime. /\r\n----\r\nThe concept of  /an infinite Lifetime/  is just a tiny little odd, does this mean the value is set to infinite - or do we really expect persistent non-volatile storage of the message until it is sent?, I'd perhaps geel happier if we explained this as /an infinitie value for the lifetime property means that ..../\r\n----\r\nSection: Niceness {#send-niceness}\r\nThe term /normal/\r\n/Note that this inversion of normal schemes for expressing priority has a convenient property: priority increases as both Niceness and Lifetime decrease./\r\n- I wonder if this actually is clearer just to say:\r\n/This encoding of the priority has a convenient property that the priority increases as both Niceness and Lifetime decrease./\r\n\r\n/It is most naturally represented as a non-negative integer./\r\n- the other terms are defined more concretely. Is there any reason we do not start the niceness section by saying Niceness is a numeric (non-negative integer) quantity. \r\n---\r\nI didn't read the appendexes because I thought they were still being edited - happy to read when asked.",
      "createdAt": "2018-06-01T06:56:17Z",
      "updatedAt": "2018-06-12T08:22:14Z",
      "closedAt": "2018-06-12T08:22:14Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll try to take care of these early next week, together with a few other updates I planned for that period.",
          "createdAt": "2018-06-01T08:52:32Z",
          "updatedAt": "2018-06-01T08:52:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About this one:\r\n\r\n> An ideal transport system implementation would assign the Connection the capacity share (M-N) x C / M, where N is the Connection's Niceness value, M is the maximum Niceness value used by all Connections in the group and C is the total available capacity.\r\n\r\nI'd rather keep this: otherwise it's not clarified anywhere what the real meaning of a niceness value is - is it a linear priority, is it like doubling priorities per value (as Harald was forced to invent here, for lack of any other available definition: https://tools.ietf.org/html/draft-ietf-rtcweb-transports-17#section-4.1 ), or what? And BTW, indeed we *do* implement it like this in NEAT - AFAIK both the SCTP scheduler and Safiqul's coupled cc. kernel patch do this.",
          "createdAt": "2018-06-06T06:19:05Z",
          "updatedAt": "2018-06-06T06:22:12Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #193",
          "createdAt": "2018-06-12T08:22:14Z",
          "updatedAt": "2018-06-12T08:22:14Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWUzMjg0MjQxNjQ=",
      "title": "Detailed read-through of ARCH document",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/187",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "These issues mostly relate to the ARCH document wording:\r\n-\r\nSection: Introduction \r\nIt looks to me like we should have a reference after:/the BSD socket() interface./\r\n---\r\nSection:  Background. << separate issue on missing background>>\r\n---\r\nSection: Transport Services Architecture and Concepts\r\n- The Application box seems one character wider than the TAPS boxes. i know apps are important to APIs, but suspect this is just a typo with extra '-' characters!\r\n---\r\n/primarily offer knobs that are applicable to multiple transports/\r\n- Understand /knobs/, but suspect someone who does not speak English as a first language could be most puzzled, can we use a different word please?\r\n---\r\nThis may be something:\r\n/by which data transmission is ceased/\r\n- To me this doesn't read as common English and would be:\r\n/by which data transmission is stopped/\r\n/by which data transmission ceases/\r\n---\r\n/Endpoint can vary in levels of specificity/\r\n- /Endpoint/ and /vary..specificity/\r\n... does it really vary, this seems difficult to pin down.\r\n- Is this better as:\r\n/An Endpoint may be specified at various levels/?\r\n---\r\n/that it wants to use for transport connections/\r\n... surely it does use it, or is more intended (if so, what)? \r\n- Is it simpler as:\r\n/that it uses for transport connections/\r\n---\r\n/paths between itself and the Remote Endpoint/\r\n- I think strictly speaking, it is not between the App and the remote endpoint, but the local and remote endpoints, so could I suggest:\r\n/paths between the Local Endpoint and the Remote Endpoint/\r\n---\r\n/These options can come in the form of /\r\ncould this be written:\r\n/These options can take the form of /\r\n-- appears multiple times in the ID.\r\n---\r\n/Examples of options which may influence/\r\nshould be:\r\n/Examples of options that may influence/\r\n--\r\n/but that if this protocol is employed, a particular set of options should be used./\r\n- understood, is it even clearer (or not) as:\r\n/but that if this protocol is employed, a particular set of options should then be used./\r\n---\r\nIn Section: Establishment Actions and Data Transfer Objects and Actions and Termination Actions::\r\n- I read this as definitions of terms, but there is no syntax that helps someone understand this. Would it look foolish to include a colon or something after each term (as for the case currently defining message), so it is super clear that this is the defining para?\r\n---\r\nIn Section: Establishment Actions\r\n/Connection to a remote endpoint/\r\n- Could remote endpoint be capitalised here to be consistent with earlier?\r\n---\r\n/for example, to a TCP simultaneous open./\r\n- do we need an info reference here. (Sadly, many people will not know what this is).\r\n---\r\nIn Section: Data Transfer Objects and Actions\r\n/ Messages may or may not be usable if incomplete or corrupted. /\r\n- Agree, but not entirely clear, so I think we should explain to the reader. Could we say:\r\n/If a received Message is incomplete or corrupted, it may or may not be usable by a specific application./\r\n---\r\nIn Section: Transport System Implementation Concepts\r\n/the functionality of transport networking/\r\n- what is transport networking? - either define or rephrase, e.g. as:\r\n/the functionality required to provide a transport service across a network/\r\n---\r\nIn Section: Connection Group: \r\n/Connection Group: A Connections Group/\r\n- mixed single and plural, suggest:\r\n/Connection Group: A Connection Group/\r\n---\r\n/Path: A Path represents an available set of properties of a network route on which packets may be sent or received./\r\n- I'm not so happy with this. I know people use terms in various ways but to me this is not a route.\r\n- I'd prefer something like:\r\n/Path: A Path represents an available set of properties that a Local Endpoint may use to send or receive packets with a Remote Endpoint./\r\n---\r\nI think we need to define /candidate/ in some way, e.g. something like: a path or protocol identified in the gathering stage over which a connection may be attempted in the racing stage/.\r\n- Also I'd much prefer to actually the two terms (as we currently do in the earlier figure): \r\n/Candidate Gathering/\r\nand \r\n/Candidate Racing/\r\n---\r\nThe present contents of, provides a set of definitions which are fine...\r\n/Transport System Implementation Concepts/\r\n- but I really wonder if I could suggest something slightly different. I wonder if we could call this /Transport System Concepts/ and move this way forward in the document to provide a nice early introduction of these terms (with forward refs to sections where these are discussed - if that appeals.\r\n----\r\nThings I'd like to see in this section:\r\n/Transport System Implementation Concepts/\r\n- Can we add a couple of sentences on gathering and racing, just to explain this using the terms used in the /lifetime of a connection/ figure.\r\n- Can we create small subsections on /Cached State/ and /System Policy/\r\n----\r\nI think the subsection section titles below should be changed:\r\n/Gathering//Candidate Gathering/\r\nand \r\n/Candidate Racing/Candidate Racing/\r\n===================================================\r\n/### Message Framing, Parsing, and Serialization {#framing}/\r\n- This subsection appears out-of sequence. (Actually this could really help the reader if made a little easier to read and placed ahead of discussing the details). <<separate comment>>\r\n",
      "createdAt": "2018-06-01T08:20:16Z",
      "updatedAt": "2018-06-18T21:52:23Z",
      "closedAt": "2018-06-18T21:52:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this, we can discuss details in PR",
          "createdAt": "2018-06-18T21:52:23Z",
          "updatedAt": "2018-06-18T21:52:23Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWUzMjg0MjQ5MDM=",
      "title": "ARCH: Message Framing, Parsing, and Serialization",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/188",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Architecture",
        "help wanted"
      ],
      "body": "- This subsection appears out-of sequence. (Actually this could really help the reader if made a little easier to read and placed ahead of discussing the details).\r\n- I would like to express a preference for a rewrite of this section to use a simpler style of English.\r\n- I also would like consideration whether to position (at least parts of) this subsection earlier to explain why messages are being considered. If I read the spec without knowing more, an app developer could wonder what happened to the concept of streams and what I had lost.\r\n----\r\n/for transports that care about timing/\r\n- Is this transports that care, or applications that care?\r\n---\r\n/choosing what messages to retransmit/\r\nperhaps should be:\r\n/choosing which messages may be retransmitted/\r\n---\r\n/such as SCTP/\r\n- expand abbreviation on first use, and provide reference.\r\n---\r\n/message oriented API/message-oriented API\r\n---\r\n- I don't agree with this text:\r\n/To support a message oriented API, while still being compatible with stream-based transport protocols, implementations of the transport services architecture should provide APIs for framing and de-framing messages. That is, we push message framing down into the transport services API, allowing applications to send and receive complete messages./\r\n- Maybe a rewrite could separate what it means to have minimal support for messages and what additional API functions you could have to allow more advanced support for messages.\r\n- I think we agreed an API **could** do this, and I think we have to say this is optional. Here is a start at what I suggest:\r\n/A message-oriented API, can remain compatible with a stream-based transport protocol. An implementation of the transport services architecture could provide additional API functions for framing and de-framing of the messages. That is, ..../\r\n---",
      "createdAt": "2018-06-01T08:22:53Z",
      "updatedAt": "2019-03-25T12:16:14Z",
      "closedAt": "2019-03-25T12:16:14Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section being referenced no longer exists",
          "createdAt": "2019-03-25T12:16:14Z",
          "updatedAt": "2019-03-25T12:16:14Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWUzMjg0MjY4MTQ=",
      "title": "ARCH: Background/intro inadequate",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/189",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "To me the document is in very good shape, but there are several things that just appear, and a few short paras and maybe a simple picture could help avoid people giving-up before they know the document is useful to them.\r\n\r\nWe seem to not introduce it nicely, I'd suggest:\r\n+ This isn't scarey (draw a simple familiar figure to start our story, that the reader immediately recognises)\r\n+ Sockets v Streams ... we speak of messages, let's explain early that they ae all you need for any app.\r\n+ Events ... we know these are \"nromal\" - but let's say we provide an eevent-driven interface. it would even be worth saying why thsi is much better (Tommy - Apple have been doing this from the start, can you perhaps say why it is beautiful?)\r\n\r\nComments follow:\r\n\r\nSection:  Background.\r\n- The last part of this section suddenly introduces messages. I know it is just an example, but readers may be already looking here at whether this is an interface to TCP or UDP or something else ... and I think we do not really tackle that earlier enough. One way to help that would be to draw a diagram that looks something like this, in this section:\r\n\r\n  +-----------------------------------------------------+\r\n  |                    Application                      |\r\n  +------------------------+----------------------------+\r\n                           |\r\n  +------------------------|----------------------------+\r\n  |           Transport  Services  API                  |              \r\n  +------------------------|----------------------------+\r\n                           |\r\n  +------------------------|----------------------------+\r\n  |         Transport   System  Implementation          |\r\n  |                                                     |\r\n  |        e.g.,  UDP, TCP, SCTP, DCCP, QUIC, ...       |\r\n  +------------------------|----------------------------+\r\n\r\n  +------------------------|----------------------------+\r\n  |              Network Layer Interface                |\r\n  +-----------------------------------------------------+\r\n\r\nAnd the say that the Transport  Services  API provides message-oriented communication using transport protocols (e.g. UDP, TCP, etc). I'd also mention the words /data transfer/ somewhere.\r\n\r\nProviding a simpler earlier diagram may also be slightly easier on the new reader.\r\n---\r\nIn the same way, the intro should explain a little of the idea of /events/ - common enough to some, but may be unexpected for a new reader.",
      "createdAt": "2018-06-01T08:29:10Z",
      "updatedAt": "2018-10-16T20:58:52Z",
      "closedAt": "2018-10-16T20:58:52Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suspect you're already writing this sort of approach:\r\n\r\nI think it would be super nice if the background/intro text clearly had a para expalining that this is a call-back based API. I do suspect that many people coming to this will be atrracted because the new API is simple and provides a more modern interface. The rationale for why we design it to enable multiple transports, etc, is the \"detail inside the engine\" the fact it delivers what they want is the first point to make:-).",
          "createdAt": "2018-10-16T08:03:40Z",
          "updatedAt": "2018-10-16T08:03:40Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly does #236 close this issue?",
          "createdAt": "2018-10-16T10:52:31Z",
          "updatedAt": "2018-10-16T10:52:31Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram Yes, I think so.",
          "createdAt": "2018-10-16T20:58:52Z",
          "updatedAt": "2018-10-16T20:58:52Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWUzMjg1MTkwOTE=",
      "title": "Connection properties in \"Setting and Querying of Connection Properties\" are not well structured and underspecified",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/190",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API"
      ],
      "body": "In Section 9 \u2013 \"Setting and Querying of Connection Properties\" \u2013 the properties of an established connection and path are heavily underspecified.\r\n\r\nShould be fixed along with #153.",
      "createdAt": "2018-06-01T13:26:18Z",
      "updatedAt": "2018-07-02T07:20:18Z",
      "closedAt": "2018-07-02T07:20:18Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm working on this issue within our pull request for #153, using the terminology as simplified there.\r\n\r\nFor Section 9, I'm proposing the following:\r\n* An application can query Connection Properties on a connection.\r\n* Connection Properties include the status of the connection and whether it is possible to send and to receive data on it. (One of them might not be possible, e.g., in a unidirectional connection.)\r\n* Additionally, Connection Properties include the Connection's Transport Properties. \r\n* Transport Properties include Selection Properties, so the application can know which Protocol Selection Properties had been specified, and which ones are actually supported by the protocol that has been chosen.\r\n  * For Establishing connections (i.e., we are not done racing yet, the final protocols have not been selected yet), the application gets the Selection Properties that had been specified on the Preconnection earlier.\r\n  * For Established, Closing, or Closed connections (i.e., the protocols have been selected), the application learns whether the Selection Properties are actually provided by the selected protocols. For example, if the application specified earlier, \"Control Checksum Coverage: Prefer\", now it will get \"Control checksum coverage: True\", indicating that on this connection it can indeed control the checksum coverage.\r\n* Transport Properties also include Protocol Properties (Generic and Specific). These Protocol Properties can still be modified by the application. Basically, Protocol Properties are the only thing that the application can still set, everything else it can only query at this point.\r\n* Finally, the application can query properties of the path. Not sure how well we have to specify them, probably this part will be implementation-specific just like, e.g., the Interface Instance or Type.\r\n\r\nDoes everyone agree, or is there anything to discuss here?\r\nFor me this is not a big change, it's just putting what was already there in terms of #153. The only thing I'm wondering if whether the Protocol Selection Properties of the finally chosen protocols are still \"Selection Properties\", as the selection is already done. That's why they were called \"Transport Features\" before, but now I want less terms and they're almost the same thing...",
          "createdAt": "2018-06-22T12:37:12Z",
          "updatedAt": "2018-06-22T14:30:54Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK - so I commented on these things before - but in these things I think I agree. I'd personally prefer to keep the features as attributes implemented in the transport (etc) and the properties as the things requested. Indeed this begs the question about what to call the resulting transport when you selected properties and now get a transport. I think still calling them (for consistency) properties seems really good to me. :-).",
          "createdAt": "2018-06-22T12:43:55Z",
          "updatedAt": "2018-06-22T12:43:55Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWUzMjkwNzA5MTk=",
      "title": "Adjust status once it's clear...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/192",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "currently it's Informational",
      "createdAt": "2018-06-04T14:06:48Z",
      "updatedAt": "2018-08-31T14:04:42Z",
      "closedAt": "2018-08-31T14:04:42Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ISTM this should be Informational for Arch and Impl, and PS for API. I suspect we'll want to spend a little time discussing this on the agenda in Montreal.",
          "createdAt": "2018-06-19T09:32:29Z",
          "updatedAt": "2018-06-19T09:32:29Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "IMHO this  API really needs to be PS -one useful point is this can be cited by other organisations.\r\n\r\nI am not sure if arch should be PS to allow it also to appear outside the ietf ... but that\u2019s probably clearer when we understand the final shape. Imply is info.",
          "createdAt": "2018-06-19T10:01:49Z",
          "updatedAt": "2018-06-19T10:01:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that we should do:\r\n\r\n- Architecture: Informational\r\n- API: Proposed Standard\r\n- Implementation: Informational",
          "createdAt": "2018-06-19T15:31:51Z",
          "updatedAt": "2018-06-19T15:31:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From https://datatracker.ietf.org/meeting/102/materials/minutes-102-taps-00\r\n\r\nHum for interface:\r\n    Standards: (strong hum) (+1 from meetecho)\r\n    Experimental: (small hum)\r\nNo hum for informational\r\n\r\nHum for architecture:\r\n    Standards: (strong hum)\r\n Informational: (light hum)\r\n\r\nHum for implementation:\r\n   Informational: (strong hum)\r\n   Other track: (no hum)\r\n       ",
          "createdAt": "2018-08-31T14:01:22Z",
          "updatedAt": "2018-08-31T14:01:22Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWUzMzYyMTM5MjI=",
      "title": "Clones and entanglement",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/202",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "I previously agreed with this:\r\nThere is only one Protocol Property that is not entangled now I don\u2019t. \r\n\r\nHere is why.... I think the default for any per message action is independent to each cloned entity. Niceness is one aspect - relative priority and DSCP may fit here. So also I argue does checksum coverage. Is it possible a flow is cleaned and one clone used for video, one for audio? They may well present different coverage needs. Niceness:DSCP: coverage: TTL - for those datagram protocols where this is important.\r\n- Conversely : If all packets of clones follow the same path, you would NOT wish to separately manage the max packet size, or such path detail; these are shared by all clones: maximum size: time for aborting;\r\n- Alas this also makes me ask a more fundamental question: is capacity profile inherited the same by clones - and how do such things actually relate when the  multistream mode is used - to me this more tightly binds the steams. On this,  I would value opinions - because for udp I can see both ways, but ietf outputs suggest that for tcp and sctp there should be one capacity (dscp phb group if using this ) per flow/association, and I expect that also applies to quic.\r\n\u2014-",
      "createdAt": "2018-06-27T12:45:23Z",
      "updatedAt": "2018-08-27T13:42:24Z",
      "closedAt": "2018-08-27T13:42:24Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, I'm not sure I fully understand this - is the problem that so many properties *are* entangled, or is it that one isn't?  IIUC you say \"the former\". \r\n\r\nNow note, cloning and entanglement just represent multi-streaming. So a lot of things naturally must be \"entangled\"...\r\n\r\nThe capacity profile is configurable per-message, so that shouldn't be a problem.",
          "createdAt": "2018-06-27T16:18:20Z",
          "updatedAt": "2018-06-27T16:18:20Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Aha - I started things when I have very limited connectivity. Sorry. So trying to brief:\n\nI think there is more than niceness that is not entangled. \n\nI think I need more clarity on what it means to be cloned but not allow multi streaming.\n\nGorry\n\n> On 27 Jun 2018, at 18:18, mwelzl <notifications@github.com> wrote:\n> \n> First, I'm not sure I fully understand this - is the problem that so many properties are entangled, or is it that one isn't? IIUC you say \"the former\".\n> \n> Now note, cloning and entanglement just represent multi-streaming. So a lot of things naturally must be \"entangled\"...\n> \n> The capacity profile is configurable per-message, so that shouldn't be a problem.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2018-06-27T17:14:18Z",
          "updatedAt": "2018-06-27T17:14:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - more than niceness that is not entangled is fine, but mostly these will be things (I suspect) that can be adjusted per-message anyway, so why worry about them...\r\n\r\nWe're currently undergoing re-organization; I think considering something like this, which essentially means going through the properties one by one, is better done after Montreal.\r\n\r\nRegarding being cloned but not allow multi streaming: that combination doesn't make sense to me.",
          "createdAt": "2018-06-27T20:03:05Z",
          "updatedAt": "2018-06-27T20:03:05Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On this we seem to agree? And I think the test needs edit.\n\n- all per message actions are not entangled?\n... niceness is one example. To me the text needs improved, to be clear there are others.\n\n- check what is intended with multi streaming\n\nGorry - still on a poor link from a phone.\n\n> On 27 Jun 2018, at 22:03, mwelzl <notifications@github.com> wrote:\n> \n> Ok - more than niceness that is not entangled is fine, but mostly these will be things (I suspect) that can be adjusted per-message anyway, so why worry about them...\n> \n> We're currently undergoing re-organization; I think considering something like this, which essentially means going through the properties one by one, is better done after Montreal.\n> \n> Regarding being cloned but not allow multi streaming: that combination doesn't make sense to me.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2018-06-28T06:33:17Z",
          "updatedAt": "2018-06-28T06:33:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed!",
          "createdAt": "2018-06-28T07:50:08Z",
          "updatedAt": "2018-06-28T07:50:08Z"
        }
      ]
    },
    {
      "number": 203,
      "id": "MDU6SXNzdWUzMzYyMTQ2Mzk=",
      "title": "API: Max message / transmission size",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/203",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I am still unsure whether max message size is constrained by the discovered path MTU, or is more like the maximum data gram  payload size that can be passed. \r\n\r\nTo me: These could be quite different. After working on plpmtud, I now think we need both.\r\n\r\nThe words:\r\nThis property, if applicable, represents the maximum Message size that can be sent without incurring network-layer fragmentation and/or transport layer segmentation at the sender. \r\nLeaves me still uncertain because of the \u201cand/or\u201d\r\nAnother thing is the behaviour  of the value ...\r\n*  in tcp and over http  the use for this is a connection property, effectively agreeing the size of pdu to be exchanged over the connection at setup. Apps have no need to know the underlying value of the MSS.\r\n* Quite the converse for UDP/sctp/dcc where apps need to know and find out the max packet (data gram payload) size as they send during a flow. This changes with time and apps need to know this.\r\n",
      "createdAt": "2018-06-27T12:47:22Z",
      "updatedAt": "2018-10-16T11:57:52Z",
      "closedAt": "2018-10-16T11:57:52Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I am still unsure whether max message size is constrained by the discovered path MTU, or is more like the maximum data gram payload size that can be passed.\r\n\r\nI think it's the latter everywhere except in the part that you quote - the readable property \"Maximum Message size before fragmentation or segmentation\". There, it's about the Path MTU.\r\n\r\nThe value's behavior could be determined at run time, as it is queried for a connection. This is then for the implementation draft. The \"and/or\" translates into \"with P(LP)MTUD / without P(LP)MTUD\", I'd say.\r\n\r\nWhat's missing or wrong here?",
          "createdAt": "2018-06-27T16:14:24Z",
          "updatedAt": "2018-06-27T16:14:24Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I don\u2019t understand how that works. These are 2 different things\n\nGorry\n\n> On 27 Jun 2018, at 18:14, mwelzl <notifications@github.com> wrote:\n> \n> I am still unsure whether max message size is constrained by the discovered path MTU, or is more like the maximum data gram payload size that can be passed.\n> \n> I think it's the latter everywhere except in the part that you quote - the readable property \"Maximum Message size before fragmentation or segmentation\". There, it's about the Path MTU.\n> \n> The value's behavior could be determined at run time, as it is queried for a connection. This is then for the implementation draft. The \"and/or\" translates into \"with P(LP)MTUD / without P(LP)MTUD\", I'd say.\n> \n> What's missing or wrong here?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2018-06-27T17:16:01Z",
          "updatedAt": "2018-06-27T17:16:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's a moot point to discuss: clearly, the text is too confusing as it is. We should clear it up.",
          "createdAt": "2018-06-27T20:05:17Z",
          "updatedAt": "2018-06-27T20:05:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I now tried to fix this in the text. After careful consideration, my fantastic update was to only change \"and/or\" into \"or\" in the text that we were discussing. That is, the description of the property \"Maximum Message size before fragmentation or segmentation\" now reads: \"This property, if applicable, represents the maximum Message size that can be sent without incurring network-layer fragmentation or transport layer segmentation at the sender.\"  (check https://github.com/taps-api/drafts/blob/master/draft-ietf-taps-interface.md if you want to take a look - it seems that the scripts that create the nicely formatted page at https://taps-api.github.io/drafts/draft-ietf-taps-interface.html have stopped).\r\n\r\nSo let's see if this is clear: my understanding is that the three read-only properties \"Maximum message size concurrent with Connection establishment\", \"Maximum Message size on send\" and \"Maximum Message size on receive\" mean the maximum datagram payload size that can be passed. That's also what the text says.\r\n\r\nNow, to have some control on fragmentation, one may also want to ask for (and maybe get: \"N/A\") the maximum message size that can be passed without incurring fragmentation in the sender or in the network. That is, the transport system would have to give back the PMTU minus header overhead to the application - it's the maximum payload that won't lead to fragmentation anywhere. This is the information provided by the property \"Maximum Message size before fragmentation or segmentation\".\r\n\r\nWhile I'm not sure we need to use the words \"segmentation\" here, else I would think the description of this transport property already says that clearly enough?!  I mean, what's the application got to do with the PMTU itself, of course \"message size\" is about the message that the application is dealing with. I think that's implicitly clear because all is about specific \"messages\" here, which are passed from applications to the transport system and back.",
          "createdAt": "2018-08-31T13:51:26Z",
          "updatedAt": "2018-08-31T13:52:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm not quite sure where we have arrived, so let me try some points/questions:\r\n\r\n\u2022 Maximum Message size before fragmentation or segmentation\r\n- OK. I'd imagine this is the MPS specified  in DPLPMTUD. You could get a value for TCP, but I am not sure what the TCP PMTU or even the MSS means to an App using TCP or TLS.\r\n- This changes when the PLPMTU/PMTU algorithm updates.\r\n- This only has impact when \"DF\" is set for IPv4 and there is no endpoint frag.\r\n\r\n\u2022 Maximum Message size on send\r\n- OK. This is the largest size you can send:-), For Datagram transports is this the Min of (the largest size I can send, and the largest size an endpoint can reassemble)?\r\n- It sounds like this is frozen on connect.\r\n\r\n\u2022 Maximum Message size on receive\r\n- Is this the largest size an endpoint can reassemble?\r\n- It sounds like this is frozen on connect.\r\n\r\nSo.....\r\nIs there a property that says the message is (non)fragmentable? (DF in IPv4 and no endpoint frag).\r\n- clearly that only has an action if you do not use TCP, TLS, etc.\r\n\r\nDo we assume the App does not do PLPMTU (in which case we need to be able to send probes>MPS and to set DF), and expect that to run beneath TAPS (where we may not need to worry)?\r\n",
          "createdAt": "2018-09-06T11:35:30Z",
          "updatedAt": "2018-09-06T11:35:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n> On Sep 6, 2018, at 1:35 PM, Gorry Fairhurst <notifications@github.com> wrote:\n> \n> I'm not quite sure where we have arrived, so let me try some points/questions:\n> \n> \u2022 Maximum Message size before fragmentation or segmentation\n> \n> OK. I'd imagine this is the MPS specified in DPLPMTUD. You could get a value for TCP, but I am not sure what the TCP PMTU or even the MSS means to an App using TCP or TLS.\n> This changes when the PLPMTU/PMTU algorithm updates.\n> This only has impact when \"DF\" is set for IPv4 and there is no endpoint frag.\nYes to all!\n\n> \u2022 Maximum Message size on send\n> \n> OK. This is the largest size you can send:-),\nYes\n\n> For Datagram transports is this the Min of (the largest size I can send, and the largest size an endpoint can reassemble)?\nIt\u2019s the largest size you can send, as exposed by the transport (if available). It would be reasonable to implement this as you say, but I don\u2019t know of any implementation that can do that.\n(the abstract APIs of the protocols we considered in RFC 8303 and RFC 8304 don\u2019t expose such a thing, or we missed it, which would surprise me).\n\n> It sounds like this is frozen on connect.\nYes\n\n> \u2022 Maximum Message size on receive\n> \n> Is this the largest size an endpoint can reassemble?\nI guess so; in case of UDP, I would think it is GET_MMS_R from RFC 8304.\n\n> It sounds like this is frozen on connect.\nYes\n\n\n> So.....\n> Is there a property that says the message is (non)fragmentable? (DF in IPv4 and no endpoint frag).\n> \nNo !!!\nFrom minset, we must have that - either we had it and accidentally lost it in the updates, or we forgot to include it. Great catch!\n\n\n> clearly that only has an action if you do not use TCP, TLS, etc.\n> Do we assume the App does not do PLPMTU (in which case we need to be able to send probes>MPS and to set DF), and expect that to run beneath TAPS (where we may not need to worry)?\n> \nI don\u2019t think we should make this assumption, given that PLPMTU using UDP options isn\u2019t available everywhere yet. This way, DPLPMTUD could be rolled out gradually underneath, providing an MPS value when it\u2019s available, and when that is available, it\u2019s reasonable for the application to assume that some form of PMTUD is happening and it doesn\u2019t need to do this job.\n\nCheers,\nMichael\n\n",
          "createdAt": "2018-09-06T12:13:01Z",
          "updatedAt": "2018-09-06T12:13:01Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK so one thing is we spotted a need for something (a flag, I'll call flag1) to trigger DF, etc. I think we agree.\r\n\r\n(1) When an endpoint sends a datagram and uses DPLPMTUD or PMTU for datagrams, it will by default send packets less than the MPS that set the DF flag in IPv4 and instruct the stack to not perform endpoint fragmentation of datagrams. A datagram app can explicitly clear that mode and permit fragmentation to take place. If an App can get an MPS from the OS, then it should use this.\r\n\r\n(2) And this is how that (kindof) works:\r\n* Some stacks do maintain a host cache and use something link PMTU or at least black hole detection to store a value per IP address(es). I suspect much of this machinery is broken in a world where ICMP messages are dropped and ECMP is common, but PMTUD basically works by clearing the cache periodically and waiting to see if it gets an ICMP message. If it exists this cache seems to be the basis for a \"legacy\" stack to give you a value for \"Maximum Message size before fragmentation or segmentation\". That's all OK.  If DPLPMTUD happens to be enabled lower in the stack (in SCTP, UDP-Options, etc) then this will all work as expected:-).\r\n\r\n(4) However in theory an app could also perform DPLPMTUD :\r\n* I'm not convinced datagram apps do perform DPLPMTUD at the app layer (but would love examples)  - you would then need at least to set the above flag1 to force DF and no endpoint fragmentation, but then also need to set another \"flag2\", to tell the stack that the host cache entry is not to be used for this specific datagram. This \"flag2\" is what lets the app send a probe packet larger than the cached (PL)PMTU, and starting with this is what could finally trigger an increase in the MPS by raising the (PL)PMTU (which would require yet another call to do update the cache).  I'm unsure of the current availability and degree of standardisation of these extra flags in current stacks, and how you would tell the stack that PMTUD shouldn't be done, because the app is doing PLPMTUD...\r\nSomeone who understands a range of OS'es may help me... ?\r\n\r\nSo...  My starting suggestion is for TAPS to document it as if PMTUD or PLPMTUD is done lower in the stack (i.e. (1) assuming (2) being done) and to stay quiet for the moment about (3).\r\n\r\nWhat do you think?\r\n\r\nGorry\r\n",
          "createdAt": "2018-09-06T13:42:36Z",
          "updatedAt": "2018-09-06T13:42:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi,\n\n\n> On Sep 6, 2018, at 3:42 PM, Gorry Fairhurst <notifications@github.com> wrote:\n> \n> OK so one thing is we spotted a need for something (a flag, I'll call flag1) to trigger DF, etc. I think we agree.\n> \n> (1) When an endpoint sends a datagram and uses DPLPMTUD or PMTU for datagrams, it will by default send packets less than the MPS that set the DF flag in IPv4 and instruct the stack to not perform endpoint fragmentation of datagrams. A datagram app can explicitly clear that mode and permit fragmentation to take place. If an App can get an MPS from the OS, then it should use this.\n> \nI agree.\n\n> (2) And this is how that (kindof) works:\n> \n> Some stacks do maintain a host cache and use something link PMTU or at least black hole detection to store a value per IP address(es). I suspect much of this machinery is broken in a world where ICMP messages are dropped and ECMP is common, but PMTUD basically works by clearing the cache periodically and waiting to see if it gets an ICMP message. If it exists this cache seems to be the basis for a \"legacy\" stack to give you a value for \"Maximum Message size before fragmentation or segmentation\". That's all OK. If DPLPMTUD happens to be enabled lower in the stack (in SCTP, UDP-Options, etc) then this will all work as expected:-).\nI agree, and I can imagine that it would work like this.\n\n> (4) However in theory an app could also perform DPLPMTUD :\n> \n> I'm not convinced datagram apps do perform DPLPMTUD at the app layer (but would love examples) - you would then need at least to set the above flag1 to force DF and no endpoint fragmentation, but then also need to set another \"flag2\", to tell the stack that the host cache entry is not to be used for this specific datagram. This \"flag2\" is what lets the app send a probe packet larger than the cached (PL)PMTU, and starting with this is what could finally trigger an increase in the MPS by raising the (PL)PMTU (which would require yet another call to do update the cache). I'm unsure of the current availability and degree of standardisation of these extra flags in current stacks, and how you would tell the stack that PMTUD shouldn't be done, because the app is doing PLPMTUD...\n> Someone who understands a range of OS'es may help me\u2026 ?\n\nThis is where I get lost. I think today, we have essentially TCP and UDP-based applications (I\u2019m not mentioning (D)TLS because I don\u2019t know how these things work with (D)TLS). In case of TCP, the application doesn\u2019t need flag1 or flag2 because the any form of PMTUD is not the application\u2019s business. In case of UDP, DPLPMTUD doesn\u2019t exist (sorry - surely soon it will !  but this paragraph started with \u201ctoday\u201d\u2026), so IF an application cares about efficiency, it has no other choice but to set DF and do PMTUD. I don\u2019t know if any apps do that but if you consider QUIC or SCTP/UDP etc. as an app over UDP today, I\u2019d sure hope they do that.\n\nIn the TCP case, neither flag1 nor flag2 are needed. In the UDP case, your flag2 is not needed because nobody does PLPMTU for you below you, so far.\n\n> So... My starting suggestion is for TAPS to document it as if PMTUD or PLPMTUD is done lower in the stack (i.e. (1) assuming (2) being done) and to stay quiet for the moment about (3).\n> \n> What do you think?\n> \nAssuming your (4) above is the (3) that you mean here\u2026.\nI agree that a TAPS system should exhibit the behaviour your describe in (1).\nAbout (3) (or (4) :) ), it seems to me that your \u201cflag2\u201d is something that should perhaps be included in draft-ietf-tsvwg-datagram-plpmtud if it\u2019s not in there yet?\n\nCheers,\nMichael\n\n",
          "createdAt": "2018-09-06T14:44:47Z",
          "updatedAt": "2018-09-06T14:44:47Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I'm following this correctly, I think the point is that if you use a real transport then it's a transport feature that is hidden from the app. If you use UDP (which is not a transport) you may have to implement it yourself. I think UDP is a special case here and as such this flag is a protocol/UDP-specific configuration.",
          "createdAt": "2018-09-06T15:01:35Z",
          "updatedAt": "2018-09-06T15:01:35Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "That's very annoying: UDP **IS** a transport!\r\n\r\nThat aside, a UDP-App needs to decide what to do - at least for IPv4, there may be good reasons to not set DF and allow fragmentation.\r\n\r\nIf you say tunnels and user-land stacks can not be used over the top of TAPS then, maybe you can manage without the flags. That depends on what can be layered over \"UDP\".\r\n\r\nGorry",
          "createdAt": "2018-09-06T15:17:54Z",
          "updatedAt": "2018-09-06T15:17:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak SCTP can do this too: https://tools.ietf.org/html/rfc6458#page-68\r\nI guess this can be generally helpful as part of Application-Layer Framing.\r\n\r\nI conclude that we really want a \"Don't Fragment\" Message Property.",
          "createdAt": "2018-09-06T15:57:13Z",
          "updatedAt": "2018-09-06T15:57:13Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Filed DF as #226, lets' move discussion on that over there. Once we have that, is there anything left here?",
          "createdAt": "2018-09-07T06:24:38Z",
          "updatedAt": "2018-09-07T06:24:38Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks! I think that's the only thing. Gorry?",
          "createdAt": "2018-09-07T06:58:57Z",
          "updatedAt": "2018-09-07T06:58:57Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "#226 is a good idea.\r\n\r\nI think we can decide that users of the TAPS API can't do application-layer PLPMTUD, and currently rely on this being provided below the TAPS interface. That may be OK for now, we have to somehow stop the API growing wider and wider.\r\n",
          "createdAt": "2018-09-07T07:25:08Z",
          "updatedAt": "2018-09-07T07:25:08Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What? Decide that they *can't* do app-layer PMTUD? But I think we must make it possible for them to do it, and that's what the \"don't fragment\" + \"max size before fragmentation\" things are about.",
          "createdAt": "2018-09-07T13:59:36Z",
          "updatedAt": "2018-09-07T13:59:36Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "We are not in synch. That happens. I'll try again:\r\n\r\n(1) To utlise PMTUD (at the IP layer) or PLPMTUD (below the TAPS API), then you need to set DF and disable source fragmentation. I think this should be the default. Packets will fail when larger than the \"max size before fragmentation\" size, and therefore it is really helpful for the user of the TAPS service to know that. In some cases, the MPS can be too small for an app (even ridiculously small for IPv4), apps have a choice to clear the flag to potentialy trigger source/network fragmentation. #226  is about this.\r\n\r\n(2) To *implement* PLPMTUD/DPLPMTUDin an app above TAPS will need more functions at the API (to over-ride the host cache, and  either reset the host-cache or disable network PMTUD). I was asking whether there is an important need to add this to our TAPS interface, and I suggest we could decide to be silent on this topic in this spec. ",
          "createdAt": "2018-09-07T15:16:33Z",
          "updatedAt": "2018-09-07T15:16:33Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for explaining!\r\n\r\nSo it seems to me that this is still not resolved. I would like to make it possible for a system underneath the TAPS API to implement PMTUD (which it will signal by providing a value via \"max size before fragmentation\") AND for the application itself to implement PMTUD.\r\n\r\nAbout 1: I agree, in principle - but there's one exception: I don't know how it would be handled in case of TCP. Here, you can't get any reasonable number back in \"max size before fragmentation\" and you should be allowed to send arbitrarily large messages if you want. So, JUST because of TCP, I would NOT make \"set DF and disable source fragmentation\" the default.\r\n\r\nAbout 2: Here I don't understand why you need to over-ride or reset the host cache - because, which protocol are you talking about? For TCP, we shouldn't be doing this anyway. For UDP, right now, there isn't any functionality below, so why would it not work to implement PMTUD in the application based on what we have right now?\r\n\r\nIf your wish is to support UDP PMTUD underneath TAPS, I understand that, and I imagine that it complicates things a little, and I'd agree to be silent about this *for now*. We could get back to this discussion later.\r\n\r\nDoes that make sense?",
          "createdAt": "2018-09-07T15:32:56Z",
          "updatedAt": "2018-09-07T15:32:56Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm not explaining well:\r\n\r\nI think we agree:  \"max size before fragmentation\" and teh flag allows a system underneath the TAPS API to implement PMTUD.\r\n\r\nTCP needs to return the largest message it can support - presumably the socket buffer size? or perhaps infinite for a stream? I think TCP ignores the flag and interanlly always behaves as if the \" \"set DF and disable source fragmentation\"\" was true. It fragments at the transport, not network layer.\r\n\r\nI'll explore (2) in some real OS code, but for me, that's a story for later, not now.\r\n\r\nGorry",
          "createdAt": "2018-09-07T18:39:39Z",
          "updatedAt": "2018-09-07T18:39:39Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, I think we have converged. Thanks!",
          "createdAt": "2018-09-07T20:35:50Z",
          "updatedAt": "2018-09-07T20:35:50Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWUzMzYyMTUwODg=",
      "title": "Api: more bits",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/204",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\r\nText:\r\nInternally, the transport system will first exclude all protocols and paths that match a Prohibit, then only keep candidates that match a Require, then sort candidates according to Preferred properties, and then use Avoided properties as a tiebreaker. \r\n- does not read correct for me... I understand excluding prohibit, but the action on require seems wrong. I expected to remove candidates with prohibit and remove candidates that do NOT have require. What is written is different.\r\n\u2014-\r\nI would prefer a para break before:\r\nThe Rendezvous() Action causes the\r\n- to show the change of topic.\r\n\u2014\r\nRefs needed:\r\nSIP or WebRTC\r\n\u2014\r\nmaximum Message size\r\n- should this be capitalised? What is maxlen? The same value? Of different?\r\n\u2014-\r\nI could not finally understand what is intended by this text;\r\nThe exact disposition of the Message when the Sent Event occurs is specific to the implementation and the constraints on the Protocol Stacks implied by the Connection's Transport Properties.",
      "createdAt": "2018-06-27T12:48:42Z",
      "updatedAt": "2018-07-02T07:55:15Z",
      "closedAt": "2018-07-02T07:55:15Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWUzNDE4OTg4NjU=",
      "title": "Define the server-side equivalent of racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/206",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "csperkins"
      ],
      "labels": [
        "API",
        "Architecture",
        "ready for text"
      ],
      "body": "When `Preconnection.Initiate()` is called, the stack picks candidates and races them, selecting the \"best\" one.\r\n\r\nWhen `Preconnection.Listen()` is called, does the stack listen on *all* non-prohibited candidates, or the first _n_ candidates in order of preference, or...?\r\n\r\nThis needs to be explicitly addressed both in -arch and -interface.\r\n\r\n(thanks Zahed for raising this at the TSV dinner)",
      "createdAt": "2018-07-17T12:31:52Z",
      "updatedAt": "2019-11-21T05:01:41Z",
      "closedAt": "2019-11-21T05:01:41Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, haven't done this yet for protocols, but I've been working on this recently for path listening. The approach there is:\r\n\r\n- Create the same preconnection settings with preferences for which paths/Interfaces/etc are allowed to be used\r\n- When you do candidate gathering, you get a list of all eligible interfaces for listening\r\n- Open a sub-listener on each of these interfaces (we call the sub-listener an \"Inbox\")\r\n- Watch the candidate list, and remove and add inboxes as necessary",
          "createdAt": "2018-07-17T13:05:58Z",
          "updatedAt": "2018-07-17T13:05:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another area in which we do some interesting dynamic inbox work is when you use multiplexed protocols: say you are listening for new HTTP2/TLS/TCP connections on a TCP-level \"Inbox\"; when you get one, you can also start listening for extra streams on those connections as an HTTP2-level \"Inbox\". Thus there is precedent for listening for specific things based on interactions of other connections. Could be useful?",
          "createdAt": "2018-07-17T13:08:22Z",
          "updatedAt": "2018-07-17T13:08:22Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly I think it is useful.\r\nThe problem I see is that doing so will force us to fully model what pseudo-transports are and how they work.  That is definitely useful but adds another layer of complexity. We have to decide whether to include this in the API or build this as a layer on top.",
          "createdAt": "2018-07-18T22:37:11Z",
          "updatedAt": "2018-07-18T22:37:11Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also needed to implement ICE.",
          "createdAt": "2018-07-23T12:45:07Z",
          "updatedAt": "2018-07-23T12:45:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wonder why this has the API label: ISTM that nothing in the current API draft contradicts implementing what @tfpauly says in his first message above. There are Preconnections, with various preferences, from which Connections are established via Active or Passive Open - so it should be expected that any preferences chosen on the Preconnections also apply when Listening.\r\n\r\nRegarding @tfpauly's second message (\"Thus there is precedent for listening for specific things based on interactions of other connections. \"), if I got this right, you want to be able to prefer \"Listen\" to operate on streams from an already existing connection.\r\n\r\nAs a TAPS user, couldn't I implement this by using \"Clone\" on the first connection and not even calling Listen on it - now, the sender could send me data? If I want to be less strict and additionally allow other incoming Connections (in case the sender isn't muxing Connections), I can also issue a Listen on a new Preconnection.",
          "createdAt": "2019-01-23T10:06:01Z",
          "updatedAt": "2019-01-23T10:06:01Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's API because we need a way to get the listening candidates from the TAPS system, before the racing starts, so we can communicate them to the peer via some indirect channel for rendezvous. This is likely `Resolve()`, but we need to confirm this works and specify all the details.",
          "createdAt": "2019-01-24T23:27:22Z",
          "updatedAt": "2019-01-24T23:27:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah ok!  I thought this might be a reason but I don't know enough about the rendezvous procedure.",
          "createdAt": "2019-01-25T08:14:55Z",
          "updatedAt": "2019-01-25T08:14:55Z"
        },
        {
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "should be considered with #282 ",
          "createdAt": "2019-03-25T12:17:47Z",
          "updatedAt": "2019-03-25T12:17:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also note that while it already happens implicitly for socket listeners, listening on multiple interfaces and addresses by default needs to be specified.",
          "createdAt": "2019-03-25T12:19:11Z",
          "updatedAt": "2019-03-25T12:19:11Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWUzNDIwNzI3ODQ=",
      "title": "There is no Selection Property for Preservation of Message Boundaries ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/207",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Just realized that during Tommy's Presentation",
      "createdAt": "2018-07-17T20:29:54Z",
      "updatedAt": "2019-02-20T08:17:29Z",
      "closedAt": "2019-02-20T08:17:29Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "not clear this is necessary for the Bangkok rev, unless someone has cycles to send a PR, so dropping milestone.",
          "createdAt": "2018-10-19T09:28:34Z",
          "updatedAt": "2018-10-19T09:28:34Z"
        }
      ]
    },
    {
      "number": 208,
      "id": "MDU6SXNzdWUzNDI4Nzk4OTQ=",
      "title": "Re-Structure Transport Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/208",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "After getting a better understanding, we need to push the properties in a next-step structure.\r\n\r\nWe actually agreed on three kinds of Properties:\r\n - Selection Properties (stuff that effects the pre-connection)\r\n - Connection Properties (stuff that effects the connection)\r\n - Message Properties (stuff that effects the individual message)\r\n\r\nEach of them can be set on the objects above in the list and are used as defaults then.\r\n\r\nEach property will be marked as specific (clear protocol specific meaning) or generic (needs implementation and protocol specific meaning, but otherwise consistent behavior).\r\nMore fancy Intents are deferred to another layer above the TAPS system.\r\n\r\nSelection Properties requesting per-Message behavior are just cross-references.",
      "createdAt": "2018-07-19T20:36:23Z",
      "updatedAt": "2018-12-03T10:35:34Z",
      "closedAt": "2018-12-03T10:35:34Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see the resolution to #218; I would also suggest moving protocol selection properties up to a section closer to the pre-establishment phase section of the document. I didn't see a response from @philsbln today so I didn't do this, not wanting to collide with any work you may have in progress. I'll probably get cycles to do this again on 15.10. though if you like; I would like to get these out for -03. ",
          "createdAt": "2018-10-10T16:16:17Z",
          "updatedAt": "2018-10-10T16:16:17Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fine with me \u2013 please retain data types when moving and leave overview in Section 12 analogous to the other properties.\r\n\r\nAs soon as I get spare cycles again, I will turn Section 12 in a proposal for a registry",
          "createdAt": "2018-10-13T21:05:06Z",
          "updatedAt": "2018-10-13T21:05:06Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Taking the token here. Note that Section 12 will largely be replaced a list/table showing relationships among properties and containing references back into the document where each property (split by class) will be defined. \"Classification\" will then disappear in the text, being implicit in the document structure.",
          "createdAt": "2018-10-16T08:41:51Z",
          "updatedAt": "2018-10-16T08:41:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "will keep this open until there's consensus on the restructure; removing assignments and milestones to reflect that this is the state we'll have for BKK though.",
          "createdAt": "2018-10-17T07:53:30Z",
          "updatedAt": "2018-10-17T07:53:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we had consensus before and in BKK, so I'm closing this.",
          "createdAt": "2018-12-03T10:35:24Z",
          "updatedAt": "2018-12-03T10:35:24Z"
        }
      ]
    },
    {
      "number": 209,
      "id": "MDU6SXNzdWUzNDI4OTQ1OTE=",
      "title": "Add a few example of Specific Properties ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/209",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We should add a few examples of TCP/UDP/SCTP specific properties to demonstrate how these work and have a guideline for additional mapping documents",
      "createdAt": "2018-07-19T21:23:47Z",
      "updatedAt": "2019-03-25T12:25:03Z",
      "closedAt": "2019-03-25T12:25:03Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is in \u00a79.1.12, so we're done.",
          "createdAt": "2019-03-25T12:25:03Z",
          "updatedAt": "2019-03-25T12:25:03Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "MDU6SXNzdWUzNDI4OTUyNzk=",
      "title": "Do we need an IANA Registry of Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/210",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "We will end up with a set Turns out we might need a lot of (protocol) specific properties, we should discuss whether we need an IANA registry of properties and how this will look like.\r\n\r\n - Include Types ?\r\n - Include Names ?\r\n - Some numeric representation ?\r\n\r\nWhat do we do with ENUM values?",
      "createdAt": "2018-07-19T21:26:22Z",
      "updatedAt": "2018-09-07T06:25:45Z",
      "closedAt": "2018-09-07T06:25:45Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't really understand why we would need a registry. Who would be using the registry?",
          "createdAt": "2018-07-19T21:27:20Z",
          "updatedAt": "2018-07-19T21:27:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that a registry seems unnecessary; this is not a matter of protocol or on-the-wire standard. ",
          "createdAt": "2018-07-19T22:07:29Z",
          "updatedAt": "2018-07-19T22:07:29Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we don't want to clutter the basic API document, we will end up having at least a half a dozen documents defining specific properties for different protocols.\r\nDoes anyone have a good alternative to collect all these except in an IANA registry?",
          "createdAt": "2018-07-19T22:23:25Z",
          "updatedAt": "2018-07-19T22:23:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We do *not* need to have documents specify every property. Implementation should be allowed to extend as they need.",
          "createdAt": "2018-07-19T22:40:38Z",
          "updatedAt": "2018-07-19T22:40:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this discussion does suggest that we might want to be more explicit up front in the interface document about the scope and purpose of the document (i.e. this is meant primarily to define a standard API \"shape\", not the particular strings and codepoints, etc.). I'll file an issue.\r\n",
          "createdAt": "2018-07-20T12:04:49Z",
          "updatedAt": "2018-07-20T12:04:49Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @tfpauly that we don't need to document every property, and with @britram that we're documenting the shape of an abstract API, *but* I also see value in consistent property naming across concrete implementations of that API. Some form of registry might make sense here.",
          "createdAt": "2018-07-23T12:40:02Z",
          "updatedAt": "2018-07-23T12:40:02Z"
        },
        {
          "author": "adfalk",
          "authorAssociation": "NONE",
          "body": "This seems like a topic for the mail list rather than GH.\n\n--aaron\n\nOn 23 Jul 2018, at 8:40, Colin Perkins wrote:\n\n> I agree with @tfpauly that we don't need to document every property, \n> and with @britram that we're documenting the shape of an abstract API, \n> *but* I also see value in consistent property naming across concrete \n> implementations of that API. Some form of registry might make sense \n> here.\n>\n> -- \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/taps-api/drafts/issues/210#issuecomment-407043981\n\n\n",
          "createdAt": "2018-07-23T17:53:38Z",
          "updatedAt": "2018-07-23T17:53:38Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "per list discussion, ISTM this is a maybe? But in any case not now, because it can easily be done in a separate document, and the API doesn't need it to be complete.",
          "createdAt": "2018-09-07T06:25:45Z",
          "updatedAt": "2018-09-07T06:25:45Z"
        }
      ]
    },
    {
      "number": 211,
      "id": "MDU6SXNzdWUzNDMxMTYyOTE=",
      "title": "Be explicit about what the interface defines and does not define",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/211",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Now that the document is targeted for the standards track, its purpose (i.e. what exactly it standardizes, and what it does not) should be made clear. This is made a little more difficult because, as an abstract API we intend to be implementable in any reasonable language (i.e. no brainfuck kthxbye), \r\n\r\nHere's what I think the scope is:\r\n\r\n- message-orientation\r\n- asynchronicity of event and reception\r\n- asynchronicity of resolution and initiation\r\n- the \"shape\" of the API: objects and events, and interactions between them, with a RECOMMENDATION that you use the same names (\"unless this facility is implemented in terms of a networking interface that already has different names or naming conventions for equivalent objects\" or something like that).\r\n- an MTI set of selection, connection, and message properties, and definitions (though not names) of these properties. \r\n- a larger fully defined set of selection, connection, and message properties, such that if a system implements a given property it must implement it as described.\r\n",
      "createdAt": "2018-07-20T13:53:35Z",
      "updatedAt": "2018-10-18T07:48:06Z",
      "closedAt": "2018-10-18T07:48:06Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why would we not want to make a recommendation on the names of properties? We'll need to name them in the drafts anyway, if we're to cross-reference them from elsewhere, and at that point there's no benefit in not recommending re-use of those names in concrete API implementations.",
          "createdAt": "2018-07-23T12:44:11Z",
          "updatedAt": "2018-07-23T12:44:11Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think providing consistent naming across different implementations will be a key argument for the adoption of the abstract interface. The strongest argument for sticking to BSD Sockets is that they somehow look the same on all platforms. We should not miss the change to at least give recommendations about how to name the individual objects and properties. Implementations can and should extend and divert from it where it makes sense, but recommending names should help the individual APIs look at least similar. \r\n",
          "createdAt": "2018-09-06T12:38:39Z",
          "updatedAt": "2018-09-06T12:38:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are different kinds of things we can recommend names for.\r\n\r\n- objects \r\n- actions\r\n- events \r\n- properties\r\n\r\nWe have pretty good recommendations for the first three (though different languages have e.g. different capitalization conventions). Names of properties are descriptive, though, and would make bad code names, so if we want to do the fourth we have some work to do.\r\n\r\nWhat I would propose to do for Bangkok: assume we recommend names for the first three, open an issue for recommended property names (which is necessary for @philsbln's registry project anyway).",
          "createdAt": "2018-10-17T08:26:03Z",
          "updatedAt": "2018-10-17T08:26:03Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWUzNDgzOTA3NDY=",
      "title": "Consider per-context addresses as suggested by draft-gont-taps-address-usage-*",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/212",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "The discussion around ``draft-gont-taps-address-usage-problem-statement`` and ``draft-gont-taps-address-usage-analysis``suggests that it should be possible to request per-application / per-context / per-connection source addresses.\r\n\r\n - For the cases of per-application and per-connection source addresses, this can be tuning this can be accomplished by the addition of a property. This includes name-resolution issues.\r\n - For per-context source addresses, I am not sure whether our current architecture is fit to support this.\r\n\r\nConsider the following case: a browser wants to separate different tabs onto different source addresses. It needs some way to specify some kind of *context* to allow the transport API either to assign the right address to a new connection or request a new address for all upcoming connections and name resolutions done within this context.\r\nAs this is orthogonal to multi-streaming, simply cloning an existing connection is not sufficient.\r\n\r\nOne possible solution would be to introduce some new \"Taps Context\" that is used when creating pre-connections, but that looks like overkill for this feature\u2026",
      "createdAt": "2018-08-07T16:12:28Z",
      "updatedAt": "2019-03-25T12:28:42Z",
      "closedAt": "2019-03-25T12:28:42Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing on lack of activity. This is a good thought experiment to see if the API is flexible enough to support it. However, see #300 for specific handling of privacy addresses in V6.",
          "createdAt": "2019-03-25T12:28:30Z",
          "updatedAt": "2019-03-25T12:28:30Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWUzNTczMTY4MzU=",
      "title": "P* discussion",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/218",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A bunch of the taps authors had a breakfast meeting at some point in Montreal and while I wasn't able to find any minutes or notes about this, I do think we reached some kind of agreement on some parts of the P(arameter|roperty|referenc) discussion. Here is what I memorize:\r\n\r\n- There are no P*s that can be per connection and per message. Everything that is currently scoped for connections and messages should be split up into two different things with different names because it is not the same.\r\n\r\n- All P\\*s that a scoped for connections also are in scope for a preconnection, however, (1) this is not true the other way around, and (2) preconnection P\\*s are rather \"preferences\" and connection P*s are either configuration, meaning you can change them during the life of a connection, or fixed settings that you can only retrieve for your information but have been set in the preconnection phase.\r\n\r\n- Protocol-specific P* are special and kind of \"free-form\"/implementation specific. I think we actually need to further discuss how to implement/use them at some point (Do I need to specify a set of protocol P* for every possible protocol at preconnection time or does the protocol P* I specify impact my protocol selection? I think it's a bit confusing for the user if you can specify a bunch of e.g. TCP P* and then get a QUIC connection back...) but I guess that's a separate issue...\r\n\r\n- Most things that are currently classified as intents are probably not part of taps but might be implemented in a high (shim-)library that can translate these intents into P*s.\r\n\r\nDoes that sound about right? Any further thoughts?\r\n\r\n",
      "createdAt": "2018-09-05T16:52:54Z",
      "updatedAt": "2018-12-03T10:36:44Z",
      "closedAt": "2018-12-03T10:36:44Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, I guess there is also something like system configuration which I guess we have mostly ignored so far...?",
          "createdAt": "2018-09-05T17:50:10Z",
          "updatedAt": "2018-09-05T17:50:10Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to #208 ",
          "createdAt": "2018-09-05T20:02:42Z",
          "updatedAt": "2018-09-05T20:02:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to not sharing P* between Connection and Message\r\n\r\nYes, this seems like a good summary!",
          "createdAt": "2018-09-06T03:43:54Z",
          "updatedAt": "2018-09-06T03:43:54Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think this and #208 is what we agreed on.\r\nAlso, I wrote down that we wanted to make sure every generic property has a deterministic mapping to a specific protocol behavior (in the implementation draft?).\r\n\r\nI hope we can agree on whether to call them Properties or Parameters soon, too - P* confuses me...",
          "createdAt": "2018-09-06T07:58:13Z",
          "updatedAt": "2018-09-06T07:58:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks a lot Mirja for this summary. Clearly you had a constructive meeting - I agree with all these outcomes. Just one thing, about protocol-specific properties: there are in fact a couple of things in our whole design that occasionally make me stop and wonder if we're over-specifying things - and this is one of them. I mean, yes, implementations can allow their users to set a TCP-specific option for the case the system picks TCP. There's no way we could stop people from doing this, yet it's probably nothing that we should prescribe or (IMO) even recommend. So, can we just stop talking about this, and simply remove the text talking about this being a possibility?\r\n\r\n@theri: Properties!  This is now used all over the place in the interface draft and I just think it's a better choice than parameter. A parameter is what you give to a function call (\"action\" in our terminology), whereas messages, connections etc. have properties. A property could be configured via a parameter of an action.",
          "createdAt": "2018-09-06T08:10:17Z",
          "updatedAt": "2018-09-06T08:10:17Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "+1 -> P=Properties",
          "createdAt": "2018-09-06T11:13:24Z",
          "updatedAt": "2018-09-06T11:13:24Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my opinion, Properties is the least confusing term we can choose. \r\n\r\nDespite that, I have no strong opinion on how we call this thing - but not P*, please!\r\n\r\nP.S: I like it, that Properties can be a used as parameters to the protocol and path selection and therefore express preferences of the application.  \r\n",
          "createdAt": "2018-09-06T11:45:32Z",
          "updatedAt": "2018-09-06T11:45:32Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was actually thinking about calling things we do to the preconnection a preference and things we can configure for a connection a property (or just configuration?). Is that too confusing or more clear?",
          "createdAt": "2018-09-06T12:07:19Z",
          "updatedAt": "2018-09-06T12:07:19Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like it! \"Preference\" for preconnections is really nice. For the latter, I prefer property over configuration.",
          "createdAt": "2018-09-06T12:14:43Z",
          "updatedAt": "2018-09-06T12:14:43Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl / @mirjak  we agreed that one can specify connection and message properties on a pre-connection as default values. Renaming them to something else makes this difficult. Also, renaming ``Selection Properties`` to ``Preferences`` causes confusion with the ``Preference`` data type.",
          "createdAt": "2018-09-06T12:25:25Z",
          "updatedAt": "2018-09-06T12:25:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - I agree, sorry.",
          "createdAt": "2018-09-06T12:28:26Z",
          "updatedAt": "2018-09-06T12:28:26Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess it's easy to rename the data type. ",
          "createdAt": "2018-09-06T12:53:33Z",
          "updatedAt": "2018-09-06T13:57:21Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @philsbln that just calling them Properties is least confusing, and that Preferences is a data type, not a classification.",
          "createdAt": "2018-09-06T13:07:26Z",
          "updatedAt": "2018-09-06T13:07:26Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought calling them Properties was one thing we had agreed on :-) I am still fine with that.",
          "createdAt": "2018-09-06T16:03:09Z",
          "updatedAt": "2018-09-06T16:03:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to Properties",
          "createdAt": "2018-09-07T00:55:52Z",
          "updatedAt": "2018-09-07T00:55:52Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to Properties, though since we're talking about it I think \"Message Context Properties\" (formerly Send Properties) should probably just be Message Properties (or, if you like for purposes of this discussion, `M* P*` :wink: )",
          "createdAt": "2018-09-07T06:27:34Z",
          "updatedAt": "2018-09-07T06:27:54Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok - lets wrap this up:\r\n\r\n - We have rough consensus for calling P* ``Properties``\r\n - We should shorten ``Message Context Properties`` to ``Message Properties`` (the document uses both terms interchangeably at the moment)\r\n - Our primary structuring criteria for Properties is when they can be specified \u2013 This leaves us with ``Selection/Connection/Message-Properties``\r\n - Other attributes of properties are annotated in the header of the properties or described in the text if necessary: \r\n    -  The Data-Type\r\n    -  Whether they are ``Protocol-Specific (Connection) Properties`` or ``Generic (Connection) Properties``\r\n    - What selection process, i.e., (Path/Protocol-Selection, they effect\r\n    - Their meaning and whether they are interpreted.\r\n\r\nIf there is no opposition for this wrap-up, I'll try to fix these with the next parts of the restructuring.",
          "createdAt": "2018-09-07T08:47:16Z",
          "updatedAt": "2018-09-07T08:47:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@phlsbln agree broadly but i'm not sure that the selection properties appear in the right place in the document. I have some cycles on a train today to try to do this compression/re-org, so I'm happy to do this unless you're already in progress on this one.",
          "createdAt": "2018-10-10T09:45:50Z",
          "updatedAt": "2018-10-10T09:45:50Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oops bad tag of @philsbln ^^ see above",
          "createdAt": "2018-10-10T14:29:50Z",
          "updatedAt": "2018-10-10T14:29:50Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still on my todo list, but I have no spare cycles till end of October. \r\n\r\nThe idea of moving the selection stuff came also across my mind several times.\r\nGo ahead and move the section, I will pick up from where you finish.\r\n\r\nSorry for the late reply.",
          "createdAt": "2018-10-12T20:55:49Z",
          "updatedAt": "2018-10-12T20:55:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe that was all planned to finish by BKK, and people seemed fine with the structure in BKK. So, I think this is done and I'm closing the issue.",
          "createdAt": "2018-12-03T10:36:44Z",
          "updatedAt": "2018-12-03T10:36:44Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWUzNTczMTgwOTM=",
      "title": "WTF is a PreconnectionBinding?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/219",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "section 6.3 (Rendezvous) has the following line:\r\n\r\nPreconnectionBinding := Preconnection.Resolve()\r\n\r\nIf i read the text correctly, I'd propose to change this to \r\n\r\nPreconnection<> := Preconnection.Resolve()",
      "createdAt": "2018-09-05T16:56:12Z",
      "updatedAt": "2018-09-20T18:31:00Z",
      "closedAt": "2018-09-20T18:31:00Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, not sure what a `PreconnectionBindings` is...",
          "createdAt": "2018-09-06T03:24:47Z",
          "updatedAt": "2018-09-06T03:24:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed; the text would need to change to compensate as well.\r\n\r\n@mirjak is the `<>` on `Preconnection<> := ...` an array of preconnections? I don't think we have a notation for this yet (`<>` are event params), but we probably should.",
          "createdAt": "2018-09-06T15:24:05Z",
          "updatedAt": "2018-09-06T15:24:05Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with the change. `PreconnectionBindings` are new `Preconnection` objects derived from the initial `Preconnection` by a process like ICE. E.g., once the resolve call has done a STUN exchange to find the external address of a NAT you're behind, you'll get back an object that represents that external address.",
          "createdAt": "2018-09-06T22:08:26Z",
          "updatedAt": "2018-09-06T22:08:26Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWUzNTczMjgzMzQ=",
      "title": "Message Context Parameters: Ordered and Final",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/220",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "I would like to discuss the message context parameters \"ordered\" and \"final\" a bit more. I've put this into the same issue because I think there might be some relationship here.\r\n\r\nFirst I find \"ordered\" confusing because if you send a first message that is ordered=false and then the next one that is order=true that actually means that both messages together have a defined order, so setting it to false on the first one seems confusing. In post socket we called this dependency (and probably left the exact implementation a bit more open). I think that is actually more want we want to say: This message has to be delivered before/after the other message, however, this does not imply that both messages have to be provided to the transport right after each other. Thinking further about this, and maybe similar as we have connection groups, we may want to have message groups which basically only say that all messages belonging to the same group should be delivered in the order they have been given to the transport layer. Just an idea for now; did think this completely thought yet but maybe others have thoughts...?\r\n\r\nHowever, at this point I got reminded of partial messages, which I think always imply in-order delivery...? But to be honest I have no idea why we need partial messages at the sender-side. I think what we want is the grouping as described above (to make sure we put on those messages on the same stream in the right order) and some indication at the receiver-side that the transport has no idea about the message boundaries and just delivers a random piece of data that it received. However, these seem to be two independent concepts which should be reflected by different parameters.",
      "createdAt": "2018-09-05T17:25:37Z",
      "updatedAt": "2019-03-25T12:34:26Z",
      "closedAt": "2019-03-25T12:34:26Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that \"Ordered\" has a very confusing contract as its written here. I think that all of the functionality that is beneficial from \"Ordered\" can also be expressed via the post-sockets previous concept of marking an \"Antecedent\" to describe an explicit dependency relationship between two messages. This has the advantage of being very clear about which messages relate to one another in a situation in which reordering is possible.\r\n\r\nThe handling of partial messages do assume that all data for a *single* message is indeed sent and received in-order. I think this is a reasonable constraint to put on the API. If you really want to be able to receive chunks of a message out of order, then perhaps you should be treating those chunks as the \"messages\", right?",
          "createdAt": "2018-09-06T03:24:03Z",
          "updatedAt": "2018-09-06T03:24:03Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 05/09/2018, 18:25, mirjak wrote:\n>\n> I would like to discuss the message context parameters \"ordered\" and \n> \"final\" a bit more. I've put this into the same issue because I think \n> there might be some relationship here.\n>\n> First I find \"ordered\" confusing because if you send a first message \n> that is ordered=false and then the next one that is order=true that \n> actually means that both messages together have a defined order, so \n> setting it to false on the first one seems confusing.\n>\nI don't see that as confusing at all, the second is ordered with respect \nto the first, that reads perfect to me.\n>\n> In post socket we called this dependency (and probably left the exact \n> implementation a bit more open). I think that is actually more want we \n> want to say: This message has to be delivered before/after the other \n> message,however, this does not imply that both messages have to be \n> provided to the transport right after each other. Thinking further \n> about this, and maybe similar as we have connection groups, we may \n> want to have message groups which basically only say that all messages \n> belonging to the same group should be delivered in the order they have \n> been given to the transport layer. Just an idea for now; did think \n> this completely thought yet but maybe others have thoughts...?\n>\nI'm less sure here - I realise postsockets chose this, and NEAT chose \nnot. I am not sure having just ordered and datagram suffers hugely. I \ncan see how one can construct such a dependency beteween messages, but \nthe actual benefit of further reducing head-of-line blocking can often \nbe small except in corner cases, and I suspect this actually does not \nadd a huge value.\n>\n> However, at this point I got reminded of partial messages, which I \n> think always imply in-order delivery...? But to be honest I have no \n> idea why we need partial messages at the sender-side.\n>\nIs this what you mean by sender side: The sender starts transmission of \na (longish) message. The interface blocks transmission for whatever \nreason after it has started sending, the sender gives up transmission. \nThe last part is never sent.  It's a form of late decision.\n>\n> I think what we want is the grouping as described above (to make sure \n> we put on those messages on the same stream in the right order) and \n> some indication at the receiver-side that the transport has no idea \n> about the message boundaries and just delivers a random piece of data \n> that it received. However, these seem to be two independent concepts \n> which should be reflected by different parameters.\n>\nUnsure.\n\nGorry\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/220>, or mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1ktgQX3CteT37fTJxZOSXSuqWGuZRks5uYAkSgaJpZM4WbWv8>.\n>\n\n",
          "createdAt": "2018-09-06T06:45:16Z",
          "updatedAt": "2018-09-06T06:45:16Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also didn't find the current description confusing, and I'm afraid that going into defining dependencies and message groups is just making it all unnecessarily complex. I think Mirja's issue is mainly captured by this statement from her:\r\n\r\n> This message has to be delivered before/after the other message, however, this does not imply that both messages have to be provided to the transport right after each other.\r\n\r\nI think that statement is wrong because our text says \"...which was passed to the same Connection...\" - and so, within the same Connection, \"ordered\" really does mean \"right after each other\".\r\nAlso, obviously, this has to be ignored on the first message. I suggest to simply include the following sentence in the text:\r\n\"The Ordered property is ignored on the first Message that is sent on a Connection.\"\r\n...or what am I missing?\r\n\r\nIn line with what Gorry wrote, I can understand that defining dependencies can be more \"powerful\", but I also have doubts about the added value. Concretely, what this can give the transport system is the ability to better understand which messages can be dropped from the buffer when one of them (upon which the others depend) is dropped. However, alternatively, applications needing this can also just try to keep the buffer small and maintain control over their data as long as possible, handling such dependencies themselves. Moving this functionality into the transport system then has the advantage of making it general, applying across applications, but it comes at the cost of 1) making the API more complex, and 2) perhaps discouraging application programmers from keeping the buffer small and handling things inside their apps (where such dependencies can take various application-specific forms, dynamically changing depending on various conditions, etc.). In conclusion, I don't think it's worth it.\r\n\r\nAbout partial messages, +1 to Tommy's response.",
          "createdAt": "2018-09-06T08:40:14Z",
          "updatedAt": "2018-09-06T08:40:14Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Micheal, my point with that sentence was that, yes currently you have to send them right after each other, however that's an unnecessary constraint of the current API definition because the feature we want does not requirement that.\r\n\r\nNot sure if Gorry's maybe is that we don't need that feature at all...?",
          "createdAt": "2018-09-06T09:29:19Z",
          "updatedAt": "2018-09-06T09:29:19Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 06/09/2018, 10:29, mirjak wrote:\n>\n> Micheal, my point with that sentence was that, yes currently you have \n> to send them right after each other, however that's an unnecessary \n> constraint of the current API definition because the feature we want \n> does not requirement that.\n>\n> Not sure if Gorry's maybe is that we don't need that feature at all...?\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/220#issuecomment-419028244>, or \n> mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1kv7AxWu0gISuWgEvY1Inv6267Zu8ks5uYOrvgaJpZM4WbWv8>.\n>\n\nI haven't seen a case where we need this in the API that knows its \ninternal dependencies. I used to hold passionately to the idea of \nsophisticated buffer control, but then I discovered multiple ways apps \ncan use this... and realised if the API could allow the app to keep a \nshort buffer at the sender and multiple streams, the app can mostly do \nthe correct thing. Offloading can also make this very hard to achieve \nwhat you promise with deep buffers, unless the offload does what you \nexpect :-0.\n\nI say mostly, because I could see a case where an App may need to abort \na long message that was not sent within a deadline - e.g. due to alink \ndown or QoS-related issue, and then it may be better to give-up a \nparticular message.\n\n\nGorry\n",
          "createdAt": "2018-09-06T09:39:06Z",
          "updatedAt": "2018-09-06T09:39:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak I'm lost... maybe the disconnect is about sending vs. receiving? I think that clearly, we want to be able to say that messages (on a Connection) must be delivered to the receiver directly in order?  Or maybe you're thinking of streams - then it depends on how Connections are mapped onto streams. For now, I think we work with the assumption that 1 Connection can be 1 stream and you won't have multiple streams \"inside\" 1 Connection  (no other form of multi-streaming is currently exposed in the draft).",
          "createdAt": "2018-09-06T09:39:13Z",
          "updatedAt": "2018-09-06T09:39:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Gorry - when you say:\r\n\r\n> I haven't seen a case where we need this in the API that knows its internal dependencies. \r\n\r\n... what do you mean with \"this\" ?  Ordering altogether (as we have it now), or being able to define a string of dependencies?",
          "createdAt": "2018-09-06T09:42:47Z",
          "updatedAt": "2018-09-06T09:42:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 06/09/2018, 10:42, mwelzl wrote:\n>\n> @gorry <https://github.com/gorry> - when you say:\n>\n>     I haven't seen a case where we need this in the API that knows its\n>     internal dependencies.\n>\n> ... what do you mean with \"this\" ? Ordering altogether (as we have it \n> now), or being able to define a string of dependencies?\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/220#issuecomment-419032209>, or \n> mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1kloQCnFQP1CEYISLlH9dbZchXjmQks5uYO4YgaJpZM4WbWv8>.\n>\nSorry, could have been clearer:\n\nI see two important and useful styles:\n\n- ordered.\n- Unordrered - strictly, this is re-ordering permitted.\n\nI know apps - such as sophisticated web browsers (and RTP media servers) \nbuild a string of dependencies and use this to control what is emitted \non the wire, however these apps often want tight control to do very \nspecific things to control what they send when, I don't see this as easy \nor useful to generalise.\n\nSomeone building their own sophisticated app will have their own \nincentives. A short buffer seems sufficient to me (with \nordered/unordered) delivery. Ability to abort a partially sent message \nseems a reasonable optimisation to help avoid sender-side blocking.\n\nGorry\n",
          "createdAt": "2018-09-06T10:52:30Z",
          "updatedAt": "2018-09-06T10:52:30Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Gorry, I think what you are talking about is a connection property (not a message property). That's a different thing we should not mix up (and as such all not name the same way).\r\n\r\nAlso aborting a message is done based on the message lifetime and therefore also a different feature. ",
          "createdAt": "2018-09-06T10:55:30Z",
          "updatedAt": "2018-09-06T10:55:30Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 06/09/2018, 11:55, mirjak wrote:\n>\n> Gorry, I think what you are talking about is a connection property \n> (not a message property). That's a different thing we should not mix \n> up (and as such all not name the same way).\n>\nIndeed, this is sufficient.\n\nI don't think we need to group messages within this level of the API.\n>\n> Also aborting a message is done based on the message lifetime and \n> therefore also a different feature.\n>\nYes, that's fine as a message property.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/220#issuecomment-419051900>, or \n> mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1kvMevlSROMycJkR6LWoEPEcakcidks5uYP8igaJpZM4WbWv8>.\n>\nGorry\n",
          "createdAt": "2018-09-06T11:03:06Z",
          "updatedAt": "2018-09-06T11:03:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is getting interesting. SCTP has per-message ordering as a flag, but I must admit that I always asked myself why this is needed. I also think that a per-connection property should be enough.",
          "createdAt": "2018-09-06T11:43:50Z",
          "updatedAt": "2018-09-06T11:43:50Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the use case is that you have a multi streaming protocol but don't expose the multiple stream to the application (but still want to make use of them in a sensible way). Not sure if we want to support this use case though or at least if there is maybe a better way to support it.",
          "createdAt": "2018-09-06T12:09:51Z",
          "updatedAt": "2018-09-06T12:09:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not the use case in SCTP because in SCTP it applies per stream only, and streams are exposed.\r\nSo, I still don't know why SCTP has that...    then again, I'm not sure if there's much benefit to taking this (per-message) functionality away? At the end of the day, it's a simple thing, the receiver either looks at sequence numbers before handing over the data or not.",
          "createdAt": "2018-09-06T12:17:00Z",
          "updatedAt": "2018-09-06T12:17:00Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the text is unclear, but the concept of ordered seems clear to me. An ordered message is only ordered with respect to other ordered messages within the same connection. I suggest to clarify the text rather than introducing new more complicated concepts like message groups.\r\n\r\nWhether the \"ordered\" property is needed or not can of course be discussed, but from an abstract view I guess it makes sense. It allows to send \"out-of-band\" data on a connection. How useful it is I am not sure, but as it is supported by at least SCTP I would leave it in for now.",
          "createdAt": "2018-09-06T16:02:09Z",
          "updatedAt": "2018-09-06T16:02:09Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dependencies seem more useful than ordered, since they also affect partial reliability. I do see use cases for this, and wouldn't want to drop the functionality. ",
          "createdAt": "2018-09-06T22:17:19Z",
          "updatedAt": "2018-09-06T22:17:19Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think partial reliability is different, we have niceness and lifetime for that.",
          "createdAt": "2018-09-06T23:32:02Z",
          "updatedAt": "2018-09-06T23:32:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So dependencies (through antecedents) were a key feature of Post (like much of Post, lifted shamelessly out of Minion and its, erm, antecedents), but AFAIR there were a few reasons we left them out of the TAPS API:\r\n\r\n- they probably require new transmission schedulers and better multipath transport protocols (or even fully path-aware networks) to really make much of a difference.\r\n- a generalized solution to the \"most efficient transfer\" of a dependency tree of messages is hard, and simple implementations might lead to much worse performance.\r\n- they require a way to refer to messages you might not have sent yet (by pointer, by reference constant, by sequence number, etc) that seem like they might be very tightly tied to the features of the implementing platform and the data structures of the application.\r\n\r\nI think dependency management is a useful feature, but it might also be a good future feature. Yay registries! (?)",
          "createdAt": "2018-09-07T07:08:03Z",
          "updatedAt": "2018-09-07T07:08:03Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "all that said, I'd be okay with either per-message or per-connection ordering. If we do per-message ordering, I think that the (admittedly awkward) definition we have now is probably the most internally consistent...",
          "createdAt": "2018-09-07T07:18:38Z",
          "updatedAt": "2018-09-07T07:18:38Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom but you need to know the dependencies to know what you can safely discard, and what you must keep even if it's exceeded its lifetime",
          "createdAt": "2018-09-07T08:24:21Z",
          "updatedAt": "2018-09-07T08:24:21Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram agree with the reasons why dependencies are hard, but I do think they're important. If we leave them out of v1 we need a way to cleanly add them back later, but I'd prefer not to leave them out.",
          "createdAt": "2018-09-07T08:27:15Z",
          "updatedAt": "2018-09-07T08:27:15Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom There should be nothing you should keep if the lifetime is exceeded. If that would be the case, the lifetime would have been set wrongly. I guess in many cases if you have should dependenciess, your lifetime would be infinite anyway.\r\n\r\n@britram You don't have to refer future messages. The future message can just refer the already sent one.\r\n\r\nI don't think the transmission scheduled is such an issue because if you only have one stream, you just send everything in the order you get it and setting a dependency has no effect. But if you have multiple streams you can send one message per stream expect there is a dependency then you want to use the same stream. However, maybe it is easier to either expose stream to the upper layer in this case, or only do this for connection where the connection property is unordered.",
          "createdAt": "2018-09-07T08:34:12Z",
          "updatedAt": "2018-09-07T08:34:12Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak I'm not sure it's that simple \u2013\u00a0you might want to send data if its lifetime has been exceeded (its deadline has passed) because it's needed to allow future data, that hasn't yet missed its deadline, to be used. Dependencies allow you to express this.",
          "createdAt": "2018-09-07T08:47:40Z",
          "updatedAt": "2018-09-07T08:47:40Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The disadvantages mentioned by @britram all come on top of what I perceive to be the biggest disadvantage, already explained above. Again, rephrased shorter: this can only operate on what is in the send buffer of the transport system, yet we should probably try to keep this buffer short.\r\n\r\nA way to keep this buffer short is to keep the data + operations on it inside the application as long as possible.\r\n\r\n@csperkins - it seems to me that, if the lifetime has exceeded yet an application still wants to send it, the most straightforward way to handle this would be for the application to resend it into the transport system.\r\n\r\nMoving all this logic into the transport system (potentially complex dependencies, allowing exceeded Messages to still be sent, ..) seems like pretty clumsy design to me, when we could just leave this all up to the application. What's the real benefit of moving it down below the API?",
          "createdAt": "2018-09-07T09:44:53Z",
          "updatedAt": "2018-09-07T09:47:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl of course the application can do any of this \u2013 but why would should we push that complexity on all the application developers, forcing them to keep reinventing the wheel, when we can build it as a reusable library? Isn't the point of TAPS to make the API more expressive, so the stack can help the application writers?\r\n\r\nShort send buffers: for some applications, certainly we want to keep buffering low. For others, the data is available ahead of time, so why not pass it to the stack, and let it do something smart with how the data is transported? ",
          "createdAt": "2018-09-07T10:11:01Z",
          "updatedAt": "2018-09-07T10:11:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - I wanted us to consider the full set of trade-offs in this design decision, that's all.\r\nHaving general functionality for all apps is a pro.\r\nWhat I said, and what Brian added to it, are the con's.\r\n\r\nMy vote is for simplicity... but sure, I see your point.",
          "createdAt": "2018-09-07T10:17:02Z",
          "updatedAt": "2018-09-07T10:17:02Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also think we should keep things simple. \r\n\r\n@csperkins I am not fully up-to-date with post, so I am not sure what functionality want to provide here that is supported by the standard transport protocols and that can not be expressed with the basic primitives? In our current model, connections map to streams for protocols that support multi-streaming so can you not get the functionality you are after using a connection group or an unordered connection? For partial reliability, at least SCTP will not send a message after the lifetime has expired. What protocol supports this?",
          "createdAt": "2018-09-07T12:17:45Z",
          "updatedAt": "2018-09-07T12:17:45Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think a dependency (antecedent-based) API is complex, although an effective implementation of it might be. If we're going to support partial reliability and deadlines, then I think we really do need the ability to specify dependencies \u2013\u00a0or at least to cleanly add this to the API in a backwards compatible manner.\r\n\r\n@abrunstrom our TCP Hollywood prototype supports this \u2013 yes, it's a research prototype rather than a widely deployed protocol, but surely the goal of this API is to be general enough to support upcoming protocols, not just what's deployed today?",
          "createdAt": "2018-09-10T22:33:01Z",
          "updatedAt": "2018-09-10T22:33:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think there's any word of future protocols in the TAPS charter, and that's for a good reason: TAPS needs to stay easy enough to implement (and, of course, also use) to really have an impact. At least that should be the case for the mandatory-to-implement part.\r\n\r\nWe have an appendix with \"Experimental Transport Properties\", already containing properties that protocols don't support today, but future protocols might. This is where this could fit, IMO.",
          "createdAt": "2018-09-11T06:26:05Z",
          "updatedAt": "2018-09-11T06:26:05Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, but I disagree on this \u2013 this is a fundamental property of partially reliable protocols, and it needs to be supported (or, at minimum, possible to add in a backwards compatible manner).",
          "createdAt": "2018-09-11T08:37:28Z",
          "updatedAt": "2018-09-11T08:37:28Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still sceptical. At the end of the day, it's just about dropping things from a buffer; there can be 100 different ways to decide to drop stuff from a buffer - you say that this a fundamental property of partially reliable protocols, and I could answer that the fundamental properties of partially reliable protocols should include everything in RFC 7496  (time-based, priority-based, and # retransmission-based dropping). We can do all of that but I don't think that's helpful.\r\n\r\nI don't argue the usefulness of the functionality that you propose (to me, it seems a lot more useful than priority-based or # retransmission based dropping), but I'm seriously worried about the API growing too large and the implementation growing too heavy. I think that what you want could be implemented quite nicely on top of a layer like we already have: when a PR transport drops a message, it should tell the application about it, and then the application can drop the messages that depend upon it from its own memory that it still has control over. This way, the application sees less buffering and has more control.\r\n\r\nYou argued for generalising functionality and not having to re-invent the wheel inside applications.\r\nAbout that, why not offer it in a shim that takes more data in its buffer than the TAPS API below it, and drops things from it based on the information it gets from the TAPS API (about packets dropped by the PR transport)?",
          "createdAt": "2018-09-11T09:42:18Z",
          "updatedAt": "2018-09-11T09:42:18Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Designing a new, supposedly general-purpose, API, then immediately telling users of that API they have to implement a shim to fix its limitations is not exactly a vote of confidence in TAPS...\r\n\r\nWe have extensive experience with this feature as part of RTP, and the API additions are small, well-understood, and have been previously specified in Post Sockets. I'm hardly arguing for some unusual, complex, experimental API change.\r\n",
          "createdAt": "2018-09-12T12:17:17Z",
          "updatedAt": "2018-09-12T12:17:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this seems like a good discussion to take to the interim if we have remaining time...\r\n\r\nHere's where my thoughts are on this now (having just caught up on the thread):\r\n\r\n- a dependency API is probably easy to specify (I tend to agree with @csperkins); we can add \"depends-on\" as a refrence from a message context to another message context, at the cost of being able to easily reuse message contexts for default purposes.\r\n- the simplest implementations of a dependency API would still be somewhat tricky to get not-wrong. For instance, the easiest way to implement message context references would lead to the entire dependency chain being stuck in core and ineligible for garbage collection in GC languages, unless the API had a more complex ownership contract than \"caller always owns the message context\". In any case, you'd want to implement reliable-in-ordered \"by default\" without using such a construct.\r\n- an implementation of a dependency API that actually gets a massive win requires a new transport and/or changes to the architecture. On the other hand, new transport and changes to the architecture are *why we're doing TAPS* in the first place, so this is actually less of a con than I thought it was.\r\n\r\nI agree with @csperkins's basic argument that if we want TAPS to be the Transport Interface Of The Future\u2122 that dependency tracking would be very good to have, if only to get application developers used to thinking in these terms. So IMO (now), if we can come up with a way to specify this and convince ourselves that it is easily correctly implementable, we should try to get it in.",
          "createdAt": "2018-09-12T12:53:17Z",
          "updatedAt": "2018-09-12T12:53:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just an add-on to one of Brian's points here:\r\n\"an implementation of a dependency API that actually gets a massive win requires a new transport and/or changes to the architecture. \"\r\n\r\nThe biggest problem that I see with this is missing here: it also requires a large buffer.\r\n\r\nSo all in all, I'm not convinced, but that's just my view. I personally give a very high weight to the \"KISS\" side of things here. Maybe too high, what do I know. At the end of the day, where I place myself in this functionality-vs-complexity trade-off is just my gut feeling.",
          "createdAt": "2018-09-12T13:38:47Z",
          "updatedAt": "2018-09-12T13:38:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "BTW, +1 to discussing this at the interim !",
          "createdAt": "2018-09-12T13:40:20Z",
          "updatedAt": "2018-09-12T13:40:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it also requires a large buffer\r\n\r\nYes, it does (I see this as a detail hiding behind \"somewhat tricky to get not-wrong\", but that's just me).\r\n\r\nMy two-really-three questions on the buffer issue (and these are actual I-don't-know-the-answer questions):\r\n\r\n1. In the contexts in which people would actually implement dependency-aware transport (generally biggish media servers), does the size of the buffer matter?\r\n\r\n2. (Isn't the size of the buffer constant for this sort of thing anyway, and we're just arguing which side of the API boundary it has to live on?)\r\n\r\n3. Is a dumb implementation of a dependency API (i.e. one that providing dependency information as an application does not give you much win, but which does not otherwise penalize you for trying) that *doesn't* need a large buffer possible?",
          "createdAt": "2018-09-12T14:52:05Z",
          "updatedAt": "2018-09-12T14:52:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I *believe* I can answer these questions ... so here's a try:\r\n\r\n1. Yes absolutely: to stream non-live-content, the goal is typically to operate lossless and adjust the quality if needed to avoid buffer underruns. E.g., streaming over TCP works quite okay, as we know from various DASH applications and also e.g.: https://ieeexplore.ieee.org/document/5497172/?tp=&arnumber=5497172&filter%3DissueId+EQ+%225602023%22\r\n\r\n... so the types of ideas where one throws away data because of dependencies are typically a matter of live content. I find it hard to imagine this being useful for anything else.\r\n\r\n2. I guess it can be constant, yes, and yes we're arguing which side of the API boundary it has to live on.\r\n\r\n3. Certainly possible, but it doesn't have much to operate on.",
          "createdAt": "2018-09-12T20:31:02Z",
          "updatedAt": "2018-09-12T20:31:18Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's interesting: I generally cite that paper as an explaining why streaming over TCP does not work especially well... \r\n\r\nYes, we're arguing which side of the API boundary this feature lies. Whether we continue to implement this in the applications, or whether we accept the long implementation experience as evidence that it's a useful feature, and provide dependency and timing information so newer transport protocols can be designed to help applications.\r\n\r\nA dumb implementation: isn't that just to ignore the dependency information? It offers no benefit, but also has no real cost (the applications that could use this know the dependencies anyway, so the only cost is the additional, ignored, parameters passed to the send call).\r\n\r\n",
          "createdAt": "2018-09-20T14:23:19Z",
          "updatedAt": "2018-09-20T14:23:19Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A dumb implementation: isn't that just to ignore the dependency information? \r\n\r\nwell, maybe. It depends on the details of the contract on the dependency information. If the contract is \"X depends on Y means X will not be sent until Y is acked\", then the TAPS sender (behing the API) has to track it. If the contract is \"X depends on Y means X will not be sent until Y is sent\", then the TAPS sender can trivially compile deps down to an ordered message buffer list. If the contract is \"X depends on Y means that the transport will take that under advisement and try to do the right thing\", then the TAPS sender can completely ignore.",
          "createdAt": "2018-09-20T14:39:18Z",
          "updatedAt": "2018-09-20T14:39:18Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram we'd need to specify an appropriate API contract, to be sure, but none of these, or the other variants I might imagine, seem difficult to implement. I'd tend to opt for a contract of the \"hint that the transport might find useful to optimise things\" form, but the details of the contract are for a different discussion.",
          "createdAt": "2018-09-20T15:00:46Z",
          "updatedAt": "2018-09-20T15:00:46Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "See how much you hate or love this:\r\n- I agree the conversation is indeed about whether the dependency function is above or below the API. I suggest we have much more significant changes - such as asynch call back that are more significant.\r\n- I suspect this could be in a library above the API in many cases.  I strongly argued that we should not include this as something an API has to implement....\r\n- I suspect some apps will wish to do this sort of things themselves with slight variants - that is what happended when we tried to support datagrams.  Of course, some others will not bother or use this.\r\n- I do not mind a system choosing to place this below the API (if it chooses). That is, I still argue this should not be required from an initial TAPS implementation.",
          "createdAt": "2018-09-20T18:52:23Z",
          "updatedAt": "2018-09-20T18:52:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - side note, about the paper: I guess it's possible to use their model to argue in this or that direction; sure, there are limits, and they are quantified in this paper. The authors say that \"Our research reveals that real-time application performance over TCP may not be as delay-unfriendly as is commonly believed\", which is why is tend to use it like I do. But, it depends on what one considers \"delay-unfriendly\", of course.\r\n\r\nAnyway, back to the point.\r\nI'd strongly argue for a dumb implementation not doing anything, on the basis of the API contract just being a hint from the application with no promises made, exactly as suggested by @csperkins. Anything more gets in the way of fall-backs which defeats the purpose of TAPS  (because it requires fall-back code inside the application). For anyone who might not like that line of reasoning, let me try this: stricter API contracts have a rotten QoS smell from the 90's.\r\n\r\nAbout Gorry's message, I have been arguing that this shouldn't be mandatory-to-implement functionality before... so I obviously agree. Can't we just say that this, like other mechanisms that don't speak to what protocols are offering today (i.e. beyond minset - e.g., the \"traffic category\" or \"size to be sent or received\" intents), belongs in an appendix?",
          "createdAt": "2018-09-21T08:11:39Z",
          "updatedAt": "2018-09-21T08:11:39Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I tend to think this is pretty fundamental for real-time applications, so I think we do need to either include it in the first version, or provide a backwards compatible way of adding it. I think it's one of the simpler parts of the API to implement, so I'm not understanding the push-back.\r\n\r\n@mwelzl \"like other mechanisms that don't speak to what protocols are offering today\" \u2013 people have been implementing this in RTP for many years! It's not a novel feature. Yes, it's beyond the minset, but restricting TAPS to the minset makes it somewhat backward looking and uninteresting, surely? ",
          "createdAt": "2018-09-27T22:27:37Z",
          "updatedAt": "2018-09-27T22:27:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About \"what protocols are offering today\", I meant transports - to draw a line between 1) functionality that's almost only a hand-over to the protocols below (with happy eyeballing and all that), which we definitely need; and 2) functionality that adds something on top (which can be useful, but could just as well include 15 more RTP things, FWIW).\r\n\r\nI'm not at all saying 2) should be out, just that, in general, things in category 2 should be optional to implement. What I'm going to say below is: I think I AM in fact convinced now, but for other reasons - the \"RTP has done this for many years\" argument is not convincing me at all.\r\n\r\nAs I said earlier, that this should not be mandatory is just based on a \"gut feeling\" in the trade-off between added benefit and added complexity. I tend to lean heavy on the \"no added complexity\" side because I'm keen on seeing something that would really be picked up by implementers. If we add so many bells and whistles that the sheer length of the document scares people away, we haven't achieved anything. However, several points have made my gut feel better about this: 1) your statement that it's an easy API update; 2) the agreement (which I hope we have?) that this is just a hint from the application, nothing binding, i.e. a simple implementation could just ignore it; 3) Tommy's elaborations at the virtual interim on how they could implement things more efficiently because this buffer is in the kernel in their case.\r\n\r\nThe latter point is particularly strong. If I think of the NEAT library in user space, I'd wonder, why does NEAT have to do that - couldn't RTP-over-NEAT do it?  But the thing with buffers is, if you have poorly managed buffers below whatever you invent, you're still lost. It seems to me that we've had quite a long history of poor buffer management with the sockets API - consider how late TCP_NOTSENT_LOWAT came about, and how big a deal this very TCP-specific hack can be.\r\n\r\nSo, being able to control the buffer better really does strike me as key functionality and something that could convince folks that this API makes a difference (\"better buffer management than with the sockets API\" is a convincing statement by itself, I think). So yes, I guess I'm convinced by now.\r\n\r\nIn more general terms, maybe we could say that buffer management mechanisms should be excluded from my category 2), and they can be mandatory (of course only if the API change is minor and the implementation can be easy).",
          "createdAt": "2018-09-28T06:37:21Z",
          "updatedAt": "2018-09-28T06:37:21Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I agree: \"people have been implementing this in RTP for many years! It's not a novel feature\", I said this on the interim call, I still see that on this, but not quite the same. I think we've reached something that I I would appreciate a little time for someone explain face-to-face, because I may have missed something.",
          "createdAt": "2018-10-09T17:15:41Z",
          "updatedAt": "2018-10-09T17:15:41Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl \"I meant transports\" \u2013\u00a0RTP *is* is a transport protocol! Yes, it has some non-transport features, but I'd strongly argue that deciding what packets to send is very much transport-related.",
          "createdAt": "2018-10-15T21:15:51Z",
          "updatedAt": "2018-10-15T21:15:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - yes I'm aware you're from the RTP-is-a-transport planet  :-)   :-)   but RTP does so much more than just deciding what packets to send...",
          "createdAt": "2018-10-15T21:59:30Z",
          "updatedAt": "2018-10-15T21:59:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why, oh why, did I have to do this. Sometimes I think I'll never learn. This is not the time and place for this discussion. We're discussing about what I think is a quite fuzzy boundary, and we will not be able to quickly agree on anything. Yet, this discussion has already converged - if you want your API change in, write text. I'll accept that RTP is a transport or whatever.",
          "createdAt": "2018-10-15T22:13:59Z",
          "updatedAt": "2018-10-15T22:13:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hey @mwelzl are you ok? closing.",
          "createdAt": "2019-03-25T12:34:26Z",
          "updatedAt": "2019-03-25T12:34:26Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWUzNTczMzQzNzg=",
      "title": "Connection.Receive(minIncompleteLength, maxLength)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/221",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I don't think having the receive parameter \"minIncompleteLength\" and \"maxLength\" is the right approach here. \r\n\r\n\"minIncompleteLength\" is rather a configuration for the transport layer to decide when to create a callback receive event, therefore providing it together with receive() is too late. It's probably a Connection P*. \r\n\r\n\"maxLength\" seems to superfluous because ideally receiving is a zero copy operation and as the transport as stored the data already somewhere it doesn't seem useful to set a limit here. Of course again there probably needs to be a system config and or connection P* somewhere. If at all this seems rather like an implementation detail to me (that may or may not be discussed somewhere  but should not be part of the actual API spec). ",
      "createdAt": "2018-09-05T17:43:40Z",
      "updatedAt": "2019-03-25T12:35:47Z",
      "closedAt": "2019-03-25T12:35:47Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree that the minimum incomplete message length for a single invocation of Receive should be a connection P*\u2014we use this quite often to be different for each Receive. Say, you want to receive exactly 4 bytes to read some header value, and then you want to read a minimum of 1KB, and up to the length of that message, etc. The point of minimum incomplete length is that you really don't want to be signaled or woken up as an application at this stage of your processing until N bytes are available. If you ever need to read a little bit (which almost all apps do), you'd have to set your connection P* to 1, and then you can't get this receive low water mark behavior.\r\n\r\nThe same goes for the max length. While the max length I could ever receive maybe could be a system limitation, there are two very important functions for specifying it per Receive: I may not be able to handle parsing more data than a certain amount right now (I want to read up to a point, which will determine which code module I need to pass the connection to in order to do further processing); or I want to communicate back pressure down to the transport stack. If I don't have a max length on a Receive, do we assume that the Receive is asking for as many bytes as possible, and to read them all into process memory at once? Yes, maybe you have zero-copy from the library to the app (which itself is not a guarantee), but you almost certainly cannot guarantee zero-copy from the driver, and something needs to also tell TCP when to close its window.",
          "createdAt": "2018-09-06T03:18:01Z",
          "updatedAt": "2018-09-06T03:18:01Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, my model is a bit different here (which suggests that this might be more of an implementation questions). I assume that the usual case it that you invoke receive based on a full message. If you always want to read header separate from the body, you may wamt to send them in different messages, especially if you don't want to wait until the full message is received before you can read the header. I think that is also the HTTP mapping model here. However, even if you don't send them separately, I don't think it is a problem to receive the full message. Basically what receive does in this case, is giving you a pointer to a piece of memory and tell you that it is all yours now. How much you read from it at once is your decision. I understand that this is under the assumption of zero copy but I think that is what we should aim for (especially if the assumption is that most implementation will anyway work on top of the sockets API for now).  ",
          "createdAt": "2018-09-06T08:23:53Z",
          "updatedAt": "2018-09-06T08:23:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the usual case is that you want to Receive a complete message. In that case, you don't specify (minIncompleteLength, maxLength) at all! It's equivalent to saying UINT_MAX for both values. The only time that an application would specify the min/max lengths is for receiving partial messages. So, since this is predicated on the application wanting to handle partial data.\r\n\r\nAlso, with regards to copies... if our message is very very large (many gigabytes of a file, in which case the app may be wanting to stream it in partial chunks), then we cannot not simply deliver a buffer of the entire message to the application to read out of. The amount they read at a time, via the invocations of Receive(), determine the flow control on the stream. ",
          "createdAt": "2018-09-07T00:55:07Z",
          "updatedAt": "2018-09-07T00:55:07Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still not happy with the concept of partial messages. At the moment it seems nearly more natural to send partial messages than full messages (especially as the property is called \"final\" instead of \"partial\"). Which goes back to the other discussion on order and final, and I still don't really see why you need partial messages at sender-side. The application can just decide to segment any big message in any way call it a \"chunk\" of a message or whatever and provide it as a message to the transport. All you need, if at all, is telling the transport that there is a dependency.\r\n\r\nFor the receiver side, if you don't know the message boundary, you can only provide random chunks (and should tell the upper layer that it is a random chunk). With providing a length to the transport, you can reinforce to received messages at the boundaries if you have this information. If that is what you want, I think we a) need only one length and b) should call it that way.",
          "createdAt": "2018-09-07T08:19:48Z",
          "updatedAt": "2018-09-07T08:19:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the transport API provides support for message boundaries, and those message boundaries are transmitted the other side, the sender may need/want to stream in a single message in multiple chunks (partial messages). Requiring the application to use some other understanding or mapping of messages really isn't ideal.\r\n\r\nTo be very concrete:\r\n\r\nLet's say I have a protocol that supports independent sending and receiving of messages, like how an HTTP message would get its own QUIC stream. If I have a particularly large request or response (megabytes or gigabytes) I may not be able to send it all at once; and even if I can, I may want to be able to pace the data.\r\n\r\nIn another case, let's say I have a simple TLV message protocol on top of TCP. I want to treat a single TLV as a message for both sending and receiving. Maybe most of the time I have small messages that I write atomically, but a couple of the messages are large, or not generated as one piece of data (maybe because I'm receiving it in pieces off of another network connection). It's convenient to be able to push data in in pieces.",
          "createdAt": "2018-09-07T15:59:04Z",
          "updatedAt": "2018-09-07T15:59:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak are you okay closing this one?",
          "createdAt": "2019-01-25T12:45:23Z",
          "updatedAt": "2019-01-25T12:45:23Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWUzNTc0ODQ0NTU=",
      "title": "Reusing Preconnections?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/222",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Regarding this text:\r\n\r\n```\r\nThe Initiate() Action consumes the Preconnection. Once Initiate() has\r\nbeen called, no further properties may be added to the Preconnection, and\r\nno subsequent establishment call may be made on the Preconnection.\r\n```\r\n\r\nThis seems to imply that the Preconnection object, which may be full of many carefully tuned settings that could be useful for another Connection, is no longer usable. While I understand that the specific Preconnection cannot change for a Connection, this is inconvenient to the application.\r\n\r\nI see two good options to solve this:\r\n\r\n- Make a deep copy of the Preconnection upon Initiate(), and say that a Preconnection may be used or changed but changes can no longer influence the Connection (this is what Network.framework currently does)\r\n- Allow a Preconnection.clone() method to let the applications do the deep copy themselves when and if they want to re-use.",
      "createdAt": "2018-09-06T03:36:19Z",
      "updatedAt": "2020-01-22T20:29:40Z",
      "closedAt": "2020-01-22T20:29:40Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to reusing the preconnection. Do you even need a deep copy. The connection is a new object that should be independent of the preconnection anyway, no?\r\n\r\nAnother thought: Are there actually ways to get different connections out of the preconenction. E.g. you do racing and end up with two open connections and (suddenly) want to use both...?",
          "createdAt": "2018-09-06T08:06:53Z",
          "updatedAt": "2018-09-06T08:06:53Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to see this as well.\r\nTo me it makes most sense to allow calling Initiate() on the same Preconnection multiple times to get multiple Connections, but not allow to change this Preconnection anymore after the first Initiate. This way it would be similar to Listen() and Rendezvous(), where we have a Preconnection that yields multiple Connections, and that cannot be changed anymore after Listen() or Rendezvous(). So here we already have a binding between the Preconnection and the Connections that come out of it.\r\n\r\nIf the application wants to change the Preconnection before re-using it, I'd be in favor of letting it explicitly clone the Preconnection - not sure if we actually want to call it clone() though, because we already have Connection.Clone(), which creates a Connection Group, a completely different thing.",
          "createdAt": "2018-09-06T08:17:42Z",
          "updatedAt": "2018-09-06T08:17:42Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why do you think it should not be allowed that a preconnection can be changed after the first initiate? If you don't change it you should get the same kind of connection, if you change it you might get something different. Your choice!",
          "createdAt": "2018-09-06T08:28:56Z",
          "updatedAt": "2018-09-06T08:28:56Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wanted the API contract to be similar for different forms of Connection establishment. But I may be overthinking this.",
          "createdAt": "2018-09-06T08:33:27Z",
          "updatedAt": "2018-09-06T08:33:27Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, I like the idea of reusing Preconnections.\r\n\r\nI am not sure whether we should define now whether they should be changeable after the first initiation. There might be kinds of Preconnections where this is a good idea, there might be others where it is not. \r\nI anticipate one can realize connection pools as a sub-class of Preconnection. In this case, in such cases, it should not be possible to change a Preconnection.\r\n \r\n\r\n",
          "createdAt": "2018-09-06T12:09:07Z",
          "updatedAt": "2018-09-06T12:09:07Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the difference is if you think you morph a preconnection into a connection, or if the preconnection create the connection. i think the first think does not make sense because their are two completely different things; they have not actions or events in common.",
          "createdAt": "2018-09-06T12:13:02Z",
          "updatedAt": "2018-09-06T12:13:02Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak The morphing one has its beauty for modeling TCP fastopen / 0-RTT data.",
          "createdAt": "2018-09-06T12:19:07Z",
          "updatedAt": "2018-09-06T12:19:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whether it makes sense to re-use a `Preconnection` perhaps depends on how fully specified it is? Reusing a completely specified `Preconnection`, that will just re-open an identical 5-tuple as an existing `Connection` might not make sense. Reusing a partially specified `Preconnection`, e.g., with the source port left as a wildcard to new connections can open without conflicts, seems reasonable.",
          "createdAt": "2018-09-06T22:02:15Z",
          "updatedAt": "2018-09-06T22:02:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins right, using the exact same set of fully-specified properties isn't going to work. But having a partially specified one and copying it, or modifying one that was used (by switching out the Remote, etc) would be useful.",
          "createdAt": "2018-09-07T00:50:19Z",
          "updatedAt": "2018-09-07T00:50:19Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This might work better the other way -- on `Initiate()`, the Preconnection corresponding *to the initiated/initiating connection* gets deep-copied *into the new connection*, leaving the existing Preconnection in the state that it was. That deep copy, inside the connection, cannot be reused, but the existing one could be.\r\n\r\n(This probably only works for connections on which you `Initiate()`. `Listen()` turns the preconnection into a listener from which multiple `Connections`, each of which will have their own deep copy of the listener, will spawn. `Rendezvous()` might be even weirder, but there's a potentially bigger win to allowing reuse, but I don't quite have my head around how it would work)",
          "createdAt": "2018-09-07T07:22:59Z",
          "updatedAt": "2018-09-07T07:22:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So i think there is actually not that much too deep copy because a preconception is not a super class of a connection. At the moment when you call initiate or rendezvous the preconception should create a connection and store all information regarding this connection in the connection object which is later returned. The only thing that needs \"copying\" is the properties but you need to create a new object anyway because preconnection properties have preferences and connection properties not but have to be marked as mutable or unmutable. These two things are also not the same. So the only that that's left to copy maybe are the endpoints. Not sure if the preconnection and connection both have a copy of the endpoints or if an endpoint only exists once and both have a reference (which means if the endpoint gets somehow updated that's relevant for both) or maybe even the connection does not need a reference to the endpoint anymore...?",
          "createdAt": "2018-09-07T08:27:07Z",
          "updatedAt": "2018-09-07T08:27:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly right \u2013 but I don't know a way of specifying \"a `Preconnection` is consumed if fully specified, else may be reused` in any current programming language. Maybe tracking lifetimes so closely doesn't matter though, and we can just write this in the draft.",
          "createdAt": "2018-09-07T08:33:30Z",
          "updatedAt": "2018-09-07T08:33:30Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have no problem with an Interface where some Preconnections can be reused and others can not.\r\n\r\nThat makes a pretty nice case for ``Initialte()``-- preconnection can be reused --  and ``listen()`` -- preconnection reuses itself for multiple incoming connections.\r\nFor ``rendezvous()`` I see this API-wise as some kind of listen called at both sides.",
          "createdAt": "2018-09-07T08:58:03Z",
          "updatedAt": "2018-09-07T08:58:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Side meeting says we can reuse the initiate call. Implementation should specify that a deep copy is made on Initiate() or Listen()",
          "createdAt": "2019-03-25T12:44:02Z",
          "updatedAt": "2019-03-25T12:44:02Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will be trivial to fix after #301 is done",
          "createdAt": "2019-03-25T12:50:06Z",
          "updatedAt": "2019-03-25T12:50:06Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry to reopen an old issue, but when reading the current API draft, I noticed that it still says that reusing the Preconnection is possible for Listeners, but not possible for Initiate() and Rendezvous(). For example, see Section 6.1: \"The Initiate() Action consumes the Preconnection [\u2026]\"\r\n\r\nFrom what I read in this issue, I think Preconnections should be allowed to be reused for Initiate() and Rendezvous() as well (possibly with a note on deep-copy).",
          "createdAt": "2020-01-14T14:43:49Z",
          "updatedAt": "2020-01-14T14:43:49Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "MDU6SXNzdWUzNTc2MDEwNjE=",
      "title": "Collapse InitateWithIdempotentData() back in to Initiate()",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/224",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In commentary on #214, @mirjak asks: \r\n\r\nHowever, why do we need to have two different function. If we only have initiate and provide idempotent data as an optional input parameter that should be fine, right?\r\n\r\nThe argument here is that you *really* want to be explicit about the fact that the data you pass to `InitiateWithIdempotentData()` is idempotent, so you have to put it in the name. Another way to do this, though, would be to require a `MessageContext` with the `Idempotent` property to be passed when message data is passed to `Initiate()` on pain of an error.",
      "createdAt": "2018-09-06T10:52:35Z",
      "updatedAt": "2019-03-25T12:45:31Z",
      "closedAt": "2019-03-25T12:45:31Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, you can also put it in the name of the input parameter of the initiate action:\r\n\r\n'Initiate(idempotentData)'\r\n\r\nDo we even need a messageContext here?\r\n\r\n",
          "createdAt": "2018-09-06T10:57:46Z",
          "updatedAt": "2018-09-06T10:57:46Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "On 06/09/2018, 11:52, Brian Trammell wrote:\n>\n> In commentary on #214 <https://github.com/taps-api/drafts/pull/214>, \n> @mirjak <https://github.com/mirjak> asks:\n>\n> However, why do we need to have two different function. If we only \n> have initiate and provide idempotent data as an optional input \n> parameter that should be fine, right?\n>\n> The argument here is that you /really/ want to be explicit about the \n> fact that the data you pass to |InitiateWithIdempotentData()| is \n> idempotent, so you have to put it in the name. Another way to do this, \n> though, would be to require a |MessageContext| with the |Idempotent| \n> property to be passed when message data is passed to |Initiate()| on \n> pain of an error.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/taps-api/drafts/issues/224>, or mute the thread \n> <https://github.com/notifications/unsubscribe-auth/AHC1kt6V3rs5gsQTpNKGCLNep_hmlJyaks5uYP50gaJpZM4WcsYa>.\n>\nI think both are OK. We've visited this in the past I recall.\n\nI favour: InitateWithIdempotentData\n\nFor exactly the reason you say, because it makes it very explicit. If \nApple's API does it different, I would listen to why....\n\nGorry\n",
          "createdAt": "2018-09-06T11:01:08Z",
          "updatedAt": "2018-09-06T11:01:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "now covered by InitiateWithSend(), closing.",
          "createdAt": "2019-03-25T12:45:31Z",
          "updatedAt": "2019-03-25T12:45:31Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWUzNTc5MzQ5MjQ=",
      "title": "\"Fragmentation Prohibited\": message/connection property?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/226",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Discussion on #203 identified that we probably want a Message (and/or Connection) property that forces DF on for IPv4 (and, I guess, ensures that datagram sends on IPv6 below MTU will fail, by disabling sender fragmentation, as well).",
      "createdAt": "2018-09-07T06:23:41Z",
      "updatedAt": "2018-10-10T14:59:55Z",
      "closedAt": "2018-10-10T14:59:54Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This should also prevent IPv4 sender fragmentation. It's possible to generate IPv4 fragments from the stack with the DF set. \r\nI think the property should default to do this, and I'd suggest \"ALLOW Network Fragementation\" as a suggested name.",
          "createdAt": "2018-09-07T07:16:31Z",
          "updatedAt": "2018-09-07T07:16:31Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has to be a Message Property, however, we expect programmers to typically set this property on a Connection or Preconnection (as default for all messages).",
          "createdAt": "2018-09-07T09:01:36Z",
          "updatedAt": "2018-09-07T09:01:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair so you say \"network fragmentation\". This excludes fragmentation in the host, which we may also want to control if we want to send unfragmented PMTU-sized packets. On the other hand, if this includes fragmentation in the host, your suggested default will always fail for TCP when I send messages > PMTU, yet in case of a TCP-like service I really don't want to care about this.\r\n\r\n=> My suggestion would be to just to drop the word \"network\" and (alas) NOT make forbid-fragmentation the default.\r\n\r\n@philsbln it has to be a Message Property, yes. But what makes you say that you'd expect programmers to typically set this on a Connection or a Preconnection?",
          "createdAt": "2018-09-07T09:56:18Z",
          "updatedAt": "2018-09-07T09:56:18Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl the only use case to set this on a per-message basis I can image is PMTU discovery and I hope this is usually done by the transport system implementaion",
          "createdAt": "2018-09-07T10:36:03Z",
          "updatedAt": "2018-09-07T10:36:03Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln I agree with you but don't see the relationship with setting that on a Connection or Preconnection.",
          "createdAt": "2018-09-07T11:33:32Z",
          "updatedAt": "2018-09-07T11:33:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed to the general point that this is a useful property!\r\n\r\nTo the discussion of where it goes, I agree with @philsbln. We had discussed letting defaults for Messages be set connection-wide for convenience, so I think the point is that this would commonly be set as a convenient default, rather than having the application set it over and over.",
          "createdAt": "2018-09-07T15:50:19Z",
          "updatedAt": "2018-09-07T15:50:19Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After reading #203 again, I get the feeling we actually need two properties:\r\n\r\n - **Allow Fragmentation** for the Messages passed to the transport service. \r\n - **Allow IP level Fragmentation** for the Packets generated by the transport protocol.\r\n\r\nNow it becomes ugly: \r\n - For UDP, both are equivalent.\r\n - For TCP/QUIC, the former set to false means that sending a message should fail if the exceeds the PMTU after passing the framer. This also implies that a message should be sent within a single packet.\r\n - For TCP/QUIC, the latter set to false means that the transport system should set the DF flag for v4 and disable local fragmentation for v6, but the transport protocol can still split a message into multiple packets.\r\n\r\nWhile the former definitely works as discussed so far, I have no idea what should happen if the latter is set to false on a message but the former is set to true\u2026",
          "createdAt": "2018-09-08T12:42:02Z",
          "updatedAt": "2018-09-08T12:42:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure about QUIC, but what you say here about TCP isn't right: none of this should matter to TCP, you can't control DF with it and the PMTU shouldn't be visible to the application.",
          "createdAt": "2018-10-08T12:33:25Z",
          "updatedAt": "2018-10-08T12:33:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More on philsbln's note above: I'm putting TCP aside, and assuming he's right about QUIC:\r\n\r\n1) The former set to false, but the latter to true: \"a message should be sent within a single packet\" - but then we want to be able to allow network-layer fragmentation? That seems strange to me.\r\n\r\n2) The latter set to false, but the former to true: so here we want the DF flag, but it's still ok to split messages across multiple packets. Again, that seems strange to me.\r\n\r\n=> I struggle to see a use case for any of these combinations. My proposal would be to have only one boolean property that controls both IP- and transport-level fragmentation (allowing or forbidding both).",
          "createdAt": "2018-10-08T12:44:54Z",
          "updatedAt": "2018-10-08T12:44:54Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "while I was writing #232, I also came to think that this should be a single message context property whose implementation was context-dependent made more sense. I'm happy to rework #232 along these lines.",
          "createdAt": "2018-10-08T12:48:51Z",
          "updatedAt": "2018-10-08T12:48:51Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I may have confused people - but I too think it is OK to express this as one property. I think there are subtle differences, but such details are not important to TAPS. (Any app needing finer control will likely need to control more than this).",
          "createdAt": "2018-10-09T16:58:56Z",
          "updatedAt": "2018-10-09T16:58:56Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this alternative is in #235 ",
          "createdAt": "2018-10-10T09:33:44Z",
          "updatedAt": "2018-10-10T09:33:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #235",
          "createdAt": "2018-10-10T14:59:54Z",
          "updatedAt": "2018-10-10T14:59:54Z"
        }
      ]
    },
    {
      "number": 228,
      "id": "MDU6SXNzdWUzNjAyMDQ4OTk=",
      "title": "Rename either Conn. or Msg. Niceness",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/228",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "I suggest:\r\nConnections have Priorities\r\nMessages have Niceness\r\n\r\nAlso, for Message Niceness (if that's the name that stays), we need to clarify that this can, for example, influence how messages are ordered in the send buffer (as per Mirja's suggestion).\r\n\r\nThis issue is the result of the discussion on Niceness at the interim. See:\r\nhttps://etherpad.tools.ietf.org/p/notes-ietf-taps-interim-2018-09-12",
      "createdAt": "2018-09-14T08:25:01Z",
      "updatedAt": "2019-02-07T09:46:28Z",
      "closedAt": "2019-02-07T09:46:28Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think Priorities and Niceness are just a sign issue, and are not the right way to distinguish between per-message or per-connection/per-stream priorities.\r\n\r\nWhile I like the notion of \"niceness\", I think calling both priorities makes it easier to describe the difference between message priority and stream priority. The exact interaction between both should be declared unspecified, while we should give explicit examples of how the individual priorities map to protocols and interact with other properties like \"ordered\".\r\n\r\nIf we have protocol-specific interactions, they should be captured by protocol-specific properties.",
          "createdAt": "2018-09-20T07:28:46Z",
          "updatedAt": "2018-09-20T07:28:46Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> While I like the notion of \"niceness\", I think calling both priorities makes it easier to describe the difference between message priority and stream priority. The exact interaction between both should be declared unspecified, while we should give explicit examples of how the individual priorities map to protocols and interact with other properties like \"ordered\".\r\n\r\nThis makes sense; however, the sign issue (do priorities go from 0 down or from 0 up?) is not merely a stylistic choice. Post did these 0-down for a reason. Unless the number of priority classes is itself a connection property, ISTM that it's much easier to dynamically handle 0-is-max as opposed to 0-is-min priority. In the former case, any new (higher numeric) priority the TAPS system has not yet seen on a connection must yield to all others, while in the latter, any new (higher numeric) priority must cause *all other* pending stuff to yield. The former seems easier to implement...",
          "createdAt": "2018-09-20T14:55:56Z",
          "updatedAt": "2018-09-20T14:55:56Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have no strong opinion on the choice of Niceness vs. Priority, though I also see Phil's point.\r\n@britram about the implementation benefit - I understand what you say here but I still can't see why this would make it easier to implement. Can you give a concrete example for how this would make things easier?",
          "createdAt": "2018-10-10T06:43:18Z",
          "updatedAt": "2018-10-10T06:43:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram ping",
          "createdAt": "2019-01-23T09:45:44Z",
          "updatedAt": "2019-01-23T09:45:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so presume that you have N queues or transmission treatments configured, and someone starts sending with open-ended highest-wins integer priority N. Okay, cool, assign to highest priority queue. Now what happens when priority N+1 is used? do you shift all the other senders down one?\r\n\r\nwith niceness (open-ended lowest wins), the application developer is kind of forced to think in terms of \"what is my highest priority stuff\" at the beginning.\r\n\r\nmost APIs I know of here has closed-ended priority classes, which is why they sidestep this problem.\r\n\r\n(That said, most of my preference for niceness is aesthetic -- we've had mixed success with wide deployment of \"do non-default stuff to make it Go Faster\", so \"do non-default stuff to yield\" might work out better...)",
          "createdAt": "2019-01-23T09:50:07Z",
          "updatedAt": "2019-01-23T09:50:07Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "not sure that's much beyond a restatement of my october comment though.",
          "createdAt": "2019-01-23T09:50:39Z",
          "updatedAt": "2019-01-23T09:50:39Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's still abstract. Regarding this:\r\n\r\n> Now what happens when priority N+1 is used? do you shift all the other senders down one?\r\nI'd say yes, and I can't see an implementation difference.\r\n\r\nFor most (reasonable) scheduling algorithms, I don't think there's a difference if the new unseen value is high or low, as it has to affect the probability of taking something from the queue for every other queue anyway. Or take the credit-based scheduling that's loosely described in https://tools.ietf.org/html/rfc8298#section-4.1.2.8 - here, a decision about giving a lot of credit or not so much credit to a new stream is made. Whether an implementation maps \"large value from the API\" to \"lot of credit\" or \"large value from the API\" to \"little credit\" doesn't really make a difference, does it? \r\nIn can definitely say that it makes no difference in approaches like our cc. coupling in draft-ietf-rmcat-coupled-cc: here we use the sum of all priorities to calculate the priority share that everyone gets.\r\n\r\nRegarding aesthetics, my argument pro \"priority\" is that a priority is a much more common concept in protocols than \"niceness\" (e.g. also QUIC talks about \"Stream Prioritization\" and not \"Stream Niceness\"). As for \"non-default stuff making it Go Faster\" or not, implementations can define these things as they want, they could also limit priorities to a range of 0-1, then no new value will be \"non default\"?    Bottom line, IMO, this is not *really* about non-default, it's just a number coming from the application, nothing more.",
          "createdAt": "2019-01-23T11:02:04Z",
          "updatedAt": "2019-01-23T11:02:04Z"
        }
      ]
    },
    {
      "number": 230,
      "id": "MDU6SXNzdWUzNjI1Mjk4MjI=",
      "title": "Split \"Notification of excessive retransmission\" in a Connection and a Selection Property",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/230",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "As discussed in #227",
      "createdAt": "2018-09-21T09:28:08Z",
      "updatedAt": "2019-01-18T22:11:42Z",
      "closedAt": "2019-01-18T22:11:42Z",
      "comments": []
    },
    {
      "number": 231,
      "id": "MDU6SXNzdWUzNjc1NDM3OTQ=",
      "title": "Ordering of Operations should refer to Connection states",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/231",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Connections have states, and the document specifies a contract for ordering operations. It seems like the latter of these should probably refer to the former.",
      "createdAt": "2018-10-07T11:05:39Z",
      "updatedAt": "2018-10-08T12:36:53Z",
      "closedAt": "2018-10-08T12:36:53Z",
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWUzNzA0OTYzODk=",
      "title": "Another does of NiTs for Architecture",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/237",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "From /Introudction/\r\nPlease define/API/ in  /Many APIs to perform/.\r\n---\r\nFirst Para mentions TCP, but not UDP - some people could draw conclusions (very silly perhaps) that this is about TCP. It would be super nice to include an e.g. with Datagrams mentioning QUIC and UDP. ...\r\n\r\n\r\n---\r\nFrom /Design principles/\r\nCurent text:\r\n/and it can communicate with different Remote Endpoints to optimize performance./\r\nMy new proposed text:\r\n/and it can communicate with different Remote Endpoints to optimize performance, robustness to failure, or some other metric/.\r\n\r\n---\r\nFrom /Access to Specialized Features/\r\nThis says:\r\n/Since applications will often need to control fine-grained details of transport protocols to optimize their behavior and ensure compatibility with remote peers, a Transport Services system also needs to allow more specialized protocol features to be used./\r\nI quibble. I don\u2019t believe this is /often/, and anyway I do not think this is the most prevalent case, just and important usage, so I would suggest we write something:\r\n/There are applications that will need to control fine-grained details of transport protocols to optimize their behavior and ensure compatibility with remote peers,. A Transport Services system will therefore also needsto allow more specialized protocol features to be used./\r\n---\r\nFrom /Access to Specialized Features/\r\nThis says:\r\n/A specialized feature may be required by an application only when using a specific protocol, /\r\nI suggest:\r\n/A specialized feature could be required by an application only when it uses a specific transport protocol, /\r\nand change:\r\n/For example, if an application is using UDP, it may require/\r\nto:\r\n/For example, if an application is using UDP, it could require/\r\n---\r\nPlease remove /In order to preserve flexibility and compatibility .../\r\nSuggest:\r\n/To preserve flexibility and compatibility .../\r\n---\r\nPlease change:\r\n/Mappings of these API features in the Implementation document, on the other hand, must explain the ramifications of each feature on existing protocols. It is expected that the Implementation document will be updated and supplemented as new protocols and protocol features are developed./\r\nto this:\r\n/The mappings of these API features is explained in the TAPS Implementation [REF], which also explain the implications of the feature provided by existing protocols. It is expected that this documentation will be updated and supplemented as new protocols and protocol features are developed./\r\n---\r\nPlease change:\r\n/require any changes on remote hosts./\r\nsuggest:\r\n/require any changes to a remote host./\r\n---\r\nPlease change:\r\n/Transport protocols such as SCTP provide/\r\nadd commas:\r\n/Transport protocols, such as SCTP, provide/\r\n---\r\n",
      "createdAt": "2018-10-16T08:30:39Z",
      "updatedAt": "2018-10-16T13:05:12Z",
      "closedAt": "2018-10-16T13:05:12Z",
      "comments": []
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWUzNzE0MTI0NDg=",
      "title": "names in code for properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/243",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "The API suggest object, action, and event names. It should suggest property names as well. Add \"code\" names for each of the Selection, (Generic) Connection, and Message properties in the respective subsections.",
      "createdAt": "2018-10-18T08:18:18Z",
      "updatedAt": "2019-03-11T11:12:28Z",
      "closedAt": "2019-03-11T11:12:28Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram do you still want to do this or should I do it as first preparation for the registry/property names PR?",
          "createdAt": "2019-01-29T20:49:20Z",
          "updatedAt": "2019-01-29T20:49:20Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWUzNzQzMDE0MjQ=",
      "title": "Change minset reference from normative to informative",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/245",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Right now, minset is a normative reference for the Interface draft.\r\nIt should be changed to an informative reference for the following reasons:\r\n\r\n- it's not necessary to read how we represent transport features in minset in order to implement the API specified in our interface draft (see [IESG statement on normative references](https://www.ietf.org/blog/iesg-statement-normative-and-informative-references/))\r\n- There is now Appendix C on how minset is reflected in the API.\r\n- it avoids a downref\r\n",
      "createdAt": "2018-10-26T09:31:18Z",
      "updatedAt": "2018-10-31T11:50:36Z",
      "closedAt": "2018-10-31T11:50:36Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Absolutely right, please go ahead and close this.",
          "createdAt": "2018-10-26T09:54:05Z",
          "updatedAt": "2018-10-26T09:54:05Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "MDU6SXNzdWUzNzc3OTU3MjQ=",
      "title": "address TODO's from minset appendix",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/246",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "these are a few minor changes to apply, and properties to add (e.g. \"disable MPTCP\")",
      "createdAt": "2018-11-06T11:02:34Z",
      "updatedAt": "2018-12-12T10:40:33Z",
      "closedAt": "2018-12-12T10:40:33Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is done, yes?",
          "createdAt": "2018-12-04T12:35:47Z",
          "updatedAt": "2018-12-04T12:35:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No. But I'm planning to do a PR to address this issue this week.",
          "createdAt": "2018-12-04T13:05:56Z",
          "updatedAt": "2018-12-04T13:05:56Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that this also requires closing #109, which I re-opened with a concrete proposal to address something from minset.",
          "createdAt": "2018-12-06T08:00:20Z",
          "updatedAt": "2018-12-06T08:00:20Z"
        }
      ]
    },
    {
      "number": 247,
      "id": "MDU6SXNzdWUzNzg2NjE5OTI=",
      "title": "API document should begin with a simple usage example",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/247",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API",
        "help wanted",
        "ready for text"
      ],
      "body": "Similar to the way we added simple diagrams to the architecture document to make the \"story\" of the document more compelling, we should begin the interface document with a simple workflow for an example connection. This way, we can show concretely up front how this is simple and useful, while being quite flexible and powerful. This can also inform how we then continue to explain depth to the details.",
      "createdAt": "2018-11-08T10:12:05Z",
      "updatedAt": "2019-03-11T11:53:50Z",
      "closedAt": "2019-03-11T11:53:31Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to prepare a PR this week.",
          "createdAt": "2019-03-06T11:13:03Z",
          "updatedAt": "2019-03-06T11:13:03Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #293 ",
          "createdAt": "2019-03-11T11:53:31Z",
          "updatedAt": "2019-03-11T11:53:31Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWUzNzg2NzAwMjA=",
      "title": "Implementation should separate out protocol-specific bits",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/248",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Right now, there are protocol specific examples mixed into the generic flow description; then, later, there is a section that has some description for protocol specific considerations.\r\n\r\nPossible re-organizations:\r\n\r\n1.\r\n\r\nPer-protocol mappings for each API call + per-protocol specific options. This is a guide to each protocol, such as a section for UDP and how each call is implemented for UDP, and what options UDP offers specifically.\r\n\r\nGeneral discussion about Pre-Establishment, Establishment, Data Transfer, etc, that has less information about specific protocols.\r\n\r\n2.\r\n\r\nStructure everything with the general topics (Pre-Establishment, Establishment, Data Transfer, etc), and have a rigorous list of each protocol's mappings at the end of each section. So, for Establishment, we describe racing, etc; and then go through and explain what Initiate() does for TCP, UDP, UDP Lite, QUIC, SCTP.",
      "createdAt": "2018-11-08T10:32:51Z",
      "updatedAt": "2019-10-28T01:09:17Z",
      "closedAt": "2019-10-28T01:09:17Z",
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "I'd go further and say that protocol-specific stuff need to be split out into a separate document.\r\n\r\nProtocol-specific mappings should be defined in a standards-track document, whereas most of the Implementation draft should be Informational.",
          "createdAt": "2018-11-14T16:58:30Z",
          "updatedAt": "2018-11-14T16:58:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@JonathanLennox - maybe ... I don't disagree with your proposal, but I do think that this should be a discussion for a larger group. Maybe the right strategy, for now, is to reorganize along Tommy's proposed method #1 or #2 (not sure myself which one is better), and then later take text out as you propose if this is the consensus. Make sense?",
          "createdAt": "2018-11-15T10:32:02Z",
          "updatedAt": "2018-11-15T10:32:02Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "Agreed -- this would need consensus of the WG, not just a GitHub issue discussion.  Separating out the text to start, so it's clear what would end up in a separate document, would be a good first step.",
          "createdAt": "2018-11-15T16:53:23Z",
          "updatedAt": "2018-11-15T16:53:23Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd tend to lean towards option 2, but I suspect we won't know for sure if it works until someone tries to implement the changes. I'd prefer not to introduce more drafts unless we absolutely have to.",
          "createdAt": "2018-11-15T17:29:04Z",
          "updatedAt": "2018-11-15T17:29:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is covered well by #352 ",
          "createdAt": "2019-10-28T01:09:14Z",
          "updatedAt": "2019-10-28T01:09:14Z"
        }
      ]
    },
    {
      "number": 249,
      "id": "MDU6SXNzdWUzODA3OTg0MjI=",
      "title": "API needs a way to handle \"STARTTLS\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/249",
      "state": "CLOSED",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "SMTP and XMPP (among other protocols, probably) have \"STARTTLS\" semantics, where a TLS layer can be inserted on top of an already-existing (unencrypted) connection sometime after some application-layer protocol negotiation has already happened.\r\n\r\nFrequently, the choice of certificate presented / accepted can depend on information in the application-level protocol (since these mechanisms pre-date the invention of SNI).\r\n\r\nThere should be some way some way for applications using the TAPS API to be able to do this.",
      "createdAt": "2018-11-14T17:06:59Z",
      "updatedAt": "2019-11-19T08:22:41Z",
      "closedAt": "2019-11-19T08:22:41Z",
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "API-wise, this feels like it might be similar to the issue of dynamically changing a connection's framer (the Websockets problem).",
          "createdAt": "2018-11-14T17:09:11Z",
          "updatedAt": "2018-11-14T17:09:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, this seems like the same problem as websockets.\r\n\r\nHowever, like websockets, the actual implementation of transition-to-TLS with STARTTLS is application-dependent, so there could be an argument that the application logic really does need to be involved here (i.e., that STARTTLS belongs above the TAPS interface boundary). I'm not sure I buy that argument, though.\r\n\r\nTagging this discuss...",
          "createdAt": "2018-12-03T14:34:03Z",
          "updatedAt": "2018-12-03T14:34:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way to solve this that's a bit of a cute hack is to:\r\n- Let framer protocols defined by the application have the ability to do a short handshake (which is often the case, you may need a prelude prior to application data)\r\n- Put a framer protocol that defines \"STARTTLS\" *below* TLS in your protocol stack to insert itself before TLS starts",
          "createdAt": "2018-12-03T15:52:51Z",
          "updatedAt": "2018-12-03T15:52:51Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "The problem with making STARTTLS be part of a framer is that STARTTLS is, in some circumstances, opportunistic -- the protocol might proceed without TLS if the peer doesn't support it.\r\n\r\nAlso, the first level of application code (parsers, etc.) that uses the TCP connection before STARTTLS is going to be essentially the same as the code that uses the TLS connection after STARTTLS, so artificially forcing the former to be a framer feels unfortunate.\r\n\r\nI feel like a more general solution is a mechanism whereby the application can take an existing connection, and then dynamically add another protocol on top of it, or replace the existing top.  A framer in this context could be just a special case of a protocol.\r\n\r\n(There'd need to be some way for the application, or the replaced protocol, to push back any excessive already-read bytes to its parent connection to be read by the new child, but that doesn't seem so complex.)\r\n",
          "createdAt": "2018-12-03T16:53:19Z",
          "updatedAt": "2018-12-03T16:53:19Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have not fully defined the API of the framer yet \u2013 I guess \"un-reading\" is a common case for a framer anyway. What we then need is\r\na) A way to replace a framer in-flight\r\nb) A set of pseudo-framer, e.g., for TLS\r\nc) A way to stack framers (which also looks not-so-uncommon)",
          "createdAt": "2018-12-06T10:38:31Z",
          "updatedAt": "2018-12-06T10:38:31Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "I think we need to be able to stack protocols in general, not just framers.\r\n\r\nThis was my point with STARTTLS, but consider also the case of implementing HTTPS 1.1 vs. 2:\r\n\r\nConnect with TLS, with ALPN set to \"h2\".\r\nCheck ALPN negotiation in the result\r\nDepending on the result, insert either HTTP/1.1 or HTTP/2 on top of the TLS connection.",
          "createdAt": "2018-12-06T16:55:38Z",
          "updatedAt": "2018-12-06T16:55:38Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@JonathanLennox Must this be exposed through the API directly or, e.g., for the HTTP case, would it be better to hide this below pseudo-transports. \r\n\r\nWe still habe not really described yet what framers are \u2013 do we consider the to work like Linux KCM or do we consider them to really parse the message and returning a message object.\r\nIf we make framers powerful enough, we can at least cover the STARTTLS, ALPN and HTTP/1.1 vs HTTP/2 use cases with them. \r\n\r\nStuff like the upgrade HTTP/1.1 over TLS over TCP to HTTP/3 over QUIC over UDP should better be done by the protocol racing component",
          "createdAt": "2018-12-07T11:26:35Z",
          "updatedAt": "2018-12-07T11:26:35Z"
        },
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "Yes, HTTP/1.1 vs. HTTP/2, proper, should be implemented by the stack itself, since HTTP is a protocol defined by TAPS.\r\n\r\nThat said, TAPS is never going to be able to implement every protocol every application will want to use, and mechanisms like ALPN will likely be needed by applications' protocols as well.  My general rule of thumb is that every mechanism that the TAPS stack needs internally is likely going to also be needed by applications.",
          "createdAt": "2018-12-07T15:42:02Z",
          "updatedAt": "2018-12-07T15:42:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed with a shrug: no stack mutation needs to be in the architecture as discussed in Singapore (106). Framers are capable of being abused^Winnovated-with for stack mutation.",
          "createdAt": "2019-11-19T08:22:40Z",
          "updatedAt": "2019-11-19T08:22:40Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWUzODYxMjg5MzA=",
      "title": "Architecture",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/251",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "admin stuff"
      ],
      "body": "Please can we add a MAMI Ack for the next rev of architecture.\r\nSuitable words are (taken from the API document):\r\n\r\n   This work has received funding from the European Union's Horizon 2020\r\n   research and innovation programme under grant agreements No. 644334\r\n   (NEAT) and No. 688421 (MAMI).",
      "createdAt": "2018-11-30T10:32:00Z",
      "updatedAt": "2018-12-01T22:36:23Z",
      "closedAt": "2018-12-01T22:36:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done!",
          "createdAt": "2018-12-01T22:36:23Z",
          "updatedAt": "2018-12-01T22:36:23Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "MDU6SXNzdWUzODYxNDE1MjU=",
      "title": "Do we need to have an explicit/separate object for Listener?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/254",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "Or is a Listener just a Preconnection that is configured in a certain way? ",
      "createdAt": "2018-11-30T11:05:27Z",
      "updatedAt": "2019-03-25T12:48:49Z",
      "closedAt": "2019-03-25T12:48:49Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Listener is its own object for sure, in my mind. A Preconnection just exists as a configuration/description\u2014it doesn't register anything.\r\n\r\nThe fundamental part of a Listener is that it actually binds to the local ports on the various paths that are applicable. A Preconnection is a potential Connection or Listener, but until you actually initiate or listen, you don't know if you'll hit some error due to someone else on the system having registered on the same port, etc.",
          "createdAt": "2018-12-02T22:38:53Z",
          "updatedAt": "2018-12-02T22:38:53Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I'm pretty sure that every implementation will have an listener object; my questions is rather is that something that needs to be exposed as an own object and does that need to be described in the arch doc? I'm not sure here but I'm also okay keeping it but in that case we need to fix the diagram (as the listener is created from a preceonnection when you call listen).",
          "createdAt": "2018-12-03T09:20:28Z",
          "updatedAt": "2018-12-03T09:20:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that the diagram needs updating, ala #257",
          "createdAt": "2018-12-03T15:53:46Z",
          "updatedAt": "2018-12-03T15:53:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixing API to align with arch #301",
          "createdAt": "2019-03-25T12:48:49Z",
          "updatedAt": "2019-03-25T12:48:49Z"
        }
      ]
    },
    {
      "number": 255,
      "id": "MDU6SXNzdWUzODYxNDIyMjA=",
      "title": "Editorial: Move Message Object to basic objects section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/255",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "Given messages are part of the basic concept we rely on, I would propose to move the definition of Message to the Basic Objects section and rename \"Data Transfer Objects and Actions\" to just \"Data Transfer Actions\".",
      "createdAt": "2018-11-30T11:07:30Z",
      "updatedAt": "2019-10-18T22:58:01Z",
      "closedAt": "2019-10-18T22:58:01Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe put also everything that is listed in the \"Pre-Establishment\" section into the Basic Objects section (basically just remove the heading), because all other subsections then only talk about actions and events.",
          "createdAt": "2018-11-30T11:14:08Z",
          "updatedAt": "2018-11-30T11:14:08Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And as we are talking about this part of the doc, I find it a bit strange that there is a point for \"endpoint\" while that term on it own does not show up in the image. However, actually this point doesn't provide a whole lot of information. The only interesting bit is this sentence:\r\n\r\n\"An Endpoint may be specified at various levels, and an Endpoint with wider scope (such as a hostname) can be resolved to more concrete identities (such as IP addresses).\"\r\n\r\nMaybe we can just remove the endpoint definition and instead add a sentence similar as the one above to each of the local and remote endpoint definitions?",
          "createdAt": "2018-11-30T11:17:43Z",
          "updatedAt": "2018-11-30T11:17:43Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or alternatively, move local and remote endpoint (and message) to Basic Objects, and have a separate section to talk about properties (maybe even including message and connection properties...)",
          "createdAt": "2018-11-30T11:36:31Z",
          "updatedAt": "2018-11-30T11:36:31Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree with this change; perhaps we can have a better name for \"Basic Objects\", but they are a category for a reason.\r\n\r\nPerhaps the Basic Objects can be though of as \"Top-Level Objects\"\u2014they're the main things you interact with to establish connectivity and send data. There are other objects (Endpoints, Paths, Messages) but those are only useful when attached to a Preconnection, Connection, or Listener.",
          "createdAt": "2018-12-02T22:34:55Z",
          "updatedAt": "2018-12-02T22:34:55Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think top-level objects is any better. And I would see endpoint and message also as one of the main things you interact with if you want to send or establish. If you want to create a preconnection you have to create an enpoint first; if you want to send you have to create a message first.\r\n\r\nHowever, I think I understand where you see the difference but I don't know if it is any important to distinguish here. These are all objects while the others things you described are not objects but actions or events.\r\n\r\nI guess if you put all objects in the same section you could have two subsections but I also don't know what the right headings would be (assosiation objects and data objects... :-( )",
          "createdAt": "2018-12-03T09:17:11Z",
          "updatedAt": "2018-12-03T09:17:11Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe tell the story a little bit differently:\r\n - Basic Operation Overview (no message there)\r\n - Transport Services Concepts\r\n   - Objects\r\n   - Phases\r\n   - Actions\r\n   - Properties",
          "createdAt": "2018-12-05T14:21:16Z",
          "updatedAt": "2018-12-05T14:21:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed with @mirjak, let's rename `Basic Objects` to something like `Connection Objects`.",
          "createdAt": "2019-10-18T22:34:48Z",
          "updatedAt": "2019-10-18T22:34:48Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "MDU6SXNzdWUzODYxNDg4MzA=",
      "title": "Reconcile Property groupings between Arch and API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/256",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "Architecture",
        "ready for text"
      ],
      "body": "Reviewing the arch doc right now which talkes about path and protocol selection properties, however, the API doc now has transport properties, connection properties, and message properties... I think we need to realign the terms here....",
      "createdAt": "2018-11-30T11:27:02Z",
      "updatedAt": "2019-01-25T12:53:25Z",
      "closedAt": "2019-01-25T12:53:25Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I admit to being slightly lost now with th\be naming and re-organization process... so maybe this is a left-over thing that should no longer exist... but: the API draft says \"Collectively, Selection, Connection, and Message Properties can be referred to as Transport Properties.\"\r\n\r\nUnless I'm mistaken, this is what's needed:\r\n\r\n- API draft: it seems strange how the list of selection properties (from 5.2.1 onward) appears out of nowhere. There should be a new heading, 5.3, just before what is now 5.2.1, called \"Selection properties\"\r\n\r\n- Arch draft: with some exceptions that should perhaps be removed, the API draft doesn't really distinguish between \"path\" and \"protocol\" selection properties. Can we remove this distinction from the arch draft? Because of the availability of a protocol with certain abilities, a transport system might also make a decision about a certain path, and a path selection property might lead to a decision for a path that rules out a certain protocol... so this distinction seems to me to be a bit artificial anyway.",
          "createdAt": "2018-12-03T08:16:25Z",
          "updatedAt": "2018-12-03T08:16:25Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We converged on classifying properties into Selection, Connection, and Message Properties.\r\n\r\nIf that is still true, then the architecture draft should refer to these classes of properties as well.\r\nI agree that there isn't necessarily a clear distinction between Path and Protocol Selection Properties, so we can merge them into a single class in the architecture document and just state that these properties can influence both path and protocol selection.\r\n \r\nAbout Transport Properties as a generic term to refer to all properties, I don't recall an extensive discussion on this, but I think it's alright (and makes more sense than what is in the API doc now, which basically uses Transport Properties as a synonym for Selection Properties).",
          "createdAt": "2018-12-03T12:27:26Z",
          "updatedAt": "2018-12-03T12:27:26Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I completely agree with @theri \u2013 don't re-iterate the whole discussion, please.\r\n\r\nWe definitely need to make sure properties are consistent across all drafts. That primarily requires changes to Section 4.1.2. \r\n\r\nWhat I definitely would like to see is a short Section in the Architecture explaining what Properties are and that they are our tool to expose \"knobs\" of the transport. \r\nI am willing to volunteer for this, but It may take until next week.",
          "createdAt": "2018-12-05T13:26:33Z",
          "updatedAt": "2018-12-05T13:26:33Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by 5b173e2",
          "createdAt": "2019-01-25T12:53:23Z",
          "updatedAt": "2019-01-25T12:53:23Z"
        }
      ]
    },
    {
      "number": 257,
      "id": "MDU6SXNzdWUzODYxNTI5NjA=",
      "title": "Not all Events are shown in the diagram",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/257",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Should we add \"Connection Ready\", \"Message Sent\", and \"Path Properties Changed\" to the diagram? Actually I not sure why \"Path Properties Changed\" shows up in this doc at all. This seems to be rather specific and the section actually explicilty says \"The API may expand this list.\".",
      "createdAt": "2018-11-30T11:40:16Z",
      "updatedAt": "2019-10-18T23:19:41Z",
      "closedAt": "2019-10-18T23:19:41Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Btw. Receive() is also missing in the diagram...",
          "createdAt": "2018-11-30T11:41:08Z",
          "updatedAt": "2018-11-30T11:41:08Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And listen() should be a call on Preconnection. However see also issue #254 ",
          "createdAt": "2018-11-30T11:48:04Z",
          "updatedAt": "2018-11-30T11:48:04Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually looking at this even more, the way Events are display is confusing in general. Maybe we should considering redrawing this diagram differently or splitting it up in two/multiple diagrams...?",
          "createdAt": "2018-11-30T11:50:56Z",
          "updatedAt": "2018-11-30T11:50:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram can you help look at how we want this diagram to be?",
          "createdAt": "2018-12-02T23:47:57Z",
          "updatedAt": "2018-12-02T23:47:57Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on it.",
          "createdAt": "2018-12-04T12:36:50Z",
          "updatedAt": "2018-12-04T12:36:50Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rendezvous and Framer are not in the diagram but not sure it makes sense to add that; also some events are still missing but I'd be afraid that the diagram becomes too confusing if we add more things. Current diagram is definitely better than the previous version!",
          "createdAt": "2019-01-15T16:24:19Z",
          "updatedAt": "2019-01-15T16:24:19Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still on this one. @mirjak let's have a look at this this week or next.",
          "createdAt": "2019-03-25T12:49:16Z",
          "updatedAt": "2019-03-25T12:49:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I had another look at this and... it seems done to me? @mirjak can you close or point out what else we need here?",
          "createdAt": "2019-06-27T19:58:36Z",
          "updatedAt": "2019-06-27T19:58:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Where \"done\" = \"adding additional events will make the diagram less useful in general\")",
          "createdAt": "2019-06-27T19:59:23Z",
          "updatedAt": "2019-06-27T19:59:23Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that adding more would make the diagram too complex. Maybe it would make sense to have a different diagram that shows all interaction with the application like conn ready or path properties changed; but might also be a boring diagram.\r\n\r\nwhat would be nice, would be to have the rendezvous part in there somehow but that doesn't seem really straight forward... maybe also a separate diagram?",
          "createdAt": "2019-07-01T14:59:34Z",
          "updatedAt": "2019-07-01T14:59:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Weirdest part of the diagram is that send is an arrow into connection... but it's a function that is called on connection, while initiate is an arrow from preconnection to connection, but is a function on the connection.",
          "createdAt": "2019-10-18T22:35:41Z",
          "updatedAt": "2019-10-18T22:35:41Z"
        }
      ]
    },
    {
      "number": 258,
      "id": "MDU6SXNzdWUzODYxNjEzOTI=",
      "title": "Do we need a terminology section in arch?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/258",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "csperkins",
        "britram"
      ],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "I think we should move some of the terms definied in \"Transport System Implementation Concepts\" to a terminilogy section at the beginning of the doc, such as \"Path\", \"Connection Group\", \"Protocol Instance\" and \"Protocol Stack\", because these terms seems rather basic and not implementation internals. Further these terms have already been defined in other docs, so it would just be fine to say there that we are using these terms from these other docs at the beginning.\r\n\r\nAlternatively or additionally, I'm wondering if it would be possible to integrate the term \"Path\" somewhere in the first diagram (\"Concepts and Relationships in the Transport Services Architecture\").",
      "createdAt": "2018-11-30T12:07:15Z",
      "updatedAt": "2019-11-19T08:24:02Z",
      "closedAt": "2019-11-19T08:24:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to representing path in the diagram",
          "createdAt": "2018-12-02T01:01:38Z",
          "updatedAt": "2018-12-02T01:01:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since much of the document really is defining terms and concepts, I'd like to keep those all together in the same part. They used to be more at the front, but then we decided to put more of the Design Principles\u2014\"why this is cool\"\u2014up front. I'd like to get more input and discussion on this.",
          "createdAt": "2018-12-02T01:02:38Z",
          "updatedAt": "2018-12-02T01:02:38Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the \"why this is cool - up front\" sequence that we have now. Seeing a terminology section to begin with makes me think \"okay, I have to learn this by heart, wait, let me get a coffee, now I can dig through this document\". That's ok for a spec that I must read, as a coder... but this one maybe has a different role, of convincing people that this whole TAPS thing is any good?  If that's at least part of the role, I wouldn't put a terminology section early.",
          "createdAt": "2018-12-03T07:57:03Z",
          "updatedAt": "2018-12-03T07:57:03Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, we don't have to have a terminology section, however, I had the feelings that the terms \"Path\", \"Connection Group\", \"Protocol Instance\" and \"Protocol Stack\" don't really fit where they are right now and effectiviely these are exactly the terms that we already defined in other docs and that why I was thinking that a terminology section that explains terms from previous docs could work. Would there be any other option to move these terms somewhere else? Maybe just in their own subsection?",
          "createdAt": "2018-12-03T09:25:41Z",
          "updatedAt": "2018-12-03T09:25:41Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't mind the location, but maybe we need to give more context? The draft is a long list of concepts, with perhaps not enough explanation and context around them.",
          "createdAt": "2018-12-07T12:09:43Z",
          "updatedAt": "2018-12-07T12:09:43Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed as OBE in Singapore.",
          "createdAt": "2019-11-19T08:24:02Z",
          "updatedAt": "2019-11-19T08:24:02Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWUzODYxNjMzNDA=",
      "title": "Clarify path vs endpoint racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/260",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "review"
      ],
      "body": "as I would think a path is an association of a remote and local enpoint...?\r\n\r\nAt least based on the definition we have in the arch doc, I don't really understand the difference.",
      "createdAt": "2018-11-30T12:13:32Z",
      "updatedAt": "2019-03-19T16:05:45Z",
      "closedAt": "2019-03-19T16:05:45Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are different concepts; I can certainly try to improve clarity, but at the most simple levels:\r\n- Path racing is like racing between Wi-Fi and Cellular interfaces, or across different PvDs on a single interface (so, local endpoint related)\r\n- Endpoint racing is like racing between four different IP addresses resolved from a hostname on a single interface/path/PvD (so, remote endpoint related).\r\n\r\nPerhaps specifying that \"endpoint racing\" is really \"remote endpoint racing\" will help",
          "createdAt": "2018-12-01T22:38:53Z",
          "updatedAt": "2018-12-01T22:38:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I updated the architecture document with the following:\r\n\r\n```\r\n* Path Racing: Path Racing is the act of attempting to establish, or \r\nscheduling attempts to establish, multiple Protocol Stacks that\r\n differ based on a selection from the available Paths. Since \r\ndifferent Paths will have distinct configurations for local addresses\r\n and DNS servers, attempts across different Paths will perform \r\nseparate DNS resolution stepss, which can lead to further racing\r\n of the resolved Remote Endpoints.\r\n\r\n* Remote Endpoint Racing: Remote Endpoint Racing is the act of attempting\r\n to establish, or scheduling attempts to establish, multiple Protocol Stacks\r\nthat differ based on the specific representation of the Remote Endpoint, \r\nsuch as IP addresses resolved from a DNS hostname.\r\n```\r\n\r\nDoes that help?",
          "createdAt": "2018-12-02T21:52:23Z",
          "updatedAt": "2018-12-02T21:52:23Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That does help, however, i guess I would call both of these path racing; while one is the remote endpoint racing, I guess the one would then be local enpoint racing...?",
          "createdAt": "2018-12-03T09:10:34Z",
          "updatedAt": "2018-12-03T09:10:34Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": " I actually think /path/ is a good description for this one, it's not really about which endpoint you choose for the source, but which path you wish to evaluate.",
          "createdAt": "2018-12-03T09:17:03Z",
          "updatedAt": "2018-12-03T09:17:03Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with Gorry. \r\nAdding to that: Path racing might be the choice between local interfaces, but it might also be the choice between two IPv6 prefixes that the endpoint got assigned by different routers on the local link, so you essentially choose which router your traffic will go through.\r\n\r\nSmall suggestions/nits for @tfpauly's text:\r\ns/DNS servers/DNS resolvers/\r\ns/stepss/steps/",
          "createdAt": "2018-12-03T12:45:35Z",
          "updatedAt": "2018-12-03T12:45:35Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The confusing part to me is that we defined path as something that has an local and remote enpoint. So with is path racing only focused on local porperties and remote enpoint racing something different?",
          "createdAt": "2018-12-03T12:59:54Z",
          "updatedAt": "2018-12-03T12:59:54Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just skimmed the document for path definitions and the only one I can find is:\r\n\r\n _Path: Represents an available set of properties that a local system can use to communicate with a remote system, such as routes, addresses, and physical and virtual network interfaces._\r\n\r\nWhich fairly well matches @tfpauly's definition of Path Racing. \r\n ",
          "createdAt": "2018-12-06T19:53:20Z",
          "updatedAt": "2018-12-06T19:53:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln right, I don't think that a `Path` is a local + remote endpoint\u2014it is a way off the device, effectively like a PvD (not an association from Post)",
          "createdAt": "2018-12-06T22:12:20Z",
          "updatedAt": "2018-12-06T22:12:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly I used to characterise a path with src-addr + output-interface, but this is not future proof if we consider segment routing.\r\nI guess PvD is a nice first explanation, but might be wrong in many cases, e.g., in an IPv6 hybrid access scenarios with multiple routers on an ethernet network announcing different prefixes and different PvDs or in cases where you have a wireless and wired access within the same PvD\r\n\r\nI guess getting more concrete than your definition will not do us any good.",
          "createdAt": "2018-12-07T11:32:10Z",
          "updatedAt": "2018-12-07T11:32:10Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWUzODYxOTAwNzE=",
      "title": "Editorial: Why own subsection for \"Transport Security Equivalence\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/261",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "I think the text in \"Transport Security Equivalence\" could also just be added to the bullet point above as done for the other requirements as well. I don't see why we need an own subsection there...",
      "createdAt": "2018-11-30T13:35:07Z",
      "updatedAt": "2018-12-02T01:00:07Z",
      "closedAt": "2018-12-02T01:00:07Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Btw. maybe \"Transport Stack Equivalence\" should be a subsection of \"Transport System Implementation Concepts\"?",
          "createdAt": "2018-11-30T13:39:09Z",
          "updatedAt": "2018-11-30T13:39:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed for both points\u2014I just moved the \"Transport Security Equivalence\" section into the bullet point 3 in the stack equivalence, and made that part of the implementation section.",
          "createdAt": "2018-12-02T01:00:07Z",
          "updatedAt": "2018-12-02T01:00:07Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWUzODYxOTMxMDg=",
      "title": "Editorial: section \"Message Framing, Parsing, and Serialization\" seems a bit misplaced",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/262",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "csperkins",
        "britram"
      ],
      "labels": [
        "Architecture",
        "review"
      ],
      "body": "First this section only takes about message framing and not parsing and serialization. Second the section seems to be added random at the end (I know why this is), however, maybe we can add some of the text to the \"Design Principles\" section and other the part taking about message properties (which by the have not be introduced in this doc) somewhere where message is defined...?",
      "createdAt": "2018-11-30T13:43:40Z",
      "updatedAt": "2019-03-19T16:04:35Z",
      "closedAt": "2019-03-19T16:04:35Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I quite agree that this is misplaced at the moment. I think migrating the text it has uniquely into Design Principles and Message makes sense.",
          "createdAt": "2018-12-01T22:32:11Z",
          "updatedAt": "2018-12-01T22:32:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've moved the text into Section 1.3. Data Transfer Using Messages, and 4.1.4. Data Transfer Objects and Actions. I think this flows better. Please let me know if that satisfies you as well!",
          "createdAt": "2018-12-02T23:46:15Z",
          "updatedAt": "2018-12-02T23:46:15Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM (with a couple of minor editorial nits I pushed)",
          "createdAt": "2018-12-07T11:50:47Z",
          "updatedAt": "2018-12-07T11:50:47Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2019-01-15T16:19:20Z",
          "updatedAt": "2019-01-15T16:19:20Z"
        }
      ]
    },
    {
      "number": 263,
      "id": "MDU6SXNzdWUzODYxOTM3NTM=",
      "title": "Security consideration section in arch doc could mention equivalence requirement agian.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/263",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "And provide a backward reference to the respective section",
      "createdAt": "2018-11-30T13:45:29Z",
      "updatedAt": "2018-12-02T23:31:12Z",
      "closedAt": "2018-12-02T23:31:12Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good call! Added.",
          "createdAt": "2018-12-02T23:31:12Z",
          "updatedAt": "2018-12-02T23:31:12Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWUzODc3NjE1NDQ=",
      "title": "Do we want to add Connection Pools to the Architecture / API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/266",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "During the discussion of possible QUIC mappings for TAPS in Bangkok, we have seen that there might be two ways to map QUIC Streams / Connections to TAPS Messages / Connections / Connection groups \u2013 Mapping QUIC Streams to TAPS Message is more convenient for HTTP style applications, mapping QUIC streams to TAPS Connections looks more natural. \r\n\r\nOne way to solve this tussle is to introduce a new kind of object \u2013 a Connection Pool:\r\n- An application can send a message using a connection pool and get events for a reply without touching a connection object\r\n- A connection pool can represent things like a multi-streaming QUIC connection or a bunch of TCP connections between equivalent endpoints.\r\n- To make this logic happen, a Connection Pool needs to be stuffed with framers to make this work\r\n- A Send on a connection pool may take Selection Properties to aid selection between multiple connections within a pool.\r\n\r\nDo we want to add Connection Pools to the Architecture / API ?",
      "createdAt": "2018-12-05T13:40:25Z",
      "updatedAt": "2019-07-08T10:17:00Z",
      "closedAt": "2019-07-08T10:17:00Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mapping a TAPS message to a QUIC stream seems odd to me. QUIC/HTTP streams can carry multiple requests, surely? I'd like to understand the mapping much better before introducing connection pools.",
          "createdAt": "2018-12-06T08:21:43Z",
          "updatedAt": "2018-12-06T08:21:43Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The QUIC/HTTP mapping opens a new bi-directional stream for each request.\r\nIn reply, it can send the HTTP reply and multiple push-promises related to the request.\r\nThe pushed objects then go on a separate uni-directional server-initiated stream each.",
          "createdAt": "2018-12-06T10:23:45Z",
          "updatedAt": "2018-12-06T10:23:45Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't the reply and the push promises be separate TAPS messages? This sounds like several messages sent on a single stream.",
          "createdAt": "2018-12-06T12:29:38Z",
          "updatedAt": "2018-12-06T12:29:38Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So Reply and Push-Promise would be received over the same stream, where a HTTP/3 framer can decide what to do: \r\n- Separate them into separate TAPS messages. \r\n- Append a list of all Push-Promises to the response message \r\n\r\nStill there is a 1:1 relationship between requests/responses and QUIC streams.\r\nThe semantic if push-promise in HTTP/3 binds a push to a request while the unsolicited response comes on new separate stream (which the client would need to \"listen\" for if we map QUIC streams to TAPS connections)\r\n",
          "createdAt": "2018-12-06T14:55:33Z",
          "updatedAt": "2018-12-06T14:58:09Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I view the framer as something that handles packetisation, not something that's involved in connection handling. The Reply and Push-Promise would be de-framed as TAPS messages, and when the server initiates a new stream, a `ConnectionReceived<>` event would fire. The logic is HTTP/3 is not in TAPS; just the framing.",
          "createdAt": "2018-12-07T11:24:10Z",
          "updatedAt": "2018-12-07T11:24:10Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I view framers more as some kind of input filters that can do anything from looking at message boundaries to implementing protocol layers \u2013 but I guess this does not matter for this case.\r\n\r\nIn both cases above, the framer parses HTTP/3 \u2013 the only question is wether on a HTTP/3 frame or an HTTP/3 Request level. The latter has the advantage that Requests are neatly aligned with QUIC streams (except for server push that needs additional application logic) and allow to turn HTTP/3 Requests/Responses into TAPS messages.",
          "createdAt": "2018-12-07T11:47:28Z",
          "updatedAt": "2018-12-07T11:47:28Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems we perhaps need to define the framer more clearly",
          "createdAt": "2018-12-10T18:30:00Z",
          "updatedAt": "2018-12-10T18:30:00Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm afraid that the framer is turning into a magic box that can potentially do whatever we currently can't agree on. Like @csperkins, I didn't expect a framer to do connection handling. However, it seems we do need a certain amount of functionality beyond \"just framing\", like changing them in-flight, as per #249.\r\n\r\nRegarding Connection pools, I'm sceptical - it seems like a proposal to add a lot of extra just to support some possibly obscure types of messages-stream mapping (while we are trying to abstract streams away here, as much as possible). It reminds me a little of a discussion in NEAT, where we added stream numbers just because Michael Tuexen wanted to be able to talk to some existing SCTP servers that assume certain communication to go over a stream with a certain number. That was ok for the research project that it was - but I think here, we should minimize such things; this specific SCTP functionality would probably be a protocol-specific property for us here.\r\n\r\nBack to the point: I think we should add as little as possible, while ensuring that we can communicate with an HTTP/3 peer. This means that, if there are 2 HTTP-QUIC mapping options allowed, optional to choose from, then locally, for a TAPS host, we should pick one, but we must be able to correctly communicate with an HTTP/3 peer that can be implemented with option 1 or 2.  I'm not sure that this amounts to the same functionality?\r\n\r\nIn other words: if a TAPS host wants to correctly communicate with a non-TAPS HTTP/3 host, does it really need these Connection Pools?",
          "createdAt": "2019-01-30T08:21:46Z",
          "updatedAt": "2019-01-30T08:21:46Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Connection pools are not needed for a TAPS host to communicate with a non-TAPS HTTP/3 hosts. This can always be resized on top of TAPS.\r\n\r\nConnection Pools are needed to hide from the application whether HTTPS (HTTP/1.1 over TLS), HTTP/2 or HTTP/3 (HTTP over QUIC) are used. The logic around these protocols has become so tightly integrated with TLS, QUIC and Happy Eyeballs that using these three from TAPS while implementing the HTTP variants in the application may need many back and forth channels, e.g., to add information learned though ALT SRV to the Happy Eyeballs candidates and enable  connection coalescing.\r\nIn the future, it will become even tighter and may also include DNS resolution (see https://github.com/quicwg/base-drafts/issues/253).\r\n\r\nSo I fear without abstracting HTTP away in the connection pool, the tight interactions defined between HTTP variants and everything else will force HTTP clients to re-implement most of the TAPS functionality or require them to interact with the TAPS implementation internals to share all necessary information.",
          "createdAt": "2019-01-30T09:53:20Z",
          "updatedAt": "2019-01-30T09:53:20Z"
        },
        {
          "author": "mikkelfj",
          "authorAssociation": "NONE",
          "body": "If ordered messaging is important, you should map a TAPS connection to a stream. If low latency is important, you should map each TAPS messages to a single stream.\r\n\r\nLatency that is normally 5ms on average can jump to 300ms out of nowhere.",
          "createdAt": "2019-01-30T11:22:40Z",
          "updatedAt": "2019-01-30T11:22:40Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikkelfj I don't think this is the right abstraction, but a hack.\r\n\r\n1. The mapping of Messages to Streams should be done by the application.\r\n2. The only exception I would like to make is for pseudo-transports like HTTP. Here, we have a 1:1 mapping for HTTP/3 (by design, whereby multiple streams can share one connection) and arbitrary mapping for HTTP/1.1 and HTTP/2 (which can introduce head-of-line blocking by sharing a connection). For the latter case, your heuristic is useful.\r\n\r\nTo enable the application to choose between 1. and 2., we need the connection pool abstraction. Using it gives you 2., manually managing connections gives you 1.",
          "createdAt": "2019-02-04T15:38:14Z",
          "updatedAt": "2019-02-04T15:38:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right now there are voices against the Connection Pools in PR #295. I agree with the sentiment of @tfpauly and @britram there that we shouldn't add such functionality unless we must (and they don't seem to see that necessity), i.e. Connections should give you all functionality you need anyway.\r\n\r\nLooking at this issue again, @philsbn writes: \"So I fear without abstracting HTTP away in the connection pool, the tight interactions defined between HTTP variants and everything else will force HTTP clients to re-implement most of the TAPS functionality or require them to interact with the TAPS implementation internals to share all necessary information.\"\r\n\r\nThat draws a worrisome picture. My take-away is that, if Connection Pools are not added, then the implementation draft should explain how Connections can work atop HTTP/1.1, /2 and /3.",
          "createdAt": "2019-03-11T09:30:41Z",
          "updatedAt": "2019-03-11T09:30:41Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I am not sure wether we really need a connection pool object or can merge its functionality into the Connection object. The functionality I see is the following:\r\n - Merge several transport protocol connection into one TAPS connection (possibly also across different protocols like HTTP/1.1, HTTP/2, HTTP/3\u2026).\r\n - Link Requests to Responses.\r\n - Allow per-message path- and endpoint selection (which implies automatically spawning transport protocol connection including racing)\r\n\r\nAs this semantic requires a big explicit switch, I am not sure this is \"just\" a selection property.",
          "createdAt": "2019-03-11T09:52:52Z",
          "updatedAt": "2019-03-11T09:53:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand. But if we can do this more easily, with lots of \"Require\" classifiers, that would be nicer IMO.",
          "createdAt": "2019-03-11T10:02:12Z",
          "updatedAt": "2019-03-11T10:02:12Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that abstracting some more connection/stream/message handling away from the application is a good idea. I think it would be best to have this functionality provided by a TAPS Connection, instead of adding a separate Connection Pool.\r\nHowever, this is not \"just\" a selection property, but a bigger switch. Actually I'd like it if the application does not explicitly have to set a property that it is okay with having multiple underlying TCP connections instead of one QUIC connection, for example.\r\n\r\nAs I see it, this goes back to our definition of TAPS Connection and how it relates to Protocol Instances and Stacks, maybe touching upon the \"What is a Connection\" discussion we had a year ago:\r\n\r\nReading the architecture draft, I find that Connection is defined as \"state pertaining to the underlying transport protocol instance and any ongoing data transfer\", and Protocol instance is right now defined a \"a single instance of one protocol\". From this I conclude that one TAPS Connection can maybe abstract one QUIC connection with multiple streams, but it cannot abstract multiple TCP connections. Thus, an application would have to check whether the Connection is HTTP/1.1 HTTP/2, or HTTP/3, and in the two former cases, perhaps it has to create more TAPS Connections. I agree this is a problem.\r\n\r\nTo solve this, I think we could define a TAPS Connection as \"state pertaining to one or multiple underlying transport protocol instances\". Then the application would have just one TAPS Connection and be able to use it like a Connection Pool in PR #295, just send Messages and not care about the HTTP version or any underlying TCP connection or HTTP/2 or QUIC stream handling.\r\n\r\nHowever, this has architecture implications. For example, it implies that Initiate() is not the only action that can spawn a TCP connection, but a transport system can also create new TCP connections (or new QUIC streams) on Send(). So if the application calls Send(), it might result in a new underlying TCP connection for the same TAPS Connection. I'm not sure our current architecture covers this. \r\nSimilar with Listen() and Receive(): Does an incoming TCP connection always create a new TAPS Connection for the application, or can it also just be an incoming Received<> event? \r\n\r\nI'm wondering if defining a Connection as potentially multiple protocol instances could create problems for Connection Properties, which might be different for different protocol stack instances, i.e., different TCP connections.\r\n\r\nAlso, I'm wondering about multipath/multistreaming protocols - right now, Section 4.2 in the architecture document reads as if any \"multiplexing transport protocol\" MUST be represented as multiple TAPS Connections in a Connection Group to the application. But maybe we want to further abstract this in some cases, i.e., hide the multiple streams from the application, and just provide one TAPS Connection to the application, on which it receives multiple Messages? Then we would again be close to the Connection Pool proposed in the PR.\r\n\r\nSo, all in all, if we want this functionality (which I think we really want), but not add Connection Pools but let the Connection provide the functionality, I think we have to go back and revisit the definition of Connection and how it relates to protocol stack instances.\r\nI suggest we talk about this in-person in Prague.",
          "createdAt": "2019-03-11T11:04:18Z",
          "updatedAt": "2019-03-11T11:04:18Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see any of this land today anyway \u2013 will make two PRs for discussion in Prague \u2013 one with explicit Connection Pool object and one with extended Connection object and selection Property with default forbid.\r\n\r\n@theri do you think the time for connection pools on the agenda is sufficient?",
          "createdAt": "2019-03-11T11:04:53Z",
          "updatedAt": "2019-03-11T11:08:20Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @theri for this very good analysis of the situation. Exactly the scope for a discussion to be had IMO.",
          "createdAt": "2019-03-11T13:01:18Z",
          "updatedAt": "2019-03-11T13:01:18Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I can see benefits in adding this (thanks Theresa for the review of issues) - but I still don't know that we have to do this right now - so why would I change from: \"we shouldn't add such functionality unless we must\"? ",
          "createdAt": "2019-03-21T08:56:44Z",
          "updatedAt": "2019-03-21T08:56:44Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Status update for this issue:\r\n - PR #321 adds a way to link requests and responses to the API.\r\n - Once #321 landed, I will make another PR to the API that describes connection coalescing and connection pooling",
          "createdAt": "2019-05-15T12:08:49Z",
          "updatedAt": "2019-05-15T12:08:49Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With #321 merged, there is only the connection coalescing and connection pooling part missing, which needs a bit of discussion in Montreal before turning it into text.",
          "createdAt": "2019-07-04T08:19:38Z",
          "updatedAt": "2019-07-04T08:19:38Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this issue as all remaining work moved to Implementation and will be tracked in Issue #339",
          "createdAt": "2019-07-08T10:17:00Z",
          "updatedAt": "2019-07-08T10:17:00Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWUzODgxNTE1MzI=",
      "title": "Property text cleanup",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/268",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "- Some have a type, some don't.\r\n- Somewhere it says that this property applies to connections and connection groups, when *all* the per-connection ones should apply to groups (so this needs a general statement on top instead of a mention in every property).\r\n- Some have a mention of a default value, some don't.\r\n",
      "createdAt": "2018-12-06T10:34:41Z",
      "updatedAt": "2019-01-24T08:23:14Z",
      "closedAt": "2019-01-24T08:23:14Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WRT \"some have a type, some don't\" -- some of this may be intentional after my last edit pass, where I removed the explict \"preference\" type for things that are selection preferences. We can add it back if there's consensus that that's a better style though.",
          "createdAt": "2018-12-06T11:30:20Z",
          "updatedAt": "2018-12-06T11:30:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can do one pass over them when preparing the PR proposal for the registry stuff",
          "createdAt": "2018-12-06T18:46:17Z",
          "updatedAt": "2018-12-06T18:46:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, this isn't a useful issue (sorry for opening it!) - it's like opening an issue that says \"typos here and there\". The right thing to do is to proof-read the whole thing, or the part this is about, and do a PR with fixes. No general discussion needed, so I'm closing this.",
          "createdAt": "2019-01-24T08:11:46Z",
          "updatedAt": "2019-01-24T08:11:46Z"
        }
      ]
    },
    {
      "number": 269,
      "id": "MDU6SXNzdWUzODgyNTk4MDc=",
      "title": "Clarify multi-streaming can cause that ConnectionReceived events can be fired from pre-connection used for initate()",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/269",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "This issue popped up while discussing #266 and seem to be a wired QUIC multi-streaming issue, possible affecting SCTP too):\r\n\r\nWhen a multi-streaming protocol like QUIC allows both ends to open new streams (e.g. by cloning the QUIC connection representing the stream), the both side needs a way to get a ConnectionReceived event for a new stream. That might result in the following weird pattern:\r\n```\r\npc1 := NewPreconnection(\u2026)\r\nc1 := pc1.Initiate()\r\n\u2026\r\npc1 ->  ConnectionReceived<c1.1>\r\n\u2026\r\npc1 ->  ConnectionReceived<c1.2>\r\n```\r\n\r\nI think this needs to be documented somehow and we may need to add a Selection Property do turn off this behaviour.",
      "createdAt": "2018-12-06T15:18:09Z",
      "updatedAt": "2019-06-14T21:22:30Z",
      "closedAt": "2019-06-14T21:22:30Z",
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Calling `Initiate()` is an active open. Once the connection is open, the peer can open new streams, but those would surely be `ConnectionReceived<>` events on the *`Connection`* not on the `Preconnection`.",
          "createdAt": "2018-12-07T11:18:40Z",
          "updatedAt": "2018-12-07T11:18:40Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins I am not sure with this one: assuming you have a bunch of ``Connections`` which are streams on the same multi-streaming connection \u2013 which one should fire the ``ConnectionReceived<>``? The first one? What happens if I close the first one?",
          "createdAt": "2018-12-07T11:36:22Z",
          "updatedAt": "2018-12-07T11:36:22Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a good point, and I'm not sure I know the answer, but I *don't* think the`Preconnection` should fire the events. A `Preconnection` is a potential connection, yet to be instantiated, but these connections come from an already active connection.\r\n\r\nI've never been entirely comfortable with cloning a connection as the multi-streaming abstraction. This is perhaps the first scenario where it struggles though.",
          "createdAt": "2018-12-10T18:35:04Z",
          "updatedAt": "2018-12-10T18:35:04Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not understand the pattern in the example. You do not get a ConnectionReceived after an active open, you need a Listen?",
          "createdAt": "2018-12-10T19:19:45Z",
          "updatedAt": "2018-12-10T19:19:45Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom Your assumption is true for TCP, but not for multi-streaming transports like QUIC.\r\nWith QUIC, you can indeed get additional TAPS connections (QUIC streams) based on an existing, initiated connections. The question is how to handle this.\r\n\r\n@csperkins A possible way out would be making ``ConnectionGroup`` an explicit Object that fires the ``ConnectionReceived<>`` (possibly renamed to ``ConnectionEstablished<>``. An ``initiate()`` then would return the connection group (in analogy to the ``Listener`` for ``listen()``) and the ``Connection`` itself is returned by an event then.",
          "createdAt": "2018-12-11T10:23:38Z",
          "updatedAt": "2018-12-11T10:23:38Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln the TAPS interface is the same weather you have TCP or QUIC underneath. For TAPS an active open generates a READY event not a ConnectionReceived? I do not think your example is a valid TAPS sequence.",
          "createdAt": "2018-12-11T10:31:22Z",
          "updatedAt": "2018-12-11T10:31:22Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom the Ready event is not shown in the example (it would be within the first ``\u2026``).\r\nThe problem I raised is how to model the addition of streams to a multi-streaming connection. In case of QUIC, additional streams can be initiated by the server/listening side of the QUIC connection.\r\nIf we model QUIC streams as TAPS connections, this results in ``ConnectionReceived<>`` events at the client (and server) side for each new QUIC stream.",
          "createdAt": "2018-12-11T13:01:08Z",
          "updatedAt": "2018-12-11T13:01:08Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln agree we could add `ConnectionGroup`, although it's a significant shift in the model. If we did that, we might also want to revisit `clone()` as the way of creating a new stream on a connection, in favour of a method on `ConnectionGroup`.\r\n\r\n@tfpauly did you implement this with QUIC? How does your implementation work?",
          "createdAt": "2018-12-11T18:27:59Z",
          "updatedAt": "2018-12-11T18:27:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also see a problem with the communication pattern here. To me, modelling a stream as a TAPS connection means that for every new connection that a peer creates (be it a stream of an existing connection or not), I'll have to listen. So: if I expect 5 incoming connections, which may e.g. be 1 connection with 1 stream and 4 later-added streams below the API, I'll have to listen 5 times.\r\n\r\nWhat this also means is that the grouping notion should be a readable property - I believe that we currently only describe it as something that's actively created via clone().\r\n\r\nRegarding code, no idea how @tfpauly has done this, but I believe that the NEAT implementation is like I describe here. For more details on this specific aspect, see: http://dl.ifip.org/db/conf/networking/networking2017/1570349380.pdf",
          "createdAt": "2018-12-12T10:58:52Z",
          "updatedAt": "2018-12-12T10:58:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins We create a Listener from a Connection to handle inbound streams associated with the same parent transport connection. \r\n\r\n@mwelzl Currently, our Listener object doesn't require calling Listen() for each new connection\u2014you can get the event invoked many times, so it doesn't require knowing how many streams may be opened by the peer. In order to get back pressure, we're talking about having a window for how many new inbound connections will be allowed at a time.",
          "createdAt": "2018-12-12T17:48:10Z",
          "updatedAt": "2018-12-12T17:48:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, that also sounds perfectly reasonable. Actually it seems that this (receiving multiple ConnectionReceived events on one Preconnection) is already supported by our current text, sorry for missing this!\r\n\r\nSo... what is the problem we're discussing here - what do we need to change in the text?\r\nI think we need only the following:\r\n\r\n1. do we have a use case for one Listener getting multiple Connections *without* having these Connections grouped? (I guess not? Grouping is not a *promise* of multi-streaming.) If so, we need the ability to query whether connections are grouped (currently grouping is only created actively via \"clone\"). Otherwise, we can just statically say that all Connections that are created from the same Preconnections are grouped.\r\n\r\n2. some kind of ConnectionReceived event for the Rendezvous case, with text saying that all Connections created off the same PreConnection are grouped.  (right?)\r\n\r\n3. a way to provide back pressure. Here, we already have PreConnection.Stop(). In the interest of keeping things simple, do we think that intelligently switching between a listening and a non-listening mode would be enough? If so, maybe we should have a call similar to Stop which stops listening, but does *not* dispose of the PreConnection, such that Listen could be called again. Maybe have an \"End\" call which stops and disposes, and let Stop only stop listening (because \"Stop\", to me, indicates only stopping but nothing else).",
          "createdAt": "2018-12-13T08:29:48Z",
          "updatedAt": "2018-12-13T08:29:48Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly This solution sounds very reasonable \u2013 I guess we should do it the same way for TAPS and add that as Text to the API\r\n\r\n@mwelzl Some comments:\r\n\r\n1. It depends \u2013 if writing a server, you might want all streams of a multi-streaming connection grouped, but not all multi-streaming connections received through the same listener. So the behaviour wether to group should be a property of the Listener.\r\n\r\n2. I would not group connections received through the same Rendezvous (analogous to server-style listener).\r\n\r\n3. We might want to add a ``Stop()`` and a ``MaxPendingConnections``or  ``MaxConnections`` property to the listener ",
          "createdAt": "2018-12-13T11:32:06Z",
          "updatedAt": "2018-12-13T11:32:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbn:\r\n\r\n1. I agree, but: just because groups may encompass more than the Connections from one Listener doesn't mean that it would be bad to always group the Connections from one Listener (i.e., group them among themselves, but maybe group them with others too). Besides, I think that wouldn't be the listener *deciding* anyway.\r\n\r\n2. Just to understand this, are you saying \"no, see my argument for case 1\" ?  Then we're just discussing case 1, my answer is above. Otherwise I'd say: why not?\r\n\r\n3. yes ... but what do you mean with `Stop()`? We have `Stop()`, just the semantics are not what I suggested. Regarding `MaxConnections`, I think that's a good idea - my own proposal was me overdoing \"keep it simple, let's not add features\". Nobody needs to use this unless they want to.",
          "createdAt": "2018-12-13T12:04:24Z",
          "updatedAt": "2018-12-13T12:04:24Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl \r\n\r\n1. I guess the answer really depends on what a connection group is for you. I always saw connection groups as an abstraction for multi-streaming connections (or their emulation) \u2013 therefore I see no use for grouping connections from multiple listeners. My opinion is auto-grouping for multi-streaming is fine, otherwise it is not.\r\n\r\n2. really falls out of 1\r\n\r\n3. I want your semantics, but call it ``Listener.stop()``",
          "createdAt": "2018-12-13T14:25:46Z",
          "updatedAt": "2018-12-13T14:25:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln \r\n\r\n1. Me too. I can imagine other things ( this paper of ours comes to mind:  http://heim.ifi.uio.no/michawe/research/publications/ctrltcp-infocom-gi-2018.pdf  ), but generally I agree and don't think we should complicate the API for this. But I'm getting confused: *you* wrote \"you might want all streams of a multi-streaming connection grouped, but not all multi-streaming connections received through the same listener\". That sounded to me like *you* want to support multiple streams, but from several listeners?!\r\n\r\n2. ACK\r\n\r\n3. Agreed!",
          "createdAt": "2018-12-13T14:55:51Z",
          "updatedAt": "2018-12-13T14:55:51Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl let me elaborate on this\u2026\r\n\r\n- You might want all streams of a multi-streaming connection grouped, e.g., all streams within  a QUIC connection\r\n- You might not want all multi-streaming connections (e.g., QUIC connections) received through the same Listener object grouped\r\n- You definitely do not want all  all streams of all QUIC connection received through one listener grouped (except if you have hierarchical groups that allows you to sort that out the cases above) ",
          "createdAt": "2018-12-13T15:45:41Z",
          "updatedAt": "2018-12-13T15:45:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with all this. Anyway I think it's a moot point: whether they're grouped or not is not up to the listener to decide? So grouping needs to be something that can be queried.",
          "createdAt": "2018-12-13T21:36:01Z",
          "updatedAt": "2018-12-13T21:36:01Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok \u2013 fair enough \u2013 but I still think the Listener is the right place to _configure_ whether connections that come out of it should be grouped by default or not.",
          "createdAt": "2018-12-17T08:42:57Z",
          "updatedAt": "2018-12-17T08:42:57Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not unless we have a concrete idea on what to do with this information inside the transport system.\r\n\r\n=> I think no text update is needed as a result of this issue and lean towards closing it...",
          "createdAt": "2019-01-03T16:09:17Z",
          "updatedAt": "2019-01-03T16:09:17Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we really need a text update for the grouping, but for the original question.\r\n\r\nTo address the handling of incoming streams in multi-streaming connections, I would like to have the solution @tfpauly outlined reflected in the API.",
          "createdAt": "2019-01-08T14:33:15Z",
          "updatedAt": "2019-01-08T14:33:15Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One question on this, for @tfpauly, the description of your Listener object being able to accept multiple events, is that how it works in general or was that specif for a multi-streaming scenario?\r\nAs specified I am not sure that our Listen action does not allow multiple ConnectionReceived events? The text says \r\n\r\n> Listening continues until the global context shuts down, or until the Stop action is performed on the same Preconnection",
          "createdAt": "2019-01-25T14:08:30Z",
          "updatedAt": "2019-01-25T14:08:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom The listener object for all cases (both multi streaming and receiving brand-new transport connections) allows multiple events.\r\n\r\nI think the existing text is a bit ambiguous, but it seems that \"listening continues\" implies that the event can certainly fire again.",
          "createdAt": "2019-01-28T17:32:53Z",
          "updatedAt": "2019-01-28T17:32:53Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Revisit after #301 is done",
          "createdAt": "2019-05-08T16:48:05Z",
          "updatedAt": "2019-05-08T16:48:05Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWUzOTA2NDIzNTY=",
      "title": "Add re-initiate() call for voluntary connection migration ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/270",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "future work"
      ],
      "body": "In #38 we discussed several reasons and ways how multipath and connection migration may be used to address changing application requirements. While most of the use-cases are better captured by a connection pool (see Issue #266 and #38), some might really want to change an existing connection. Therefore, we should add something like re-initiate to perform this operation.",
      "createdAt": "2018-12-13T11:47:11Z",
      "updatedAt": "2019-11-19T08:32:25Z",
      "closedAt": "2019-11-19T08:32:25Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The discussion in #38 ends with @gorryfair saying: \"...this drfat needs to leave the path selection properties in Pre-Establishment state - It's always possible to be more exotic and there are clearly cases where this will in future be useful. However, I am really keen to avoid making this API byzantine in complexity, and this is an area where I fear this is great PhD material and poor standards.\" which got a thumbs-up from @tfpauly. Then, @philsbln wrote: \"I came to the conclusion that this kind of functionality is best capsuled either in a connection pool (see Issue #266) or in some migrate/re-initiate call for most practical use cases.\"\r\n\r\nHere you're asking for the re-initiate because some practical use cases don't seem to be captured by the connection pool idea. Could you give us examples?",
          "createdAt": "2019-01-25T09:56:11Z",
          "updatedAt": "2019-01-25T09:56:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll try closing and hope that all is well  :-)     I mean, it was even marked as \"science fiction\"...",
          "createdAt": "2019-01-29T15:49:20Z",
          "updatedAt": "2019-01-29T15:49:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "``Connection Pool`` solves everything that communicates in a request/response pattern, e.g., HTTP. This is the \"automagic\" mode.\r\n\r\n``re-initiate`` is needed if one really uses a stream and wants to manually migrate it, e.g., explicitly switching to a different address for SCPT or open a sub-flow for MPTCP. \r\n\r\nStill two different issues.",
          "createdAt": "2019-01-29T20:46:05Z",
          "updatedAt": "2019-01-29T20:46:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, understood - fine to keep discussing this as a separate issue. However, I'd still like to close it: can you tell me very concretely when / how you need this?  FWIW, address switching in SCTP is handled *by* SCTP, and the API that gives such per-sub-flow control for MPTCP hasn't gone further in the MPTCP group IIRC.\r\n\r\nA concrete problem I see with this is: what are the real semantics of re-initiate, regarding the old Connection? That all data is perhaps lost, or perhaps not? How much must I retransmit on the new connection? Can there be duplicates?\r\n\r\nIt seems that these things must then be handled by the application, if it really needs to such functionality. Thus, could this be part of what a framer does?",
          "createdAt": "2019-01-30T08:02:50Z",
          "updatedAt": "2019-01-30T08:02:50Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For SCPT, a re-initiate does roughly the same as the \"Set Primary Address\" socket option, but instead of specifying the address, one could also use the selection property magic.\r\n\r\nFor MPTCP, I presume this will most likely change parameters in the path manager, e.g., whether to use the sub-flows as active/backup or active/active or change the primary sub-flow.\r\n\r\nThe semantic of re-initiate is \"migrate/adapt if possible\" \u2013 for the other case, I am unsure whether it is \"break and initiate a new one\" or \"do nothing\" \u2013 maybe this can be a parameter.",
          "createdAt": "2019-01-30T10:24:55Z",
          "updatedAt": "2019-01-30T10:24:55Z"
        }
      ]
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWUzOTA3MjY3NTE=",
      "title": "Clarify what a framer is and what it can do ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/271",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "discuss",
        "help wanted"
      ],
      "body": "In the discussion of Issues #266 and #249 we encountered that the current document do not really describe what a framer is and can do.\r\n\r\nNon-conclusive list of open questions:\r\n- Do framers only determine frame boundaries (as Linux KCM) or do they parse whole message and return nice objects?\r\n- Are framers stackable?\r\n- What functionality/API can framers use \r\n- Do we want a bunch of standardised framers to implement (pseudo-)protocols like HTTP\r\n- Can we switch framers (e.g.,  to implement STARTTLS)",
      "createdAt": "2018-12-13T15:20:52Z",
      "updatedAt": "2019-01-25T13:03:59Z",
      "closedAt": "2019-01-25T13:03:59Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A first pass at these. I'm going to start with the last one, because IMO it's the only question driven by the demands of the protocols we implement in TAPS (which should be the source of requirements in an abstract API)\r\n\r\n>    Can we switch framers (e.g., to implement STARTTLS)\r\n\r\nThis is the most important question in this pile IMO, since the answer determines the set of protocol stacks we can \"assist\" with framing. I think we want the ability to switch framing modes. The subquestion here seems to be how modeswitching works:\r\n\r\n- does the framer switch its own mode, \r\n- or does it ask the TAPS system to switch to a different framer,\r\n- or does it ask the application to switch to a different framer,\r\n- or does the application have to notice it's in a different mode and switch to a different framer.\r\n\r\nImplementation issues here seem mainly to be related to pushback and buffering.\r\n\r\n>    Do framers only determine frame boundaries (as Linux KCM) or do they parse whole message and return nice objects?\r\n\r\nThis seems to me to be implementation-dependent -- it turns a bytestream into whatever message abstraction the API presents to its client. Different implementations are going to have different reasons to have the thing returned/consumed have a different shape.\r\n\r\n>    Are framers stackable?\r\n\r\nThis seems to depend on the answer to the question above, which means it's implementation dependent.\r\n\r\n>    What functionality/API can framers use\r\n\r\nThis... also seems implementation dependent -- restrictions on framers are up to the environment the implementation provides for framers. (ISTM that framers should almost-always look like functions, but whether those functions have a hook for, e.g., maintaining state is... implementation-depedent.)\r\n\r\n>    Do we want a bunch of standardised framers to implement (pseudo-)protocols like HTTP\r\n\r\nIf the framers are implementation-dependent, then this seems like \"no\". We could suggest a set of framers that should be made available, and names for them, I suppose. But otherwise this seems like overspecification for an abstract interface.\r\n\r\nLet me add another question to this list: do we need to somehow explicitly support the notion of hardware-accelerated framers?\r\n\r\n\r\n",
          "createdAt": "2018-12-21T16:35:32Z",
          "updatedAt": "2018-12-21T16:35:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As y'all know, I favor simplicity. I'm sceptical about layered framers etc. ***being an issue for the TAPS API design***  (I'm not at all sceptical about such things existing in code!).  My view is that framers should essentially be a hook to a function to frame or deframe, and yes you should be able to change it, at your own risk, anytime you want. Luckily, so far, that seems to match what we have in the text, except that we don't have text allowing to change framers on existing connections so far (I think it should be added).\r\n\r\nSo, from that perspective, I'm very happy with everything @britram says in his answer here: implement what you wish, but let's not concern the API with it.\r\n\r\nRegarding @britram's question: how mode switching would work - here I'd be tempted to quickly shoot \"the app can decide, whenever, just supply a new function and that's it\", but the mention of pushback and buffering makes me wonder if I'm missing something. Maybe, just maybe, that simple approach isn't good enough. I'd suggest to choose this option for now until someone sees a case where this causes a real problem.\r\n\r\nAbout hardware-accelerated framers, I guess @tfpauly is the only one who could answer this.",
          "createdAt": "2019-01-03T16:04:59Z",
          "updatedAt": "2019-01-03T16:05:48Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree with @britram and @mwelzl. My view of framers was as functions of the form:\r\n``\r\nfn deframer(newly_received_data, saved_context) -> (parsed_object, context_to_save)\r\n``\r\nI'd expect a particular implementation of TAPS to provide a standard set of these framers that are instantiated when the connection is setup for a known pseudo-transport, or you can pass a custom deframer for a new protocol.\r\n\r\nDo we need to stack framers? I'm not sure. An implementation would likely be engineered to allow message parsing and de-framing code to be internally composed in some way, but conceptually it's not clear we need more than a single level in the API. Features like STARTTLS can be conceptually handled within an HTTP framer, for example.",
          "createdAt": "2019-01-15T15:34:05Z",
          "updatedAt": "2019-01-15T15:34:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this because the useful remnant of this discussion is continued in #249.",
          "createdAt": "2019-01-25T13:03:57Z",
          "updatedAt": "2019-01-25T13:03:57Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWUzOTU5NDIxMTU=",
      "title": "7.3.7. Reliable Data Transfer (Message) redundant?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/273",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Because we also have 7.3.1 Lifetime, with the statement \"When a Message\u2019s Lifetime is infinite, it must be transmitted reliably.\"",
      "createdAt": "2019-01-04T14:22:11Z",
      "updatedAt": "2019-01-25T13:16:41Z",
      "closedAt": "2019-01-25T13:16:41Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is IMO an open question -- \"infinite lifetime\" meaning reliable came from Post Sockets (and I'm, of course, partial to this way to do things), but I think this redundancy came from someone thinking that was a little too implicit. ",
          "createdAt": "2019-01-07T10:14:29Z",
          "updatedAt": "2019-01-07T10:14:29Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's redundant nevertheless. My suggestion is to leave the issue open for a bit, and at some later point, if nobody objects, remove \"Reliable Data Transfer (Message)\".",
          "createdAt": "2019-01-07T11:06:25Z",
          "updatedAt": "2019-01-07T11:06:25Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It has a slightly different meaning (putting the 90% of the packets corner-cases aside):\r\n - ``Message Lifetime`` suggests when to expire a message form send/retransmit queue\r\n - ``Reliable Data Transfer (Message)`` suggests whether to re-transmit regardless of any timing.\r\n\r\nThe former is useful for optimising retransmissions in real-time scenarios, the latter is useful for application-level FEC/network coding.",
          "createdAt": "2019-01-08T14:44:19Z",
          "updatedAt": "2019-01-08T14:44:35Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even after your explanation I don't understand how the latter of your cases differs from \"Lifetime\" set to infinite.",
          "createdAt": "2019-01-08T14:58:31Z",
          "updatedAt": "2019-01-08T14:58:31Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On review, I don't think \"Reliable Data Transfer\" (Message) is, on its own, unambiguously implementable. \r\n\r\nPost Socket's per-message PR parameters (Lifetime and Niceness) were drawn from how SCTP allows apps to set PR preferences. \r\n\r\n[RFC 3758](https://tools.ietf.org/html/rfc3758#section-4.1) defines a \"timed reliability\" service, which is exactly what Message Lifetime is meant to expose. This makes sense, since PR is most useful in media applications where time limits are easy to determine.\r\n\r\n[RFC 7496](https://tools.ietf.org/html/rfc7496#section-3.1) adds a \"Limited Retransmissions\" service, which allows the sender to set the max (but not min or average or required) RTX count. A trivial implementation of `\"Reliable Data Transfer (Message)\" := False` could be equivalent to setting this counter to 0. IIRC, this is in SCTP because I asked Michael T\u00fcxen for it in 2006 on behalf of the IPFIX working group, but I don't think anyone ever implemented it for IPFIX. Nevertheless if we believe in it we could add it as a message property (which wouldn't be \"reliable data transfer\", but rather \"max RTX count\").\r\n\r\n(7496 also specifies [priorities](https://tools.ietf.org/html/rfc7496#section-3.2), which is covered by Niceness).",
          "createdAt": "2019-01-08T15:09:10Z",
          "updatedAt": "2019-01-08T15:09:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed, RFC 7496 has some rather obscure features; when I talked to Michael Tuexen about it, he said that it was implemented upon request from people who needed it - but these would be people with very specific SCTP needs, caring about the number of packets being sent under certain circumstances  for telephony signalling. If you care at that level, you care about the specific protocol in use too.\r\n\r\nAt least the RTX count only makes sense for an application if it also knows some things about the environment (the RTT, at least) that it might not need to care about... and the app-measured RTT may not be quite the same as the transport-measured one. The latter is unavailable to the app but matters greatly for the RTX count. I think that a lifetime is enough for partial reliability that's meaningful to the application, and perhaps priorities, which indeed map to our per-message Niceness.",
          "createdAt": "2019-01-08T15:26:22Z",
          "updatedAt": "2019-01-08T15:26:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What I'm saying is I'm the one who asked for RTX count, and I'm not sure it's useful. So I'm +1 to sticking with Lifetime, defaulting to infinite = fully reliable",
          "createdAt": "2019-01-08T16:36:16Z",
          "updatedAt": "2019-01-08T16:36:16Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok, got it.\n\nSent from my iPhone\n\n> On 8 Jan 2019, at 17:36, Brian Trammell <notifications@github.com> wrote:\n> \n> What I'm saying is I'm the one who asked for RTX count, and I'm not sure it's useful. So I'm +1 to sticking with Lifetime, defaulting to infinite = fully reliable\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2019-01-08T22:03:30Z",
          "updatedAt": "2019-01-08T22:03:30Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl: I see \"do not retransmit\" as a nice optimisation to prevent retransmission of stale date. Let's consider an application that does state replication and wants to use reliability for its handshake, but will take care of the individual message retransmissions itself to prevent retransmission of stale state. This is, e.g., possible with the proposed QUIC datagram extension.\r\nLifetime is not the most useful option for the application, as it does not know in advance when a message will become outdated. It just wants no re-transmits.\r\nBesides that, I see no use-case for \"re-transmit only 7 times\".\r\n",
          "createdAt": "2019-01-10T10:08:19Z",
          "updatedAt": "2019-01-10T10:15:28Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A-ha!  You're asking to support the semantics of *un*reliable message transfer. Good catch!\r\n\r\nI was about to answer \"just set lifetime to 0\", but the Lifetime description (reasonably, IMO) says: \"Lifetime specifies how long a particular Message can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted.\"   Because it's not only about *re*transmission, we need a separate property to be able to say \"don't drop it from your own send buffer, and don't retransmit it, but do send it once.\"  It's this functionality you're after, right?",
          "createdAt": "2019-01-10T10:15:01Z",
          "updatedAt": "2019-01-10T10:15:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yeah it'd be neat if \"lifetime\" could be three-state: \"never RTX, RTX forever, TX/RTX before deadline\" but I'm not sure I want to invent a new, easy-to-implement-wrong datatype for this.\r\n\r\nSo this is two properties, but I don't think the boolean is \"reliable data transfer (message)\". something like \"retransmission desired\"?\r\n\r\nActually, the semantics of that combine nicely:\r\n\r\n- RTX desired false, lifetime infinite: always send once\r\n- RTX desired false, lifetime finite: send once if not expired, otherwise do not send\r\n- RTX desired true, lifetime infinite: always send until ACKed\r\n- RTX desired true, lifetime finite: send until ACKed until expired\r\n\r\nThe document should probably treat them as specially related though.",
          "createdAt": "2019-01-10T10:19:36Z",
          "updatedAt": "2019-01-10T10:19:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this proposal a lot. Indeed I think the document should then also list your four cases.\r\n\r\n(just \"until ACKed until expired\" doesn't sound very good, but that's an easy fix)",
          "createdAt": "2019-01-10T10:47:56Z",
          "updatedAt": "2019-01-10T10:47:56Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At the moment unrelaible msg transfer is covered by the Reliable Data Transfer (Message) property.\r\nSo i think the question is if we need to distinguish\r\n\r\n- RTX desired false, lifetime finite: send once if not expired, otherwise do not send\r\n- RTX desired true, lifetime finite: send until ACKed until expired\r\n\r\nIs there a use case for that? The other two cases (reliable/unreliable) are covered.",
          "createdAt": "2019-01-10T10:54:11Z",
          "updatedAt": "2019-01-10T10:54:11Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Please do not create a \" \"don't drop a datagram from your own send buffer, \"... that's a hideous invention. A transport that is reliable, will know what to do when a drop occurs and likely have a good idea of how to avoid self-congesting it's lower layers.  A datagram app may or may not have this ability, but anyway has to be able to deal with loss and congestion.\r\n\r\nI am really not in favour of adding more control of this - it's hard to implement and hard to get right. And... there is duplication in some networks, and there is retransmission in some networks as design artefacts or on purpose. So the app/transport still has to deal with this. \r\n\r\nFrom what I recall, the sigtran work with SCTP added stuff to that transport to try and make it better for an already semi-reliable upper layer protocol - these tweaks are now in the Spec, although not commonly used outside that bespoke app. I'm not saying it was wrong, but maybe in retrosepec it was a mistake to put these extra switches in the general transport spec? (either way I do not agree that existance in the SCTP Spec as a sign that this is implenented or useful or even unambigious).\r\n\r\nI suggest telling the transport/network to do \"retx\" or not is fundamentally wrong. The API should state something about the usage's general requirements (\"Lifetime\" is close to what I expected), and let the transport figure out what to do. I'd press for keeping the \"property\" simple and not trying to understand what the path and transport and OS stacks could do.\r\n",
          "createdAt": "2019-01-10T10:58:05Z",
          "updatedAt": "2019-01-10T10:58:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm. To summarize this discussion:\r\n- @philsbn gave a good reason why \"Lifetime\" is not enough.\r\n- @abrunstrom points out that updating what we have now to talk about RTX only helps in a special case, which may well be a corner case; this seems to call for leaving things as they are \r\n- @gorryfair strongly urges to leave things as they are.\r\n\r\nMy suggestion is to conclude this discussion by leaving things as they are (but massage the text a tiny bit to stress the importance of having a separate \"reliable data transfer\" property - so that the confusion that I had doesn't happen for future implementers of a transport system).",
          "createdAt": "2019-01-10T14:41:47Z",
          "updatedAt": "2019-01-10T14:41:47Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also would like to add the warning, that setting \"reliable transfer (message)\" to \"false\" on a message is just an optimisation \u2013 it has the semantic of \"the transport system may disable retransmissions or other reliability mechanisms for this particular message\" \u2013 so if we have TCP beneath, it's a NO-OP. ",
          "createdAt": "2019-01-14T13:40:03Z",
          "updatedAt": "2019-01-14T13:40:03Z"
        }
      ]
    },
    {
      "number": 277,
      "id": "MDU6SXNzdWUzOTk0Mzg1NzE=",
      "title": "Write architecture text about application context/caching",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/277",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "Write text in Architecture to clarify intent of what was originally described in #244",
      "createdAt": "2019-01-15T16:52:04Z",
      "updatedAt": "2019-03-19T16:05:25Z",
      "closedAt": "2019-03-19T16:05:24Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done with #294 ",
          "createdAt": "2019-03-19T16:05:24Z",
          "updatedAt": "2019-03-19T16:05:24Z"
        }
      ]
    },
    {
      "number": 282,
      "id": "MDU6SXNzdWU0MDc0NjU1MDY=",
      "title": "Implementation should describe how to handle proxies/TOR",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/282",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "adventureloop",
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "discuss",
        "help wanted"
      ],
      "body": "Having proxies to go through on a system (SOCKS, HTTP Connect, etc) or a set of TOR endpoints requires the implementation to do some nested/recursive work, and pass down endpoints correctly to protocol instances. The implementation document should describe this.",
      "createdAt": "2019-02-06T22:44:04Z",
      "updatedAt": "2019-11-19T08:50:32Z",
      "closedAt": "2019-11-19T08:50:32Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2019-02-07T08:17:24Z",
          "updatedAt": "2019-02-07T08:17:24Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is already text in 4.1.3.3. Protocol Options. Is that sufficient or do we need more?",
          "createdAt": "2019-10-18T23:23:40Z",
          "updatedAt": "2019-10-18T23:23:40Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "MDU6SXNzdWU0MDc2MTkzOTU=",
      "title": "Common notation for optional parameters",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/283",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Even though all the languages we want to support don't have convenient syntax for optional parameters to functions/methods, it would be nice to note that we intend for some parameters to not be mandatory on every call.",
      "createdAt": "2019-02-07T10:00:52Z",
      "updatedAt": "2019-02-08T10:37:00Z",
      "closedAt": "2019-02-08T10:37:00Z",
      "comments": []
    },
    {
      "number": 285,
      "id": "MDU6SXNzdWU0MDgxMzIyNDk=",
      "title": "Group management",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/285",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Connections must, of course, have a group number. (It's just not written anywhere yet. A group number should be generic Connection property, in Section 9.1.)  Otherwise, how could one know which Connections are grouped and which are not? And they may be grouped in different ways - one can have a group of 2 Connections, and another group of 3, and then priorities apply only among the Connections in each respective group.\r\n\r\nSo far, not a big deal, I guess.... now comes the \"this really only existed in Michael's mind\" part:\r\n\r\nThese group numbers should not *only* be readable: on Preconnections, they should be writable as well. This, then, expresses a wish to have certain Connections automatically grouped and some not. The semantics should be: same number = they are regarded as \"grouped\", but there is no guarantee that they really are muxed, i.e. streams of one underlying transport connection (e.g. SCTP Association). Different number = they are NOT grouped and never will be.\r\n\r\nISTM that, with this construct, the only point of the Selection Property \"Multistream Connections in Group\" is to be able to tell this wish for stream muxing early, when only one Preconnection has been created. Else one could create multiple Preconnections and give them the same group number, and that would convey the same wish. But I guess requiring \"you want multi-streaming: you must create multiple Preconnections before calling init\" is a hassle.",
      "createdAt": "2019-02-08T12:29:49Z",
      "updatedAt": "2019-03-25T12:51:02Z",
      "closedAt": "2019-03-25T12:51:01Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, I am confused now, we have clone for this purpose, no? Connections that are cloned are grouped (get the same group numnber)?",
          "createdAt": "2019-02-08T16:02:46Z",
          "updatedAt": "2019-02-08T16:02:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "but they may also get grouped automatically, without a call to clone. Only with clone, how do I say that I don\u2019t want certain Connections to be grouped?\n\nSent from my iPhone\n\n> On 8 Feb 2019, at 17:02, abrunstrom <notifications@github.com> wrote:\n> \n> Ok, I am confused now, we have clone for this purpose, no? Connections that are cloned are grouped (get the same group numnber)?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2019-02-08T16:29:22Z",
          "updatedAt": "2019-02-08T16:29:22Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Really? Where is this described? Not sure that is a good idea. ",
          "createdAt": "2019-02-08T16:39:20Z",
          "updatedAt": "2019-02-08T16:39:20Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought the right place to describe it would be the implementation draft; I don't think it's there yet. However, I also don't believe we have any text contradicting it.\r\n\r\nminset made the argument that the only aspect of multi-streaming that involves application-specific knowledge (knowledge that only applications have, i.e. something that really must be under application control) is prioritization between groups of streams. We have that in the API. But the decision on whether a Connection becomes a stream or not isn't really relevant to applications.\r\n\r\n...except, of course, if they care about what goes on in the network - e.g. multiple 5-tuples could be routed differently, etc. etc. ... or you may want to be compatible with a peer that doesn't work with this kind of mapping. So, it must be possible to disable this, but note that this is a case of an application doing protocol-specific stuff (e.g., designed to talk to a \"normal\" SCTP server). Necessary to support but not the main design direction.\r\n\r\nThe whole point is to try to automate network optimizations and put them below the API. So, IMO, the right design is to allow for automatic mapping of Connections to streams, and even encourage doing this by default if possible. What can be wrong about that, when it can be disabled anyway?",
          "createdAt": "2019-02-09T23:38:47Z",
          "updatedAt": "2019-02-09T23:38:47Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When you call clone the connections are grouped. It is up to the implementation to decide if it becomes a stream or not. If you do not want them to be grouped you need to set up a second connection using a new Preconnection. This covers the two cases, so I do not understand why we would need anything more? I do not disagree with any of what you write above, but the automatic mapping to streams only applies within a connection group, right? Maybe I have misunderstood what this issue is about?",
          "createdAt": "2019-02-10T16:45:42Z",
          "updatedAt": "2019-02-10T16:45:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I see. Well I guess it's more a syntactical issue - as a developer, it seems that \"clone\" is something one really has to think about before deciding to do it, and if one doesn't care much and \"just\" wants a Connection, it's not the most obvious call to make. I'd like to have cloning be the default behavior somehow, with a way to opt-out rather than to opt-in.\r\n\r\nMaybe it's enough to put explicit text around the \"init\" calls, saying that these are intended for trying to reach a destination for the first time, and that Clone should normally be the preferred choice for multiple Connections?",
          "createdAt": "2019-02-11T07:46:16Z",
          "updatedAt": "2019-02-11T07:48:22Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I mcuh prefer the latter - we don't even need to say \"intended\" --- you could just say that most apps will benefit from the advantages this gives them. \r\n\r\nGorry",
          "createdAt": "2019-02-11T10:18:57Z",
          "updatedAt": "2019-02-11T10:18:57Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok; convinced. Seems like, in typical Michael style, I created \"much ado about nothing\" here.",
          "createdAt": "2019-02-11T10:22:22Z",
          "updatedAt": "2019-02-11T10:22:22Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cloning is also easier than setting up a new preconnection and again populating it with your preferences, so should be simpler for the app developer.",
          "createdAt": "2019-02-11T10:30:31Z",
          "updatedAt": "2019-02-11T10:30:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also true...",
          "createdAt": "2019-02-11T10:37:46Z",
          "updatedAt": "2019-02-11T10:37:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To conclude: @abrunstrom convinced me that this issue is a non-issue. I should have closed this long ago.",
          "createdAt": "2019-03-25T12:51:01Z",
          "updatedAt": "2019-03-25T12:51:01Z"
        }
      ]
    },
    {
      "number": 286,
      "id": "MDU6SXNzdWU0MDgyMTkxMDA=",
      "title": "Interface draft should describe a way to express transport-level padding for messages",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/286",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This could expressed as a property on outgoing messages. Should it then also be expressed as metadata for received messages?",
      "createdAt": "2019-02-08T16:10:11Z",
      "updatedAt": "2019-05-15T13:18:38Z",
      "closedAt": "2019-05-08T16:53:35Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This rather depends on why the transport API adds padding, and whether the transport API knows how much padding to add or the app, and finally how the padding is added.\r\n\r\nOn send, I understand your proposal, and that would be OK with me. It would also be fine to simply send \"null\" data as a part of the original data?\r\n\r\nI am less sure of what should happen at receive. It could be that the transport does not forward padding upwards to the receiver if it was added by the stack at the sender. That would seem to be fine to me, and I don't (yet) know why the receiver would care, you may have a use-case.\r\n",
          "createdAt": "2019-04-30T17:33:31Z",
          "updatedAt": "2019-04-30T17:33:31Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This sounds like three problems for me:\r\n1) Padding at the application (I guess we should not care, unless done in a framer)\r\n2) Padding added somewhere in the protocol stack\r\n   - very generic thingy, depends on the protocols chosen after racing\r\n   - may happen at multiple layers and add up\r\n   - the application my want to specify it wants at least messages of size X on top of the IP layer\r\n      - required for QUIC amplification protection\r\n      - may be useful for probing and amplification protection for other protocols\r\n      - the transport system can then choose whether padding is needed and where to pad\r\n3) Protocol Specific Padding, which needs a property per protocol\r\n\r\nI agree it would be nice to have some way of exposing \"how much padding was added\" as receive meta-data, but this would require more design on what  receive meta-data is and how it should look like.",
          "createdAt": "2019-05-03T08:45:47Z",
          "updatedAt": "2019-05-03T08:45:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Interesting.\r\nI agree on (1) We do not care, but safely could mention if it otherwise creates doubt.\r\n(2) QUIC can add that, and may choose to. TCP can't, UDP can't; UDP-Options could; etc. Any tunnel/framing can clearly do that. As a starting point I suggest we don't let the text talk to talk about this.\r\n(3)   I suggest we also don't describe this, and leave this as a possible future thing to add once this current spec is published.\r\n\r\n",
          "createdAt": "2019-05-08T08:16:12Z",
          "updatedAt": "2019-05-08T08:16:12Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at May interim -- we might want to separate the goal from the mechanism. Deferring this until QUIC (or some other protocol) actually implements it. Will be a good test of experimental extensibility of TAPS. ",
          "createdAt": "2019-05-08T16:53:35Z",
          "updatedAt": "2019-05-08T16:53:35Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And when we come to this in future, note that RFC 6562 suggests transport-level padding via Secure RTP as a security mechanisms to address certain threats. There are real use cases for this.",
          "createdAt": "2019-05-09T21:48:18Z",
          "updatedAt": "2019-05-09T21:48:18Z"
        }
      ]
    },
    {
      "number": 287,
      "id": "MDU6SXNzdWU0MDgyMjAzMTQ=",
      "title": "Consider explicitly handling connection coalescing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/287",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-08T16:13:11Z",
      "updatedAt": "2019-05-08T16:54:44Z",
      "closedAt": "2019-05-08T16:54:44Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "moving this discussion to #266",
          "createdAt": "2019-05-08T16:54:44Z",
          "updatedAt": "2019-05-08T16:54:44Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "MDU6SXNzdWU0MDgyMjEwMzU=",
      "title": "Describe how to deal with post-handshake control messages for protocols such as TLS",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/288",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "NewSessionTickets, for example, will arrive after TLS connections are ready. We should describe how the implementation deals with these messages, what state is updated, etc.",
      "createdAt": "2019-02-08T16:14:53Z",
      "updatedAt": "2020-06-19T16:55:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWU0MTIzMDA5NTU=",
      "title": "Add Preference Level \"Default\" and check for all Selection Properties whether defaults are necessary ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/289",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "We discussed the use of a \"Default\" preference level that restores the system default in #207.\r\n\r\nIn addition, we should check whether we really need to fix the default values for all Selection Properties in the API document or can make some of them to be \"Implementation Specific\".",
      "createdAt": "2019-02-20T08:25:48Z",
      "updatedAt": "2019-03-08T17:21:02Z",
      "closedAt": "2019-03-08T17:21:02Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by PR #292 ",
          "createdAt": "2019-03-08T17:21:02Z",
          "updatedAt": "2019-03-08T17:21:02Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWU0MjQ4NjY1NzI=",
      "title": "TAPS ARCH - Textual review to notes",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/299",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "These are all comments on rev -03, and I think they can all be held to edit for the next revision.\r\n\r\n(1)  SHOULD be defined to apply to multiple transport\r\n- is this the same as:\r\n SHOULD apply to multiple transport\r\n\r\n(2) mechanisms which\r\n- should be:\r\nmechanisms which,\r\n\r\n(3) Connection Group:\r\n- is now renamed:\r\nTAPS Context: (or similar).\r\n\r\n(4) within the same Connection Group are allowed be multiplexed\r\n- is the /multiplexed/ the same as /cloned/ now?\r\n\r\n(5) Is this normative:\r\n  [I-D.ietf-taps-interface]\r\n\r\nThese are normative:\r\n [RFC8174] \r\n [RFC2119] ",
      "createdAt": "2019-03-25T12:06:05Z",
      "updatedAt": "2019-11-20T06:12:43Z",
      "closedAt": "2019-11-20T06:12:43Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed the parts of this that are still valid with 3471e89",
          "createdAt": "2019-11-20T06:12:43Z",
          "updatedAt": "2019-11-20T06:12:43Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU0MjQ4NzUyNDE=",
      "title": "Add property for address privacy",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/300",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "API should allow a preconnection property to specify if a private (IPv6) address is preferred. Outbound connections should prefer this. Listeners should avoid this.",
      "createdAt": "2019-03-25T12:27:55Z",
      "updatedAt": "2019-11-21T04:30:37Z",
      "closedAt": "2019-11-21T04:30:37Z",
      "comments": []
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU0MjQ4ODI5NjE=",
      "title": "Add an explicit listener object to the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/301",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "We talk about listen objects in architecture and implementation, but not in the API.\r\n\r\nChanges needed:\r\n - Let ```listen()``` return a Listener\r\n - Move the ```stop()``` the Listener\r\n - Allow Preconnection to be used multiple times.",
      "createdAt": "2019-03-25T12:46:16Z",
      "updatedAt": "2019-06-14T21:22:30Z",
      "closedAt": "2019-06-14T21:22:30Z",
      "comments": []
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWU0MjUzNDM2Mjc=",
      "title": "UDP idempotence",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/302",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair",
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "This came up in a dinner among some of us yesterday: all UDP messages should be understood as being idempotent, because UDP doesn't protect the receiver against getting duplicates. This is different from unreliable transmission with, e.g., SCTP (or, probably, a future such extension of QUIC?), where you can be sure you're not getting a duplicate.",
      "createdAt": "2019-03-26T10:43:02Z",
      "updatedAt": "2019-05-29T07:50:23Z",
      "closedAt": "2019-05-29T07:50:23Z",
      "comments": []
    },
    {
      "number": 303,
      "id": "MDU6SXNzdWU0MjU5MTI1MTE=",
      "title": "More expressive multipath transport property",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/303",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "The current multipath selection property is an on/off selection.  We will eventually need something more expressive here to distinguish for instance between handover/back-up and aggregate multipath modes.\r\n",
      "createdAt": "2019-03-27T11:45:19Z",
      "updatedAt": "2019-11-21T04:30:34Z",
      "closedAt": "2019-11-21T04:30:34Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For reference, the Network.framework multi path property values are:\r\n\r\n```\r\n\t/// Multipath services represent the modes of multipath usage that are\r\n\t/// allowed for connections.\r\n\tpublic enum MultipathServiceType {\r\n\t\t/// No multipath transport will be attempted\r\n\t\tcase disabled\r\n\t\t/// Only use the expensive interface when the when the primary one is not available\r\n\t\tcase handover\r\n\t\t/// Use the expensive interface more aggressively to reduce latency\r\n\t\tcase interactive\r\n\t\t/// Use all available interfaces to provide the highest throughput and lowest latency\r\n\t\tcase aggregate\r\n\t}\r\n```",
          "createdAt": "2019-03-27T11:49:09Z",
          "updatedAt": "2019-03-27T11:49:09Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I remember correctly, we had something like this that got turned into a regular preference at some point in time. I agree that this expressiveness is useful, but can't this be achieved even better by also setting CostPreference + CapacityProfile?",
          "createdAt": "2019-03-28T08:17:53Z",
          "updatedAt": "2019-03-28T08:17:53Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "MDU6SXNzdWU0MjY5NTE0NzQ=",
      "title": "Clarify mapping of Connection to multiple flows",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/304",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "The arch definition of connection should add a sentence to say that there may be multiple flows (MPTCP, MPQUIC, or even connection pooling) below the abstraction. This was assumed but not stated.",
      "createdAt": "2019-03-29T11:55:59Z",
      "updatedAt": "2019-07-03T07:13:42Z",
      "closedAt": "2019-07-03T07:13:42Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "May be fixed by PR #320 ",
          "createdAt": "2019-05-06T14:59:21Z",
          "updatedAt": "2019-05-06T14:59:21Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by #320",
          "createdAt": "2019-07-03T07:13:42Z",
          "updatedAt": "2019-07-03T07:13:42Z"
        }
      ]
    },
    {
      "number": 305,
      "id": "MDU6SXNzdWU0MjY5NjMwODA=",
      "title": "Protocol stacks that are not equivalent",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/305",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Per the architecture draft, only protocol stacks that are equivalent can be safely raced. What is the expected behavior if selection properties are set in such a way that the resulting candidate set includes protocol stacks that are not equivalent? Would the selection properties simply be treated as invalid? ",
      "createdAt": "2019-03-29T12:28:23Z",
      "updatedAt": "2019-12-02T01:11:22Z",
      "closedAt": "2019-12-02T01:11:21Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "To me \"equivalent\" relates to either candidate would provide the set of functions needed.\r\n\r\nAt the risk I don't answer your question: My take is that one can always define policy and API properties that produce a useless outcome. It's not the job of a TAPS system to validate these (although someone may like to try that as a separate sanity checking tool); in just the same way that someone can write code that doesn't implement an algorithm.\r\n\r\nThe goal is rather that if this specifies \"sensible\" properties and policy you get the required outcome. You may get no connection or something unexpected if the request is not well-founded.",
          "createdAt": "2019-05-08T08:04:12Z",
          "updatedAt": "2019-05-08T08:04:12Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, so if an application chooses to provide properties that allow both TCP and UDP the implementation would race those two which would result in a default win for UDP, is that correct? ",
          "createdAt": "2019-05-08T14:51:22Z",
          "updatedAt": "2019-05-08T14:51:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, and I'd say the answer to your question is yes. Of course, later you may find that UDP doesn't really work on the path for the given port, and then it would be great to have an open TCP connection available to fall back to.",
          "createdAt": "2019-05-24T08:49:30Z",
          "updatedAt": "2019-05-24T08:49:30Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess we should define \"equivalent protocol stacks\" a little less rigorous in the architecture document. For an application that does not care about message boundaries, and reliable transport and has its own congestion control, protocol stacks with TCP and UDP may indeed be equivalent with respect to the application's requirements.\r\n\r\nThis would require to rewrite 1. of the enumeration in Section 4.2.3 which could use a second look anyway, because it mixes up application requirements in sense of interface behaviour and application protocols that directly depend on specific transport protocols beneath, which is what PR #327 is all about.",
          "createdAt": "2019-07-04T08:48:31Z",
          "updatedAt": "2019-07-04T08:48:31Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also mailing list discussion in July 2019.",
          "createdAt": "2019-11-19T08:26:26Z",
          "updatedAt": "2019-11-19T08:26:26Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We also need to say here what \"equivalence\" means for security.\r\nRight now, Security Considerations says \"As described above in Section 4.2.3, if a Transport Services system races between two different Protocol Stacks, both MUST use the same security protocols and options.\"\r\nI think if we consider equivalence as \"you can use whatever stack that satisfies the things that the application requested\", this should also apply to security.\r\nNow that the application has to explicitly select a security protocol, I think it should also be allowed for the application to say that multiple security protocols are fine. Like, allow applications to say \"Use TLS 1.3 if available, but if not, TLS 1.2 is also fine\" (instead of failing).",
          "createdAt": "2019-11-19T08:31:37Z",
          "updatedAt": "2019-11-19T08:31:37Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #389 ",
          "createdAt": "2019-12-02T01:11:21Z",
          "updatedAt": "2019-12-02T01:11:21Z"
        }
      ]
    },
    {
      "number": 306,
      "id": "MDU6SXNzdWU0MjY5NjU1ODM=",
      "title": "Failure of unsatisfiable configurations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/306",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Make it clearer that the implementation should only check for unsatisfiable selection property configurations after initiate/listen/rendezvous has been called. ",
      "createdAt": "2019-03-29T12:35:16Z",
      "updatedAt": "2019-11-19T08:34:48Z",
      "closedAt": "2019-11-19T08:34:48Z",
      "comments": []
    },
    {
      "number": 307,
      "id": "MDU6SXNzdWU0MjY5NzAwNzc=",
      "title": "Differentiating between bad selection property configuration and connection issues",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/307",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Per the interface draft, an InitiateError gets thrown both when the set of (protocol) candidates is empty as well as when it is not possible to establish a connection.\r\nThe distinction here is that an application can mend an error involving an empty candidate set while it does not necessarily have control over fixing issues related to the network. \r\nIt might be useful to divide this into distinct two errors, one that points to an empty candidate set and one that points to issues during an actual connection establishment attempt. ",
      "createdAt": "2019-03-29T12:48:10Z",
      "updatedAt": "2019-07-21T19:46:27Z",
      "closedAt": "2019-07-21T16:12:58Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MaxF12 closed this one and open issue #341 and #342 which are parts of a possible solution for this. Let's continue discussion in these",
          "createdAt": "2019-07-21T19:46:27Z",
          "updatedAt": "2019-07-21T19:46:27Z"
        }
      ]
    },
    {
      "number": 308,
      "id": "MDU6SXNzdWU0MjY5NzcwNjk=",
      "title": "Treatment of optional transport properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/308",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "What is the expected treatment of protocols that provide certain properties but which are not a mandatory part of the protocol, e.g. multistreaming in SCTP. If the application prohibits multistreaming, will SCTP be discarded during the candidate selection process? Will the API simply set the max in- and outbound streams to 1 during initialization of the SCTP association? What happens in cases where the API is not able to reliably turn individual properties on and off? ",
      "createdAt": "2019-03-29T13:06:27Z",
      "updatedAt": "2019-05-08T14:49:06Z",
      "closedAt": "2019-05-08T14:49:06Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My immediate response would be \"that's up to you as an implementer\". I actually believe we should not specify expectations like this - perhaps just discuss a possible decision (as an example) in the implementation draft?",
          "createdAt": "2019-05-07T08:49:19Z",
          "updatedAt": "2019-05-07T08:49:19Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Text proposal for Implementation:\r\n\r\nIf an application specifies to \"prohibit\" some feature, the implementation SHOULD disable this feature if possible and SHOULD emit an appropriate error signal if the feature is used by either the local or the remote endpoint. Whether the existence of an (optional) feature excludes protocol stacks form being selected should be weighed by implementors on an individual basis.",
          "createdAt": "2019-05-07T09:35:51Z",
          "updatedAt": "2019-05-07T09:35:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why translate \"prohibit\" into SHOULD? Clearly this is a MUST?   and this text proposal is confusing IMO because \"prohibit\" refers to the feature as exposed to the application, so saying \"disable this feature if possible\" seems really strange to me.",
          "createdAt": "2019-05-07T12:02:52Z",
          "updatedAt": "2019-05-07T12:02:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I really think we should not use the RFC2119 keywords in this way in the implementation draft. I don't even say we ought to tell implementors how to to violate a MUST, better we leave the API to speak to this, and (perhaps - if we need) identify considerations in the implementation, but don't start redefining the spec. I suggest we say noting on this point.",
          "createdAt": "2019-05-07T12:30:07Z",
          "updatedAt": "2019-05-07T12:30:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh yes, RFC 2119 language is even altogether inappropriate in this draft. I fully agree.",
          "createdAt": "2019-05-07T12:49:12Z",
          "updatedAt": "2019-05-07T12:49:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl and @gorryfair - you both convinced me\u2026 so I'd like to change my \"SHOULD\" into \"must\" and ask for feedback whether we want to have this note in Implementation or rather not say anything.",
          "createdAt": "2019-05-07T12:49:36Z",
          "updatedAt": "2019-05-07T12:49:36Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I still prefer to say less: In answer to the original question, I'd suggest:\r\n\r\nIf an application prohibits multistreaming, then the underlying transport must not utilise this. A TAPS system could still select a transport that permits this feature, providing that the multistreaming function is not used (e.g. an SCTP association, limited to one outbound stream). However, in this example, if there were no additional reason to choose SCTP, then the system could be setup to prefer to use TCP to satisfy this request.\r\n",
          "createdAt": "2019-05-07T13:50:14Z",
          "updatedAt": "2019-05-07T13:50:14Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments, it will remain implementation specific. ",
          "createdAt": "2019-05-08T14:49:06Z",
          "updatedAt": "2019-05-08T14:49:06Z"
        }
      ]
    },
    {
      "number": 309,
      "id": "MDU6SXNzdWU0MjY5ODU2MzY=",
      "title": "Clarification on queued receives",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/309",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "It should be made more clear in what order queued receives are considered, i.e. what happens if an application calls Receive(minIncompleteLength=20), then calls Receive(minIncompleteLength=1). What now happens if e.g. 10 bytes of data arrive? Will the second receive only be considered after the first has been fulfilled? ",
      "createdAt": "2019-03-29T13:27:02Z",
      "updatedAt": "2019-11-21T05:00:41Z",
      "closedAt": "2019-11-21T05:00:41Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would seem natural to me that enqueuing is what it is - i.e., saying once \"I can receive blocks of at least 20 bytes\" cannot be undone.\r\n\r\nSo, if the sequence is:\r\n1) Receive(minIncompleteLength=20)\r\n2) Receive(minIncompleteLength=1)\r\n3) 10 bytes arrive\r\n\r\n... then the first Receive call should be the one that matters, and the 10 bytes would have to wait until another 10 bytes arrive before the second Receive call can be processed.\r\n\r\nI think that @tfpauly should add a clarifying sentence because his implementation probably already does it in one way or another.",
          "createdAt": "2019-10-21T14:15:38Z",
          "updatedAt": "2019-10-21T14:15:38Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps its not such a big issue, but I think this would take the option away from application developers to have an OR option for receives. For example, an application would have no way to say that it wants to receive either something with minIncompleteLength 100 or MaxLength 10.\r\n\r\nI also think there might be some confusion when it comes to requiring message ordering. For example:\r\n\r\n1. Application calls Receive(maxLength=10)\r\n2. Application calls Receive(maxLength=20)\r\n3. Message with length 20 arrives\r\n4. Message with length 10 arrives\r\n5. Application get received callback for message with length 10\r\n6. Application get received callback for message with length 20\r\n\r\nFor the application it now seems that the message with length 10 arrived before the one with length 20 even though that is not the case. ",
          "createdAt": "2019-10-30T13:26:23Z",
          "updatedAt": "2019-10-30T13:26:23Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWU0MjY5ODc1NTg=",
      "title": "msgref is never specified ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/310",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "In the interface draft, msgref is part of 4 callbacks (RendezvousError, Sent, Expired and SendError), however it is never mentioned what msgref is. As the Send action does not have any return value it is also unclear how the application is actually supposed to know what msgref references to. ",
      "createdAt": "2019-03-29T13:31:36Z",
      "updatedAt": "2019-07-03T07:17:31Z",
      "closedAt": "2019-07-03T07:17:31Z",
      "comments": []
    },
    {
      "number": 312,
      "id": "MDU6SXNzdWU0MzgyMzg2NTI=",
      "title": "Detailed author review of Arch text for -03 to prepare -04",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/312",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "TAPS Architecture - Additional comments on rev -03 (detailed read-through).\r\n\r\nNote: This adds to my previous set of review issues - these could be handled at the same time.\r\n\r\nSection 1 :\r\n- Can we make reading easier:\r\n\u201cThis flexibility does not only enable\r\n   faster deployment of new feature and protocols, but it can also\r\n   support applications with racing and fallback mechanisms which\r\n   otherwise need to be implemented in each application separately.\u201d\r\n- suggest:\r\n\u201cThis flexibility enables\r\n   faster deployment of new feature and protocols,. It can also\r\n   support applications with racing and fallback mechanisms, which\r\n   otherwise need to be implemented in each application separately.\u201d\u201d\r\n\u2014\r\n\u201cAlthough following the Transport\r\n   Services Architecture does of course not mean that \u201c\r\n- do we need /of course/ (this reads oddly).\r\n\u2014\r\n\u201cfrom one system to the another\u201d\r\n- should be:\r\n\u201cfrom one system to another\u201d\r\n==========\r\nSection 1.1 :\r\n\u201cThe model of using sockets for networking can be represented as\r\n   follows\u201d\r\n- could we insert \u201ctraditional\u201d or \u201cexisting\u201d or something like that before \u201cmodel\u201d, since a new reader may not realise this is the description of what exists rather what this document develops?\r\n\u2014\r\n\u201c, which provides the interface to the implementations of\r\n   UDP and TCP (typically implemented in the system's kernel), which in\r\n   turn send data over the available network layer interfaces.\u201d\r\n- Two \u201c, which\u201d in a long sentence, could we write:\r\n- \u201c. This API provides the interface to the implementations of\r\n   UDP and TCP (typically implemented in the system's kernel), which in\r\n   turn send data over the available network layer interfaces.\u201d\r\n\u2014\r\n\u201cThe Implementation\u201d\r\n- Is capitalised \u201cI\u201d needed?\r\n\u2014\r\n\u201cfor mapping the API into the various available transport\u201d\r\n- Is this \u201cinto\u201d or \u201cto\u201d  - I think the interface maps to these?\r\n\u2014\r\n\u201cThere are a few key departures that Transport Services makes from the\r\n   sockets API:\u201d\r\n- a \u201cfew key\u201d seems odd to me in a spec.\r\n\u201cThere are key differences between the architecture of the Transport Services system and the architecture of the sockets API:\u201d - or something like that?\r\n==========\r\nSection 1.2 :\r\n\u201cand changes to available network links\u201d:\r\n- insert \u201cthe\u201d and \u201cto\u201d so it does not mean that it makes the change:\r\n- \u201cand changes in the available network links\u201d\r\n\u2014\r\nSection 1.3 :\r\n\u201cHTTP/1.1 uses character delimiters to segment messages\r\n   over a stream; TLS record headers carry a version, content type, and\r\n   length; and HTTP/2 uses\u201d\r\n- I think this needs text needs several references to the specs?\r\n==========\r\nSection 3 :\r\n\u201c   The following considerations were used in the design of this\r\n   architecture.\u201d\r\n- If these were only a list of considerations, then we we do not need \u201cRFC2119\u201d language after all in this section. If they are actually the basis of the architecture, then we need to change the words \u201cconsiderations\u201d to \u201crequirements\u201d or something. I actually think it is helpful for the basis for the design should be expressed in RFC2119 language.\r\n-  I suggest the best option could be simply to omit the sentence?\r\n\u2014\r\n\u201cthat include some transport security\r\n   protocol are eligible to be used.\u201d\r\n- The word \u201csome\u201d is wrong, and also \u201cprotocol\u201d.\r\n- I think this should be \u201ca transport security function\u201d? \r\n\u2014\r\nSection 3.3 :\r\n\u201cThe abstract API definition\r\n   [I-D.ietf-taps-interface] describes this interface and is aimed at\r\n   application developers.\u201d\r\n- \u201caimed at\u201d seems odd because of \u201cand\u201d and \u201caimed\u201d.\r\n\u201cThe abstract API definition\r\n   [I-D.ietf-taps-interface] describes this interface. This is expected to be utilised by\r\n   application developers.\u201d\r\n\u2014\r\n\u201cIt is expected that all\r\n   implementations of Transport Services will offer the entire mandatory\r\n   API, but that some features will not be functional in certain\r\n   implementations.\u201d\r\n- This seems to me to still be possible to read the \u201cmandatory\u201d part os optional, which can\u2019t be. Is it also OK to say this instead:\r\n\u201cIt is expected that all\r\n   implementations of Transport Services system will offer the entire mandatory\r\n   API. However, some features provided below the API may not be functional in certain\r\n   implementations.\u201d\r\n\u2014\r\n\u201cAll implementations are REQUIRED to offer\r\n   sufficient APIs to use the distilled minimal set of features offered\r\n   by transport protocols  ...\u201c\r\n- What does the plural \u201cAPIs\u201d mean?\r\n- I suggest we write:\r\n\u201cAll implementations are REQUIRED to offer\r\n   an API that is sufficient to provide the distilled minimal set of features offered\r\n   by transport protocols \u2026\u201d\r\n\u2014\r\n\u201c, but it is possible that some very\r\n   constrained devices might not have, for example, a full TCP\r\n   implementation beneath the API.\u201d\r\n- I\u2019m not fond of RFC2119 constructs that include an exception clause. Could we write this instead?\r\n\u201cFor example, it is possible that some very\r\n   constrained devices might not have, for example, a full TCP\r\n   implementation beneath the API [I.D.ietf-lwig-tcp-constrained-node-networks-07].\u201d\r\n- This ref is I believe in cross-WG WGLC and should now be stable.\r\n\u2014\r\n\u201cIt is expected that this document will be\r\n   updated and supplemented as new protocols and protocol features are\r\n   developed.\u201d\r\n- could we replace \u201cthis document\u201d by the [REF], to avoid the possibility of misreading/misquoting it as the architecture document itself?\r\n\u2014\r\n\u201cdefines new protocols that require any changes\r\n   to a remote system.\u201d\r\n- to me the first part here is that there is no implementation work required at the RECEIVER. I think that should be clear. \r\n\u2014\r\n\u201c The Transport Services system MUST be deployable\r\n   on one side only.\u201d\r\n- I think the second point is that it can be deployed in this way which places design constraints on the system, specifically that the SENDER is a one-sided system. Is it possible we could put this in a separate para instead, e.g.\r\n\u201cThe Transport Services system MUST be deployable\r\n   on one side only. A Transport Services system implemented at the sending endpoint can communicate with a remote endpoint on any existing system that implements the transport protocol(s) selected by the TAPS System. Similarly a Transport Services system at a listening endpoint can communicate using a using a transport protocol at a sending endpoint implemented in an existing system.\u201d\r\n==========\r\nSection 4.1 :\r\n\u201cestablish\r\n   communication and send and receive data.\u201d\r\n- insert comma after \u201ccommunication\u201d or \u201cthen\u201d after first \u201cand\u201d\r\n\u2014\r\n\u201cA Preconnection can be fully specified and\r\n      represent a single possible Connection\u201d\r\n- is this /represents/?\r\n\u2014\r\n\u201cThe Remote Endpoint MUST be specified in the\r\n      Preconnection is used to Initiate connections.\u201d\r\n- seems broken English, Is this:\r\n\u201cThe Remote Endpoint MUST be specified if a\r\n      Preconnection is used to Initiate connections.\u201d\r\n\u2014\r\nin 4.1.2:\r\n\u201cChanges made\r\n      to Connection Properties after establishment take effect on a\r\n      best-effort basis.\u201d\r\n- My understanding was that this does **not** change the protocol selection, but can change the way the protocol uses the path. If I was correct, then it would be good to add a sentence to say this.\r\n\u2014\r\nIn 4.1.3:\r\n\u201cprepare any required\r\n      local or remote state to be able to send and/or receive Messages.\u201d\r\n- what becomes able? \r\n\u201cprepare any required\r\n      local or remote state to enable the endpoint to send and/or receive Messages.\u201d\r\n\u2014\r\nIn 4.1.4:\r\n\u201cIf a received Message is incomplete or corrupted, it\r\n      might or might not be usable by certain applications.\u201d\r\n- I agree this is possible, but I\u2019d like to assert this really must **not** be the default and it is important to highlight that. Is it possible to say: \u201cIf a received Message is incomplete or corrupted, the default action is to not pass the data to the application. A certain application can override this default and the data might or might not be usable by that application.\u201d \r\n\u2014\r\n\u201cMessage Properties can be used to annotate specific Messages.  \u201c\r\n- I agree, however I think it is really  important to say that these annotations for sending exist only within the Local Endpoint and doe not cause additional bytes to be communicated to the Remote Endpoint. For example, they could change the DSCP, for instance. [[We need to choose words carefully, because the the DSCP is actually communicated across the path and could be sent end-to-end, but it is **not** additional data added to the message on the wire .]]\r\n\u2014\r\n\u201cWhen receiving Messages, Message\r\n      Properties can contain per-protocol properties.\u201d\r\n- Again, I think it is important to say the Remote Endpoint can add per-protocol properties to the messages it receives.\r\n\u2014\r\n\u201cproperties specific to how the Message's content\r\n      is to be sent. \u201c\r\n- I think we should delete the apostrophe,  or alternatively we could write \u201ccontent of the message\u201d.\r\n\u2014\r\n\u201cStatus of the Send operation can be delivered back\r\n      to the application in an event (Section 4.1.5).\u201d\r\n- could be :\r\n\u201cThe Status of the Send operation can be delivered back\r\n      to the sending application in an event (Section 4.1.5).\u201c\r\n\u2014\r\nIn 4.1.5:\r\n\u201cThis list of events that can be delivered to an application is not\r\n   exhaustive, but gives the top-level categories of events.\u201d\r\nCould be:\r\n\u201cThis section provides the top-level categories of events events that can be delivered to an application. This list is not\r\n   exhaustive.\u201d\r\n\u2014\r\nIn 4.2:\r\n\u201cThe Transport System Implementation Concepts\u201d\r\n- We do not need to define this as a capitalised term.\r\n\u2014\r\n\u201care allowed be multiplexed\u201d\r\n- insert /to/ before /be/.\r\n\u2014\r\n\u201cApplications can use can use their explicitly defined\u201d\r\n- please rephrase:\r\n\u201cAn application can explicitly define \u201c\r\n\u2014\r\n\u201cincluding\r\n      any state it has necessary\u201d\r\n- please remove /it has/\r\n\u2014\r\n\u201cand a Transport Services system's policies and\r\n      heuristics.\u201d\r\n- could we instead write:\r\n\u201cand the heuristics or policies of the Transport Services system.\u201d\r\n\u2014\r\nIn 4.2.3:\r\n\u201cTransitioning between different Protocol Stacks is in some\r\n   cases controlled by properties that only change when application code\r\n   is updated.  \u201c - is this statement about the present case, or the case with TAPS, this is not clear, but I think the former?\r\n\u2014\r\n\u201cThis functionality\r\n   can be a powerful driver of new protocol adoption, but needs to\u201d\r\n- I agree - is it protocol or stack functionality, I think this could be better as:\r\n\u201cThis functionality in the API\r\n   can be a powerful driver of new protocol adoption, but needs to\u201d\r\n\u2014\r\n\u201cBoth stacks MUST offer the same transport services\u201d\r\n- this could use a reference to mindset perhaps? \r\n\u2014\r\n1.\r\nCould better with a reference. We could use  [RFC8303] and [RFC8304] to contrast the two?\r\n\u2014\r\n2.\r\n\u201cHowever, if the\r\n       application does not require reliability, then a Protocol Stack\r\n       that adds unnecessary reliability might be allowed as an\r\n       equivalent Protocol Stack as long as it does not conflict with\r\n       any other application-requested properties.\u201d\r\n- allowing or not allowing seems odd, could we write:\r\n3.\r\n\u201cHowever, if the\r\n       application does not require reliability, then a Protocol Stack\r\n       that adds reliability could be regarded as an\r\n       equivalent Protocol Stack providing this would not conflict with\r\n       other application-requested properties.\u201d\r\n\u2014\r\nIn 4.2.4:\r\n\u201cproperties of the Implementation\u201d\r\n- implementation should not be capitalised.\r\n\u2014\r\n\u201cTransport System Implementation\u201d\r\n- implementation should not be capitalised.\r\n\u2014\r\n\u201cThe interface to specify these Groups\u201d\r\n-groups should not be capitalised.\r\n\u2014\r\nNormative references:\r\n[I-D.ietf-taps-interface]\r\n[RFC8174]\r\n[RFC2119]",
      "createdAt": "2019-04-29T10:03:44Z",
      "updatedAt": "2019-11-19T07:38:12Z",
      "closedAt": "2019-11-19T07:38:12Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was done!",
          "createdAt": "2019-11-19T07:38:12Z",
          "updatedAt": "2019-11-19T07:38:12Z"
        }
      ]
    },
    {
      "number": 313,
      "id": "MDU6SXNzdWU0MzgyNjgwMTY=",
      "title": "API Draft author editorial comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/313",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "```\r\n\u201cThe simplicity of this API is a key reason the Internet won the protocol wars of the 1980s. \u201c\r\n- Reference needed (some may be too young to remember):-0.\r\n\u2014\r\n\u201cAs a first step to realizing this design, [I-D.ietf-taps-arch] describes a high-level architecture for transport services.\u201d\r\n- I\u2019d much prefer to remove \u201cAs a first step to\u201d from the start of the final para of introduction. Once that is published as a PS we do not need to be so \u201ctentative\u201d, and perhaps unintended but still seems to potentially devalue the arch\r\n\u2014\r\n\u201cThe method for dispatching and handling Events is left as an\u201d\r\n- I\u2019m unsure what \u201cleft as\u201d intends, is it just that this is an implementation detail, or was something not done? Would the sentence read the same without /left as/?\r\n\u2014\r\n\u201cMessage- as opposed to stream-orientation,\u201d\r\n-could this be:\r\n\u201cMessage-orientation as opposed to stream-orientation,\u201d\r\n\u2014\r\n\u201cAn application primarily interacts with this interface through two Objects, Preconnections and Connections.\u201d\r\nCould we use a colon instead of a comma after objects?\r\n\u2014\r\n\u201cdefined in [I-D.ietf-taps-arch].|\r\n- could be: \u201cdefined in the TAPS Architecture [I-D.ietf-taps-arch].\u201d\u201d\r\n\u2014\r\n\u201cfollowing the phases described in [I-D.ietf-taps-arch].\u201d\r\n- could be:\r\n\u201cfollowing the phases defined in the TAPS Architecture [I-D.ietf-taps-arch].\u201d\r\n\u2014\r\n\u201cendpoint\u201d is capitalised in the architecture Spec, when used as a TAPS term.\r\n\u2014\r\n\u201cbut there is a transport protocol which provides \u201c\r\n- please change /which/ to /that/.\r\n\u2014\r\n\u201cthis octet stream\u201d\r\n- do we still with in 2019 to talk about \u201coctet\u201d streams?\r\n\u2014\r\nIn 4.2 at the end of para 2. we seem to have a list delimited by inline minus symbols, could these be translated to bullets to make this easier to read?\r\n\u2014\r\nIn 4.2 para 2. \r\n- The setting of parameters is now well-described in detail in the architecture - please can we cross-ref here?\r\n\u2014\r\nIn 4.2 final para:\r\n\u201cConnection Properties specified early on may be used\u201d\r\n- could be better as:\r\n\u201cEarly specification of Connection Properties allows their use\u201d\r\n\u2014\r\n\u201cAlso note that Protocol Specific Properties\u201d\r\n- I\u2019d prefer to not diminish this to a note, cam we simply state:\r\n\u201cProtocol Specific Properties\u201d\r\n\u2014\r\nIn 4.2.1.:\r\n\u201cfor properties defined by an RFC which are not protocol specific..\u201d\r\n- should be:\r\n- \u201cfor properties that are not specific to a protocol and are defined by an RFC.\u201d\r\n\u2014\r\nIn Section 4.3:\r\n\u201cWhile there is no interoperability benefit to tightly defining how the interface be presented to application programmers in diverse platforms, maintaining the \u201cshape\u201d of the abstract interface across these platforms reduces the effort for programmers who learn the transport services interface to apply their knowledge in multiple platforms.\u201d\r\n- This sentence is unduly hard to parse:\r\n\u201cThere is no interoperability benefit in tightly defining how the interface is presented to application programmers across diverse platforms. However, maintaining the \u201cshape\u201d of the abstract interface across these platforms reduces the effort for programmers who learn the transport services interface to then apply their knowledge across multiple platforms.\u201d\r\n\u2014\r\n\u201cSHOULD carry the names given for them in the document, \u201c\u2028- could we change /carry/ to /use/ or /specify/ or /employ/ or something?\r\n\u2014\r\n\u201c, even if said implementation is a non-operation, e.g. because transport protocols implementing a given Property are not available on the platform.\u201d\r\nCould we break the sentence and explain as:\r\n\u201c. The interface should be implemented even when this results in no-operation, e.g. there is no action when the API specifies a Property that is not available in a transport protocol implemented on a specific platform.\u201c\r\n\u2014\r\n\u201cstatic singleton objects\u201d \r\n- probably should be explained.\r\n\u2014\r\n\u201cPre-Establishment\u201d is capitalised in the architecture.\r\n\u2014\r\n\u201cfor the Connections they are about to make, or to query the API about potential connections they could make.\u201d\r\n- why is connections capitalised once and not the second time?\r\n\u2014\r\n\u201cSelection Properties which select paths\u201d\r\n- change /which/ to /that/.\r\n\u2014\r\n\u201cAlso note that reliability is usually combined with congestion control in protocol implementations, rendering \u201creliable but not congestion controlled\u201d a request that is unlikely to succeed. \u201c\r\n- Agree, but useful to add a parenthesis that the converse is not necessarily true.\r\n\u2014\r\n\u201cNote that marking a specific interface\u201d\r\n- In the next para the note is incorporated as the final line of the para in which the note applies, can we change this to also be in the same place?\r\n\u2014\r\n\u201cImplementations should provide all types that are supported on some system to all systems, in order to allow applications to write generic code.\u201d\r\n- I think this could be improved by:\r\n\u201cAn implementation should provide all types that are supported on the local system to all remote systems, to allow applications to write generic code.\u201d\r\n- but what does /all/ imply?\r\n\u2014\r\n\u201cNote that marking a specific interface type as Required limits path selection to a small set of interfaces, and leads to less flexible and resilient connection establishment.\u201d\r\n- Is that ALWAYS the case? I think this is a case of \u201ccould lead to\u201d or at best \u201cmay often lead to\u201d\r\n\u2014\r\nIn 5.2.12:\r\n\u201cOne possible side-effect is increased jitter, which may be problematic for delay-sensitive applications. The recommended default is to Prefer this option.\u201d\r\n- If this only leads to increase jitter, then this default may be OK. Are we sure this can not lead to duplication or reordering of data? If it did, then I\u2019m concerned this becomes a default.\r\n\u2014\r\nIn 5.2.13:\r\n\u201cIn case a unidirectional connection is requested, but unidirectional connections are not supported by the transport protocol, the system should fall back to bidirectional transport.\r\n\u201c\r\n- please explain \u201cfall back\u201d in terms of the TAPS language.\r\n- What is the default if not specified - I think the default should be bidirectional.\r\n\u2014\r\nIn section 5.3.2:\r\n\u201cOnce configured, parameters may also be supplied during connection establishment. These are best handled as client-provided callbacks. \u201c\r\n- Is a callback what the TAPS architecture refers to as an Event?\r\n```",
      "createdAt": "2019-04-29T11:24:59Z",
      "updatedAt": "2019-10-30T10:16:00Z",
      "closedAt": "2019-10-30T10:15:59Z",
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A related note on section 5.2.13 (direction of communication):\r\n\r\nThe descriptions for unidirectional send and receive in section 5.2 seem to leave open the possibility of bidirectional behavior, but in section 11 (Managing Connections) it's an error condition if performing the unsupported operation.\r\n\r\nCurrent:\r\n\"Unidirectional send: The connection must support sending data\"\r\n\r\nSuggested:\r\n\"Unidirectional send: The connection must support sending data, and the application cannot use the connection to receive any data\"\r\n\r\n(and similar for unidirectional receive)",
          "createdAt": "2019-07-20T20:28:56Z",
          "updatedAt": "2019-07-20T20:28:56Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWU0MzgyNjg1NDg=",
      "title": "Default for Use 0-RTT session establishment",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/314",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "In Section 5.2.5: Use 0-RTT session establishment with an idempotent Message\r\n\r\n\u201cThe recommended default is to Prefer this option.\u201d\r\n\r\nI argue that this default is much braver than specified in the IETF present. Once could argue the same for QUIC, but the TCP-basis for this feature was determined, based - as I recall - on the need for idempotent data *and* the need to provide server-side support that was not specified. The safe option is to not enable this as a default, requiring Apps to explicitly say their data is idempotent.\r\n\r\n\u201cpotentially multiple times\u201d - probably should be explicitly explained that \u201cthe transport does not provide idempotency, which could result in multiple copies of the message data being passed to the Receiving Endpoint.\u201d",
      "createdAt": "2019-04-29T11:26:24Z",
      "updatedAt": "2019-07-03T13:56:10Z",
      "closedAt": "2019-07-03T13:56:10Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "And... This was relating to TCP, SCTP, etc - which are connection-oreinted. We maybe should discuss this with respect to the Datagram case (UDP et al) in issue #302.",
          "createdAt": "2019-05-08T08:07:55Z",
          "updatedAt": "2019-05-08T08:07:55Z"
        }
      ]
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWU0MzgyNjg2OTg=",
      "title": "Default for Control checksum coverage",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/315",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In Section 5.2.7 Control checksum coverage on sending\r\n\r\n\u201cThe recommended default is to Ignore this option.\u201d\r\n\r\nI argue that this default is much braver than specified in the IETF present in RFC 8085. The default for IPv6 is also that this is required by default. Again, I would argue that applications need to explicitly be designed to accept this.\r\n\r\n\u2014\r\nIn Section, 5.2.8. Control checksum coverage on receiving\r\n\r\n\u201cThe recommended default is to Ignore this option.\u201d\r\n\r\nI argue that this default is much braver than specified in the IETF present in RFC 8085. The default for IPv6 is also that this is required by default. Again, I would argue that applications need to explicitly be designed to accept this.\r\n",
      "createdAt": "2019-04-29T11:26:50Z",
      "updatedAt": "2019-07-03T13:57:26Z",
      "closedAt": "2019-07-03T13:57:26Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this seems reasonable to me, I don't recall how we ended up at Ignore.",
          "createdAt": "2019-05-06T13:25:13Z",
          "updatedAt": "2019-05-06T13:25:13Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I think we need to re-phrase this as I guess you mis-read it.\r\n\r\nThe property only defines whether you want a protocol that provides this feature, not whether it should be enabled. The latter is controlled by the property in 7.3.6.",
          "createdAt": "2019-05-06T14:57:35Z",
          "updatedAt": "2019-05-06T14:57:35Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this seems to be a misunderstanding. Perhaps we also need to clarify that _Ignore_ just means that the property is ignored when ranking alternatives for candiadet selection and racing, not that the application can ignore it?",
          "createdAt": "2019-05-06T18:27:39Z",
          "updatedAt": "2019-05-06T18:27:39Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I don't understand something about 5.2.7 and 5.2.8 ... So let me ask a more stupid question:\r\n- IETF transports always do provide full coverage by default.\r\n- Why do we have a property to request control of checksum coverage at all, why don't we just have a property that says you want to have (require) or would like to have (prefer), or don't care (ignore) some size of limited checksum coverage - as in 7.3.6. \r\n\r\nIf you don't get the coverage that you ask for, then you will get more coverage. ... so \"require\" is in some way \"prefer a protocol that gives at least an ability to provide this much?\".\r\n\r\n---\r\nThen in 7.3.6:\r\n\r\nI think \" This property specifies the length of the section of the Message....\" is actually the *minimum* length of message - the transport can always protect more.\r\n\r\nI don't understand: \" ... a special value (e.g. -1) can be used to indicate the default.  \"\r\n- the default is *full* coverage, how is this different to a zero parameter?\r\n\r\nGorry\r\n",
          "createdAt": "2019-05-07T12:45:29Z",
          "updatedAt": "2019-05-07T12:45:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "per TAPS interim, let's Avoid this.",
          "createdAt": "2019-05-08T16:01:30Z",
          "updatedAt": "2019-05-08T16:01:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #330 partially addresses this:\r\n7.3.6 was re-written to include \"minimum\" and fix the special value related text, also using the same style as in the other Message Properties now to specify the default.",
          "createdAt": "2019-05-24T10:34:04Z",
          "updatedAt": "2019-05-24T10:34:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #335 addresses the last missing bit here:\r\n\r\n> IETF transports always do provide full coverage by default.\r\n> Why do we have a property to request control of checksum coverage at all, why don't we just have a property that says you want to have (require) or would like to have (prefer), or don't care (ignore) some size of limited checksum coverage - as in 7.3.6.\r\n\r\nI changed both Selection Properties to ask for full coverage and have them default to Require. The effect is similar to before, but intuitively this is clearer and makes more sense, I suppose.",
          "createdAt": "2019-07-02T09:10:20Z",
          "updatedAt": "2019-07-02T09:10:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #335",
          "createdAt": "2019-07-03T13:57:25Z",
          "updatedAt": "2019-07-03T13:57:25Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWU0MzgyNjkzMDE=",
      "title": " Section 4.2.1 - Transport Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/316",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\r\n Section 4.2.1: \u201cAllow different components of a TAPS implementation to pass Transport Properties, e.g., between a language frontend and a policy manager.\u201d\r\n- Question??? : Would it also be OK to include a suggestion that these could also be retrieved from storage, e.g. \u201cAllow different components of a TAPS implementation to pass Transport Properties, e.g., between a language frontend and a policy manager, or to retrieve a list of properties from a file or other storage.\u201d\r\n\r\n Section 4.2.1.:\r\nAre the definitions of \u201cshould\u201d actually \u201cSHOULD\u201d, I don\u2019t otherwise understand the meaning of the lower case should. Actually, why is it SHOULD not MUST for the IETF-specified class?\r\n",
      "createdAt": "2019-04-29T11:28:29Z",
      "updatedAt": "2019-07-03T13:57:44Z",
      "closedAt": "2019-07-03T13:57:44Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am in favour of adding the suggestion for using this representation on stable storage, but shouldn't it be rather \"or as a representation of properties retrieved from a file or other storage.\"\r\n\r\nI chose \"should\" over \"must\" here because I feared  defining protocol specific properties for all important IETF protocols may creep in as a dependency for publication of this document otherwise.\r\nWith regarded to the casing, this really must be a SHOULD.",
          "createdAt": "2019-04-29T13:15:14Z",
          "updatedAt": "2019-04-29T13:21:43Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #335 ",
          "createdAt": "2019-07-03T13:57:44Z",
          "updatedAt": "2019-07-03T13:57:44Z"
        }
      ]
    },
    {
      "number": 317,
      "id": "MDU6SXNzdWU0MzgyNzAyNDU=",
      "title": "The recommended default and can we specify rather than recommend?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/317",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Section 5.2: \u201cThe recommended default\u201d\r\n\r\nThsi may sound radical for TAPS, however, I have trouble understanding why we do not simply not specify the defaults, rather than recommend them.  \r\n\r\nI think we provide plenty of ways that an app can using a system can over-ride defaults, but if we do not agree on the meaning of a default, there are real dangers in interior problems between systems - we say common language helps, in this case it hinders. I propose that we make all the default recomendations as requirements for the default case?\r\n",
      "createdAt": "2019-04-29T11:31:10Z",
      "updatedAt": "2019-10-21T14:26:09Z",
      "closedAt": "2019-10-21T14:26:08Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense to me.  (just to be clear, I think you meant to say \"...why we do not simply specify the defaults\" instead of \"do not simply not specify\" - i.e. you WANT to specify the defaults)",
          "createdAt": "2019-04-29T12:58:51Z",
          "updatedAt": "2019-04-29T12:58:51Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I was motivating specifying a default for each, by motivagting why and stating something like:\r\n\r\nThe dafault MUST be xxx.\"",
          "createdAt": "2019-04-29T13:12:17Z",
          "updatedAt": "2019-04-29T13:12:17Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess relying on the defaults from the defaults in the API is dangerous anyway, but this really depends on the properties:\r\n - For some properties, e.g., ```Notification of ICMP soft error message arrival``` this is harmless and having a should-default is fine.\r\n - For semantic-changers like ```Reliable Data Transfer``` or ```Preservation of data ordering``` we need either a MUST or no default at all and require the application to explicitly specify what it wants.",
          "createdAt": "2019-04-29T13:34:22Z",
          "updatedAt": "2019-04-29T13:34:22Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Right. I'm keener on making the dafault \"safe\" than requiring specification. A \"safe\" default means that actually means if the app wants something, different it has to specify. Happy to review a set of defaults if this helps.",
          "createdAt": "2019-04-29T15:44:37Z",
          "updatedAt": "2019-04-29T15:44:37Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the current phrasing \"An implementation of this interface must provide sensible defaults ...\" is quite ambiguous as anything can be \"sensible\" given the right context. \r\n\r\nThere is also the system policy to consider, which would still provide a way to deviate from the default on a system to system basis. ",
          "createdAt": "2019-04-29T23:19:12Z",
          "updatedAt": "2019-04-29T23:19:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MaxF12 The system policy is the reason why not all defaults are MUSTs.\r\n\r\nSo, I am very much in favor to cut through the properties and turn the defaults to MUST for a well-chosen set of them.",
          "createdAt": "2019-04-30T06:58:00Z",
          "updatedAt": "2019-04-30T06:58:00Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think I don't have the same viewpoint. Pehaps we need to understand what is intended by \"default\" - do you see this as a \"TAPS system default\"...  I am quite happy that the TAPS system default is over-ridden in the application code or in a policy - presumably whoever made the policy change had a good reason to do this and they will then get the behaviour they tweak - and that may change what the application sees when it expresses no preference itself?",
          "createdAt": "2019-04-30T07:33:36Z",
          "updatedAt": "2019-04-30T07:33:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Possibly\u2026 the evaluation of Preferences is a complicated beast. Let me write up what my perspective is:\r\n1. There is a \"TAPS default\" (in the document). \r\n   - If this is Require or Prohibit, there is no way for an implementation to get around the requirement even if it is \"just the default\". \r\n   - Changing \"TAPS default\" in an implementation is considered harmful, because it breaks portability.\r\n2. The \"TAPS default\" is used unless the application sets something.\r\n3. A System Configuration (you may call this policy) may override the applications' preference within bounds:\r\n   - It MUST honour require/prohibit \r\n   - It may change prefer/ignore/avoid to anything it likes\r\n4. The Policy/Racing component (you may call this differently) chooses the transport options that\r\n   - honour require/prohibit \r\n   - somehow weight prefer/ignore/avoid and express it in penalties for the racing\r\n\r\nThis results in a simple consequence:\r\n - If the \"TAPS default\" is Require or Prohibit, this is a MUST default.\r\n -  If the \"TAPS default\" is something else, it is either a SHOULD or we can remove it completely.",
          "createdAt": "2019-04-30T12:49:55Z",
          "updatedAt": "2019-04-30T12:49:55Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Why is this so:\r\n\r\n\"A System Configuration (you may call this policy) may override the applications' preference within bounds:\r\nIt MUST honour require/prohibit\"\r\n\r\n- I can see that an IETF BCP for UDP mandates the default to be REQUIRES Checksum coverage. That is way the IETF has reached consensus on the default. Now, if I invent a tunnel-broker application, I may have good erasons to not stick to teh default, and I could indeed find other guidance that lets me do different when I can provide other checks. So if I know what I am doing I can include policy or application configuration to change that. That's quite OK. \r\n\r\n- Back to the app that doesn't want something special - it needs to get the checksum coverage feature, otherwise it doesn't function normally in some cases. That to me is why the default system value is REQUIRES.\r\n\r\nI think if we think, we know the default for many functions and can cite PS or BCP documents to support these choices.\r\n\r\nI am however, unsure what you write above about understanding of the \"consequences\"...\r\n",
          "createdAt": "2019-04-30T13:28:50Z",
          "updatedAt": "2019-04-30T13:28:50Z"
        },
        {
          "author": "adfalk",
          "authorAssociation": "NONE",
          "body": "<Chair interrupt>This seems like a policy discussion that would be \nbetter had on the wg email list.</>\n\nOn 30 Apr 2019, at 9:28, Gorry Fairhurst wrote:\n\n> Why is this so:\n>\n> \"A System Configuration (you may call this policy) may override the \n> applications' preference within bounds:\n> It MUST honour require/prohibit\"\n>\n> - I can see that an IETF BCP for UDP mandates the default to be \n> REQUIRES Checksum coverage. That is way the IETF has reached consensus \n> on the default. Now, if I invent a tunnel-broker application, I may \n> have good erasons to not stick to teh default, and I could indeed find \n> other guidance that lets me do different when I can provide other \n> checks. So if I know what I am doing I can include policy or \n> application configuration to change that. That's quite OK.\n>\n> - Back to the app that doesn't want something special - it needs to \n> get the checksum coverage feature, otherwise it doesn't function \n> normally in some cases. That to me is why the default system value is \n> REQUIRES.\n>\n> I think if we think, we know the default for many functions and can \n> cite PS or BCP documents to support these choices.\n>\n> I am however, unsure what you write above about understanding of the \n> \"consequences\"...\n>\n>\n> -- \n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/ietf-tapswg/api-drafts/issues/317#issuecomment-487952298\n\n\n",
          "createdAt": "2019-04-30T14:09:35Z",
          "updatedAt": "2019-04-30T14:09:35Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If an application relies on Checksum coverage of the whole message and expresses this either by specifying it or not specifying it because it knows it is the default behaviour, changing this behaviour \"by policy\" may cause the application to malfunction.\r\nIf you change the protocol behaviour \"on path\" and implement the required functionality in a different way, it does not feel like a policy thing any more, but as some kind of path/middlebox behaviour.",
          "createdAt": "2019-04-30T14:13:30Z",
          "updatedAt": "2019-04-30T14:13:30Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm not going down the on-path discussion.\r\n\r\nIn answer to the first question:  \"yes\" if someone deploys stupid policies - then it will break applications. That was always true of NEAT policy, when we had the NEAT framework and I guess of any other polcie: If theres is a  request nonsense properties it will break the app, just as surely as broken code asking for wrong properties will also break it. \r\n\r\nBut, I could write a policy that says my App can tolerate XXX, and providing I supply code to support this, my app would work just as well as if I had requested a property XXX via the API. I can also do something more complex - like when I use network YYY and I can use ZZZ and then I don't need XXX. Whether that is easier by defining policy or by writing code using the API depends. \r\n\r\nIf we understand one another, we can continue on the list...\r\n",
          "createdAt": "2019-04-30T15:13:13Z",
          "updatedAt": "2019-04-30T15:13:13Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I got your point \u2026 this also rises the question whether properties specified by the application and properties specified by the policy/configuration are equivalent / should use the same language / may override each other or fail in case of a conflict. \r\n\r\nI always implied that the application will only set a minimal set of properties (bare necessary requirements + runtime-dependent information), and the configuration/policy will do the fine-tuning, but hat is not a canonical view of things.\r\n\r\nLets' take this discussion to the list.  ",
          "createdAt": "2019-05-02T13:34:10Z",
          "updatedAt": "2019-05-02T13:34:10Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK - let's do that.\r\n\r\nCould we also try to start a discussion about the set of default values in a seprate thread. I think we can address some of these quickly, albeit we wait for the list discussion (or wider consensus) on whether they are SHOULD or MUST.",
          "createdAt": "2019-05-02T13:38:41Z",
          "updatedAt": "2019-05-02T13:38:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From discussion in Montr\u00e9al: \"the default is\"",
          "createdAt": "2019-07-22T18:46:58Z",
          "updatedAt": "2019-07-22T18:46:58Z"
        }
      ]
    },
    {
      "number": 318,
      "id": "MDU6SXNzdWU0MzgyOTMxMjA=",
      "title": "More editorial author comments on API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/318",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "In section 6.4:\r\nThis para opens with the words \u201cGroups of Connections\u201d\r\n- Please check which letter groups should be capitalised in this section, I think it should be \u201cConnection Group\u201d, so this should be \u201cGroups of connections\u201d.\r\n\u2014\r\nIn Section 7:\r\n\u201cData is sent in terms of Messages,\u201d\r\n- Is it true that \u201cblocks of data supplied by the application are sent as Messages\u201d \r\n- or what does \u201cin terms of\u201d refer to?\r\n\u2014\r\nIn Section 7.1:\r\n\u201cMessage data is created as an array of octets\u201d\r\n- even I have a a hard time remembering 6-bit bytes, can we declare \u201coctet\u201das historic and use \u201cbytes\u201d.\r\n- is the data \u201ccreated\u201d or \u201ctransferred\u201d\r\n\u2014\r\nIn Section 7.1:\r\n\u201cApplications can query the protocol property Maximum Message Size on Send to determine the maximum size allowed for a single Message.\u201d\r\n- I don\u2019t know how the app does this across the API, can we be more clear? (It could be the example below seeks to explain this, in which case maybe a little wording change would help me?)\r\n\u2014\r\nSection 7.2:\r\n\u201cThere are several events\u201d\u2028- should this be \u201cEvents\u201d?\r\n\u2014\r\nSection 7.2.1:\r\n\u201cand is no longer the responsibility of the implementation of this interface\u201d:\r\n- why use the words \u201cthe implementation of\u201d, is there something more subtle that needs explained, or can these words be deleted?\r\n\u2014\r\nSection 7.3:\r\n\u201cThe simpler form of Send that does not take any messageContext is equivalent to passing a default MessageContext with not values added.\u201d\r\n- These read wrong: /not/ /is equivalent/, could this be better?\r\n\u201cThe simpler form of Send, which does not take any messageContext, is equivalent to passing a default MessageContext without adding any values.\u201d\r\n- Also, what are values here: properties or something else?\r\n\u2014\r\nSection 7.5:\r\n\u201cIn order to reduce the overhead\u201d\r\n- please remove /In order/ to avoid any misunderstanding about ordering.\r\n\u2014\r\nSection 9.1.2. Required minimum coverage of the Corruption Protection for receiving\r\n- The default needs to be protect the entire message.\r\n",
      "createdAt": "2019-04-29T12:34:27Z",
      "updatedAt": "2019-07-01T13:45:40Z",
      "closedAt": "2019-07-01T13:45:40Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #330 addresses this. A detail below:\r\n\r\nRegarding:\r\n> Please check which letter groups should be capitalised in this section, I think it should be \u201cConnection Group\u201d, so this should be \u201cGroups of connections\u201d.\r\n\r\nSure this can (and should!) lead to some form of grouping of transport connections below, but it is meant as a construct applying to the Connections that an application sees - conceptually these are the ones that are grouped. So I think it should be \"Connections\", not \"connections\".",
          "createdAt": "2019-05-24T10:34:45Z",
          "updatedAt": "2019-05-24T10:34:45Z"
        }
      ]
    },
    {
      "number": 319,
      "id": "MDU6SXNzdWU0MzgyOTM2Mjk=",
      "title": "Section 7 default",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/319",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Section 7.3.1:\r\n- The word \u201clifetime\u201d appears several times in the architecture document. I am unsure whether any of these uses are the same as the use here. This would be helped (of course) a little, if this section were renamed as \u201cMessage Lifetime\u201d\r\n- What is the default? if any?\r\n\u2014\u2014\r\nSection 7.3.2 \r\n- What is the default priority?\r\n- Interesting question, but I suggest it could be useful to still have a default even if the meaning and range are varying. If the default were, say, \u201c100\u201d then anything less than 100 is less priority and anything more is more than default priority. That\u2019s useful if I supply no param in one connection and then supply a param in other connections.\r\n\u2014\r\nSection 7.3.3. Ordered\r\n- I think this needs to default to safety: i.e. TRUE - Required.\r\n\u2014\r\nSection 7.3.4. Idempotent\r\n-I think this needs to default to safety: i.e.  \u201cFALSE\u201d.\r\n\u2014\r\nSection 7.3.5. Final\r\n- I think this should default to the most common: i.e.  \u201cFALSE\u201d.\r\n\u2014\r\n7.3.7. Reliable Data Transfer (Message)\r\n- this should default to something.\r\n\u2014\r\n7.3.9. Singular Transmission\r\n- What is the default?\r\n\u2014\r\n",
      "createdAt": "2019-04-29T12:35:44Z",
      "updatedAt": "2019-06-26T08:47:33Z",
      "closedAt": "2019-06-26T08:47:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #330 addresses this. Some details below:\r\n\r\nRegarding \"lifetime\", the use is indeed different. However, all these occurrences seem to clearly refer to a different thing than the Message Property from context (e.g., by saying \"the lifetime of a connection\"). Renaming this into Message Lifetime seems clumsy and inconsistent (as in: why are all the other Message Properties not prefaced with \"Message\"?), so I decided to leave this as it is.\r\n\r\nRegarding 7.3.7: I chose \"true\" as a default because it is probably the most common (and allows TCP as a protocol choice).\r\n\r\nRegarding 7.3.9: I chose \"false\" as a default because it is probably the most common (and allows TCP as a protocol choice).",
          "createdAt": "2019-05-24T10:33:44Z",
          "updatedAt": "2019-05-24T10:33:44Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWU0NDA4Nzc4MTE=",
      "title": "Issues concerning framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/322",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Hi, we now implemented (basic) framers in [PyTAPS](https://github.com/fg-inet/python-asyncio-taps), here are some things we noticed that might be of value for the upcoming interim:\r\n\r\n- The current way the deframer is supposed to modify the octetstream is not very well specified, the deframer should probably have an interface to the connection on which it can either tell it how much of the stream it has removed or what the new stream is. \r\n\r\n- If the application enables partial receives, the framer needs a way to communicate to the connection that it only deframed part of the message.\r\n\r\n- If there is an error during the deframing process (that is not caused by an incomplete message), the deframer needs some standardized behavior on how to indicate this. The connection should then throw an appropriate event, possibly an invalid configuration event (as mentioned [here](https://github.com/ietf-tapswg/api-drafts/issues/307)) since both are issues the application can actively remedy. ",
      "createdAt": "2019-05-06T20:41:39Z",
      "updatedAt": "2019-07-14T20:41:25Z",
      "closedAt": "2019-07-14T20:41:25Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please see the proposed changes in #323, and review!",
          "createdAt": "2019-05-06T22:16:31Z",
          "updatedAt": "2019-05-06T22:16:31Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "These have been solved by the new version of framers, thanks.",
          "createdAt": "2019-07-14T20:41:25Z",
          "updatedAt": "2019-07-14T20:41:25Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU0NDQ0MDM2NDg=",
      "title": "Add explicit protocol selection.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/324",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "This issue was discussed in the May 2019 interim.\r\n\r\nSome Applications may really need a specific protocol and can not rely on the transport system  to choose an appropriate one. ",
      "createdAt": "2019-05-15T12:13:03Z",
      "updatedAt": "2019-11-22T00:52:01Z",
      "closedAt": "2019-11-22T00:52:01Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Agreed. Although that does not mean we have to or even should standardise a way to express this.",
          "createdAt": "2019-05-15T12:49:50Z",
          "updatedAt": "2019-05-15T12:49:50Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess we should standardise a way to express this, to avoid ossifying the selection properties on the assumption \"combination x1 x2 x3 is guaranteed to give you YTP\".\r\nNevertheless, we should discourage its use by having profiles (#325 ) as a more convenient alternative.",
          "createdAt": "2019-05-15T13:01:42Z",
          "updatedAt": "2019-05-15T13:14:33Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @philsbln; if we do not provide a standard way to express this, the workarounds people will end up using when they need this will be much worse for taps's adoption and goals than giving them a way to express an explicit need for a specific protocol.\r\n\r\nEven though I also see that providing this will sometimes result in apps using the same old protocols instead of making use of new and better ones, we can't get rid of the need for picking specific protocols in some cases, and we can't serve the need by ignoring it.\r\n\r\nIMO the solution is to accept that developers will make the wrong choice on this sometimes, and to make it so that there's a good 1-line fix when they realize it.  Making it harder to express won't prevent the mistakes, it'll just make the mistakes harder to unwind.",
          "createdAt": "2019-05-17T19:47:14Z",
          "updatedAt": "2019-05-17T19:47:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that apps need to be able to restrict this. That has been part of the architecture from the start, although the API doc doesn't specify how to do it.\r\n\r\nBased on the architecture, my suggestion is:\r\n- Specify a set of allowed protocol stacks if you want to restrict; if you leave it empty, we choose for you\r\n- The protocol stacks are composed of per-protocol options, to express \"if you use TCP, use these TCP flags\"",
          "createdAt": "2019-05-17T20:22:12Z",
          "updatedAt": "2019-05-17T20:22:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please take a look at PR #327 wether it addresses the first of @tfpauly's points.\r\n\r\nFor the second one, I think the current design with protocol specific properties is sufficient, as protocol specific properties on a preconnection are ignored for other protocols.",
          "createdAt": "2019-05-20T08:40:10Z",
          "updatedAt": "2019-05-20T08:40:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suggestion from the authors' meeting in Montr\u00e9al: leave this underspecified in the standard, and state that implementations SHOULD provide the application a way to override transport selection and instantiate a specific stack, but make this functionality explicitly non-portable. ",
          "createdAt": "2019-07-24T20:44:47Z",
          "updatedAt": "2019-07-24T20:44:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(also explain why you may want to force a stack per @gorryfair)",
          "createdAt": "2019-07-24T20:47:21Z",
          "updatedAt": "2019-07-24T20:47:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Michael: figure out where to put this. Note that selection properties are also used for listening, and that (especially servers) might want to provide explicit protocol stack selection, but that methods for explicit selection are out of scope for the abstract interface. michael suggests this belongs up top, near/in intro.",
          "createdAt": "2019-11-21T04:48:44Z",
          "updatedAt": "2019-11-21T04:48:44Z"
        }
      ]
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU0NDQ0Mjk1NTM=",
      "title": "Add support for Property Profiles",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/325",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This issue was discussed in the May 2019 interim.\r\n\r\nAfter fist implementation experiences, we feel that we should add a convenient way to express common Transport Parameter combinations as some kind of profile, e.g. \"TCP like\" meaning \"Reliable, in-order, non-message preserving\"",
      "createdAt": "2019-05-15T13:09:31Z",
      "updatedAt": "2019-08-01T18:35:52Z",
      "closedAt": "2019-08-01T18:35:52Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal how to solve this:\r\n\r\nReplace the TransportProperties constructor in section 5.2 with\r\n~~~\r\n   TransportProperties := NewTransportProperties(propertyProfile?)\r\n~~~\r\n\r\n@gorryfair promised this at the interim. I only open this issue to document the proposal how to solve this.",
          "createdAt": "2019-05-15T13:13:51Z",
          "updatedAt": "2019-05-15T13:13:51Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "This can be closed.",
          "createdAt": "2019-07-28T01:34:26Z",
          "updatedAt": "2019-07-28T01:34:26Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #328",
          "createdAt": "2019-08-01T18:35:47Z",
          "updatedAt": "2019-08-01T18:35:47Z"
        }
      ]
    },
    {
      "number": 331,
      "id": "MDU6SXNzdWU0NDgxMDAyNTE=",
      "title": "9.1 defaults",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/331",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "With the exception of read-only Properties, something should be said about the default values of the Generic Connection Properties in Section 9.1.",
      "createdAt": "2019-05-24T10:37:25Z",
      "updatedAt": "2019-07-03T13:58:03Z",
      "closedAt": "2019-07-03T13:58:03Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed by #335",
          "createdAt": "2019-07-03T13:58:03Z",
          "updatedAt": "2019-07-03T13:58:03Z"
        }
      ]
    },
    {
      "number": 334,
      "id": "MDU6SXNzdWU0NjIyNDkwMDQ=",
      "title": "Consider message send API that takes padding policy as input",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/334",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API",
        "future work"
      ],
      "body": "One might want to send a message M as a multiple of size B octets. Since padding is (increasingly) supported by transports, this should be something a TAPS implementation provides. Moreover, applications should ideally be able to specify their padding policy. ",
      "createdAt": "2019-06-29T00:50:47Z",
      "updatedAt": "2019-11-21T04:17:15Z",
      "closedAt": "2019-11-21T04:17:14Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I don't agree this is a need in the basic API. \r\n\r\nWhile there are good reasons to introduce padding - and it solves some issues , I suggest this is often something that can be done by the app or library using the TAPS system. I don't think this is a core application need, and it is debatable whether this is something that should be used by default in applications. \r\n\r\nFor example: I'm not convinced that CHAFF packets on their own provide much protection from machine learning of traffic characteristics. I am also concerned that routinely padding data is a method that significantly reduces performance over some types of path (e.g. it makes inefficient use of radio resource). \r\n",
          "createdAt": "2019-06-29T05:34:47Z",
          "updatedAt": "2019-06-29T05:34:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> I suggest this is often something that can be done by the app or library using the TAPS system.\r\n\r\nOf course! I do not mean to imply this should be the default case. What I'm suggesting is that the API let clients make use of padding mechanisms provided by modern transports. Punting this to the application is certainly possible, and QUIC's a good example of what happens when that's done. \r\n\r\nAll that said, this could certainly be something discussed in the implementation document. I'm not advocating for it to be in the API document (though I see why the title of the issue might suggest that :)). \r\n\r\n> For example: I'm not convinced that CHAFF packets on their own provide much protection from machine learning of traffic characteristics\r\n\r\nIt's an open area of research. Fixed-sized and adaptive padding can, for example, help quite significantly in some cases.\r\n\r\n>  I am also concerned that routinely padding data is a method that significantly reduces performance over some types of path (e.g. it makes inefficient use of radio resource).\r\n\r\nCertainly. It's a tradeoff. ",
          "createdAt": "2019-06-29T13:58:33Z",
          "updatedAt": "2019-06-29T13:58:33Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see a value in being able to influence padding from the application, but am nit sure what the right way of exposing this control from the API is. This gehts even more complicated as most use-cases I see are somewhat security related:\r\n\r\n - Amplification prevention (require messages that trigger large responses to be large themselves). This is much easier if the application can instruct the transport system to pad to the MTU estimate somewhere \u2013 especially because it relieves the application from taking size changes by the encryption into account.\r\n- Traffic obfuscation \u2013 especially if packet sizes provide too many insights.\r\n\r\nWhile the first one could be a message property, the second one should definitely be a security property and may ask for a certain level of protection.",
          "createdAt": "2019-07-01T07:22:47Z",
          "updatedAt": "2019-07-01T07:22:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Considered.",
          "createdAt": "2019-11-21T04:17:14Z",
          "updatedAt": "2019-11-21T04:17:14Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "MDU6SXNzdWU0NjQxMzc2MjE=",
      "title": "Send() -> Sent<> mapping underspecified",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/336",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "PR #321 added a return value to the Send to make matching of send error events and reply messages to their originating message easier:\r\n\r\n~~~\r\nmessageContext := Connection.Send(messageData, messageContext?, endOfMessage?)\r\n~~~\r\n\r\n@tfpauly raised the concern that this this adds return value that most often is not needed and ignoring it may often trigger a warning. \r\nTherefore, we have to decide whether to keep the return value based on what is worse:\r\n\r\n - Requiring the application to explicitly create a message context if it wants to identify the message that caused a send errors event or was the original request of a reply.\r\n - Having a return value that is often ignored and causes a lot of warnings in several implementations.",
      "createdAt": "2019-07-04T08:34:20Z",
      "updatedAt": "2019-08-20T22:34:53Z",
      "closedAt": "2019-08-20T22:34:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As stated in the PR, I'd prefer to see `Send()` not return any value. If you want to be able to look up information about a context, send an explicit context.\r\n\r\nThe point about receiving send errors is interesting\u2014and I'd argue that the messageContext is *not* what you want to associate errors with. When you're sending partial messages, you have one MessageContext across multiple send operations. The first 10 sends on a message context can succeed, and then the eleventh can fail. The error should be associated with the call to `Send()`, not the context. I'm not sure how our pseudocode handles this, but it would effectively be a completion or promise in specific languages.",
          "createdAt": "2019-07-08T16:31:53Z",
          "updatedAt": "2019-07-08T16:31:53Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The mapping between sends and error events is indeed complicated and worth an issue on its own:\r\n - Multiple partial sends can easily end up in the same packet \u2013 resulting in a single Fail event for a dozen partial sends\r\n - A singe message context can represent many partial sends \r\n - A singe message context can represent many packets\r\n - With message coalescation, even a single packet can be associated with a dozen message contexts (think: QUIC with stream as a message, small requests)\r\n\r\nI still think returning a message context on error events is the right thing to do, but mapping it to the message context passed to send will, indeed, be much more complicated.",
          "createdAt": "2019-07-09T11:23:54Z",
          "updatedAt": "2019-07-09T11:23:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It multiple `Send` calls happen to be sent in a single packet (say a UDP packet), and this hits an error (which for most protocols like TCP doesn't make sense, but you could have an ICMP error for UDP), *each* `Send` call should have its own error. The fact that the transport laid out the bytes in a certain way is an implementation detail. There should be a dozen fail events for a dozen failed sends.\r\n\r\nI don't think in general a \"packet\" really has anything to do with the API surface for sending here, and that's a distraction to the API contract.",
          "createdAt": "2019-07-09T15:26:07Z",
          "updatedAt": "2019-07-09T15:26:07Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the notion of \"packet\" does not belong into the API, but thinking about packetization is necessary to understand all error cases.\r\n\r\nI am not really convinced that we can and should really match all sends with errors: Let's consider the following (extreme) case: \r\nAn application uses partial sends to send a fairly large amount of data byte wise and that data gets transported over TCP. Nagel will coalesce the data into larger packets. Now consider we have a few hundred kilobytes in the send buffer, when a TCP RST for the connection arrives. \r\nWhat should happen?\r\n - Send a single connection error\r\n - Send a single send error indicating the state of the stream\r\n - Send a few hundred thousand send errors for all bytes in the send buffer\r\n - Send a few hundred thousand send errors for all bytes that are not acknowledged",
          "createdAt": "2019-07-10T08:28:06Z",
          "updatedAt": "2019-07-10T08:28:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please see section 7.3.1:\r\n\r\n```\r\nThe Sent Event occurs when a previous Send Action has completed, i.e., when the data derived from the Message has been passed down or through the underlying Protocol Stack and is no longer the responsibility of this interface. The exact disposition of the Message (i.e., whether it has actually been transmitted, moved into a buffer on the network interface, moved into a kernel buffer, and so on) when the Sent Event occurs is implementation-specific.\r\n```\r\n\r\nThat means that any Send operation that has successfully enqueued its data into the send buffer will have received a Sent event. Acknowledgement is *not* an event delivered to the application.\r\n\r\nIn the case you gave, the following will happen upon a RST, as always should happen upon a RST:\r\n\r\n- The connection will report a ConnectionError event with something like ECONNRESET, in *addition* to:\r\n- Every outstanding Send operation that was not yet able to enqueue its data in the TCP send buffer due to backpressure will generate a unique SendError event, with something like ECONNRESET or ENOTCONN.\r\n\r\nAll other Send operations that did enqueue data would have already delivered the Sent event, and are no longer relevant for delivering errors.",
          "createdAt": "2019-07-10T15:27:51Z",
          "updatedAt": "2019-07-10T15:27:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Decided in Montr\u00e9al: no, send() should not return a MessageContext, it should be passed one.",
          "createdAt": "2019-07-22T19:14:43Z",
          "updatedAt": "2019-07-22T19:14:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think \"it must always be passed one\" was the agreed outcome, right?",
          "createdAt": "2019-07-22T19:19:37Z",
          "updatedAt": "2019-07-22T19:19:37Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I'm in favor of each Send must have either exactly one Sent Event or a SendError event. We didn't confirm consensus though.",
          "createdAt": "2019-07-22T19:21:02Z",
          "updatedAt": "2019-07-22T19:21:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rollback. I meant something else, and just created unnecessary confusion, I'm afraid.\r\n\r\n1) I think you said that send() \"must always be passed a MessageContext\", but it's in fact an optional parameter and should probably stay one.\r\n\r\n2) about \"each Send must have exactly one Sent Event or a SendError event\", this is a different question... I think I agree with Colin here, who suggested that this should be left up to implementations to decide. (and he said that the current text would even allow for that)",
          "createdAt": "2019-07-22T19:26:51Z",
          "updatedAt": "2019-07-22T19:26:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in Montr\u00e9al: there is a 1:1 relationship between Send() and Sent<>. Text needs to be clear on this.",
          "createdAt": "2019-07-24T20:17:29Z",
          "updatedAt": "2019-07-24T20:17:29Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed with 46ec43cb3c04d2d3a859edb1efa5212a99bfe8a3",
          "createdAt": "2019-08-20T22:34:16Z",
          "updatedAt": "2019-08-20T22:34:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Accidentally pushed this to master instead of to a PR branch\u2014pretty small diff. If you want to change something there, let me know!)",
          "createdAt": "2019-08-20T22:34:53Z",
          "updatedAt": "2019-08-20T22:34:53Z"
        }
      ]
    },
    {
      "number": 337,
      "id": "MDU6SXNzdWU0NjQ5MDQyODM=",
      "title": "Update implementation mapping text for SCTP",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/337",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "We've updated Implementation mapping details for most protocols with #333, but we didn't tackle SCTP yet.",
      "createdAt": "2019-07-07T01:16:50Z",
      "updatedAt": "2019-10-22T21:02:59Z",
      "closedAt": "2019-10-22T21:02:59Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine with this being assigned to me. However, it's more than just writing the SCTP text. Here's the relevant part of what I wrote in PR #333:\r\n\r\n>  we should describe things focusing on the transport's API call to be made (in line with the spec - that's why we have RFCs 8303 and 8304) rather than protocol internals. E.g., rather than saying that Abort on a TCP connection transmits a RST, I think we should simply say that Abort calls ABORT.TCP [RFC 8303, Section 4.1].\r\n> I can take care of these things, later. I'd still like to focus more on the API doc at this time.\r\n\r\nI don't suggest to delete much of the text that's there but definitely amend it with the RFC reference at least for what's covered in RFC 8303. There's a very direct line from this type of text in RFC 8303 to the original specs, so I do believe that should be helpful.\r\n\r\nThat's (obviously) post-Montreal though!",
          "createdAt": "2019-07-07T08:33:56Z",
          "updatedAt": "2019-07-07T08:34:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl: please send a PR along these lines.",
          "createdAt": "2019-07-24T20:13:25Z",
          "updatedAt": "2019-07-24T20:13:25Z"
        }
      ]
    },
    {
      "number": 338,
      "id": "MDU6SXNzdWU0NjQ5MDQ1OTU=",
      "title": "Listen filtering behavior for TLS connections?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/338",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "future work",
        "mappings"
      ],
      "body": "As I was updating text for #333, I noticed that the Listener object delivers connections, but doesn't provide a particular way to reject connections. Based on existing text, I assume that ReceivedConnection delivers a connection once the TLS server handshake is complete. Some implementation may want to rate limit, or modify/block inbound connections. \r\n\r\nShould we have some event that lets applications handle inbound connections before they are ready?\r\n\r\nOf course, for TLS, we can rely on callback handlers set for the handshake, but that requires each protocol to do this potentially.",
      "createdAt": "2019-07-07T01:22:31Z",
      "updatedAt": "2020-06-19T16:55:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram mentioned that post-sockets had a notion of an event for pre-accept to be able to reject connections, maybe at multiple levels?",
          "createdAt": "2019-07-22T18:56:44Z",
          "updatedAt": "2019-07-22T18:56:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed in Montr\u00e9al:\r\n\r\n1. #343 covers the backpressure case.\r\n2. Each protocol in the stack at listen time may want to ask the application whether or not an incoming request should be allowed to continue. As far as we know, most of the applications that care about rejecting connections before a TLS handshake will do this outside the application.",
          "createdAt": "2019-07-24T20:12:38Z",
          "updatedAt": "2019-07-24T20:12:38Z"
        }
      ]
    },
    {
      "number": 339,
      "id": "MDU6SXNzdWU0NjUxNzI5OTk=",
      "title": "Add text about connection coalescing and connection pooling",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/339",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "This is a follow-up issue for #266 \u2013 As we have the ready to support connection coalescing and connection pooling, we have to describe it more closely in the Implementation.",
      "createdAt": "2019-07-08T10:15:37Z",
      "updatedAt": "2019-11-04T18:20:49Z",
      "closedAt": "2019-11-04T18:20:49Z",
      "comments": []
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWU0Njc4ODQ1NzE=",
      "title": "Comments on new framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/340",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "Just some points about the new text on framers in the API draft:\r\n\r\n- In 10.2 it is specified in which order multiple framers run on incoming and outgoing messages, it is however never specified what the order looks like on Start and Stop events.\r\n- In 10.6, \"MessageFramer.DeliverAndAdvanceReceiveCursor\" appears to be missing the \"Data\" argument that is present in \"MessageFramer.Deliver\".\r\n- Also in 10.6, in the second paragraph it says:\r\n> The application requests a specific amount of data it needs to have available in order to parse. \r\n\r\nWhen it is probably meant to say \r\n\r\n> The framer implementation requests a specific amount of data it needs to have available in order to parse. \r\n\r\n- While the framer implementation is able to notify the Connection that it has finished handling a Start event (by calling MessageFramer.MakeConnectionReady), there is no such way for Stop events.\r\n\r\n\r\n",
      "createdAt": "2019-07-14T21:05:52Z",
      "updatedAt": "2020-01-03T00:02:58Z",
      "closedAt": "2020-01-03T00:02:58Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As notes for the responses to these points:\r\n\r\n- If there are multiple framers, the \"lowest\" one (the one closest to the transport) would receive start first, and the next would get the start event when the lower one is ready. Similar for stop.\r\n- Good calls on the missing data argument and the typo re application vs framer.\r\n- I was thinking to use the failConnection call to complete a stop, potentially with no error? ",
          "createdAt": "2019-07-16T23:33:05Z",
          "updatedAt": "2019-07-16T23:33:05Z"
        }
      ]
    },
    {
      "number": 341,
      "id": "MDU6SXNzdWU0NzA3OTg3MzA=",
      "title": "Make InitiateError more generic",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/341",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [
        "API"
      ],
      "body": "The current reasons for an InitiateError to occur exclude several configurations that should result in one, e.g. the localAddress being a group address but the selected direction of communication being bidirectional. ",
      "createdAt": "2019-07-21T16:19:49Z",
      "updatedAt": "2019-11-01T16:54:33Z",
      "closedAt": "2019-11-01T16:54:33Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Base this on #342, add a reason for \"no candidate available\"",
          "createdAt": "2019-07-24T20:04:13Z",
          "updatedAt": "2019-07-24T20:04:13Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWU0NzA3OTkwMTE=",
      "title": "Allow error events to include reason",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/342",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [
        "API"
      ],
      "body": "Error events should be able to hand the application a reason that further details the circumstances of the error event being fired. This should be optional and doesn't have to be portable but an implementation should provide an enumerated list of all the possible reasons.",
      "createdAt": "2019-07-21T16:22:42Z",
      "updatedAt": "2019-11-08T11:34:33Z",
      "closedAt": "2019-11-08T11:34:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to be clear, you mean \"...but an application should be provided with an enumerated list of ...\", right?",
          "createdAt": "2019-07-21T18:54:00Z",
          "updatedAt": "2019-07-21T18:54:00Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes sorry, the TAPS implementation should provide a list of enumerated reasons for errors.",
          "createdAt": "2019-07-21T18:59:09Z",
          "updatedAt": "2019-07-21T18:59:09Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No problem. That's an easy text fix, I think.",
          "createdAt": "2019-07-21T19:07:36Z",
          "updatedAt": "2019-07-21T19:07:36Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #351 ",
          "createdAt": "2019-11-08T11:34:30Z",
          "updatedAt": "2019-11-08T11:34:30Z"
        }
      ]
    },
    {
      "number": 343,
      "id": "MDU6SXNzdWU0NzEyNjAyODk=",
      "title": "Listeners should have backpressure",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/343",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "There should be a way to put back pressure or limits on the number of inbound connections for a listener. The two approaches are:\r\n\r\n1. To have a one-to-one callback for listen -> received connect\r\n2. To have a way to set a numeric limit of new inbound connections\r\n\r\nMy preference is (2). (1) has an issue of being very impractical for servers that don't know how many connections they'll receive, and may require them to call `listen` a thousand times without any other activity. (2) is more similar to how calling `listen()` on sockets work.",
      "createdAt": "2019-07-22T18:59:52Z",
      "updatedAt": "2019-10-21T14:12:13Z",
      "closedAt": "2019-10-21T14:12:12Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on variant 2 - indeed it's common and known to people from sockets, and just seems like the easier and more efficient solution (albeit maybe less \"beautiful\", in a way).",
          "createdAt": "2019-07-22T19:09:50Z",
          "updatedAt": "2019-07-22T19:09:50Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on variant 2 as well.",
          "createdAt": "2019-07-22T23:23:04Z",
          "updatedAt": "2019-07-22T23:23:04Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do variant 2.",
          "createdAt": "2019-07-24T19:59:07Z",
          "updatedAt": "2019-07-24T19:59:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe that PR #350 fully addresses this; hence I'm closing it.",
          "createdAt": "2019-10-21T14:12:12Z",
          "updatedAt": "2019-10-21T14:12:12Z"
        }
      ]
    },
    {
      "number": 344,
      "id": "MDU6SXNzdWU0NzEzNjEzNzc=",
      "title": "Framers: Move parts to Implementation draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/344",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "As discussed at the IETF 105 TAPS session:\r\n\r\nI suggest defining framers as a set of functions that transforms messages into byte streams and vice versa (quite similar to what we have now, but replace \"piece of code\" with \"set of functions\"). And then we have to find words for the \"Framers can also do a bit more negotiation, handshake, etc\".\r\n\r\nAlso, I suggest keeping the following in the API draft:\r\n\r\n- how to add a Framer to a Preconnection\r\n- what functionality a Framer can implement\r\n- how an application can interact with framer metadata through the Message Context\r\n\r\nThe rest I suggest to move to the Implementation draft, e.g., the \"How can a Framer be implemented\". It's an example, but Framers can also be implemented in different ways.\r\n\r\nI'm willing to contribute text if needed.",
      "createdAt": "2019-07-22T22:08:51Z",
      "updatedAt": "2019-11-11T22:48:45Z",
      "closedAt": "2019-11-11T22:48:45Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done with #359!",
          "createdAt": "2019-11-11T22:48:45Z",
          "updatedAt": "2019-11-11T22:48:45Z"
        }
      ]
    },
    {
      "number": 347,
      "id": "MDU6SXNzdWU0NzM0NTExMTg=",
      "title": "\"Events\" versus \"Callbacks\" for security-relevant asynchrony",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/347",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "Architecture",
        "ready for text"
      ],
      "body": "The TAPS architecture uses Events for all asynchronous happenings, except the trust and challenge callbacks. I think this is the right way to do things but I'm not sure because the callbacks are slightly underspecified at the moment -- callbacks are distinct from events because events are fire-and-forget from the TAPS system's PoV, while callbacks might fail (and the system and transport stacks react to that failure).\r\n\r\nThis raises a few questions:\r\n\r\n1. Should we more explicitly specify callbacks in \u00a75.3.2? (I think yes)\r\n2. Should we add the concept of callbacks to the architecture? (I'm not sure, maybe?)\r\n3. Should we generalize events instead to allow them to have a boolean return? (I think no)\r\n",
      "createdAt": "2019-07-26T16:59:21Z",
      "updatedAt": "2019-11-21T04:32:35Z",
      "closedAt": "2019-11-21T04:32:35Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it is a good idea to keep them separate and specifying them more explicitly. \r\nWe should also give the documents a pass with that differentiation in mind, for example in Sec. 2 of the API it says that callbacks are a possible way to implement events.",
          "createdAt": "2019-07-26T18:36:36Z",
          "updatedAt": "2019-07-26T18:36:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. Yes, we should specify callbacks in the API document\r\n2. No, I don't think the architecture needs a formal callback definition specifically BUT it should be updated to remove callbacks from the list of events, and just say that the API lets the application know when certain actions are completed.\r\n3. I'm not clear on the boolean return here... in general, I don't think the events need to be generalized?",
          "createdAt": "2019-07-26T20:52:00Z",
          "updatedAt": "2019-07-26T20:52:00Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"boolean return\" in terms of allowing the application to signal back that an event was not / could not be handled (which is the reason callbacks are separate).",
          "createdAt": "2019-07-31T23:28:16Z",
          "updatedAt": "2019-07-31T23:28:16Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we were very successful in normalising concepts and avoiding to add similar but slightly different things, I strongly prefer \"events\" over \"events+callbacks\".\r\n\r\nInstead of a boolean return, I prefer either saying these events may use a specific abort mechanism or need to acknowledge the passed values (and leave it to the implementation whether acknowledge means retuning a boolean, calling a function, writing to a channel or not throwing an exception).",
          "createdAt": "2019-08-01T18:02:08Z",
          "updatedAt": "2019-08-01T18:02:08Z"
        }
      ]
    },
    {
      "number": 348,
      "id": "MDU6SXNzdWU0NzM0NTkzMDM=",
      "title": "Nits on framers in arch-draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/348",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "Some points:\r\n\r\n- Figure 2 in section 1.1 maybe should include framers\r\n- In section 1.3 it says \"framing protocols\", just \"framers\" might be more consistent wording\r\n- At this point, Framers are probably more than just a \"message translation layer\" as mentioned in section 4.1.4",
      "createdAt": "2019-07-26T17:23:33Z",
      "updatedAt": "2019-11-09T11:34:14Z",
      "closedAt": "2019-11-09T11:34:14Z",
      "comments": []
    },
    {
      "number": 356,
      "id": "MDU6SXNzdWU1MDk4ODU4Nzc=",
      "title": "Fix \"Implementing maintenance\" section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/356",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "help wanted"
      ],
      "body": "In line with the API draft, this section should now probably be called \"Implementing Connection Management\", and it should avoid protocol-specific text. Making this more confusing, there's currently a \"Managing connections\" subsection there, which is full of protocol-specific references to RFC 8303 and TODO's - very very old text from me.\r\n\r\nI think that this should all be removed, and replaced with something more appropriate. I don't have a very good idea about the new text that should go in there though, which is why I'm opening this issue.\r\n\r\nThis relates to #248: maybe, at this point, if this is done, #248 is already fully addressed.",
      "createdAt": "2019-10-21T10:53:15Z",
      "updatedAt": "2019-10-28T09:36:59Z",
      "closedAt": "2019-10-28T01:08:36Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed this up with 1ac1e18. I retitled several of the sections, and made the text in connection management explain how to handle setting properties, and passing along errors. Let me know if you think this satisfies things, @mwelzl!",
          "createdAt": "2019-10-28T01:08:36Z",
          "updatedAt": "2019-10-28T01:08:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I see I'm too late - but, FWIW, I'm fine with it   :-)   thanks a lot for doing this!",
          "createdAt": "2019-10-28T09:36:59Z",
          "updatedAt": "2019-10-28T09:36:59Z"
        }
      ]
    },
    {
      "number": 357,
      "id": "MDU6SXNzdWU1MTAwMTk2OTQ=",
      "title": "Default values",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/357",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram",
        "mwelzl"
      ],
      "labels": [
        "API",
        "discuss",
        "ready for text"
      ],
      "body": "@gorryfair wrote, in now-closed issue #317:\r\n\"Could we also try to start a discussion about the set of default values in a seprate thread. I think we can address some of these quickly, albeit we wait for the list discussion (or wider consensus) on whether they are SHOULD or MUST.\"\r\n\r\nSo here I'm starting that thread, with a list of all the defaults that I found in the API draft. For the record, *I* (FWIW) agree with all of these choices.\r\n\r\n\r\nPre-establishment Transport Properties:\r\n---------------------------------------\r\n5.2.1 Reliable Data Transfer. Default Require Reliable Data Transfer\r\n5.2.2 Preservation of Message Boundaries. Default Prefer Preservation of Message Boundaries\r\n5.2.3 Configure Per-Message Reliability. Default Ignore\r\n5.2.4 Preservation of Data Ordering. Default Require Preservation of data ordering\r\n5.2.5 Use 0-RTT Session Establishment with an Idempotent Message. Default Ignore\r\n5.2.6 Multistream Connections in Group. Default Prefer\r\n5.2.7 Full Checksum Coverage on Sending. Default Require\r\n5.2.8 Full Checksum Coverage on Receiving. Default Require\r\n5.2.9 Congestion control. Default Require that the Connection is congestion controlled.\r\n5.2.12 Parallel Use of Multiple Paths. Default Prefer\r\n5.2.13 Direction of communication. Default Bidirectional\r\n5.2.14 Notification of excessive retransmissions. Default Ignore\r\n5.2.15 Notification of ICMP soft error message arrival. Default Ignore\r\n\r\nMessage Properties:\r\n-------------------\r\n7.4.1 Lifetime. Default infinite\r\n7.4.2 Priority. Default 100\r\n7.4.3 Ordered. Default true\r\n7.4.4 Idempotent. Default false\r\n7.4.5 Final. Default false\r\n7.4.6 Corruption Protection Length. Default full coverage\r\n7.4.7 Reliable Data Transfer (Message). Default true\r\n7.4.8 Message Capacity Profile Override. Default: \"No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when sending this message.\"\r\n7.4.9 Singular Transmission. Default false\r\n7.5 Partial Sends. Default true\r\n\r\nGeneric Connection Properties:\r\n------------------------------\r\n11.1.1 Retransmission Threshold Before Excessive Retransmission Notification. Default -1, and text says \"The special value -1 means that this notification is disabled.\"\r\n11.1.2 Required Minimum Corruption Protection Coverage for Receiving. Default -1, and text says \"the special value -1 indicates full checksum coverage.\"\r\n11.1.3 Priority (Connection). Default 100\r\n11.1.4 Timeout for Aborting Connection. Default -1, and text says \"The special value -1 means that this timeout is not scheduled to happen.\"\r\n11.1.5 Connection Group Transmission Scheduler. Default Weighted Fair Queueing (see Section 3.6 in RFC8260).\r\n11.1.10 Capacity Profile. Default: \"The application makes no representation about its expected capacity profile. No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when selecting and configuring transport protocol stacks. Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign the DSCP Default Forwarding [RFC2474] PHB; when the Connection is multiplexed, the guidelines in Section 6 of [RFC7657] apply.\"\r\n11.1.11 Bounds on Send or Receive Rate. Default -1 / -1 (unlimited, for both values)\r\n11.1.12 TCP-specific Property: User Timeout.\r\n  - Advertised User Timeout: default: the TCP default to be advertised via the UTO for the TCP at the remote endpoint to adapt its own \"Timeout for aborting Connection\" (see Section 11.1.4) value accordingly.\r\n  - User Timeout Enabled. Default false  (controls whether UTO is used)\r\n  - Changeable: Default true  (this controls whether incoming UTO can take effect)\r\nAll the parameters are optional, and when they are not specified, the TCP default will be used.\r\n\r\n\r\nExperimental Transport Properties:\r\n----------------------------------\r\nB.1.1 Cost Preferences. Default \"Balance Cost\"\r\n\r\n\r\nSome other things:\r\n------------------\r\n6.2 Listen, about SetNewConnectionLimit(value): \"By default, this value is Infinite\"\r\n7 Sending data: \"By default, Send enqueues a complete Message, and takes optional per-Message properties (see Section 7.1).\"\r\n8.1 Enqueuing Receives. By default, Receive will try to deliver complete Messages in a single event (Section 8.2.1).\r\nminIncompleteLength parameter: default infinite\r\nmaxLength parameter: default infinite",
      "createdAt": "2019-10-21T14:54:03Z",
      "updatedAt": "2019-11-19T08:40:25Z",
      "closedAt": "2019-11-19T08:40:13Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I didn't check in detail, but I read this and only one thing appears unexpected, so that's good!\r\n\r\nThe odd one for me is:\r\n5.2.12 Parallel Use of Multiple Paths. Default Prefer\r\n- That's fine if I have two upstream prefixes to route over, but less obviously robust if I have different radio interfaces on different paths - where variability could be a real issue. The conservative option is not to prefer robustness over Multiple Paths.  (I was thinking that SCTP has failover rather than CMT as the default).\r\n\r\nI think I also disagree with the text in 5.2.12 that states: \"in most cases, this will improve performance (e.g., achieve greater throughput)\" - or at least regard in \"most cases\" as being unhelpful generalisation without warning that this can increase brittleness, and increase variability. Maybe I'm surprised this category covers both 'failover' - which does increase robustness and reduce variability; and 'parallel use' - which tends to target opportunistic performance.\r\n",
          "createdAt": "2019-11-02T08:25:16Z",
          "updatedAt": "2019-11-02T08:25:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Default ignore.",
          "createdAt": "2019-11-19T08:40:13Z",
          "updatedAt": "2019-11-19T08:40:13Z"
        }
      ]
    },
    {
      "number": 362,
      "id": "MDU6SXNzdWU1MjQ4NjQyMjU=",
      "title": "-impl should say more about use of ALPN",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/362",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "future work"
      ],
      "body": "",
      "createdAt": "2019-11-19T08:57:05Z",
      "updatedAt": "2020-04-15T18:53:17Z",
      "closedAt": "2020-04-15T18:53:17Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe I'm the only person who hasn't been following this, but could you provide a reference, please?\r\nEven saying which IETF 106 session this was discussed in would help.\r\nThanks!",
          "createdAt": "2019-11-19T10:22:09Z",
          "updatedAt": "2019-11-19T10:22:09Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ALPN discussion took place in QUIC on Tuesday. The basic question was  is an ALPN defining the \"next\" protocol or the whole protocol stack. so is it \"h3\" or \"h3q1\".\r\n\r\nDepending on how this discussion goes on, we really have to think whether ALPN is mostly derived (otherwise manually set as a tls-specific transport property) or becomes part of the endpoint.",
          "createdAt": "2019-11-20T06:53:08Z",
          "updatedAt": "2019-11-20T06:53:08Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I heard. That sounds like we should avoid toon much text on this topic in these IDs.",
          "createdAt": "2019-11-20T06:59:39Z",
          "updatedAt": "2019-11-20T06:59:39Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree not to add too much shaky stuff to our drafts.\r\nSo... should we or should we not?",
          "createdAt": "2020-04-15T12:07:29Z",
          "updatedAt": "2020-04-15T12:07:29Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe tag it as future work and close it?",
          "createdAt": "2020-04-15T13:09:22Z",
          "updatedAt": "2020-04-15T13:09:22Z"
        }
      ]
    },
    {
      "number": 363,
      "id": "MDU6SXNzdWU1MjQ4NzczOTM=",
      "title": "\"Access to Specialized Features\" example: Security protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/363",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "The architecture draft has a few parts where it needs to be aligned with how we handle security protocols now.\r\n\r\nOne such part is Section 3.2, \"Access to Specialized Features\". Right now it says:\r\n\r\n\"Other specialized features, however, could be strictly required by an\r\n   application and thus constrain the set of protocols that can be used.\r\n   For example, if an application requires encryption of its transport\r\n   data, only protocol stacks that include a transport security function\r\n   are eligible to be used.\"\r\n\r\nTo me, this sounds like an application could just request \"Encryption: Require\" and then any security protocol that provides this function could be used. That's not how we think about security protocols anymore. So we need to change that example.\r\n\r\nI haven't really found another example for a \"specialized feature\" that might be required - \"specialized feature\" apparently means \"feature not in minset\" - so I suggest we stick with the security example, but change the wording.\r\n\r\nFor example, we could just say, \"For example, if an application requires encryption of its transport data, it could select a specific security protocol. In this case, only protocol stacks that include this security protocol are eligible to be used.\"\r\n\r\nHowever, then it's not strictly a feature anymore... right? What do the authors think?",
      "createdAt": "2019-11-19T09:21:30Z",
      "updatedAt": "2019-11-29T20:40:24Z",
      "closedAt": "2019-11-29T20:40:24Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "It sounds like a new example, unrelated to security, should be chosen for the text.",
          "createdAt": "2019-11-19T09:33:20Z",
          "updatedAt": "2019-11-19T09:34:27Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think we need a new example. Could a multuipath example do, requiring handover/failover support (or some suitable option available after resolving that issue).",
          "createdAt": "2019-11-19T23:27:24Z",
          "updatedAt": "2019-11-19T23:27:24Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I fear changing the example will not solve the overall problem. We really need to make a decision how we go ahead with the non-goal statement from the security draft.\r\n\r\nWays forward:\r\n - Automagic security is a non-goal for the security draft, but goal for the triplet (no text changes, but will hunt us on the next review)\r\n - Work around this limitation by adding profiles for tls/quic-v1 equivalent transports (must be profiles, as we decided explicit protocol selection is not part of the portable API)\r\n - Get rid of examples from the main text at all and move them to the Appendix as we can not provide relevant examples without using non-portable APIs",
          "createdAt": "2019-11-20T06:44:03Z",
          "updatedAt": "2019-11-20T06:44:03Z"
        }
      ]
    },
    {
      "number": 364,
      "id": "MDU6SXNzdWU1MjQ4ODcwMTc=",
      "title": "Update wording where interface to security protocol implies racing/abstraction",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/364",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "NONE",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Under \"Protocol Stack Equivalence\", for example, text like\r\n\r\n> Both stacks MUST offer the same security properties\r\n\r\nneeds to change to conform to the rework of the security document. This is related to #363.",
      "createdAt": "2019-11-19T09:38:14Z",
      "updatedAt": "2019-12-02T01:11:41Z",
      "closedAt": "2019-12-02T01:11:40Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think this is part of the \"protocol stack equivalence\" issue #305.\r\nAs #305 is assigned to me, I'll just self-assign this one and close both once this is done.",
          "createdAt": "2019-11-19T10:03:24Z",
          "updatedAt": "2019-11-19T10:03:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed by #389 ",
          "createdAt": "2019-12-02T01:11:40Z",
          "updatedAt": "2019-12-02T01:11:40Z"
        }
      ]
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWU1MjQ4OTg3ODA=",
      "title": "Architecture: Editorial comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/365",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "Having read -05, I have some more comments, mostly editorial.\r\n\r\nOpening an issue in case there's anything to discuss. Otherwise I might just do a PR against -arch if that's fine with the authors.\r\n\r\nIn Section 4.1.1:\r\n\"Event Handling (Section 4.1.5) defines the set of properties about which an application can receive notifications during the lifetime of transport objects.\"\r\nSet of properties? Section 4.1.5 do not refer to specific properties (as in: Transport Properties), but just lists what kinds of events exist. So I suggest changing text in Section 4.1.1 to say something like:\r\n\"Event Handling (Section 4.1.5) defines categories of notifications which an application can receive during the lifetime of transport objects.\"\r\n\r\nIn Section 4.1.4:\r\n\"When receiving Messages, Message Properties can contain per-protocol properties for properties that are sent between the endpoints.\"\r\nWhy is this constrained to properties that are sent between endpoints? Couldn't an implementation also set Message Properties that were not signaled? \r\nAlso, what does \"per-protocol\" mean here?\r\nAlso, too many \"properties\" in this sentence.\r\nI suggest changing this to something like:\r\n\"When receiving Messages, Message Properties can contain information about the received message, such as signalled by the other endpoint.\"\r\n\r\nStill Section 4.1.4:\r\n\"The status of the Send operation can be delivered back to the sending application in an event\"\r\nCan be? I thought this always happens? \r\nThe API draft in Section 7.3 says that for each Send(), the application gets exactly one event? So I think here this should be phrased as \"is delivered\" or even MUST.\r\n\r\nSection 4.1.5:\r\n\"This section provides the top-level categories of events events that can be delivered to an application.\"\r\nTop-level categories? Are there more levels of categories? Maybe just say \"categories\"?\r\nAlso, duplicate word: \"events events\".\r\n\r\nSection 4.2.1:\r\n\"Protocol Selection: [\u2026] choosing one or more sets of protocol options\"\r\nI don't think protocol options is the right word. Isn't this about racing protocol stacks? Below we use \"protocol options\" to mean something else, so here we should just say \"choosing between multiple protocol stacks\".\r\n\r\n\"separate DNS resolution stepss\" (typo)\r\n\r\nSection 6:\r\n\"Clients need to ensure that security APIs are used appropriately.\"\r\nWho or what is a client? An application? Or the transport system itself? I think it's an application. \"Clients\" is not used elsewhere in the text. So this section should replace \"clients\" with \"applications\".",
      "createdAt": "2019-11-19T09:58:08Z",
      "updatedAt": "2019-11-22T01:11:55Z",
      "closedAt": "2019-11-22T01:11:55Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All suggestions here are good, please send a PR. I'd rephrase the following:\r\n\r\n\"When receiving Messages, Message Properties can contain information about the received message, such as signalled by the other endpoint.\"\r\n\r\nto \r\n\r\n\"When receiving Messages, Message Properties can contain information about the received message, such as metadata generated at the receiver and information signalled by the remote endpoint\"\r\n\r\n(\"such as\" needs a noun, and I'd like to be more explicit here)\r\n",
          "createdAt": "2019-11-20T02:27:57Z",
          "updatedAt": "2019-11-20T02:27:57Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "MDU6SXNzdWU1MjQ5MDA1Mzc=",
      "title": "Some editorial (I hope) comments on implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/366",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "I did not manage to review it all, but I did read much of the ID, and have minor corrections-mainly comments below\r\n\r\n/such as mobile client/\r\n- as\r\n/e.g., a mobile client/\r\n---\r\n/Like with derived endpoints/\r\nas\r\n/Similar to a derived endpoint/\r\n---\r\n/Protocol options are checked next in order./\r\nas\r\n/Protocol options are next checked in order./\r\n---\r\nWhys is there no section on immediate - it would be more complete and also the subsection no. would match the list of items in sect 4.4.\r\n---\r\n\r\nSect:Derived Endpoints\r\n----\r\n/The connection library should order the derived endpoints/\r\n- what does /should/ mean here? - I thought the next stage took an ordered list (highest preference first), so I'd expect it does order? and it would seem hugely sensible to put most preferred first, aka RFC8305.\r\n---\r\n/ as a branch which can be attempted independently from other hostnames. Each of these hostnames may also resolve to one or more addresses, thus creating multiple layers of branching./\r\n- In above change /which/that/\r\n- In above /may also resolve... thus creating/ ... I can see this /might resolve to one or more addresses, that would create/\r\n... but I could also read multiple other ways to view the sentence.\r\n---\r\n/connection over either interface. /\r\n- why 2? - should this be:\r\n/ connection over any interface. /\r\n---\r\n/A single connection may be allowed to use an HTTP-based proxy, a SOCKS-based proxy, or connect directly. /\r\n- what does /may be allowed to use / actually mean?\r\n- is it allowed to use, or if not, what controls whether it is or not?\r\n---\r\n/that may provide preferable characteristics when available. /\r\n- could this be:\r\n/that, when available, could provide preferable characteristics./\r\n- is it /characteristics/, did the WG previously call these features?\r\n---\r\n/Implementations that support racing protocols and protocol options should maintain a history of which protocols and protocol options successfully established, on a per-network basis /\r\n- is it only on a per-network; could it be also per-endpoint.\r\n---\r\n/ since usable DNS results on one network may not necessarily be the same as DNS results on another network due to local network entities, supported address families, or enterprise network configurations. /\r\n- Personally, I'd go further than /may not necessarily be/ towards /there are situations when the results will be different/?\r\n---\r\nI could be overly sensitive, but didn't like:\r\n/has cached the information that SCTP is not available on the path over WiFi,/\r\n- can this be:\r\n/has current cache information that SCTP is not available on the path over WiFi,/\r\n- I wanted to avoid the impression this was something in any way permanent.\r\n---\r\nSorting branches:\r\n/ in order of their preference rank/\r\n- increasing or decreasing preference?\r\n---\r\n/Implementations should process properties in the following order: Prohibit, Require, Prefer, Avoid. /\r\n- the words should process... seem to chime wrongly to me\r\n- why wouldn't they?\r\n- can we just remove /should/ or explain what we are saying if that isn't it?\r\n... there are several \"should\" words in the rest of the para, and it seems to me that it would be more beautiful had we avoided that word, or explained why there were cases why not?\r\n---\r\n- I got a little muddled with:\r\n/ While the tree described above is a useful conceptual and\r\n   architectural model, an implementation does not know what the full\r\n   tree may become up front, nor will many of the possible branches be\r\n   used in the common case./\r\n- is this clearer as:\r\n/  The tree described above is a useful conceptual and\r\n   architectural model. However, an implementation is unable to know the full\r\n   tree before it is formed and many of the possible branches ultimately    \r\n   might not be commonly used./\r\n---\r\n/ It is useful to process success and failure throughout the tree by\r\n   child nodes reporting to their parent nodes (towards the trunk of the\r\n   tree). /\r\n- Did not parse well to me.\r\n---\r\n/New connection attempts that involve transmitting\r\n   data on the network should not be started after another leaf node has\r\n   completed successfully, as the connection as a whole has been\r\n   established. /\r\n- the /as/ read poorly to me:\r\n  /New connection attempts that involve transmitting\r\n   data on the network ought not to be started after another leaf node has\r\n   already successfully completed, because the connection as a whole \r\n   has now been established. /\r\n---\r\n/Similarly, an implementation may choose to hold\r\n   onto fully established leaf nodes that were not the first to\r\n   establish for use as part of a Pooled Connection, see Section 7.1, or\r\n   in future connections./\r\n-  what does hold on to mean, and /that were not the first to\r\n   establish for use as part of a Pooled Connection/ was unclear.\r\n---\r\n/In both cases, keeping additional connections\r\n   is generally not recommended since those attempts were slower to\r\n   connect and may exhibit less desirable properties./\r\n- maybe better as:\r\n/In both cases, it is not generally not recommended to\r\n   keep additional connections, because those attempts were slower to\r\n   connect and may exhibit less desirable properties./\r\n- but even now I don't understand, which connections are we speaking about? \r\n---\r\n/In the case\r\n   that the application signals that the initial Protocol Stack is\r\n   failing for some reason and that another option should be attempted,\r\n   the Connection can be updated to point to the next candidate Protocol\r\n   Stack.  This can be viewed as an application-driven form of Protocol\r\n   Stack racing./\r\n- I think I could understand, ... but actually unsure really what this is about.\r\n----\r\nI think this may be OK:\r\n/   If the Selection Properties allow multiple protocols to be used for\r\n   listening, and the implementation supports it, the Listener object\r\n   should register across the eligble protocols for each path.  This\r\n   means that inbound Connections delivered by the implementation may\r\n   have heterogeneous protocol stacks./\r\n- however, I don't fully understand this text.\r\n---\r\n/These map well into Connection objects./\r\n- /map well/ or /map/ or do I miss something?\r\n---\r\n/it limits the required checksum in protocols /\r\n- should be:\r\n/ it sets the minimum protection in protocols/\r\n---\r\n/Transmission Profile: TBD - because it's not final in the API yet./\r\n- NOT defined.",
      "createdAt": "2019-11-19T10:01:09Z",
      "updatedAt": "2020-05-29T15:11:06Z",
      "closedAt": "2020-05-29T15:11:06Z",
      "comments": []
    },
    {
      "number": 367,
      "id": "MDU6SXNzdWU1MjQ5MDE1MDI=",
      "title": "Implementation - PMTU text is broken",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/367",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "adventureloop",
        "gorryfair"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "This text is broken:\r\n\r\nsection 5.1\r\n/  o  Singular Transmission: when this is true, the application requests\r\n      to avoid transport-layer segmentation or network-layer\r\n      fragmentation.  Some transports implement network-layer\r\n      fragmentation avoidance (Path MTU Discovery) without exposing this\r\n      functionality to the application; in this case, only transport-\r\n      layer segmentation should be avoided, by fitting the message into\r\n      a single transport-layer segment or otherwise failing.  Otherwise,\r\n      network-layer fragmentation should be avoided--e.g. by requesting\r\n      the IP Don't Fragment bit to be set in case of UDP(-Lite) and IPv4\r\n      (SET_DF in [RFC8304]).\t/\r\n- we need to rewrite\r\n",
      "createdAt": "2019-11-19T10:02:50Z",
      "updatedAt": "2020-05-29T09:29:37Z",
      "closedAt": "2020-05-29T09:29:37Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Waiting to see exactly how DPLPMTUD finishes WGLC ... will be ready for text in Jan.",
          "createdAt": "2019-12-20T17:38:35Z",
          "updatedAt": "2019-12-20T17:38:35Z"
        }
      ]
    },
    {
      "number": 371,
      "id": "MDU6SXNzdWU1MjU2MTQxNjM=",
      "title": "Do we need an example for an HTTP/1, HTTP/2, HTTP/3 agnostic connection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/371",
      "state": "OPEN",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "This would go into the Appendix of -impl and uses non-portable functionality or a profile hiding it. ",
      "createdAt": "2019-11-20T07:00:07Z",
      "updatedAt": "2020-06-19T16:34:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why does this have the API label?",
          "createdAt": "2019-11-22T08:21:12Z",
          "updatedAt": "2019-11-22T08:21:12Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "MDU6SXNzdWU1MjYyNzc2ODc=",
      "title": "Transport Properties are not Connection Objects",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/373",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "In 4.1.1 Connection Objects we have Transport Properties as one of the bullets. But Transport Properties are not Connection Objects so this text does not really belong in this section. I suggest to move it to the next section on Pre-Esatblishment where we also describe Selection/Connection Properties or Change the name of Section 4.1.1.",
      "createdAt": "2019-11-20T23:38:09Z",
      "updatedAt": "2019-12-17T09:41:15Z",
      "closedAt": "2019-12-17T09:41:15Z",
      "comments": []
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWU1MjYyODI5MTU=",
      "title": "Protocols in Figure 2",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/374",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "I find the box Transport System Implementation with the \"(UDP, TCP, SCTP, DCCP, TLS, QUIC, etc)\" confusing in Figure 2. How should that be read? It looks like the Transport System Implementation is the protocols which I think is not the intent. In Figure 3 we have the Protocol Stacks as its own box which makes more sense I think. I am sure we discussed this figure before, but looking at it now it looks strange to me. ",
      "createdAt": "2019-11-20T23:55:14Z",
      "updatedAt": "2019-11-22T01:02:00Z",
      "closedAt": "2019-11-22T01:01:39Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We (group in Singapore) solved this by adding the word \"using\" in front of the protocols  :-)",
          "createdAt": "2019-11-22T01:01:30Z",
          "updatedAt": "2019-11-22T01:01:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added!",
          "createdAt": "2019-11-22T01:02:00Z",
          "updatedAt": "2019-11-22T01:02:00Z"
        }
      ]
    },
    {
      "number": 375,
      "id": "MDU6SXNzdWU1MjYzMTk4ODQ=",
      "title": "Multiple receives convenience feature",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/375",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "The basic API forces applications to individually queue each receive. This can seem unituitive and become annoying. \r\nI suggest the addition of a separate call to the convenience features section so we don't have to change the signature of the original receive call and keep the basic API minimal and not redundant.",
      "createdAt": "2019-11-21T02:05:50Z",
      "updatedAt": "2019-11-21T04:16:18Z",
      "closedAt": "2019-11-21T04:16:18Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or we just add a \"multiple\" parameter to the normal recv call, which would automatically imply that this would only be used to receive multiple messages of the same length, thereby making things simpler?",
          "createdAt": "2019-11-21T02:20:22Z",
          "updatedAt": "2019-11-21T02:20:22Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I had hoped we could also get something in that would just receive all incoming messages until some form of stop is called. \r\nBy adding a parameter for how many receives you want to queue you are not changing much about the (at least for me) core issue, which is that as of right now, you basically always just put another receive call into the handleReceived and handleReceivedPartial callbacks. \r\n\r\nI was thinking more along the lines of havig a startReceive(multiple?) Call that just automatically queues the reception of new messages until the optional multiple parameter is reached. If there is no multiple specified, it will just queue receives until the connection is closed. Then there would be stopReceive() which can be called at any time to stop the queueing of new receives. ",
          "createdAt": "2019-11-21T02:47:10Z",
          "updatedAt": "2019-11-21T02:47:10Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just add an optional parameter to the he recv call how many messages to receive, that can be infinity?",
          "createdAt": "2019-11-21T02:53:42Z",
          "updatedAt": "2019-11-21T02:53:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This mechanism is the way that we get backpressure. If you don't have this mechanism, you fundamentally lose flow control. I'm quite concerned about changing this.\r\n\r\nYou can certainly do a receiveMultipleMessages (with a max number of messages to receive in a batch), but that still needs an individual callback.",
          "createdAt": "2019-11-21T03:43:04Z",
          "updatedAt": "2019-11-21T03:43:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, and I'm already somewhat sorry for bringing this up. In fact these possible complications are what made me decide against opening the issue after all...   I guess people could just implement this on top of our single recv anyway if they wanted to?",
          "createdAt": "2019-11-21T04:00:02Z",
          "updatedAt": "2019-11-21T04:00:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a convenience feature. At this stage, adding them doesn't seem like the right thing to do.",
          "createdAt": "2019-11-21T04:16:18Z",
          "updatedAt": "2019-11-21T04:16:18Z"
        }
      ]
    },
    {
      "number": 382,
      "id": "MDU6SXNzdWU1MjY3NDEyNDM=",
      "title": "Multicast impact on architecture?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/382",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "We have the following in the architectire draft:\r\n\r\n> Connection Received: Signals to an application that a given Listener has passively received a Connection.\r\n\r\nShould we remove \"passively\" now that we are adding multicast? Or we go with the main use case?\r\n\r\n",
      "createdAt": "2019-11-21T17:34:28Z",
      "updatedAt": "2019-11-22T01:22:38Z",
      "closedAt": "2019-11-22T01:21:59Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's still technically passive. Perhaps you joined a group explicitly when you called Listen(), but the action of transmitting of packets that become a new connection object is still the responsibility of the initiator (the one sending multicast traffic)",
          "createdAt": "2019-11-21T23:27:27Z",
          "updatedAt": "2019-11-21T23:27:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in Singapore: while passively may be technically correct, it also adds no value. So we can remove it.",
          "createdAt": "2019-11-22T01:21:59Z",
          "updatedAt": "2019-11-22T01:21:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed",
          "createdAt": "2019-11-22T01:22:38Z",
          "updatedAt": "2019-11-22T01:22:38Z"
        }
      ]
    },
    {
      "number": 384,
      "id": "MDU6SXNzdWU1MjY5MzkwNTY=",
      "title": "Experimental cost property: cost preference",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/384",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "You've got to let me know: should this stay or should it go?\r\n\r\nI think it should go.",
      "createdAt": "2019-11-22T01:49:04Z",
      "updatedAt": "2019-11-22T03:59:01Z",
      "closedAt": "2019-11-22T03:59:01Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I like the idea as one direction for a future vision - but I don't like the idea of having this section in this document, and the think the annexe does not help.\r\n\r\nI propose we should now remove all appendix A, A.1, and A 1.1.1.\r\n\r\nGorry",
          "createdAt": "2019-11-22T02:14:00Z",
          "updatedAt": "2019-11-22T02:14:00Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer to let this stay (and move it into the main text) as it is something I got asked about whether it is in by application developers. It is there to avoid the abuse of interface type and feed into things like Apple's Low data mode.\r\n\r\n@tfpauly do do have opinion on that? How is this done in network framework? ",
          "createdAt": "2019-11-22T02:38:52Z",
          "updatedAt": "2019-11-22T02:38:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We definitely do this, but I don't think we should necessarily specify it here. Let that be another document, since I fear ratholing on this will hold up the document.",
          "createdAt": "2019-11-22T02:45:56Z",
          "updatedAt": "2019-11-22T02:45:56Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As this is the last advisable concept in the API that does not directly map to something in MINSET, lets' remove it and maybe start an extension with application intends once the documents are done.\r\n",
          "createdAt": "2019-11-22T03:21:36Z",
          "updatedAt": "2019-11-22T03:21:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll remove all of appendix A and push this directly to the master branch instead of making a PR. Not much to review.",
          "createdAt": "2019-11-22T03:57:53Z",
          "updatedAt": "2019-11-22T03:57:53Z"
        }
      ]
    },
    {
      "number": 385,
      "id": "MDU6SXNzdWU1Mjc2NTEyNjM=",
      "title": "Clarify that more flexible resolution is an architectural feature",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/385",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Especially in section 2, we should make it explicit that resolution is blended with connection establishment in a way that it is not in traditional sockets.",
      "createdAt": "2019-11-24T05:15:56Z",
      "updatedAt": "2019-11-29T20:41:58Z",
      "closedAt": "2019-11-29T20:41:58Z",
      "comments": []
    },
    {
      "number": 392,
      "id": "MDU6SXNzdWU1MzM3NzEzMDM=",
      "title": "A surprisingly few number of NiTS in Arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/392",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "I just read Arch and have the following NiTs which I think we should address:\r\n\r\n/Listeners by default register with multiple paths/\r\nought this to be:\r\n/Listeners, by default, register with multiple paths/\r\n\r\n/A Framer is a data translation layer that can be added to a Connection to define how application-level Messages are transmitted over a transport protocol. /\r\n- I think this should be (because I don\u2019t think they are protocol specific)  \r\n/A Framer is a data translation layer that can be added to a Connection to define how application-level Messages are transmitted over the transport service. /\r\n- \r\n/to retransmit in the event of packet loss,/\r\n- better to avoid event here :-)\r\n/to retransmit when there is packet loss,/\r\n",
      "createdAt": "2019-12-06T06:25:06Z",
      "updatedAt": "2019-12-20T16:07:11Z",
      "closedAt": "2019-12-20T16:07:11Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I am just gonna add a few more nits here:\r\n\r\n- The Listener object in figure 4 is a bit awkward, it appears as if the Listen() call appears out of thin air while per the API it gets called on the preconnection object like Initiate() and Rendezvous(). \r\n- In section 4.1.1, there are 5 references to section 4.1.2, is it really necessary to have that many?\r\n- Point 2 in section 4.2.3 only talks about required transport services, the same should probably be said about prohibited services, i.e. \"both protocol stacks MUST NOT offer transport services prohibited by the application\"",
          "createdAt": "2019-12-06T12:43:56Z",
          "updatedAt": "2019-12-06T12:49:39Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me add to this:\r\n - Section 1: print send() and recv() in fixed-with font [HTML/XML issue only] \r\n - Section 2 - Figure 1: socket() [with the brackets] looks odd in the figure title\r\n",
          "createdAt": "2019-12-17T10:11:12Z",
          "updatedAt": "2019-12-17T10:11:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I fear framers may be specific to the underlaying protocol, e.g., for SIP slicing messages out of TCP stream whereby doing nothing for SCTP and UDP ",
          "createdAt": "2019-12-17T10:15:06Z",
          "updatedAt": "2019-12-17T10:15:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "In relation to frames I think I only asked to add /service/ instead of protocol... I don't understand how Phil's comment reacts to that\r\n",
          "createdAt": "2019-12-17T14:20:41Z",
          "updatedAt": "2019-12-17T14:20:41Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I think protocol is correct here and would not change the sentence.",
          "createdAt": "2019-12-17T15:15:23Z",
          "updatedAt": "2019-12-17T15:15:23Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK - so I think you are saying the framer depends only on the specific next protocol, rather than upon the transport service that was offered? - It is still not clear to me that this is correct.",
          "createdAt": "2019-12-17T15:20:29Z",
          "updatedAt": "2019-12-17T15:20:29Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair that is a fairly good question\u2026 \r\n - The behaviour of the framer defiantly depends on the transport service provided (which may be a subset or superset of the transport service requested). \r\n - A framer needs to support all possible outcomes of the transport services requested\r\n - It may optimize based on the protocols it actually finds, e.g., turn into a no-op with the transport preserves message boundaries.\r\n - Whether the next protocol is a sufficient representation of this is unclear to me. Maybe not, if one thinks of supporting arbitrarily large messages and UDP over IPv6 with and without fragmentation\u2026",
          "createdAt": "2019-12-18T09:22:34Z",
          "updatedAt": "2019-12-18T09:22:34Z"
        }
      ]
    },
    {
      "number": 395,
      "id": "MDU6SXNzdWU1NDA1OTgwNjE=",
      "title": "Comments on -arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/395",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "Apologies for not organising these better -- this train journey is too short to subdivide before I arrive.\r\n\r\n- \u00a71, 1st para: \"imitated being the BSD socket() [POSIX] interface.\" ->\r\n  \"imitated being the Berkeley sockets interface [POSIX]\"\r\n- \u00a72.1, 1st para: discussion of async uses of sockets, immediately after\r\n  saying sockets provide a blocking sycnhronous interface, confuses. It\r\n  should maybe say \"When emulating an asynchronous interface using\r\n  sockets...\" rather than \"Wehn sockets are presented as an asynchronous\r\n  interface...\"?\r\n- \u00a72.1, 4th para: \"Using asynchronous events allows for a much simpler\r\n  interaction model when establishing connections and transferring data\".\r\n  This depends on the programming language, surely? For simple cases, if\r\n  you don't care about performance and advanced features, the synchronous\r\n  model is easier to use. Maybe \"...a more natural interaction model\" since\r\n  it better reflects the underlying behaviour?\r\n- \u00a72.2, 2nd para: \"Messages seamlessly work with transport protocols\r\n  that support datagrams or records, but can also be used over a stream\r\n  by defining an application-layer framer\". This make it seem like each\r\n  application needs to define its own framers when using the TAPS, but\r\n  I'd expect most framers to be introduced implicitly by the stack and\r\n  it to be unusual for them to be provided by the application. That is,\r\n  the applications says \"I want an HTTP connection\" and the stack then\r\n  implicitly figures out HTTP/2-TLS-TCP vs HTTP/3-QUIC and inserts the\r\n  appropriate framers itself.\r\n- \u00a73.2, 2nd para: \"if the API allows an application to specify a preference\r\n  for constrained checksum usage, communication would not fail when a\r\n  protocol such as TCP is selected, which uses a checksum covering the\r\n  entire payload\" - what's a constrained checksum? Does this mean partial\r\n  checksums over only part of the packet?\r\n- Figure 4: should this also show send calls, receive events, Messages,\r\n  and other events in Established? I understand that it's just showing\r\n  lifetime related events, but it seems incomplete because of that, and\r\n  the later sections introduce objects not shown in the diagram.\r\n- \u00a74.1.1: rename the subsection to \"Connection-related Objects\" since\r\n  it's broader than just Connection?\r\n- \u00a74.1.1: Can Connection Properties be specified on a Preconnection?  Can\r\n  Message Properties be specified on a Preconnection or Connection, or only\r\n  on Messages?\r\n- \u00a74.1.1 specifies that a Listener is creared from a Preconnection, but\r\n  doesn't say that a Connection is created from a Preconneciton or a\r\n  Listener. Should it?\r\n- \u00a74.1.2: \"An Endpoint can be specified at various levels\" - what's a level\r\n  here?\r\n- \u00a74.1.2, 1st bullet: \"with wider scope (such as a hostname)\" -- a hostname\r\n  doesn't necessarily have wider scope than an IP address. It might be more\r\n  abstract.\r\n- \u00a74.1.2 Selection Properties: \"a Wi-Fi Ethernet connection\"?\r\n- \u00a74.1.2 Connection Properties: \"Connection Properties SHOULD be specified\r\n  on a Preconnection prior to Connection establishment, but MAY be modified\r\n  later\" -- modified on the Preconnection later, or modified on the\r\n  Connection object after it's been established?\r\n- \u00a74.1.2 Connection Properties: \"Such changes do not affect protocol or path\r\n  selection, but only modify the manner in which a connection sends and\r\n  receives data\" -- might this cause the connection to select a different\r\n  path? I can imagine setting certain properties might make certain paths\r\n  unviable in a way that the transport could detect.\r\n- \u00a74.1.3 Initiate: \"for other protocols, this will just establish local\r\n  state\" - it might be worth giving an example here, since otherwise it\r\n  could be interpreted as being like a Listen, or saying \"for\r\n  connectionless protocols...\"? \r\n- \u00a74.1.3 Listen: \"The action of marking a Listener as willing to accept\r\n  incoming Connections\" -- phrasing is cumbersome, maybe just \"Enables\r\n  a Listener to accept incoming Connections\"?\r\n- \u00a74.1.3 Listen: \"Listeners by default register with multiple paths,\r\n  protocols, and local endpoints, unless constrained by Selection\r\n  Properties\" -- doesn't this depend on the Local Endpoint too? \r\n- \u00a74.1.3 Rendezvous: TCP simultaneous open is one type of rendezvous,\r\n  but only giving this as an example makes it seems more narrowly\r\n  scoped that I envisaged. For example, I'd expect Rendezvous could\r\n  perform an ICE exchange it STUN candidates were passed as Remote\r\n  Endpoints. Should this description be generalised?\r\n- \u00a74.1.4 Message: \"Boundaries of a Message might or might not be understood\r\n  or transmitted by transport protocols. Specifically, what one application\r\n  considers to be multiple Messages sent on a stream-based transport can be\r\n  treated as a single Message by the application on the other side, and\r\n  vice versa.\" -- I'm unconvinced by this. A stream protocol, such as TCP,\r\n  doesn't send arbitrary messages, it sends messages framed by some higher\r\n  layer protocol. The endpoints need to agree on that protocol, and hence\r\n  on the meaning and boundaries of the messages, if communication is to\r\n  proceed.\r\n- \u00a74.1.4 Message Properties: The initial sentence (\"Message Properties can\r\n  be used to annotate specific Messages\") can be read as this is the only\r\n  way to set properties; the later text that \"Message Properties MAY be set\r\n  on a Preconnection\" then surprises. Maybe combine these and restructure:\r\n  \"Message Properties can be used to annotate specific Messages or can be\r\n  set on a Preconnection [or Connection?] to specify defaults for future\r\n  messages. Message Properites might apply to how a Message is sent...\r\n  When recieving Messages...\"\r\n- \u00a74.1.4 Send: What's a \"partial Message\"? The previous text has spoken\r\n  only in terms of Messages, and has not hinted that partial messages can\r\n  be sent. Need prior introduction, if we're to allow this. It's not clear\r\n  that the architecture needs the concept of partial messages; are there\r\n  examples of protocols that send partial messages, rather than messages\r\n  of unknown size that are fragmented by the framer?\r\n- \u00a74.1.5: \"This list is not exhaustive\" -- that the list of events is not\r\n  exhaustive makes sense, but surely we should be able to provide a list\r\n  of categories of events?\r\n  Error events are missing; are there more?\r\n- \u00a74.1.6 Close: The way this is written suggests that the API doesn't\r\n  support half closed connections. That may be reasonable, but it's a \r\n  limitation. If intended, can it be made explicit.\r\n- \u00a74.1.6 is the only semantic difference between Close and Abort that\r\n  one attempts to deliver outstanding data and the other doesn't? It\r\n  seems unusual that there's no implication that Close is successful\r\n  and Abort is a failure action.\r\n- \u00a74.2.1 Path Selection: do the Selection Properties include multiple\r\n  Local Endpoints and Remote Endpoints? Or is a Preconnection supplied\r\n  with a set of Local and Remote Endpoints along with some Selection\r\n  Properties? Is Candidate Gathering itself not an operation to be\r\n  performed by the implementation before a Rendezvous can be performed? \r\n- \u00a74.2.2 Candidate Racing: The term \"racing\" implies that candidates\r\n  are tried simultaneously to see which succeeds first. That's true\r\n  in some cases, but others probe candidates in a defined order.\r\n  Should this be phrased as \"Candidate Selection and/or Racing\"?\r\n- \u00a74.2.4, 1st para: what's a \"process\" in this context? The term has not\r\n  been introduced previously.",
      "createdAt": "2019-12-19T22:01:46Z",
      "updatedAt": "2019-12-20T19:29:57Z",
      "closedAt": "2019-12-20T19:29:57Z",
      "comments": []
    },
    {
      "number": 396,
      "id": "MDU6SXNzdWU1NDEwODk1NTY=",
      "title": "Update Rendezvous text in Arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/396",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "\u00a74.1.3 Rendezvous: TCP simultaneous open is one type of rendezvous,\r\nbut only giving this as an example makes it seems more narrowly\r\nscoped that I envisaged. For example, I'd expect Rendezvous could\r\nperform an ICE exchange it STUN candidates were passed as Remote\r\nEndpoints. Should this description be generalised?",
      "createdAt": "2019-12-20T16:43:42Z",
      "updatedAt": "2019-12-23T14:52:27Z",
      "closedAt": "2019-12-23T14:52:27Z",
      "comments": []
    },
    {
      "number": 397,
      "id": "MDU6SXNzdWU1NDEwOTcyMjk=",
      "title": "Explain that Close isn't Half-Close",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/397",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "\u00a74.1.6 Close: The way this is written suggests that the API doesn't\r\nsupport half closed connections. That may be reasonable, but it's a\r\nlimitation. If intended, can it be made explicit.",
      "createdAt": "2019-12-20T17:02:08Z",
      "updatedAt": "2020-01-23T19:02:15Z",
      "closedAt": "2020-01-23T19:02:15Z",
      "comments": []
    },
    {
      "number": 398,
      "id": "MDU6SXNzdWU1NDExMTIxMjQ=",
      "title": "Slim down per-protocol behavior, move other mappings out",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/398",
      "state": "CLOSED",
      "author": "JonathanLennox",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly",
        "abrunstrom"
      ],
      "labels": [
        "Implementation",
        "mappings",
        "ready for text"
      ],
      "body": "Right now, the per-protocol behavior is specified in Implementation, which is an Informational document; however, this stuff really should be specified normatively.\r\n\r\nSo either they should be split out into (one or more?) separate documents, or Implementation should be made Normative just for the sake of one of its sections (which imo would be weird).",
      "createdAt": "2019-12-20T17:36:01Z",
      "updatedAt": "2020-08-14T15:07:03Z",
      "closedAt": "2020-08-14T15:07:03Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess having a separate document for the per-protocol behaviour makes a lot of sense.\r\nThis document than can also define names for protocol specific properties.",
          "createdAt": "2020-01-14T14:50:30Z",
          "updatedAt": "2020-01-14T14:50:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim discussion: considering splitting off a non-informational document for mapping definitions",
          "createdAt": "2020-02-21T18:01:02Z",
          "updatedAt": "2020-02-21T18:01:02Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Last discussion ended in agreement on splitting out protocol mappings. Two options were discussed 1) taking out all protocol mappings, 2) leaving TCP and UDP  as the two basic protocols and moving the other mappings. Good if we can conclude on which path to take. ",
          "createdAt": "2020-06-18T16:10:29Z",
          "updatedAt": "2020-06-18T16:10:29Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest that keeping UDP and TCP in here could be a simple expedient, especially if we make it clear that other RFCs can specify additional mappings. These two are very long-established transport protocols, and I think we can rapidly conclude this spec using them. Whilst I would be very happy to also see bindings for other important transports, that seems like something that could delay the group.  ",
          "createdAt": "2020-06-19T09:01:09Z",
          "updatedAt": "2020-06-19T09:01:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Leave minset protocols (UDP, TCP, SCTP, MPTCP), and define the template for new mappings.\r\n\r\nSplit out drafts: (TLS + DTLS), QUIC (and fallback to TLS, maybe join with TLS), HTTP",
          "createdAt": "2020-06-19T16:32:11Z",
          "updatedAt": "2020-06-19T16:32:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a small correction: minset also includes UDP-Lite, and the LEDBAT congestion control (the latter should probably be skipped since its encapsulation still isn't spec'd).",
          "createdAt": "2020-07-03T05:05:51Z",
          "updatedAt": "2020-07-03T05:05:51Z"
        }
      ]
    },
    {
      "number": 404,
      "id": "MDU6SXNzdWU1NDg4Mzg2ODk=",
      "title": "Event handlers: MUST they always be registered?  (or else..?)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/404",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In section 4, we say: \"Messages are received asynchronously through event handlers registered by the application. Errors and other notifications also happen asynchronously on the Connection.\"\r\nThis does not explain whether event handlers MUST be registered for all types of events (I guess not?), and what happens when no event handler is registered (I guess some reasonable default behavior - but shouldn't we be explicit about this?).",
      "createdAt": "2020-01-13T10:32:52Z",
      "updatedAt": "2020-02-21T14:44:16Z",
      "closedAt": "2020-02-21T14:44:16Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I definitely think they should not be required for all events (especially errors). \r\nI would assume that an event only gets thrown if an event handler is registered.",
          "createdAt": "2020-01-13T12:56:56Z",
          "updatedAt": "2020-01-13T12:56:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is important to allow certain events not to be handled by applications. That's one goal that I've had in Network.framework. A minimal application not catch all edge cases, but it can certainly ignore events it doesn't do anything special with.\r\n\r\nFor example, an application can not register any handler for a connection becoming ready, if it instead just sends, and waits for a send to succeed or fail.",
          "createdAt": "2020-01-13T17:38:04Z",
          "updatedAt": "2020-01-13T17:38:04Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If there are certain types of event handlers that MUST be registered, then we need to be explicit about that. \r\n\r\nThe others are, presumably, SHOULD register a handler?",
          "createdAt": "2020-01-13T23:26:17Z",
          "updatedAt": "2020-01-13T23:26:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I very much agree with folks that we should not require all event handlers to be registered!\r\n\r\nHowever, the text currently just isn't explicit about these things at all. Indeed: if something MUST be registered, the text should say so. But also, if an event handler is not registered for some events, then the text should explain that this is ok, and then, XYZ will happen.",
          "createdAt": "2020-01-14T07:14:10Z",
          "updatedAt": "2020-01-14T07:14:10Z"
        },
        {
          "author": "theagilepadawan",
          "authorAssociation": "NONE",
          "body": "Absolutely agree. Require the application to register all event handlers would make the API highly unflexible!\r\n\r\nCould it be an idea to require certain event handlers to be passed with key API calls like `Preconection.Listen()`? It doesn't make much sense to start listening without a handler for incoming connections. ",
          "createdAt": "2020-01-14T11:12:22Z",
          "updatedAt": "2020-01-14T11:12:22Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see no event in the API an application MUST subscribe to, but there are a lots it should. \r\n\r\nWhat might need mentioning is that some events may have implementation-specific default handlers that do some thing (e.g., exit the application) and the application should not assume ignore everything is always safe.",
          "createdAt": "2020-01-14T12:48:34Z",
          "updatedAt": "2020-01-14T12:48:34Z"
        }
      ]
    },
    {
      "number": 408,
      "id": "MDU6SXNzdWU1NDk2MTkxNTc=",
      "title": "Minor issues with Message Contexts",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/408",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "When reading the current API draft, I found three minor issues related to Message Contexts.\r\n\r\n- The RendezvousError (Section 6.3) includes a messageContext (which is even required), but neither the InitiateError nor the ListenError include one. Why? Should this messageContext at least be optional?\r\n\r\n- In Section 7.3, it says \"The Sent Event contains an implementation-specific reference to the Message to which it applies.\" - Is this in addition to the messageContext? If yes, why do we need both?\r\n\r\n- In Section 9, it says \"To get or set Message Properties, the optional scope parameter is left empty, for framing meta-data, the framer is passed.\" - I think this sentence is a bit hard to parse and it wasn't immediately obvious to me what kind of framing meta-data this refers to. Perhaps this refers to Section 10.2, so I think it's worth adding a reference to that section here. Also, I suggest turning this into two sentences, with the sentence on framing meta-data specifying that this is per-Message metadata to be used by the framer.",
      "createdAt": "2020-01-14T14:53:28Z",
      "updatedAt": "2020-02-21T15:02:29Z",
      "closedAt": "2020-02-21T15:02:29Z",
      "comments": []
    },
    {
      "number": 409,
      "id": "MDU6SXNzdWU1NDk2Mjc3NTE=",
      "title": "Security: Connection and Post-Connection Interfaces",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/409",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "Reading the API draft, I noticed that for Security parameters, the draft specifies how to set Pre-Connection Parameters (Section 5.3.1) and Connection Establishment Callbacks (Section 5.3.2).\r\nThe Pre-Connection Parameters directly correspond to what we have in the Security draft, but the rest is less clear to me:\r\n\r\nThe Security draft also has Connection interfaces (see https://tools.ietf.org/html/draft-ietf-taps-transport-security-10#section-5.2) and Post-Connection Interfaces (see https://tools.ietf.org/html/draft-ietf-taps-transport-security-10#section-5.3).\r\nThe Connection Interfaces might correspond to the Connection Establishment Callbacks. But I don't think we have the Post-Connection Interfaces in the API draft, i.e., Connection Termination, Key Update, Pre-Shared Key Export, Key Expiration, and Mobility Events.\r\n\r\nSo I wonder: Should the API draft contain more of these Security interfaces?\r\nI don't have a strong opinion on this. I'm totally fine with having the other Security parameters/interfaces be implementation-specific, so the API draft does not become even longer and more complex.\r\nHowever, I just wanted to point this out as an inconsistency among our documents.",
      "createdAt": "2020-01-14T15:07:18Z",
      "updatedAt": "2020-01-24T16:30:04Z",
      "closedAt": "2020-01-24T16:30:04Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suggestion in call is to provide some examples in an appendix of the API document. Other alternative is a future informational document to give such examples.",
          "createdAt": "2020-01-24T16:27:44Z",
          "updatedAt": "2020-01-24T16:27:44Z"
        }
      ]
    },
    {
      "number": 410,
      "id": "MDU6SXNzdWU1NDk2MzY5NTI=",
      "title": "API: Specifying local interfaces as Local Endpoint VS. as a Selection Property",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/410",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API"
      ],
      "body": "When reading the current API draft, I was wondering the following:\r\n\r\nIf an application wants to specify one or multiple local network interfaces, it can either set the Local Endpoint(s) or it can set the \"Interface Instance or Type\" Selection Property.\r\nI think both ways are valid and should exist, but I'm wondering if we should specify anything on the interaction of these two ways to do a similar thing.\r\n\r\nFor example, should we explicitly mention the Selection Property in Section 5.1 (\"Specifying Endpoints\"), to make readers aware that there is a \"better\" way to do this, which allows more flexibility?\r\n\r\nAlso, if an application specifies conflicting things, I guess this leads to an InitiateError, ListenError, or RendezvousError. Our current text already says this for the InitiateError:\r\n> \"An InitiateError occurs either when the set of transport properties and security parameters cannot be fulfilled on a Connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty) or reconciled with the local and/or remote Endpoints\"\r\n\r\nBut should we make this particular issue more explicit here and/or should we add it for the ListenError or RendezvousError?",
      "createdAt": "2020-01-14T15:21:31Z",
      "updatedAt": "2020-01-22T20:30:33Z",
      "closedAt": "2020-01-22T20:30:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For example, should we explicitly mention the Selection Property in Section 5.1 (\"Specifying Endpoints\"), to make readers aware that there is a \"better\" way to do this, which allows more flexibility?\r\n\r\nI think so, yes!\r\nRegarding the error in case of a conflict:\r\n\r\n> But should we make this particular issue more explicit here and/or should we add it for the ListenError or RendezvousError?\r\n\r\nI think so, yes - to all your questions: make it more explicit, state it in the description of both the ListenError and RendezvousError.\r\n\r\nJust my 2 cents",
          "createdAt": "2020-01-17T10:36:27Z",
          "updatedAt": "2020-01-17T10:36:27Z"
        }
      ]
    },
    {
      "number": 413,
      "id": "MDU6SXNzdWU1NTAxNTY2MzY=",
      "title": "Do we need to say more about authentication and encryption?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/413",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "I wondering if we should to talk a bit more about authentication in the the arch doc. The API doc has the concept of security parameters, however there is no discussion about this in the arch document. \r\n\r\nAlso, just double-checking: private keys and certificates/identify can be set as a security parameter of a pre-connection. However, is that really a connection parameter or rather a local endpoint property?",
      "createdAt": "2020-01-15T12:27:55Z",
      "updatedAt": "2020-04-06T13:11:42Z",
      "closedAt": "2020-04-06T13:11:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To match the API, add Security Properties to Section 4.1.2.",
          "createdAt": "2020-01-24T16:46:12Z",
          "updatedAt": "2020-01-24T16:46:12Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Try to associate with the endpoint?",
          "createdAt": "2020-01-24T16:57:32Z",
          "updatedAt": "2020-01-24T16:57:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add to figure 4 too",
          "createdAt": "2020-01-24T17:04:49Z",
          "updatedAt": "2020-01-24T17:04:49Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #506, I think?",
          "createdAt": "2020-04-06T13:11:42Z",
          "updatedAt": "2020-04-06T13:11:42Z"
        }
      ]
    },
    {
      "number": 414,
      "id": "MDU6SXNzdWU1NTAxNTg0MDg=",
      "title": "Is the Local Endpoint \"optional\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/414",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "the arch doc says:\r\n\"Local Endpoint: The Local Endpoint represents the application's\r\n      identifier for itself that it uses for transport connections; for\r\n      example, a local IP address and port.\"\r\nThis sounds like I always need some kind of identifier. However, I guess there should also be an option where I don't constrain the local interface and identifier at all and the transport service can select one, right? If that is true maybe we can say this here explicitly?!",
      "createdAt": "2020-01-15T12:31:45Z",
      "updatedAt": "2020-01-24T17:00:00Z",
      "closedAt": "2020-01-24T17:00:00Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "In section 4.1.1 it is specified when the local endpoint is required (i.e. on a listen and rendevousz) and when it is optional, is that sufficient?",
          "createdAt": "2020-01-15T19:37:20Z",
          "updatedAt": "2020-01-15T19:37:20Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I noticed that later. But just to be fully clear we could also say something more here.",
          "createdAt": "2020-01-16T08:59:07Z",
          "updatedAt": "2020-01-16T08:59:07Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, architecturally, here is *always* a local endpoint specifier, but in most client-side use cases using initiate, it will be a special local endpoint that specifies \"any/all available local endpoints\".\r\n\r\nIMO anything beyond that is an API detail, so I'd recommend closing this with no change to Arch.\r\n",
          "createdAt": "2020-01-21T10:42:42Z",
          "updatedAt": "2020-01-21T10:42:42Z"
        }
      ]
    },
    {
      "number": 416,
      "id": "MDU6SXNzdWU1NTAxNjIxMDc=",
      "title": "add example for \"information about the received Message\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/416",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "editorial",
        "ready for text"
      ],
      "body": "arch doc sec 4.1.4:\r\n\"When receiving Messages, Message Properties can contain\r\n      information about the received Message, such as metadata generated\r\n      at the receiver and information signalled by the remote endpoint.\"\r\nMaybe provide an example here...?",
      "createdAt": "2020-01-15T12:40:14Z",
      "updatedAt": "2020-04-06T13:12:35Z",
      "closedAt": "2020-04-06T13:12:35Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suggestion: ECN, which is information given from UDP in the form of such metadata.",
          "createdAt": "2020-01-17T10:38:16Z",
          "updatedAt": "2020-01-17T10:38:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "QUIC stream identifier example works",
          "createdAt": "2020-01-24T17:02:19Z",
          "updatedAt": "2020-01-24T17:02:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Final message is in API, just use that",
          "createdAt": "2020-01-24T17:03:16Z",
          "updatedAt": "2020-01-24T17:03:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #505",
          "createdAt": "2020-04-06T13:12:35Z",
          "updatedAt": "2020-04-06T13:12:35Z"
        }
      ]
    },
    {
      "number": 417,
      "id": "MDU6SXNzdWU1NTAxNjQ0NDI=",
      "title": "Add Framer to Figure 3",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/417",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "Reading something about framers in section 4.1.4 came actually a bit as a surprise to me as we don't talk a lot about framer earlier in the document (yes there is one forward reference in section 2.2 but that's it). Now that we have message in Figure 4, we should maybe also add framers...?",
      "createdAt": "2020-01-15T12:45:15Z",
      "updatedAt": "2020-02-04T00:51:19Z",
      "closedAt": "2020-02-04T00:51:19Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also maybe we should say a bit more what framers are than we currently do?\r\n\r\nThe current text is:\r\n\"   *  Framer: A Framer is a data translation layer that can be added to\r\n      a Connection to define how application-layer Messages are\r\n      transmitted over a transport protocol.  This is particularly\r\n      relevant for protocols that otherwise present unstructured\r\n      streams, such as TCP.\"\r\n\r\nWe could probably add to this:\r\n\"A framer can define a bit pattern or syntax such as a length field or prelimiter that is pre- or suspended by the transport service to the message's bytes and is know by the transport service or application on the other endpoint to parse the received bytes into a message.\"",
          "createdAt": "2020-01-15T14:44:45Z",
          "updatedAt": "2020-01-15T14:44:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Framer goes at bottom of API above implementation",
          "createdAt": "2020-01-24T17:05:59Z",
          "updatedAt": "2020-01-24T17:05:59Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "MDU6SXNzdWU1NTAyMzM1NTI=",
      "title": "Use of normative language in Arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/418",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "At some point we added normative language to the arch doc but only changed cases where use of upper case keywords are obvious. If we really want to use normative language, we would need another pass and make sure that we identified everything that should be specified normatively.\r\n\r\nAlternatively, we could just remove any normative language again and revert respective words back to lower case. I think that would be my preferred solution as a) it is less work and b) I don't think this document necessarily needs normative language.",
      "createdAt": "2020-01-15T14:51:27Z",
      "updatedAt": "2020-04-06T13:15:20Z",
      "closedAt": "2020-04-06T13:15:05Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Personally, I'd prefer to keep the language - but I agree we ought to review the items.\r\n\r\nI'd really like to use REQUIRED, RECOMMENDED, rather MUST and SHOULD - because these are not protocol operation requirements, but implementation requirements to conform.\r\n\r\ne.g.: , these properties SHOULD apply to multiple transport protocols.\r\ncould be.: , it is RECOMMENDED that these properties apply to multiple transport protocols.",
          "createdAt": "2020-01-16T13:26:59Z",
          "updatedAt": "2020-01-16T13:26:59Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think having normative language in there is a good idea because it makes it clearer what criteria we think an implementation has to meet or to give guidance on what to prioritize to implement.\r\n\r\nIn the current draft, there's two places in which I find the normative language odd and maybe misplaced though:\r\n- Section 4.1: \"Events MAY also provide opportunities for the application to interact with the underlying transport by querying state or updating maintenance options.\" - Maybe this should be rephrased or the MAY removed? Clearly events _are_ an opportunity to exchange information, which an implementation MAY or may not take.\r\n- Section 3.2: \"A Transport Services API MUST allow applications to define such requirements and constrain the system's options.\" - This seems to be oddly unspecific for a MUST: There MUST be some way to define some constraints, but what exact constraints is undefined? Also, this is in addition to minset, and I thought MUST should mostly cover minset to limit scope creep.",
          "createdAt": "2020-01-20T12:24:06Z",
          "updatedAt": "2020-01-20T12:24:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I agree with bot of those Theresa! I don't think we need keywords for either of these clauses.",
          "createdAt": "2020-01-20T14:25:33Z",
          "updatedAt": "2020-01-20T14:25:33Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following our discussion during the interim and having thought about it a bit more, I'd be okay with not having normative language in the Architecture document, as long as we make sure that it still clearly says what has to be implemented (i.e., support for minset), and as long as we still clearly warn against unsafe fallback for security protocols and such. But I guess that for me, changing the words to lower case would be enough.\r\n\r\nHowever, if we do that (and maybe even if we don't), we need to make clear that the API document actually contains ALL the normative language we need. For example, I'm not seeing anything on security protocols fallback in the API document yet.",
          "createdAt": "2020-01-28T11:40:07Z",
          "updatedAt": "2020-01-28T11:40:07Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I admit I misunderstood what Mirja's comment was. Gorry was Sorry. - this was the benefit of some discussion. This has made me realise:\r\n* The edits in Tommy's Pull Request are likely appropriate - the way the text evolved was not useful after all. I will read the whole ID carefully and...\r\n* My hope of good requirements requires much more focussed text - I take the opportunity to propose a concise requirements section along the lines of what emerged in the Interim. Coming soon.",
          "createdAt": "2020-02-21T19:08:58Z",
          "updatedAt": "2020-02-21T19:08:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm merging #502 in advance of the 107 draft deadline. There's one question as to how hard we should push minset at the arch level, which I think is a point for wider discussion, and a few nits which can be picked up after the draft lands.",
          "createdAt": "2020-03-09T12:42:49Z",
          "updatedAt": "2020-03-09T12:42:49Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Proposed new requirements section in arch opened as new issue #519. If we agree to consider that, this issue can now be closed.  ",
          "createdAt": "2020-03-27T08:03:10Z",
          "updatedAt": "2020-03-27T08:03:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#519 is the new issue for this.",
          "createdAt": "2020-04-06T13:15:19Z",
          "updatedAt": "2020-04-06T13:15:19Z"
        }
      ]
    },
    {
      "number": 419,
      "id": "MDU6SXNzdWU1NTAyNDEzNjg=",
      "title": "Acknowledgements in Arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/419",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "As I'm not an author, can you add me to ack section, please... :-)\r\n\r\nThere might be other people missing....",
      "createdAt": "2020-01-15T15:04:09Z",
      "updatedAt": "2020-01-27T09:42:19Z",
      "closedAt": "2020-01-27T09:42:19Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "actually, should we add you as an author to arch?",
          "createdAt": "2020-01-21T10:44:22Z",
          "updatedAt": "2020-01-21T10:44:22Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to be an author, however, no sure I actually wrote any text (I don't think there is much left from the postsockets text...?). Also, I guess we already have too many authors. If I get added, I'm fine to be in an authors section at the end of the doc.",
          "createdAt": "2020-01-21T11:14:40Z",
          "updatedAt": "2020-01-21T11:14:40Z"
        }
      ]
    },
    {
      "number": 420,
      "id": "MDU6SXNzdWU1NTAyNDY2OTA=",
      "title": "Where to define Connection Group?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/420",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture",
        "editorial"
      ],
      "body": "This is fully editorial: I'm not sure if the term \"Connection Group\" is introduced in the right section. There might be no perfect fit but maybe section 2.2 is a bit better?\r\n\r\nAlso I note that the terms \"Connection Group\" and \"Path\" do not not show up in any of the figures...",
      "createdAt": "2020-01-15T15:11:57Z",
      "updatedAt": "2020-01-30T16:03:36Z",
      "closedAt": "2020-01-30T16:03:36Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Make this a new subsection, i.e. 4.1.7.",
          "createdAt": "2020-01-24T17:39:33Z",
          "updatedAt": "2020-01-24T17:39:33Z"
        }
      ]
    },
    {
      "number": 426,
      "id": "MDU6SXNzdWU1NTAzMDE3ODg=",
      "title": "Syntax Preconnection",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/426",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Currently we define a Preconnection like this:\r\nPreconnection := NewPreconnection(LocalEndpoint,\r\n                                        RemoteEndpoint,\r\n                                        TransportProperties,\r\n                                        SecurityParams)\r\n\r\nAnd then use it in the examples e.g. like this:\r\n   Preconnection := NewPreconnection(None,\r\n                                     RemoteSpecifier,\r\n                                     TransportPreperties,\r\n                                     SecurityParameters)\r\n\r\nBut should we do this instead:\r\nPreconnection := NewPreconnection(LocalEndpoint?,\r\n                                        RemoteEndpoint?,\r\n                                        TransportProperties,\r\n                                        SecurityParams)\r\n\r\nI know that is also a bit confusing but maybe more inline with the syntax we define. Or we probably need to at least define the keyword \"None\"...\r\n",
      "createdAt": "2020-01-15T16:41:38Z",
      "updatedAt": "2020-02-21T16:03:33Z",
      "closedAt": "2020-02-21T16:03:33Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think your proposed syntax change makes sense.\r\nWhen we first wrote this, we didn't have optional parameters yet, but now that we do, let's use them!",
          "createdAt": "2020-01-16T09:36:39Z",
          "updatedAt": "2020-01-16T09:36:39Z"
        }
      ]
    },
    {
      "number": 427,
      "id": "MDU6SXNzdWU1NTAzMTUyNTE=",
      "title": "API, sec 5: SHOULD add Framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/427",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In the API doc sec 5 says.\r\n\"Message Framers (see Section 10), if required, should be added to the\r\n   Preconnection during pre-establishment.\"\r\nShould this be SHOULD or even MUST? If SHOULD is correct I think we need to say slightly more about when it makes sense to add a framer later.",
      "createdAt": "2020-01-15T17:04:44Z",
      "updatedAt": "2020-04-27T22:18:08Z",
      "closedAt": "2020-04-27T22:18:08Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be \"can be added...\"; not normative, just descriptive of fact.",
          "createdAt": "2020-01-24T16:32:05Z",
          "updatedAt": "2020-01-24T16:32:05Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we start with the \"If' perhaps...\r\n\"If messages frames are to be used, they MUST be  added to the\r\nPreconnection during pre-establishment.\"?",
          "createdAt": "2020-02-21T15:41:01Z",
          "updatedAt": "2020-02-21T15:41:01Z"
        }
      ]
    },
    {
      "number": 429,
      "id": "MDU6SXNzdWU1NTAzMjY2MjI=",
      "title": "selection algorithm (text in API doc)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/429",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "In section 5.2. in the API doc:\r\n\"Internally, the transport system will first exclude all protocols and\r\n   paths that match a Prohibit, then exclude all protocols and paths\r\n   that do not match a Require, then sort candidates according to\r\n   Preferred properties, and then use Avoided properties as a\r\n   tiebreaker.  Selection Properties that select paths take preference\r\n   over those that select protocols.  For example, if an application\r\n   indicates a preference for a specific path by specifying an\r\n   interface, but also a preference for a protocol not available on this\r\n   path, the transport system will try the path first, ignoring the\r\n   preference.\"\r\n\r\nThis sounds rather like an example algorithm that should maybe go into the implementation doc instead? Or is there any part of this that we need to specify normatively in order to ensure that all systems implement the same?\r\n\r\n",
      "createdAt": "2020-01-15T17:26:22Z",
      "updatedAt": "2020-03-09T16:40:43Z",
      "closedAt": "2020-03-09T16:40:43Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This goes back to issue #149 on \"conflicting policies\". At the time, we decided that there must be a deterministic outcome, therefore, text was added to both the API and the Implementation document, see #169. \r\nIf we keep it that way, perhaps the text here should point out that the goal is to resolve conflicting policies, so we achieve a deterministic outcome.",
          "createdAt": "2020-01-16T09:24:37Z",
          "updatedAt": "2020-01-16T09:24:37Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah okay, thanks for the background info; missed that. I think we need to use normative language here then. Maybe also a separate subsection makes this more prominent.",
          "createdAt": "2020-01-16T10:29:10Z",
          "updatedAt": "2020-01-16T10:29:10Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This reads to me like the rules for processing polices rather than an example algorithm. I think it is part of the API... Normative language would be good and a stronger opening that explains why the rules exist.",
          "createdAt": "2020-01-16T10:29:58Z",
          "updatedAt": "2020-01-16T10:29:58Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think a separate subsection would make this a better read - this fits fine as it stands, as an intro to the transport property specification IMO. Regarding normative language, that's a separate discussion. So, can we close this issue?",
          "createdAt": "2020-01-25T07:19:07Z",
          "updatedAt": "2020-01-25T07:19:07Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree that we don't need a separate subsection. I can try to tweak the beginning of this part a bit to explain why the rules exist as @gorryfair suggested.\r\nRegarding normative language - we definitely have it in the API draft, right? So why not have the discussion on it here as well?\r\nif we're serious about deterministic outcomes, I guess the whole thing needs to be a MUST, right?",
          "createdAt": "2020-01-27T16:57:47Z",
          "updatedAt": "2020-01-27T16:57:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, true, that normative language debate was about the arch draft, and we definitely have it in the API draft. So yes, let's discuss it here. I also think a MUST would make sense.",
          "createdAt": "2020-01-27T23:14:45Z",
          "updatedAt": "2020-01-27T23:14:45Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the order of filtering out require/prohibit is not important (outcome is the same) - making the order a MUST does not make sense. Also, first sorting by preference and then filtering has the same outcome as doing it the other way around. the only thing we need to say is that filtering MUST happen and sorting SHOULD happen.",
          "createdAt": "2020-01-28T08:20:01Z",
          "updatedAt": "2020-01-28T08:20:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok - I have to admit I didn't think this through, I just agree that we want a deterministic outcome from this.",
          "createdAt": "2020-01-28T09:38:37Z",
          "updatedAt": "2020-01-28T09:38:37Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why did we require a deterministic behavior in first place? \r\nDoes this prevent TAPS implementations from running experiments like Apple did with TCP SACK and ECN? Does this prevent probabilistic path probing?",
          "createdAt": "2020-02-19T14:08:54Z",
          "updatedAt": "2020-02-19T14:08:54Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This was discussed in the TAPS BoF? ... I thought it was about developers being assured that X will happen if they choose Y and not finding the ground shifting as they use the interface. ",
          "createdAt": "2020-02-19T17:24:45Z",
          "updatedAt": "2020-02-19T17:24:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: Prefers and avoids allow the implementation to decide the ordering and weighting; require and prohibit are the only hard requirements. Applications should be able to cope with any possibility that isn't prohibited.\r\n\r\nLikely should add implementation text to say how preferences weight racing.",
          "createdAt": "2020-02-21T17:18:04Z",
          "updatedAt": "2020-02-21T17:18:04Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "During the interim discussion, we found that #496 was too strict and limiting, so we opted for another approach that moves the selection algorithm to the Implementation draft. \r\nI'm preparing another PR implementing these changes.",
          "createdAt": "2020-02-24T14:57:40Z",
          "updatedAt": "2020-02-24T14:57:40Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text that ended up in the implementation draft is not fully consistent with the racing text, opening a new issue for this and closing this issue.",
          "createdAt": "2020-03-09T16:40:43Z",
          "updatedAt": "2020-03-09T16:40:43Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "MDU6SXNzdWU1NTA2ODk4MTM=",
      "title": "type of properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/434",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "Shouldn't section 5.2.1 to 5.2.9 also specify a type, namely Preference?",
      "createdAt": "2020-01-16T09:45:18Z",
      "updatedAt": "2020-02-21T16:04:08Z",
      "closedAt": "2020-02-21T16:04:08Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just noticed for Message and Connection Properties we have Type and Default as separate \"bullets\" for each property. Can we do the same for selection properties? ",
          "createdAt": "2020-01-16T14:59:23Z",
          "updatedAt": "2020-01-16T14:59:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, we should do this.",
          "createdAt": "2020-01-17T11:00:07Z",
          "updatedAt": "2020-01-17T11:00:07Z"
        }
      ]
    },
    {
      "number": 435,
      "id": "MDU6SXNzdWU1NTA2OTE3MTI=",
      "title": "Default values for Interface Instance and PvD",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/435",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "We require implementations to have default but we don't provide any recommendation for interface and PvD.",
      "createdAt": "2020-01-16T09:48:39Z",
      "updatedAt": "2020-02-04T08:08:50Z",
      "closedAt": "2020-02-04T08:08:50Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For Interface, this would the default be to set \"Ignore\" on all available interfaces, right? This indicates that the application has no preferences of its own, so the implementation can apply some default system policy. Also, if the application specified some local endpoint, this might constrain the actual interfaces used (related to #410).\r\nIf we try to phrase this as (Preference, Enumeration), it reads a bit weird though: (\"Ignore\", \"Cellular\") and (\"Ignore\", \"WiFi\"), for example. So perhaps we should just write text saying that the default is to set no application preference.",
          "createdAt": "2020-01-18T12:10:15Z",
          "updatedAt": "2020-01-18T12:10:15Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think text is fine as well but we need to say something.",
          "createdAt": "2020-01-20T09:56:19Z",
          "updatedAt": "2020-01-20T09:56:19Z"
        }
      ]
    },
    {
      "number": 436,
      "id": "MDU6SXNzdWU1NTA2OTMyNzg=",
      "title": "Local Address Preference always only preferred?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/436",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "For Local Address Preference we only have the option to _prefer_ stable or temporary. However, I guess we would also need a way to e.g. specify that stable is _required_, no? ",
      "createdAt": "2020-01-16T09:51:18Z",
      "updatedAt": "2020-03-08T15:37:08Z",
      "closedAt": "2020-03-08T15:37:08Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this addressed by PR #480 ?",
          "createdAt": "2020-01-22T10:45:59Z",
          "updatedAt": "2020-01-22T10:45:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think so.",
          "createdAt": "2020-01-22T11:12:40Z",
          "updatedAt": "2020-01-22T11:12:40Z"
        }
      ]
    },
    {
      "number": 437,
      "id": "MDU6SXNzdWU1NTA3MDIyMjc=",
      "title": "Configuring MP active/passive",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/437",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "For MP use we have the following option: Disable, Handover, Interactive, Aggregate. \r\n\r\nI think the option as not well defined (except Disable). Maybe the following is a bit better:\r\n\r\nHandover: : The connection should attempt to migrate to a new paths when interface availability changes and performance of the currently used path decreased below a certain threshold. This threshold is implementation-specific.\r\n\r\nInteractive: : The connection should attempt to use multiple paths in parallel in order to always select the best path available or at least achieve about the same aggregated bandwidth as provided by the best of the available paths. This can be achieved by using coupled congestion control as proposed in {{?RFC6356}} for MP-TCP.\r\n\r\nAggregate: : The connection should attempt to use multiple paths in parallel in order to maximize bandwidth. That usually means that independent congestion control instances are used on each path.\r\n\r\nI also proposed another option:\r\n\r\nRedundant: : The connection should send the same data on two of the available paths. A message property could be used to indicate which messages should be send redundantly.\r\n\r\nAnd further I think we also need a configuration option to indicate when/if a new subpath should be opened. I think there are four options: \r\n\r\nNever-passive (rely on other ending opening new paths and never send new available IPs),\r\nNever-active (rely on other ending opening new paths but signal send new available IPs), \r\nImmediate (open new path when IP because available locally or provided by other end), \r\nOn-Request (application needs to indicate).\r\n\r\nNote that there is also rfc6897 specifying a rather different interface...\r\n\r\n",
      "createdAt": "2020-01-16T10:07:10Z",
      "updatedAt": "2020-06-19T15:10:29Z",
      "closedAt": "2020-06-19T15:10:29Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are many options for MP. I think the idea with the current proposal was to start simple and stick to options that have deployment experience. As I understand the currenr proposal Aggregate is the option that uses both paths with coupled cc. I do not think we should have an option for uncoupled cc. Interactive is not targeting bulk traffic and will try to use a single path unless performance drops too much. So that is the most fuzzy. ",
          "createdAt": "2020-01-23T22:13:35Z",
          "updatedAt": "2020-01-23T22:13:35Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Handover - sounds like what is called failover in many places. Can we call failover?\r\n\r\nI'm concerned by \"interactive\" - This is fuzzy indeed. Can we manage without this?\r\n\r\nI don't like \"redundant\" - true you can do this, but then when you have different paths; CC; etc you can introduce issues - do we have experience of this - is this a great thing to do below the transport, rather than in  the App... I am quite unsure.\r\n",
          "createdAt": "2020-02-21T15:33:36Z",
          "updatedAt": "2020-02-21T15:33:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim discussion: generally not wanting to expose redundant.\r\n\r\nExposing alternate addresses to the peer and actively migrating is likely a separate property that we should specify.",
          "createdAt": "2020-02-21T17:29:56Z",
          "updatedAt": "2020-02-21T17:29:56Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also review description text on enum instances",
          "createdAt": "2020-02-21T17:32:54Z",
          "updatedAt": "2020-02-21T17:32:54Z"
        }
      ]
    },
    {
      "number": 438,
      "id": "MDU6SXNzdWU1NTA3MDM3MTM=",
      "title": "Retransmit notify",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/438",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "\"   Name: :retransmit-notify\r\n\r\n   This property specifies whether an application considers it useful to\r\n   be informed in case sent data was retransmitted more often than a\r\n   certain threshold.  The default is to Ignore this option.\"\r\n\r\nI guess we then also need an option to set this threshold?\r\n\r\nOr we make this option of type Integer and say 0 is ignore.",
      "createdAt": "2020-01-16T10:09:51Z",
      "updatedAt": "2020-04-02T15:03:16Z",
      "closedAt": "2020-04-02T15:03:16Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you say \"yes\" to this Selection Property, then (depending on the outcome of racing), the Generic Connection Property retransmit-notify-threshold (sec. 11.1.1.) will be the one to use. I guess this just needs a reference to this section.",
          "createdAt": "2020-01-16T13:59:38Z",
          "updatedAt": "2020-01-16T13:59:38Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, thanks, still reviewing... yes all we need is a reference!",
          "createdAt": "2020-01-16T14:12:00Z",
          "updatedAt": "2020-01-16T14:12:00Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Is this useful? - Lower layers may duplicate, protocols may retransmit for various reasons (apart from loss - timer issues, robustness concerns, etc. So what utility does this bring? \r\nIf we need it then we should explain and define a threshold. Can we live without these being a specified part of the API?",
          "createdAt": "2020-02-21T15:37:55Z",
          "updatedAt": "2020-02-21T15:37:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's a minset thing. So, backtracking:\r\n\r\n- Appendix: this maps to \"Notification of Excessive Retransmissions (early warning below abortion threshold)\"\r\n\r\n- Minset A.1 points back at ERROR.TCP in RFC 8303, and classifies this as: \"Optimizing because it is an early warning to the application, informing it of an impending functional event.\"\r\n\r\n- In RFC 8303, it gets clear that ERROR.TCP is about soft errors from ICMP, including at least \"ICMP error message arrived and excessive retransmissions\", and there is a pointer to Section 4.2.4.1 of RFC 1122.\r\n\r\n- There, we find: \"However, the conditions that are reported asynchronously to the application MUST include (..) Excessive retransmissions (see 4.2.3.5) (..) \". In Section 4.2.3.5, we have: \"Excessive retransmission of the same segment by TCP indicates some failure of the remote host or the Internet path.  This failure may be of short or long duration.  The following procedure MUST be used to handle excessive retransmissions of data segments [IP:11]:\", followed by text that talks about a configurable threshold for early notification (in addition to having a higher abortion threshold).\r\n\r\nSo: I agree that this may not be super useful - but it's a case where we have a MUST regarding notifying the application, and a MUST for configuring a threshold. Hence we couldn't simply make it a part of the soft error notification, because then wouldn't get to configure the threshold. As stated above, we currently do have a configurable threshold: the Generic Connection Property retransmit-notify-threshold.",
          "createdAt": "2020-03-04T11:33:11Z",
          "updatedAt": "2020-03-04T11:33:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added the reference, which was needed as @mirjak and I agreed above.\r\nIf someone wants to discuss this even more, shout - before the end of this week. If noone shouts, I'll close this next week.",
          "createdAt": "2020-04-02T12:18:31Z",
          "updatedAt": "2020-04-02T12:18:31Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Adding the reference seems like the correct thing to do. If we were to discuss the usefulness - I have doubts - but we don't need to have that discussion. ",
          "createdAt": "2020-04-02T12:30:34Z",
          "updatedAt": "2020-04-02T12:30:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing now in this case  :)",
          "createdAt": "2020-04-02T15:03:16Z",
          "updatedAt": "2020-04-02T15:03:16Z"
        }
      ]
    },
    {
      "number": 440,
      "id": "MDU6SXNzdWU1NTA3MDg1OTk=",
      "title": "Why do we use functions to set security parameters...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/440",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "... while we use (property, values) pairs to set other properties?\r\n\r\nIs there a reason for this? Otherwise I suggest we agree to one interaction model!",
      "createdAt": "2020-01-16T10:18:14Z",
      "updatedAt": "2020-06-30T14:38:51Z",
      "closedAt": "2020-06-30T14:38:50Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related I also think this text isn't really that correct:\r\n\"Security decisions, especially pertaining to trust, are not static.\r\n   Once configured, parameters may also be supplied during connection\r\n   establishment.  These are best handled as client-provided callbacks.\"\r\nYou can update some security parameter anytime during the connection using the same interface as before. However the two callbacks we have defined require actually actions that follow an event, so they have to be callbacks.",
          "createdAt": "2020-01-16T10:20:42Z",
          "updatedAt": "2020-01-16T10:20:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"However the two callbacks we have defined require actually actions that follow an event, so they have to be callbacks.\"  - that's it, these need to be callbacks. @britram made them like that because using them requires a tighter interaction model. See issue #347.",
          "createdAt": "2020-01-25T07:41:37Z",
          "updatedAt": "2020-01-25T07:41:37Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed in interim, Security Parameters are a bit different from selection properties. We should review the security parameter interface, but it will likely be independent.",
          "createdAt": "2020-02-21T17:37:12Z",
          "updatedAt": "2020-02-21T17:37:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did a closer review on these and there are two main differences between Security Parameters and the other Preferences / Events:\r\n - Use of individual calls on security parameters instead of add with keywor. These could easily be integrated, e.g., by turning ```SecurityParameters.AddCiphersuite(\u2026)``` into ```TransportParameters.Add(cipher-suites, \u2026)```\r\n - Use of Callbacks instead of Events \u2013 closed as Issue #347. Despite there is no technical reason to not turn the Security Callbacks into events, events that \"need to do something\", i.e.,  \r\n accept, reject, or return an identity, really look wired.\r\n\r\nLet's discuss which way to take this one forward:\r\n - Leave as is\r\n - Align the interface of SecurityParameters to the Transport Parameters, but keep them as a separate object and leave SecurityCallbacks as they are\r\n - Integrate the interface of SecurityParameters into the Transport Parameters, but keep SecurityCallbacks roughly the same\r\n - Integrate the interface of SecurityParameters into the Transport Parameters, make SecurityCallbacks more event-like.\r\n\r\nI am happy to make a PR for whatever we decide, but not for all of them.\r\n",
          "createdAt": "2020-06-19T08:32:24Z",
          "updatedAt": "2020-06-19T08:33:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can do the minor option to change AddCiphersuite to Add(ciphersuite...)",
          "createdAt": "2020-06-19T15:31:57Z",
          "updatedAt": "2020-06-19T15:31:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe add clarification text to say that these are pre-connection only parameters",
          "createdAt": "2020-06-19T15:37:23Z",
          "updatedAt": "2020-06-19T15:37:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Consider cutting cache lifetime, etc, from this list",
          "createdAt": "2020-06-19T15:38:27Z",
          "updatedAt": "2020-06-19T15:38:27Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We really should explicitly add a sentence to clearly say that the security functions are configured using add functions and not via Properties. This is so useful to say, so that someone does not come along and do this because they think we just didn't see this.",
          "createdAt": "2020-06-19T15:42:25Z",
          "updatedAt": "2020-06-19T15:42:25Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed with #594 ",
          "createdAt": "2020-06-30T14:38:50Z",
          "updatedAt": "2020-06-30T14:38:50Z"
        }
      ]
    },
    {
      "number": 441,
      "id": "MDU6SXNzdWU1NTA4Mzk5NTY=",
      "title": "Questions on Connection Groups",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/441",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "A couple of questions we might want to address regarding Connection Groups.\r\n\r\n1) Can the application query the interface to figure if two connection in a group share the same transport connection but on different streams or not. Is that useful? I thinks we should explicitly say that if a multiplex protocol is used, calling Clone() MUST create a new stream (and not a new connection).\r\n\r\n2) If a new connection is created by a Listener it is automatically part of a group, right? Can I detach that connection from the group? Otherwise how can I change a property only for that connection? Isn't is actually confusing that these connection are grouped?\r\n\r\n2) Should we add a pointer to coupled congestion control (rmcat) in that section?\r\n\r\n",
      "createdAt": "2020-01-16T14:24:16Z",
      "updatedAt": "2020-06-19T09:10:14Z",
      "closedAt": "2020-06-19T09:10:14Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1.\r\n\"Can the application query the interface to figure if two connection in a group share the same transport connection but on different streams or not.\" - no.\r\n\r\n\"Is that useful?\" - Good question. The behavior attained with coupled cc. for ongoing connections can be VERY similar to the behavior of multi-streaming - exposing such a detail to an application can then lead to unnecessarily protocol-specific code. Then again, it may be useful for an application to know if issuing Clone() comes with almost zero overhead, or if it produces a connection setup on the wire...  so I lean towards \"yes, it's useful\".\r\n\r\n\"I thinks we should explicitly say that if a multiplex protocol is used, calling Clone() MUST create a new stream (and not a new connection).\"  Fine by me. I think the query that you mention above, then, should be: \"is a Connection multiplexing-capable?\"  (which will, due to your MUST, translate into \"Clone() just means using a new stream\").\r\n\r\n2.\r\nThe difference between Listening with and without cloning is explicit - normally, Listen does *not* produce a Connection that's grouped with some ongoing Connections. Rather, if you WANT to do a \"listening clone\", you need to issue \"Listen\" *on* an ongoing Connection, as described in Section 6.4. So it's a different \"Listen\" call. You can't detach Connections from groups.\r\n\r\n3.\r\nYes! We've also done work on doing this with TCP connections, which works like a charm - I'll insert the coupled cc reference and cite the TCP coupling work too.",
          "createdAt": "2020-01-22T10:42:19Z",
          "updatedAt": "2020-01-22T10:42:19Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with 1): having a query that indicates if a protocol provides multiplexing is probably sufficient (+ the MUST requirement)\r\n\r\nOn 2) from how I read the document I understood that Connections that are derived from the same Preconnection are clones. If that is not the case of Listeners we need to clarify that and double-check the existing text.",
          "createdAt": "2020-01-22T11:17:17Z",
          "updatedAt": "2020-01-22T11:17:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2): that's what I meant in my answer, sorry if it wasn't clear. So what's the problem?",
          "createdAt": "2020-01-24T14:23:38Z",
          "updatedAt": "2020-01-24T14:23:38Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So are you saying Connection from the same Listeners are clones or not? And in each case shouldn't there be a way to also get the other?",
          "createdAt": "2020-01-24T15:02:06Z",
          "updatedAt": "2020-01-24T15:02:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, sorry, I misread, you talked about \"the same *Pre*connection\". No, that's not it. If you call Listen on a *Pre*connection, you get a new Connection that is not cloned. That's in:\r\nhttps://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-interface.html#name-passive-open-listen\r\n\r\nIf, however, you call Listen on an *existing Connection*, you get a clone. That's in:\r\nhttps://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-interface.html#name-connection-groups\r\n",
          "createdAt": "2020-01-24T15:16:48Z",
          "updatedAt": "2020-01-24T15:16:48Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to add, I think its inconsistent that you would call listen() on an connection object. In all other parts of the draft it is only ever used on preconnections.",
          "createdAt": "2020-01-24T17:44:42Z",
          "updatedAt": "2020-01-24T17:44:42Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No that's also not what I was talking about. You call listen on a preconnnection. At some point someone connects and the listener creates a connection (A). Then another (or the same actually) peer connect to your server (again) and the same listener creates another connection (B). Are those connections(A and B) grouped or not?\r\n\r\n",
          "createdAt": "2020-01-24T20:02:07Z",
          "updatedAt": "2020-01-24T20:02:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The same listener = a listener that was called on a preconnection.\r\nSo, in your example, you never called Listen on a Connection, which is semantically different.\r\nSo, no, A and B would not be grouped - what makes you think they could be? Noone ever made the Listen call that would do that. What am I missing?",
          "createdAt": "2020-01-24T20:25:37Z",
          "updatedAt": "2020-01-24T20:25:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MaxF12 that's just a naming thing. Using it on a connection is consistent with Clone() - it's just a different way of Cloning, as a passive instead of active open. We could call it something else - ListeningClone or something. Me, I like it as it stands because, to me, the semantics of \"this is spawned off an existing connection\" are nicely conveyed by the call being applied to a Connection instead of a Preconnection. But I wouldn't fight about the name if you think \"ListeningClone\" or something like that is better.",
          "createdAt": "2020-01-25T07:24:05Z",
          "updatedAt": "2020-01-25T07:24:05Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, its mostly a naming thing but I think there are a few things here that need to be specified which aren't obvious. For example, what happens if you call listen on two connections that belong to the same group? Personally, I would assume that you can't and would get an error if you tried.\r\n\r\nI also agree with @mirjak that it is a bit confusing that listener objects, depending on how they have been created, sometimes group connections and sometimes they don't. \r\n",
          "createdAt": "2020-01-25T10:33:37Z",
          "updatedAt": "2020-01-25T10:33:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For example, what happens if you call listen on two connections that belong to the same group? Personally, I would assume that you can't and would get an error if you tried.\r\n\r\nWhy? The two connections are already both part of the same group, so any of these Listen calls should give you yet another connection that is in the same group. I don't think there's anything indicating any other semantics - such as the error you're describing.\r\n\r\nAbout this being confusing: this is just a matter of having a passive clone. How else would you do it?",
          "createdAt": "2020-01-25T14:42:23Z",
          "updatedAt": "2020-01-25T14:42:23Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "But the listen wouldn't give you a new connection, it would give you a Listener object which in turn would give you new connection(s). Having multiple Listener objects for the same group seems wrong to me. ",
          "createdAt": "2020-01-25T15:00:39Z",
          "updatedAt": "2020-01-25T15:00:39Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this whole discussion suggests that we should indeed use a different name, ListenClone or CloneListen seems the most natural choices to me. Perhaps update the name (and the text accordingly) and see if there is still any points for confusion left.\r\nWhile calling listen on a Preconnection and a Connection are semantically different, I can see that it is easy to get lost as to what Listen we are talking about in different parts of the text.",
          "createdAt": "2020-01-25T15:03:11Z",
          "updatedAt": "2020-01-25T15:03:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes!",
          "createdAt": "2020-01-25T22:51:19Z",
          "updatedAt": "2020-01-25T22:51:19Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm currently reading the Implementation draft again, where Section 4.8.3 talks about listening for multiplexed protocols.\r\nInterestingly, the implementation draft gives different answers to the questions here:\r\n\r\n1. The Implementation draft says that \"The implementation should allow the application to introspect the Connection Group marked on the Connections to determine the grouping of the multiplexing.\" So I guess this would change the answer to question 1 here to \"Yes\", but the interface draft doesn't say how.\r\n\r\n2. \"Protocols that provide multiplexing of streams into a single five-tuple can listen both for entirely new connections (a new HTTP/2 stream on a new TCP connection, for example) and for new sub-connections (a new HTTP/2 stream on an existing connection). If the abstraction of Connection presented to the application is mapped to the multiplexed stream, then the Listener should deliver new Connection objects in the same way for either case.\" - It doesn't say what \"in the same way\" means, but I guess it means \"deliver a ConnectionReceived event\". The sentence after that talks about querying Connection groups, cited above. So this sounds to me like this text presumes that Connections from new streams on existing connections are grouped, while Connections on entirely new connections are not. But I might be misreading this. In any case, it's not clear. This thread sounds to me like incoming Connections from a Listener created by Preconnection.Listen() are never grouped.\r\n\r\nSo, I think either we should say explicitly that incoming Connections from that Listener may or may not be grouped (depending on whether there's an \"entirely new connection\" underlying or whether they're just a new stream), or we say they're never grouped and change the implementation draft later.\r\n\r\nHowever, in that latter case, we'd have outgoing multiplexed connections which are always Connection Groups, and we have incoming multiplexed connections which are never Connection Groups. That doesn't sound right.",
          "createdAt": "2020-02-15T15:56:16Z",
          "updatedAt": "2020-02-15T15:56:16Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Folks, this discussion and @theri's last comment just made me remember something: I'm afraid we have designed something that just cannot work!\r\n\r\nI don't know about QUIC, but I assume it's the same: in SCTP, passively creating a new stream just doesn't exist - a stream comes into being as soon as a new message is sent on it. So, technically, the only thing that really works would be something much more restrictive, as for example:\r\n- having a form of InitiateWithSend as an active clone,\r\n- then, on the passive side, upon InitiateWithSend-cloning, Listener -> ConnectionReceived<Connection> might just fire out of the blue, and only when that happens, Connections are cloned.\r\n",
          "createdAt": "2020-02-16T16:41:44Z",
          "updatedAt": "2020-02-16T16:41:44Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If initiate() is supposed to \"open\" new stream, calling initiate() will not lead to any action on the wire but also create some internal state that the next send of that connection will need a new stream (id). That's fine.\r\n",
          "createdAt": "2020-02-17T11:26:34Z",
          "updatedAt": "2020-02-17T11:26:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But is that a clean model?  You call initiate, and because it's just like any other Connection, maybe you expect to possible be able to read something afterwards... but that will never be the case.",
          "createdAt": "2020-02-17T15:49:55Z",
          "updatedAt": "2020-02-17T15:49:55Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that things get somewhat inconsistent here. When would a Connection created like this fire its ready event? Just immediately?",
          "createdAt": "2020-02-17T18:17:06Z",
          "updatedAt": "2020-02-17T18:17:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Felix Weinrank and Michael T\u00fcxen described in detail how this works in case of NEAT in this paper:\r\nF. Weinrank and M. T\u00fcxen. \u201cTransparent Flow Mapping for NEAT\u201c. In Workshop on Future of Internet Transport (FIT 2017), Stockholm, June 2017.\r\nhttp://dl.ifip.org/db/conf/networking/networking2017/1570349380.pdf\r\n\r\nFor their implementation, the answer to your question is \"yes\". But that's just because we wanted to map Connections at any cost - it comes with the limitation of only being to send (not receive) later, so I'd say this is not fantastic API design. Being able to receive immediately after clone() + ready would require using a signal in the underlying protocol itself - the paper discusses that this could be done with the otherwise unused \"Payload Protocol Identifier (PPID)\", but the meaning of this signal (as: \"I created a stream but I'm not sending anything\") would of course have to be known to both sides too, requiring a new standard.\r\n",
          "createdAt": "2020-02-17T19:02:03Z",
          "updatedAt": "2020-02-17T19:02:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Opening a connection that just allocates stream ID state should be fine, no? I don't think it's necessarily a problem.\r\n\r\nAs far as being able to read without sending, that's up to the protocol. No reason some future version of QUIC or similar couldn't support that.",
          "createdAt": "2020-02-17T20:54:39Z",
          "updatedAt": "2020-02-17T20:54:39Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well that's true - although, why would future-QUIC do that? Just to support TAPS's communication model? It seems efficient to just implicitly create a new stream by transmitting data on it.\r\n\r\nAnyway, at the very least, we should warn the programmer that it may not be possible to initially read on a newly cloned connection, and provide this information as a readable connection property.\r\n\r\nAlso note that we're now only discussing one aspect of the problem: is it ok to just have an \"Initiate\".\r\n\r\nThe other aspect is listening: sure, we could make a general Listen map to things and have warnings and such, but what both QUIC and SCTP would currently be doing is completely different from that. I think it would be better to specify that Listener -> ConnectionReceived might just fire out of the blue, which would also indicate that the first data has probably (with current protocols: surely) already arrived at the stack.",
          "createdAt": "2020-02-17T21:05:36Z",
          "updatedAt": "2020-02-17T21:05:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, not just to support TAPS! If there was some value in having a stream that a client can open, but not write, and have the server write, which presumably is the case you're concerned about here, and someone has a use case, they can use that.\r\n\r\nEven today, you can have a server for TCP that won't do anything until the client writes. I don't see any reason to have the API be restrictive based on particular protocol behavior, when there are cases that do allow that behavior.",
          "createdAt": "2020-02-17T22:32:07Z",
          "updatedAt": "2020-02-17T22:32:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's the communication pattern I'm concerned about. It is rare - e.g. pub-sub systems, which in principle follow that pattern, will usually implement an application-level signal from the client to the server that at least says \"I'm here\". Because this pattern is rare, I doubt that it will be supported in future-QUIC-or-whatever. And that's fine!\r\n\r\nThe problem is: if I write an application over TAPS and I decide to implement this \"I listen, and then I'm the first to send\" pattern, then:\r\n- if the underlying protocol is TCP, this will work fine\r\n- if the underlying protocol is a stream of QUIC or SCTP, my application simply gets stuck.\r\n\r\nSo we should at least put a warning about this case in there, and let an application query if, after Listen, send-before-receive is possible.\r\n",
          "createdAt": "2020-02-18T01:33:57Z",
          "updatedAt": "2020-02-18T01:33:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in interim: this sounds like a property that does protocol selection that doesn't choose QUIC if you require being able to open a stream and then read without sending (TCP allows this, QUIC doesn't).",
          "createdAt": "2020-02-21T16:50:27Z",
          "updatedAt": "2020-02-21T16:50:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Listen + ListenClone() discussion is moved to issue #508.\r\nI'll make a PR for the outcome above (protocol selection property).",
          "createdAt": "2020-02-21T16:53:22Z",
          "updatedAt": "2020-02-21T16:53:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl ping, will the protocol selection property land before the next interim?",
          "createdAt": "2020-04-06T13:22:24Z",
          "updatedAt": "2020-04-06T13:22:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ACK and YES. I had planned to do this today (not happening) or tomorrow (most likely) or the day after tomorrow (sigh, I hope tomorrow will work).",
          "createdAt": "2020-04-06T13:31:19Z",
          "updatedAt": "2020-04-06T13:31:19Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"client opens the connection but server sends first\" model is used in SMTP, right? It's not such an uncommon pattern.",
          "createdAt": "2020-04-17T15:02:12Z",
          "updatedAt": "2020-04-17T15:02:12Z"
        }
      ]
    },
    {
      "number": 443,
      "id": "MDU6SXNzdWU1NTA4NDcxOTc=",
      "title": "Message size",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/443",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "\"Maximum Message Size on Send\r\n\r\n   Name:  send-msg-max-len\r\n\r\n   Type:  Integer (read only)\r\n\r\n   This property represents the maximum Message size that can be sent.\"\r\n\r\nWhat the maximum message size for streams...? We should specify what should be returned if there is no limit. \r\n\r\nOr is the assumption that this will the return the maximum local buffer size? Would that be semantically correct?",
      "createdAt": "2020-01-16T14:35:47Z",
      "updatedAt": "2020-02-21T16:05:18Z",
      "closedAt": "2020-02-21T16:05:18Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Is this intended to be the largest size of data block that can be sent using a send operation? - In which case, I think there is always a limit?",
          "createdAt": "2020-01-16T15:24:32Z",
          "updatedAt": "2020-01-16T15:24:32Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes that limit exists but that seems to mix up two different things. If that it what we want, we need to say this explicitly.",
          "createdAt": "2020-01-16T16:49:46Z",
          "updatedAt": "2020-01-16T16:49:46Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Yes. I think we should. I am not sure what we mean by maximum message size... but maybe others want to explain?",
          "createdAt": "2020-01-16T16:59:06Z",
          "updatedAt": "2020-01-16T16:59:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair asked \"Is this intended to be the largest size of data block that can be sent using a send operation?\" - the answer is yes. Is the description of this property not clear enough? It reads: \"This property represents the maximum Message size that can be sent.\"\r\nWhy does this mix up two different things? Maybe you're thinking \"sent\" as in \"can leave the host\", while I'm thinking \"sent\" as in \"used by a send call\". So maybe that sentence should be rephrased to be more explicitly about the latter.",
          "createdAt": "2020-01-22T10:27:05Z",
          "updatedAt": "2020-01-22T10:27:05Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems we have different understandings of this property, so we clearly need to clarify this. But I guess we first need to agree what it actually means. Or maybe we just call it Maximum Buffer Size?",
          "createdAt": "2020-01-22T11:19:35Z",
          "updatedAt": "2020-01-22T11:19:35Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maximum send buffer size would capture what it means, but it describes something internal. I'd prefer to use your phrasing from above in the description: \"the largest size of data block that can be sent using a send operation? \"\r\n\r\nIt's the added \"using a send operation\" that makes it unambiguous.",
          "createdAt": "2020-01-22T11:29:22Z",
          "updatedAt": "2020-01-22T11:29:22Z"
        }
      ]
    },
    {
      "number": 446,
      "id": "MDU6SXNzdWU1NTEzMDQ4NjM=",
      "title": "Do we need msg-reliable and lifetime?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/446",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "These two message properties are interconnected and therefore have a dependency. I would rather prefer to only have one property. Lifetime already has one \"special\" value (infinity) to indicate reliable transmission. We could also declare 0 as special to indicate unreliable transmission (only transmit once and never retransmit).\r\n\r\nAlso should we rather use -1 for reliable? And also do this for other properties that currently have meaning for infinite? Or would it be more correct to say max instead of infinite?\r\n\r\nAnd more more question on lifetime: Do we need an event that indicates to the application that transmission was aborted due to lifetime expiry? ",
      "createdAt": "2020-01-17T09:34:56Z",
      "updatedAt": "2020-02-21T17:39:27Z",
      "closedAt": "2020-02-21T17:39:26Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> These two message properties are interconnected and therefore have a dependency. I would rather prefer to only have one property. Lifetime already has one \"special\" value (infinity) to indicate reliable transmission. \r\n\r\nNo. Here's a quote from the description of lifetime:\r\n\" Setting a Message's Lifetime to infinite indicates that the application does not wish to apply a time constraint on the transmission of the Message, but it does not express a need for reliable delivery; reliability is adjustable per Message via the \"Reliable Data Transfer (Message)\" property (see Section 7.4.7). \"\r\n\r\nConsider an unreliable, congestion controlled transport (e.g. QUIC with datagrams). Specifying a \"lifetime\" means that, once the lifetime has expired, the Message can be deleted from the send buffer. Setting \"lifetime\" to infinite means that the Message will never just be deleted from the send buffer. This does not at all guarantee that the Message will be retransmitted in case it was lost.\r\n\r\n> Also should we rather use -1 for reliable? And also do this for other properties that currently have meaning for infinite? Or would it be more correct to say max instead of infinite?\r\n\r\nThe mistake is the mix of \"integer\" and \"infinite\". The latter is okay for type \"numeric\". I have already fixed this in PR #403 (which is still open).\r\n\r\n> And more more question on lifetime: Do we need an event that indicates to the application that transmission was aborted due to lifetime expiry?\r\n\r\nThat's the Expired Event, see section 7.3.2.",
          "createdAt": "2020-01-17T11:18:21Z",
          "updatedAt": "2020-01-17T11:18:53Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we close this issue?",
          "createdAt": "2020-01-25T07:20:15Z",
          "updatedAt": "2020-01-25T07:20:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: Agreed with @mwelzl, closing.",
          "createdAt": "2020-02-21T17:39:26Z",
          "updatedAt": "2020-02-21T17:39:26Z"
        }
      ]
    },
    {
      "number": 447,
      "id": "MDU6SXNzdWU1NTEzMDYyMjk=",
      "title": "Is \"Singular Transmission\" the right term",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/447",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "When I initial read the heading I thought this is again about reliability. May we can call this single-segment or something...?",
      "createdAt": "2020-01-17T09:37:46Z",
      "updatedAt": "2020-06-19T16:38:34Z",
      "closedAt": "2020-06-19T16:38:34Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well it's a term - I don't like it much. Single segment doesn't mean it's all in one IP packet (it means it's all in one transport segment). \r\nWe could just say sending as a single IP packet.\r\n",
          "createdAt": "2020-01-27T14:22:54Z",
          "updatedAt": "2020-01-27T14:22:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: proposing to rename to something more simple like Don't Fragment? We don't have a good name.",
          "createdAt": "2020-02-21T17:46:57Z",
          "updatedAt": "2020-02-21T17:46:57Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't Fragment seems good too me - and tidy this sentence:\r\nOLD: /Attempts to send a message with this property set\r\n   with a size greater to the transport's current estimate of its\r\n   maximum transmission segment size will result in a \"SendError\"./\r\nNEW:  /Setting this property causes a \"SendError\" when\r\n   an attempt is made to send a message\r\n   with a size greater than the transport's current estimate of the\r\n   maximum packet size./\r\n",
          "createdAt": "2020-02-23T08:03:00Z",
          "updatedAt": "2020-02-23T08:03:00Z"
        }
      ]
    },
    {
      "number": 448,
      "id": "MDU6SXNzdWU1NTEzMDk5NDI=",
      "title": "Right design for Partial Send",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/448",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "The section on partial send says:\r\n\r\n\"All data sent with the same MessageContext object will be treated as\r\n   belonging to the same Message, and will constitute an in-order series\r\n   until the endOfMessage is marked.  Once the end of the Message is\r\n   marked, the MessageContext object may be re-used as a new Message\r\n   with identical parameters.\"\r\n\r\nCan we reconsider for a second if that is really the way we want to design this? This is really implicit and therefore an easy source for errors. I guess we could alternatively use an explicit message identifier...? Or the send action always return an identifier and for subsequent sends we input this identifier again? Or someone has a smarter idea?",
      "createdAt": "2020-01-17T09:45:29Z",
      "updatedAt": "2020-04-14T11:58:31Z",
      "closedAt": "2020-04-14T11:58:31Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have my head buried in code like some others here (@tfpauly, @MaxF12 , ..), so I guess that these folks should speak up - but just from reading this, I agree that the current design sounds like an easy source for errors.",
          "createdAt": "2020-01-17T11:22:53Z",
          "updatedAt": "2020-01-17T11:22:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to just remove the part that mentions reusing the same object. That's an implementation detail (and a perf optimization). The rest seems correct.",
          "createdAt": "2020-01-18T19:08:01Z",
          "updatedAt": "2020-01-18T19:08:01Z"
        }
      ]
    },
    {
      "number": 449,
      "id": "MDU6SXNzdWU1NTEzMTIzMDg=",
      "title": "Right semantics for batch sending?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/449",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "batch sending, as currently specified, means that you already have to have all messages ready in the application because you can declare a patch. That means you have to potentially \"buffer\" some message in the application. Wouldn't it may be better/easier to have a message property that indicates that a certain message should wait (probably up until a maximum time) for the next message and then buffer it in the transport instead?",
      "createdAt": "2020-01-17T09:50:11Z",
      "updatedAt": "2020-06-19T15:08:31Z",
      "closedAt": "2020-06-19T15:08:31Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can just clarify the text that the batch may be an arbitrarily long-running block of code, and not require knowing up front all of the data.",
          "createdAt": "2020-02-21T17:49:06Z",
          "updatedAt": "2020-02-21T17:49:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could also allow begin batch/end batch.\r\n\r\nExplain use case around optimizing send performance.",
          "createdAt": "2020-02-21T17:51:52Z",
          "updatedAt": "2020-02-21T17:51:52Z"
        }
      ]
    },
    {
      "number": 450,
      "id": "MDU6SXNzdWU1NTEzMTUxOTY=",
      "title": "What's meant by \"type of Message\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/450",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I'm not sure I understand this sentence (in sec 8. - Receiving Data):\r\n\"As with sending, the type of the Message to be passed is dependent on\r\n   the implementation, and on the constraints on the Protocol Stacks\r\n   implied by the Connection's transport parameters.\"\r\nEspecially, what's meant by \"type of Message\"?",
      "createdAt": "2020-01-17T09:55:43Z",
      "updatedAt": "2020-04-06T13:24:06Z",
      "closedAt": "2020-04-06T13:24:06Z",
      "comments": []
    },
    {
      "number": 451,
      "id": "MDU6SXNzdWU1NTEzMjY0NjU=",
      "title": "ECN property?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/451",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "A bunch or questions on ECN:\r\n\r\nDo we want a transport property that indicates that ECN should be requested during the handshake if supported by the selected protocol? Or is the assumption that this is rather a system configuration? Do we need to say this somewhere?\r\n\r\nFurther I don't think that having ECN markings as a (receive) message property is correct as a message may consist out of multiple packets/datagrams and there could also be packets that don't contain message data at all. I mean the mapping is straight forward for UDP but I guess one could also use QUIC as a datagram only service? And can one use message framers with UDP?\r\n\r\nMaybe we should have this a protocol specific property for UDP only? Or we could allow to register events that indicate reception of certain ECN-marked segments? Or we just maintain counters that could be polled by the application...?",
      "createdAt": "2020-01-17T10:17:29Z",
      "updatedAt": "2020-02-21T16:05:54Z",
      "closedAt": "2020-02-21T16:05:54Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do we want a transport property that indicates that ECN should be requested during the handshake if supported by the selected protocol? Or is the assumption that this is rather a system configuration? Do we need to say this somewhere?\r\n\r\nI think it's not of concern to the application unless the application has to do congestion control - as in UDP's case - which is probably why UDP is the only transport that exposes ECN..\r\n\r\n> Further I don't think that having ECN markings as a (receive) message property is correct as a message may consist out of multiple packets/datagrams and there could also be packets that don't contain message data at all.\r\n\b\r\nWell, in UDP - the only case we have, so far, AFAIK - it is associated with a packet, which becomes a Message. As you say, the mapping is straightforward for UDP - but e.g. QUIC as a datagram only service shouldn't expose ECN because QUIC is congestion controlled.\r\n\r\n> Maybe we should have this a protocol specific property for UDP only?\r\n\r\nWe could do that, if you think that makes it cleaner?  The logic: \"associated with a singular Message whenever it's exposed, because the transport doesn't do congestion control\" seems quite general to me. But I'd be fine with making it UDP specific anyway.",
          "createdAt": "2020-01-17T11:58:51Z",
          "updatedAt": "2020-01-17T11:58:51Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "To me it is datagram specific to connection-less protocols. Really this means UDP in this context. \r\n\r\nTransports that are connection-oriented can have the functionality to check for ECN, enable this, detect and respond to marking and appropriate machinery to decide how to fallback. To me, all of this is a system decision not application. It doesn't appear in the API except for UDP-based services.",
          "createdAt": "2020-01-18T11:34:17Z",
          "updatedAt": "2020-01-18T11:34:17Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should we have this as protocol specific property then?",
          "createdAt": "2020-01-20T09:58:22Z",
          "updatedAt": "2020-01-20T09:58:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good idea!",
          "createdAt": "2020-01-22T10:20:34Z",
          "updatedAt": "2020-01-22T10:20:34Z"
        }
      ]
    },
    {
      "number": 453,
      "id": "MDU6SXNzdWU1NTEzMzE3NjY=",
      "title": "Early data property on receive",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/453",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I'm not certain about the semantics used here, given this property can only be true once in one specific message.\r\n\r\nDid we discuss already the option of providing a message together with the ConnectionReceived event? You cannot set the message length and max length in this case but you can set a default value before you create the listener and that would be used then. Or we could even have a separate ConnectionReceivedAndMessage function for application that care about early data.",
      "createdAt": "2020-01-17T10:27:29Z",
      "updatedAt": "2020-03-04T16:24:47Z",
      "closedAt": "2020-03-04T16:24:47Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I personally find this uglier than what we have: if I don't care about a Message being idempotent or not, I can write the same code to receive a Message, whether it arrives as early data or not, and just ignore the \"early data\" Message property. With your proposal, I can't do that.",
          "createdAt": "2020-01-17T12:04:30Z",
          "updatedAt": "2020-01-17T12:04:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we close this?",
          "createdAt": "2020-03-04T10:47:53Z",
          "updatedAt": "2020-03-04T10:47:53Z"
        }
      ]
    },
    {
      "number": 454,
      "id": "MDU6SXNzdWU1NTEzMzUwNDE=",
      "title": "Receive semantics",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/454",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "In the examples at the beginning I already didn't really like the fact that we have this \"empty\" received call there as many application have a response request pattern (and only want complete messages). I wondering if we should provide a SendAndReceive function or even make the send function having an implicit receive for complete message and specify a separate SendOnly function...?\r\n\r\nI know these are rather implementation details but the goal was to optimise this interface for what application usually need/do and I'm not sure we reached this goal here.",
      "createdAt": "2020-01-17T10:33:21Z",
      "updatedAt": "2020-04-06T13:24:56Z",
      "closedAt": "2020-04-06T13:24:56Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that binding the functionality of the Receive call (flow control) with a Send as you propose isn't clean design - just because \"Send and Receive\" is common, I don't see this as necessary (then you tie exactly 1 send to exactly 1 receive ... or invent parameters for a number of sends/receives...  this all just strikes me as unnecessary complexity added to the API).\r\n\r\nI do suspect, from the way you phrase it (\"the 'empty' received call\"), that you stumbled over the syntax here - just the way it looks to issue what seems like an 'empty' receive call.\r\n\r\nSo: perhaps it would be better to make the real functionality of Receive() more explicit, by renaming it into EnqueueReceiveEvent()  ?",
          "createdAt": "2020-01-17T12:10:05Z",
          "updatedAt": "2020-01-17T12:10:05Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So: perhaps it would be better to make the real functionality of Receive() more explicit, by renaming it into EnqueueReceiveEvent() ?\r\n\r\nThat would make at least the example at the very beginning of this doc much clearer.\r\n\r\nBtw. maybe we should also say explicitly somewhere what happens if a message is received before the received event is enqueued.\r\n\r\n",
          "createdAt": "2020-01-17T13:05:38Z",
          "updatedAt": "2020-01-17T13:05:38Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree on both accounts. Let's see what others think!",
          "createdAt": "2020-01-17T13:28:41Z",
          "updatedAt": "2020-01-17T13:28:41Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @mwelzl to keep Send and Receive separate as the most basic calls. \r\n\r\nI do not really like the EnqueueReceiveEvent suggestion. The API is event-based so we have many calls of this type. Should Listen then be EnqueueConnectionReceivedEvent or why single out the Receive event to make the Enqueue-Event explicit?\r\n\r\nMaking explicitly what happens if a message is received before the received event is enqueued sounds good.",
          "createdAt": "2020-01-18T12:55:19Z",
          "updatedAt": "2020-01-18T12:55:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really don't like bundling a send and receive; that's an application choice to call them in sequence if they want. I also don't think EnqueueReceiveEvent adds much. I agree more with @abrunstrom  here.",
          "createdAt": "2020-01-18T19:10:58Z",
          "updatedAt": "2020-01-18T19:10:58Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I also agree with @abrunstrom and that we need to be explicit about what happens to messages that arrive before the first receive() call (if there never is one, what kind of error would it be when messages need to get dropped because the buffer is full?). \r\nHowever, as mentioned before, I think that the fact that you have to enqueue single receives is inconvenient in general. For example, in our implementation, there is a new receive() call in every received callback as it is required if you want to receive more than one message. \r\nI think one way to solve this is to add a transport property that specifies wether or not the application wants to just receive all (complete) messages as soon as they are available or not. \r\n\r\n",
          "createdAt": "2020-01-19T15:02:04Z",
          "updatedAt": "2020-01-19T15:02:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MaxF12 there is a very good reason to keep individual receive calls\u2014that is the mechanism for achieving meaningful backpressure. While it is convenient, sure, for an application to be able to say \"give me everything all the time\", that practically means that the implementation is always buffering up to its memory limits. If the convenience to ignore flow control/backpressure is present, you would see the majority of adopters use that method, which would increase the amount of queuing in a TAPS layer. We would certainly not implement such a function in our framework.",
          "createdAt": "2020-01-19T16:00:14Z",
          "updatedAt": "2020-01-19T16:00:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @abrunstrom and I agree with things that were said after her post.\r\n\r\nNow, a question. We all seem to agree that it's good to be explicit about what happens when a Message arrives before a Receive has been issued. My question is: what should really happen?\r\n\r\nI think that the default behavior should be to hand it on, because the code may just not have reached the first \"Receive\" yet. Else, to listen and immediately be able to receive a single message, one must always write \"listen\" and \"receive\" directly one after another...  but whenever I call \"Listen\", surely it means I'm ready to receive something?  So I guess it would be better if a call to \"Listen\" should really translate into one \"Listen\" and one \"Receive\" call. If we agree, then we should state this in the description of \"Listen\".",
          "createdAt": "2020-01-20T08:48:18Z",
          "updatedAt": "2020-01-20T08:48:18Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe I'm confusing myself now but let's assume you don't call receive immediately and, as your connection is fast, the transport received already a whole bunch of small messages before the first receive. receive will then provide me the first complete message. How do I now how many times I have to call received again to get all enqueued messages?",
          "createdAt": "2020-01-20T09:26:52Z",
          "updatedAt": "2020-01-20T09:26:52Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "> Now, a question. We all seem to agree that it's good to be explicit about what happens when a Message arrives before a Receive has been issued. My question is: what should really happen?\r\n\r\nI think the message should just sit in the queue of the taps implementation until the application calls receive. If there is a framer it may already deframe it.\r\n\r\n> Else, to listen and immediately be able to receive a single message, one must always write \"listen\" and \"receive\" directly one after another... but whenever I call \"Listen\", surely it means I'm ready to receive something? So I guess it would be better if a call to \"Listen\" should really translate into one \"Listen\" and one \"Receive\" call. If we agree, then we should state this in the description of \"Listen\".\r\n\r\nWould that be one automatic receive per incoming connection or just one automatic receive for the first new connection?\r\n\r\n> How do I now how many times I have to call received again to get all enqueued messages?\r\n\r\nWith the current API you would just have to keep calling receive() until you no longer get any received events. This is what I meant when I said that in many practical cases there will a receive() call in every received() callback.\r\n\r\nHas there ever been any consideration to change the receive semantics to something closer to how its done for framers?\r\nI.e. the application gets a received/receivedPartial event, which does not include message data, whenever there is a new message/ data. It can then call receive() to get a complete/ partial message. I think that would get rid of some of the issues like not knowing if there are any new mesaages while also keeping backpressure.\r\n",
          "createdAt": "2020-01-20T10:40:50Z",
          "updatedAt": "2020-01-20T10:40:50Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with @MaxF12 about the expected behavior.\r\n\r\nI don't think we should change Listen() to automatically do one Receive() call for the same reason that we don't want to couple Send() and Receive(). To me it sounds like bad design and also quite unintuitive. If the application wants to receive messages right away after Listen() (and ConnectionReceived<>, right, because otherwise there is no Connection to receive messages on?), why not just call Receive() right away?\r\n\r\nI think adding more calls, like make receive events more similar to framers, makes our interface even more complex, which we should really avoid.",
          "createdAt": "2020-01-20T14:36:46Z",
          "updatedAt": "2020-01-20T14:36:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @theri, and with @MaxF12 about the expected behavior: the data should just sit there and wait for Receive to be issued. I take back my proposed ListenAndReceive behavior, that was a bad idea.",
          "createdAt": "2020-01-22T10:19:27Z",
          "updatedAt": "2020-01-22T10:19:27Z"
        }
      ]
    },
    {
      "number": 455,
      "id": "MDU6SXNzdWU1NTEzNTk4NTY=",
      "title": "Message context",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/455",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In the section on message context we have the following text:\r\n\"Message Contexts can also be used to send messages that are flagged\r\n   as a reply to other messages, see Section 7.2 for details.  If the\r\n   message received was send by the remote endpoint as a reply to an\r\n   earlier message and the transports provides this information, the\r\n   MessageContext of the original request can be accessed using the\r\n   Message Context of the reply:\r\n\r\n   RequestMessageContext := MessageContext.GetOriginalRequest()\"\r\n\r\nIs that even possible? How can the transport now that a received message is a reply? Just because it was received on the same stream? Not sure if the transport can every say this for sure...?",
      "createdAt": "2020-01-17T11:23:01Z",
      "updatedAt": "2020-06-19T16:38:21Z",
      "closedAt": "2020-06-19T16:38:21Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you're writing on a QUIC stream with a message, the data coming back on that stream is the message associated with it, etc.",
          "createdAt": "2020-01-18T19:09:09Z",
          "updatedAt": "2020-01-18T19:09:09Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I'm not sure that correct to assume. E.g. assume both ends send a request on the same bidirectional stream. If you receive the request from the other end right after you've send your request, you'll assume that the reply. \r\n\r\nWhy is the function actually needed?",
          "createdAt": "2020-01-20T09:41:31Z",
          "updatedAt": "2020-01-20T09:41:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think in the one-Connection-becomes-one-stream model, this function is not needed. If messages are spread across streams, then this function is necessary to ensure that the response goes on the same stream.",
          "createdAt": "2020-01-22T10:15:57Z",
          "updatedAt": "2020-01-22T10:15:57Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "suggest this as a topic for interim discussion.",
          "createdAt": "2020-04-06T13:30:26Z",
          "updatedAt": "2020-04-06T13:30:26Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Michael will look at the interim minutes and figure out what needs to be done.",
          "createdAt": "2020-05-29T16:56:42Z",
          "updatedAt": "2020-05-29T16:56:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I found the minutes, but to no avail:\r\nhttps://etherpad.ietf.org:9009/p/notes-ietf-interim-2020-taps-01\r\n\r\nCan we just discuss this right here some more?\r\nAbove, I said that this seems to me to only be necessary when messages are spread across streams (every message is a new stream). However: the abstract entity that we already expose to an application, which incorporates the desired request-response logic, is the Connection.\r\n\r\nSo: as an application programmer, if I want to make sure that there's a clear request-response relationship between two messages, then I just need to use the same Connection for them and keep it open for this communication. How this Connection is mapped below is a different question... but anyway, this is how a programmer would convey the request-response relationship.\r\n\r\nFrom this, I conclude: @mirjak is right, this doesn't make sense and should be removed.\r\n\r\nI'm probably missing something. Tell me!",
          "createdAt": "2020-06-03T12:04:36Z",
          "updatedAt": "2020-06-03T12:04:36Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So IMO the underlying issue here is that certain transports might actually be able to bind messages to replies (QUIC), but not all can, and there's no great way to let the application know that you can't without doing unexpected things to its code flow.\r\n\r\nI'd support removing it.",
          "createdAt": "2020-06-19T15:43:58Z",
          "updatedAt": "2020-06-19T15:43:58Z"
        }
      ]
    },
    {
      "number": 457,
      "id": "MDU6SXNzdWU1NTEzNjkxNTU=",
      "title": "Framers again...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/457",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "I know we moved some text about framers into the implementation doc but that really doesn't seem right when I look at it now.\r\n\r\nThe section about framers in the implementation doc is the only section that defines an interface which probably is already an indication that just moving this text there was not right. However, also the text in the API doc seems now incomplete. \r\n\r\nI think we should move it back and rather define some real simple examples framers in the implementation document (just a prefixed length field (as many UDP mapping use) or maybe even an example implementation for STARTTLS). Further after moving it back we could figure out if really all parts of the interface are necessary or if there would be a more minimal interface that we could use. E.g. I'm not sure about the FailConnection() call or at least I think this could need more explanation.",
      "createdAt": "2020-01-17T11:44:26Z",
      "updatedAt": "2020-07-21T09:13:13Z",
      "closedAt": "2020-07-21T09:13:13Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also I think it would be good to the section on framers earlier in the doc. I will open a separate section to propose some restructuring (as I also think it would be good to have the connection properties earlier).",
          "createdAt": "2020-01-17T11:48:00Z",
          "updatedAt": "2020-01-17T11:48:00Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the real problem with framers is that we left them vague to avoid having to worry about all the implications they bring with them (which are a lot as they impact almost every stage of the life of a connection) but also to not limit what implementations can do with them by making them very rigid. \r\n\r\nBut I do agree that the text in API feels somewhat incomplete. Maybe one solution would be to explain what a framer should at least be able to do in the interface draft without specifying the actual API that is in implementation. \r\nI think we all agree at _when_ a framer should be able to interact with the connection just not _how_ that interaction is supposed to look like (as that is highly implementation specific). ",
          "createdAt": "2020-01-19T20:01:18Z",
          "updatedAt": "2020-01-19T20:01:18Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree that we should move the text back into the API document, since the group was very clear before that the details should be moved to implementation. The boundary we defined was to leave in the API: (a) the definition of what a framer is and why it's used and (b) the interface an application uses to add a framer to the connection.\r\n\r\nThe API text should be complete with regards to how a *user* of a framer performs actions. What specific text would we want to add here?",
          "createdAt": "2020-01-19T22:47:38Z",
          "updatedAt": "2020-01-19T22:47:38Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First as I say that's the only piece of additional interface we define in the implementation draft which already is a sign that it's maybe not ideal. \r\n\r\nBut for the API draft the part of how a framer interact with the transport is really unclear and looking at the part of interface, that now defined in the implementation doc, makes it really clear.\r\n\r\nI disagree that this part of the interface can or should be left to the implementation. The fact that you have to call the framer before you start any transmission and the events a framer should be aware of are generic and nothing implementation specific.",
          "createdAt": "2020-01-20T09:11:16Z",
          "updatedAt": "2020-01-20T09:11:16Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the implementation draft we say:\r\n\"A Message Framer is primarily defined by the set of code that handles events for a framer implementation\"\r\n\r\nMy assumption is that a custom framer implementation could be part of the application logic and therefore we need to define this interface as well.\r\n\r\nHowever looking at the implementation draft I guess I now confused myself about how this actually works. Why is the sending logic asynchronous? Isn't this something that happens iteratively when the application calls send(). How would that actually work? I thought the application could just call Connection.send() and then the connection could call MessageFramer.send() and that would simply return a modified message... can you give an example for sending and receiving based on the interfaces currently defined in the implementation draft?\r\n\r\nAlso please note that while I think the interface definition belongs in API draft, however, there are comments about copying and curser handling which should/could probably say in the implementation draft.",
          "createdAt": "2020-04-07T13:06:42Z",
          "updatedAt": "2020-04-07T13:06:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim:\r\n\r\nAdd to -interface:\r\n- Explain that framer(s) is in between the rest of the protocol stack and the application\r\n- Intercepts calls to start/stop and send/receive\r\n\r\nAnd just leave as is, and have another framers document in the future once we get more details.",
          "createdAt": "2020-04-17T17:00:39Z",
          "updatedAt": "2020-04-17T17:00:39Z"
        }
      ]
    },
    {
      "number": 458,
      "id": "MDU6SXNzdWU1NTEzNzY0Njk=",
      "title": "Minor text adjustments after re-structuring API doc.  (was: New proposed structure for API doc)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/458",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "I think we should reorganise the API doc a little bit. I proposed to 1) have the \"Managing Connection\" section earlier and then 2) have a new top level section on \"Data Transfer\" (inline with the arch doc) and have first one subsection that contains everything around messages and then having \"Sending Data\" and \"Receiving Data\" as two more subsections.\r\n\r\nI think the only text changed ended is in the \"Sending Data\" section where currently messages are introduced as this structure would introduce messages earlier and some new text for the start of the new \"Data Transfer\" section of course.\r\n\r\nThe structure would then look like this:\r\n\r\n7. Managing Connections \r\n     7.1.  Generic Connection Properties \r\n       7.1.1.  Retransmission Threshold Before Excessive Retransmission Notification \r\n       7.1.2.  Required Minimum Corruption Protection Coverage for Receiving \r\n       7.1.3.  Priority (Connection)\r\n       7.1.4.  Timeout for Aborting Connection \r\n       7.1.5.  Connection Group Transmission Scheduler  \r\n       7.1.6.  Maximum Message Size Concurrent with Connection Establishment \r\n       7.1.7.  Maximum Message Size Before Fragmentation or Segmentation \r\n       7.1.8.  Maximum Message Size on Send \r\n       7.1.9.  Maximum Message Size on Receive\r\n       7.1.10. Capacity Profile \r\n       7.1.11. Bounds on Send or Receive Rate \r\n       7.1.12. TCP-specific Property: User Timeout \r\n     7.2.  Soft Errors\r\n     7.3.  Excessive retransmissions\r\n8.  Data Transfer\r\n 8.1 Messages and Framers\r\n   8.1.2.  Message Contexts  \r\n   8.1.2. Message Framers \r\n     8.1.2.1.  Adding Message Framers to Connections \r\n     8.1.2.2.  Framing Meta-Data  \r\n   8.1.3  Message Properties \r\n       8.1.3.1.  Lifetime  \r\n       8.1.3.2.  Priority  \r\n       8.1.3.3.  Ordered \r\n       8.1.3..4.  Idempotent \r\n       8.1.3.5.  Final \r\n       8.1.3.6.  Corruption Protection Length \r\n       8.1.3.7.  Reliable Data Transfer (Message) \r\n       8.1.3.8.  Message Capacity Profile Override \r\n       8.1.3.9.  Singular Transmission\r\n 8.2 Sending Data \r\n     8.2.1.  Basic Sending\r\n     8.2.2  Sending Replies \r\n     8.2.3.  Send Events \r\n       8.2.3.1.  Sent  \r\n       8.2.3.2.  Expired \r\n       8.2.3.3.  SendError \r\n     8.2.4.  Partial Sends\r\n     8.2.5.  Batching Sends  \r\n     8.2.6.  Send on Active Open: InitiateWithSend \r\n 8.3  Receiving Data  \r\n     8.3.1.  Enqueuing Receives  \r\n     8.3.2.  Receive Events \r\n       8.3.2.1.  Received \r\n       8.3.2.2.  ReceivedPartial\r\n       8.3.2.3.  ReceiveError  \r\n     8.3.3.  Receive Message Properties \r\n       8.3.3.1.  ECN \r\n       8.3.3.2.  Early Data  \r\n       8.3.3.3.  Receiving Final Messages  ",
      "createdAt": "2020-01-17T12:01:08Z",
      "updatedAt": "2020-07-29T09:24:34Z",
      "closedAt": "2020-07-29T09:24:34Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea and I agree that Connection Properties should be introduced earlier.\r\nAlso, this structure introduces messageContexts before it uses them all the time.\r\n\r\nOne thing I'm wondering about, not actually related to the reordering, but while we're at it: \r\nWhy is \"TCP-specific Property: User Timeout\" under \"Generic Connection Properties\" even though it's not a Generic but a Protocol Specific Property? Shouldn't this heading be on the same subsection level as \"Generic Connection Property\"?",
          "createdAt": "2020-01-18T12:31:04Z",
          "updatedAt": "2020-01-18T12:31:04Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a separate PR that already changes that. I issued this proposed new structure before I filled the PR, so I didn't consider that. So yes!",
          "createdAt": "2020-01-20T09:55:14Z",
          "updatedAt": "2020-01-20T09:55:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd suggest keeping data transfer first, before managing",
          "createdAt": "2020-06-19T15:51:55Z",
          "updatedAt": "2020-06-19T15:51:55Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be done after the next submitted version (when all PRs are cleared) and then get immediately submitted as another separate version.",
          "createdAt": "2020-06-19T15:54:22Z",
          "updatedAt": "2020-06-19T15:54:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have now done this with commits to the master, to avoid blocking other updates with a long-standing PR. Please take a look - I think the structure is now correct, and the basic text is in place (as you say above, the intro to sending, and the intro to the new \"Data Transfer\" section). A few more text updates may be in order - e.g., in the new section 8.1.3 (Message Properties), this text now seems weird:\r\n\r\n\"The simpler form of Send, which does not take any messageContext,\"\r\nand should perhaps be written as: \"If no Message Context is provided when sending, \"  ... or something like that.\r\n\r\nI think that sections 7 and 8 now just need to be read thoroughly by someone, and the text updated accordingly to avoid weird things like this due to the new structure.\r\n\r\nThis is still assigned to me - so I can do this, with a normal PR, next. Anyway, this issue is no longer in the way of other updates now. ",
          "createdAt": "2020-07-21T10:09:32Z",
          "updatedAt": "2020-07-21T10:09:32Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought the plan was to actually submit another version to the datertracker without the restructuring and then submit the restricted one right after, so it'd be easier to track changes there as well...?",
          "createdAt": "2020-07-21T10:21:02Z",
          "updatedAt": "2020-07-21T10:21:02Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right - I'd really have liked to see drafts submitted to the data tracker immediately before and after this refactor. It's very difficult to follow the changes on GitHub.",
          "createdAt": "2020-07-21T10:35:25Z",
          "updatedAt": "2020-07-21T10:35:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The previously submitted version is almost \"right before\" - there are only very few things that happened since then. If you want to submit the \"immediately after\" version now, please be my guest - I still have trouble with the tool chain for submission. Either way, what do you expect from this? See text shifts? It's not very interesting - it'll show you that things had the previous structure before, and the one above now. You won't see anything fascinating. If you're interested in what I've done beyond cut and paste, this shows it better:\r\nhttps://github.com/ietf-tapswg/api-drafts/commit/f0f4a5d84c2b0d8d659974d60f6dc656bde6d6f4\r\n(because it shows *just* that).",
          "createdAt": "2020-07-21T10:55:41Z",
          "updatedAt": "2020-07-21T10:55:41Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The restructure maybe isn't very interesting, but it makes it obscures the other changes. Lots of people looks at diffs in the datatracker. That's much easier if a restructuring is done with a new draft version that only does the restructuring, and doesn't include technical changes.\r\n\r\nAnd yes, I'd submit an update, but can't because the draft submissions are closed. Which is another reason why I thought we were waiting to do this restructuring.",
          "createdAt": "2020-07-21T11:07:31Z",
          "updatedAt": "2020-07-21T11:07:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aha. Well sorry, I thought it doesn't matter when the pre-update changes are so small; I understand now, you say \"lots of people\", so the concern is probably about folks who might complain for having a mix of tech changes and the structure update. As for the timing, it seems I misunderstood this too - Mirja had said that she wants something to be submitted immediately after the submission system re-opens. I thought the idea was for me to do the structure update now such that we can submit the post-restructuring version immediately upon re-opening (which we still can, we just shouldn't merge any PRs until then).\r\n\r\nEither way, I think that can be solved relatively easily by someone git-savvy. If the plan is to have a clean version submitted before re-structuring, then re-structure, then submit again, all we need to do is:\r\n1) roll the master back to a commit just before the three that I did to re-structure\r\n2) submit when the system is open,\r\n3) re-apply the three commits,\r\n4) submit again.\r\n\r\nI can roll back to a commit before the one I applied, and keep a copy of my latest version so I can re-apply them easily after someone submitted and tells me \"APPLY YOUR CHANGES NOW\". Should I?",
          "createdAt": "2020-07-21T11:30:59Z",
          "updatedAt": "2020-07-21T11:30:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't \"roll back\" the commit. I believe you can just check out an old version, build and tag that one for submission (on Sunday or Monday).",
          "createdAt": "2020-07-21T11:38:18Z",
          "updatedAt": "2020-07-21T11:38:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm. If I do that, my GUI (Sourcetree) tells me: \"Doing so will make your working copy a 'detached HEAD', which means you won't be on a branch anymore. If you want to commit after this you'll probably want to either checkout a branch again, or create a new branch. Is this ok?\"   - and indeed what I get looks like a new branch... this gets a bit confusing.\r\n\r\nI created two files now, by taking a copy of the latest version, locally resetting to the version before the updates, and taking another copy, and pushed them. These files are called \"draft-ietf-taps-interface_before_restructuring.md\" and \"draft-ietf-taps-interface_after_restructuring.md\", and they are just what they say - the version immediately before and after (the latter being the same as the most recent master commit).\r\n\r\nWhoever has a working submission toolchain can take these files, compile, and submit them, one after another.",
          "createdAt": "2020-07-21T12:53:07Z",
          "updatedAt": "2020-07-21T12:53:35Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @mirjak said. We can reconstruct this from the Git history without rolling anything back, provided we know the git revision numbers.",
          "createdAt": "2020-07-21T12:53:33Z",
          "updatedAt": "2020-07-21T12:53:33Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I always find it easiest to do a fresh git checkout of a particular version, rather than try to go back.",
          "createdAt": "2020-07-21T12:55:29Z",
          "updatedAt": "2020-07-21T12:55:29Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl Going from a detached head is fine. Just check out that commit, build, and submit. No big deal. I can do that too.",
          "createdAt": "2020-07-21T15:43:08Z",
          "updatedAt": "2020-07-21T15:43:08Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the last comments: thanks; that's all fine, but we now have these two files - \"draft-ietf-taps-interface_before_restructuring.md\" and \"draft-ietf-taps-interface_after_restructuring.md\", we can just submit those and stop debating how to best do this   :)    the current master is up-to-date (after restructuring), so we can just continue with it.",
          "createdAt": "2020-07-22T08:51:07Z",
          "updatedAt": "2020-07-22T08:51:07Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "YES Let's post the interim rev of the ID, and work on the next :-)",
          "createdAt": "2020-07-23T10:29:16Z",
          "updatedAt": "2020-07-23T10:29:16Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yay, I did it!  Submitting wasn't easy, I had a string of error dependencies... in the end, fixing a brew permission error resolved things for me and I could compile and submit. I have now deleted the two temporary files, \"draft-ietf-taps-interface_before_restructuring.md\" and \"draft-ietf-taps-interface_after_restructuring.md\", from the repository.",
          "createdAt": "2020-07-27T07:40:06Z",
          "updatedAt": "2020-07-27T07:40:06Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!\r\n\r\n(And I know your pain \u2013 the markdown drafts are not easy to build\u2026)",
          "createdAt": "2020-07-27T09:09:12Z",
          "updatedAt": "2020-07-27T09:09:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I gave the shifted sections a close read now, and found no more oddities. Now I think that even the text I quoted above (\"The simpler form of Send, which does not take any messageContext,\") actually fits where it is, because it elaborates on the example that's given above - basically saying that this is not the only way it could be done, the messageContext parameter could also be skipped.\r\n\r\nSo, I think the time has come to close this issue.",
          "createdAt": "2020-07-29T09:24:27Z",
          "updatedAt": "2020-07-29T09:24:27Z"
        }
      ]
    },
    {
      "number": 461,
      "id": "MDU6SXNzdWU1NTEzODU1NjY=",
      "title": "Connection Groups, Priority, and Cloning",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/461",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Section 11.1.3 of the API says about Priority:\r\n\"As noted in Section 6.4, this property is not\r\n   entangled when Connections are cloned.\"\r\nNot sure what this means. I though when you clone a connection you would actually take the priority of the cloned connection but then you can change it independently for each connection in a group. Or what's the priority after cloning? Back to the default of 100? We should say this explicitly. Or maybe you even want to provide the priority while cloning?\r\n\r\nActually looking at this now again, I think we would need to specify cloning a bit better anyway. I assume that calling clone() on a multiplexing capable connection would create a new stream; in case of quic is would only create local state but no on-the-wire singling. However if you call clone on a TCP connection, is that basically an initial() call that triggers the TCP handshake? We should say this explicitly. \r\n",
      "createdAt": "2020-01-17T12:22:33Z",
      "updatedAt": "2020-01-22T09:55:21Z",
      "closedAt": "2020-01-22T09:55:21Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd say it's exactly as you thought:\r\nWhen you clone a Connection, all Properties are copied (including the Priority), but then they are not entangled: If you change the Priority on the cloned Connection, the Priority on the original Connection stays as it was. If Priority was entangled, then it would change on both Connections if you change it on one of them.\r\nBut yes, perhaps this is confusing and the text should be more explicit.\r\n\r\nThe part on specifying cloning better: There's text on this in the Implementation draft on what happens with Clone() for each protocol. But maybe we can say in the API document that Clone() might trigger on-the-wire signaling or it might not, depending on the protocol.",
          "createdAt": "2020-01-18T12:47:06Z",
          "updatedAt": "2020-01-18T12:47:06Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, both additions/clarification would be good.",
          "createdAt": "2020-01-20T09:53:13Z",
          "updatedAt": "2020-01-20T09:53:13Z"
        }
      ]
    },
    {
      "number": 462,
      "id": "MDU6SXNzdWU1NTEzODY0OTc=",
      "title": "Timeout for Aborting Connection",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/462",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Section 11.1.4 in the API doc on Timeout for Aborting Connection says:\r\n\"The special value -1 means\r\n   that this timeout is not scheduled to happen.\"\r\nNot sure what this is supposed to say. Doesn't every protocol have some kind of timeout after which it will give up?",
      "createdAt": "2020-01-17T12:24:45Z",
      "updatedAt": "2020-02-21T16:06:12Z",
      "closedAt": "2020-02-21T16:06:12Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "UDP doesn't...  perhaps we should be explicit about this though, to avoid confusion, and add:\r\n(this can, e.g., be a valid choice in case of UDP)\r\n",
          "createdAt": "2020-01-22T10:11:22Z",
          "updatedAt": "2020-01-22T10:12:19Z"
        }
      ]
    },
    {
      "number": 466,
      "id": "MDU6SXNzdWU1NTE0MjA1Mjg=",
      "title": "Add state diagram to section \"Connection State and Ordering of Operations and Events\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/466",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Would be nice if someone has time to do some ascii art :-)",
      "createdAt": "2020-01-17T13:38:36Z",
      "updatedAt": "2020-04-17T09:29:23Z",
      "closedAt": "2020-04-17T09:29:23Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't that be fig. 4 in the architecture draft?\r\n\r\nExcept that, looking at this now, I see inconsistencies!  E.g., I don't see \"RendezvousDone\" in the figure. Also, instead of ConnectionReceived, it says \"Connection Received\" - rather, this should probably marked as an event by writing it as \"ConnectionReceived<>\". The figure is also missing InitiateWithSend() ... probably it would be good to make this figure both complete and consistent with section 13, \"Connection State and Ordering of Operations and Events\", of the API draft? I don't think very much is missing there.",
          "createdAt": "2020-01-22T10:09:40Z",
          "updatedAt": "2020-01-22T10:09:52Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be nice to have a real state diagram here, probably with states like \"closed\", \"open\" and \"listen\" and the events that create a transition between these state.",
          "createdAt": "2020-01-22T10:29:01Z",
          "updatedAt": "2020-01-22T10:29:01Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that Figure 4 in the Arch diagram serves the purpose that Mirja's trying to address with the state diagram in API.\r\n\r\nI also don't think we need FIgure 4 to align with the specific naming and CamelCasingConventions in API.",
          "createdAt": "2020-01-24T17:42:41Z",
          "updatedAt": "2020-01-24T17:42:41Z"
        }
      ]
    },
    {
      "number": 467,
      "id": "MDU6SXNzdWU1NTE0MjI0OTg=",
      "title": "own subsection for read-only properties?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/467",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial",
        "ready for text"
      ],
      "body": "To slightly more structure the long list of connection properties in the API doc we could at least have an own subsection for read-only properties...",
      "createdAt": "2020-01-17T13:42:37Z",
      "updatedAt": "2020-02-21T16:06:28Z",
      "closedAt": "2020-02-21T16:06:28Z",
      "comments": []
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWU1NTE0MjU3Njc=",
      "title": "Clean up appendix of API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/468",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Note: I'm putting this issue in mostly so we remember to discuss at the interim. \r\n\r\nActions are:\r\n1) I think we need to decide what to do about \"Cost Preferences\" and then (re)move Appendix B\r\n\r\n2) Appendix C can probably be removed or we should point to Theresa's implementation instead (I'm not indicating that Theresa owns this implementation or that she is the only implementor but I think people know what I mean)\r\n\r\n3) Clean up Appendix D (Michael? :-) )",
      "createdAt": "2020-01-17T13:49:15Z",
      "updatedAt": "2020-01-17T15:01:12Z",
      "closedAt": "2020-01-17T15:01:12Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Appendix D: I ACK that I'll to do whatever's needed - but just out of curiosity, what do you mean with \"clean up\"? I thought it's reasonably clean as it is... of course there may need to be a cleaning pass at the end due to all the changes we're now doing, which may have quite some influence on all the backward references. No problem, I'll fix those. But what else?",
          "createdAt": "2020-01-17T14:33:03Z",
          "updatedAt": "2020-01-17T14:33:03Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... that said, I think you mean the minset appendix with appendix D? I think this is appendix C, I can't see an appendix D. Similarly, with C you probably mean B.",
          "createdAt": "2020-01-17T14:36:02Z",
          "updatedAt": "2020-01-17T14:36:02Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, it turn out that I looked that the -05 version in the datatracker... too many browser taps...\r\n\r\nSo I guess you did this already and the part about cost preference is also resolved. So I'll close this issue and have a separate for Appendix B (Sample code in Go).",
          "createdAt": "2020-01-17T15:01:12Z",
          "updatedAt": "2020-01-17T15:01:12Z"
        }
      ]
    },
    {
      "number": 469,
      "id": "MDU6SXNzdWU1NTE0NjQ4NjY=",
      "title": "Do we want to keep appendix about Go sample implementation in API doc?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/469",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Do we want to keep appendix B and if so should it point to Theresa's implementation instead (I'm not indicating that Theresa owns this implementation or that she is the only implementor but I think people know what I mean)?",
      "createdAt": "2020-01-17T15:02:52Z",
      "updatedAt": "2020-01-25T07:12:44Z",
      "closedAt": "2020-01-25T07:12:44Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Sorry for a stupid question: Why is this API - not implementation?",
          "createdAt": "2020-01-18T11:39:57Z",
          "updatedAt": "2020-01-18T11:39:57Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess originally this was supposed to illustrate a concrete example of an API based on our abstract interface.\r\nNow that we have actual implementations, to which we refer in an Appendix of the Implementation draft, maybe we can get rid of the Go sample API. It has become out of sync with the drafts anyway.",
          "createdAt": "2020-01-18T15:21:48Z",
          "updatedAt": "2020-01-18T15:21:48Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, this was meant to illustrate the API before it was defined. I'll cut it.",
          "createdAt": "2020-01-18T17:35:03Z",
          "updatedAt": "2020-01-18T17:35:03Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWU1NTE3ODc0MTQ=",
      "title": "Arch: \"the ability to easily adopt different transport protocols\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/470",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "editorial"
      ],
      "body": "In Section 1.2, Overview, the architecture draft says that TAPS offers \"the ability to easily adopt different transport protocols\".\r\nWhat does \"adopt\" mean here?\r\n\r\nI guess this relates to Section 2.3 (maybe say that explicitly here), but even after reading this Section, I don't quite understand why \"adopt\". Is the point here that a flexible interface makes it easier to add support for new protocols? Then perhaps we should say this here.",
      "createdAt": "2020-01-18T16:00:24Z",
      "updatedAt": "2020-01-20T23:05:25Z",
      "closedAt": "2020-01-20T23:05:25Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It means that applications don't need to rewrite a ton of code or adopt a new library to access a new transport protocol. In how I read it, \"adopt\" captures that, but if there's some other text you would like to suggest, that's fine.",
          "createdAt": "2020-01-18T19:15:01Z",
          "updatedAt": "2020-01-18T19:15:01Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For me \"adopt\" is fine as it should be clear from the rest of the doc. However, if we want to be more clear we could say \"make use of different protocols without the need to change the interface\" or something...?",
          "createdAt": "2020-01-20T10:12:45Z",
          "updatedAt": "2020-01-20T10:12:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, merged!",
          "createdAt": "2020-01-20T23:05:25Z",
          "updatedAt": "2020-01-20T23:05:25Z"
        }
      ]
    },
    {
      "number": 471,
      "id": "MDU6SXNzdWU1NTE3ODgzMTE=",
      "title": "Arch: Consistency of \"Transport Services system\" and \"Transport System\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/471",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "editorial",
        "ready for text"
      ],
      "body": "In the architecture document, I noticed that we sometimes say \"Transport Services system\" and sometimes \"Transport System\". Are these the same?\r\nAre \"Transport Services implementation\" and \"Transport System implementation\" the same, too?",
      "createdAt": "2020-01-18T16:07:37Z",
      "updatedAt": "2020-01-22T20:45:42Z",
      "closedAt": "2020-01-22T20:45:41Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prefer \"Transport Services system\" and \"Transport Services implementation\"",
          "createdAt": "2020-01-18T19:13:49Z",
          "updatedAt": "2020-01-18T19:13:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I find it long and clumsy  :(\r\nSide note: we'll have to rename it everywhere in the API draft too if we go with this.",
          "createdAt": "2020-01-22T10:01:59Z",
          "updatedAt": "2020-01-22T10:01:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "was this fixed by #482?",
          "createdAt": "2020-01-22T20:16:41Z",
          "updatedAt": "2020-01-22T20:16:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes it was. We already used Transport Services *most places* so it's not all that different.",
          "createdAt": "2020-01-22T20:45:41Z",
          "updatedAt": "2020-01-22T20:45:41Z"
        }
      ]
    },
    {
      "number": 472,
      "id": "MDU6SXNzdWU1NTE3ODkxNDk=",
      "title": "Arch: 4.2.3 could be misinterpreted as connection migration",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/472",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "In the architecture document, I think Section 4.2.3 Protocol Stack Equivalence could be misinterpreted to mean connection migration, i.e., changing network paths or protocol stacks during the lifetime of a single Connection.\r\n\r\n\"The Transport Services architecture defines a mechanism that allows applications to easily use different network paths and Protocol Stacks. In some cases, changing which Protocol Stacks or network paths are used will require updating the preferences expressed by the application that uses the Transport Services system.\"\r\nIt says \"use different network paths and Protocol Stacks\" and talks about changing these, but it does not say in what context or over what timeframe.\r\n\r\nMaybe here it would help to say something like \"The Transport Services architecture defines a mechanism that allows applications to easily use different network paths and Protocol Stacks for their Connections or start using new protocols as they get implemented, without requiring major changes to the applications\".",
      "createdAt": "2020-01-18T16:14:19Z",
      "updatedAt": "2020-02-24T14:14:29Z",
      "closedAt": "2020-02-24T14:14:29Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, sounds good",
          "createdAt": "2020-01-18T19:13:09Z",
          "updatedAt": "2020-01-18T19:13:09Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think there's any particular reason a future transport shouldn't renegotiate paths and stack components on the fly (but then again I think the future of the Internet will see endpoints using TLS/TCP/IPv4 *only* to establish cryptographic and routing state, then dynamically negotiating connectivity beyond that, i.e. \"legacy Internet as a bootstrap protocol alone\" so my opinion should probably be regarded as a minority one and best ignored. :) )",
          "createdAt": "2020-01-22T20:15:42Z",
          "updatedAt": "2020-01-22T20:15:42Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to Brian but I guess I was sharing an office with him for too long ;-)",
          "createdAt": "2020-01-22T22:07:40Z",
          "updatedAt": "2020-01-22T22:07:40Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So... This is a case where I wouldn't wish to speculate. It was controversial in the lead-up to TAPS for various reasons, and I'd really encourage we do not start thinking in this RFC about how that may turn in future. \r\n\r\nI do like Theresa's new para above. I would argue not to add more.",
          "createdAt": "2020-02-21T15:27:44Z",
          "updatedAt": "2020-02-21T15:27:44Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for fixing!",
          "createdAt": "2020-02-24T14:14:29Z",
          "updatedAt": "2020-02-24T14:14:29Z"
        }
      ]
    },
    {
      "number": 475,
      "id": "MDU6SXNzdWU1NTE3OTI4Njk=",
      "title": "Arch: UDP checksums as protocol-specific property?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/475",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "The architecture draft uses UDP checksums as an example of a protocol-specific property in Section 3.2 and 4.1.2.\r\nI find this a bit confusing because in the Interface draft, checksum coverage is a Generic Connection Property (Section 11.1.2).\r\nShould we maybe use a different example of a protocol-specific property, such as the TCP User Timeout we have in the Interface draft?",
      "createdAt": "2020-01-18T16:42:05Z",
      "updatedAt": "2020-01-23T19:01:43Z",
      "closedAt": "2020-01-23T19:01:43Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, we can switch the example around",
          "createdAt": "2020-01-18T19:12:12Z",
          "updatedAt": "2020-01-18T19:12:12Z"
        }
      ]
    },
    {
      "number": 476,
      "id": "MDU6SXNzdWU1NTE3OTM2NDQ=",
      "title": "Arch: service class influences protocol selection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/476",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "In the architecture document, in Section 4.1.2 under \"Selection Properties\", we have text saying: \r\n\"Examples of options that influence protocol selection and configuration of transport protocol features include reliability, service class [\u2026]\"\r\nWhy service class? \r\nFor me service class sounds like setting DSCP code points, and that does not sound like something that would influence protocol selection or path selection.\r\n\r\nMaybe we should remove this example or, if there's a specific case in which service class influences selection, reference it?",
      "createdAt": "2020-01-18T16:47:31Z",
      "updatedAt": "2020-02-24T14:15:46Z",
      "closedAt": "2020-02-24T14:15:46Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "If service class maps to offered PvD then it would be a valid example ... Although I also expect it would map to DSCP ... the two are not exclusive.",
          "createdAt": "2020-01-18T18:41:17Z",
          "updatedAt": "2020-01-18T18:41:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure we want to go into examples, but service class of traffic can certainly influence path selection. If I know I have a path that's well optimized for VoIP traffic (perhaps its a dedicated PvD, or perhaps it just has properties that work well), and another that's well optimized for bulk throughput, I may prefer paths differently.",
          "createdAt": "2020-01-18T19:06:32Z",
          "updatedAt": "2020-01-18T19:06:32Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also: if the endpoint knows that one network is org-private and will actually honor DSCP markings, and that another traverses unknown-topology Internet paths and will probably strip them, then setting AF4 is a hint that maybe the app wants to use the org-private network...",
          "createdAt": "2020-01-21T10:46:42Z",
          "updatedAt": "2020-01-21T10:46:42Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Interesting thought, but I think the IETF should actively discourage that sort of forwarding treatment. I'd hope we wouldn't have an example of this one. \r\nThe LE PHB is a little odd in this respect, in that it call for \"less\" than Default treatment - upgrading to Default is likely less desirable than choosing a path that does support LE, so it could be an example, although I'd really prefer not. \r\n",
          "createdAt": "2020-01-21T17:19:59Z",
          "updatedAt": "2020-01-21T17:19:59Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me flip this around: is there a compelling reason that the architecture should forbid an implementation to use service class in protocol stack and path selection?",
          "createdAt": "2020-01-22T20:12:25Z",
          "updatedAt": "2020-01-22T20:12:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't want to prevent it!",
          "createdAt": "2020-01-22T20:46:22Z",
          "updatedAt": "2020-01-22T20:46:22Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "If that automates DSCP selection, I think this is the wrong thing to say in this document. \r\nIf the example were PvD-based, then that would be the correct thing.",
          "createdAt": "2020-01-23T07:58:38Z",
          "updatedAt": "2020-01-23T07:58:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We'll just remove the words \"service class\"",
          "createdAt": "2020-01-24T17:46:53Z",
          "updatedAt": "2020-01-24T17:46:53Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "OK, and Issue #494 suggests to remove recommending EF in favour of explaining EF can be used.",
          "createdAt": "2020-01-27T10:52:39Z",
          "updatedAt": "2020-01-27T10:52:39Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2020-02-24T14:15:46Z",
          "updatedAt": "2020-02-24T14:15:46Z"
        }
      ]
    },
    {
      "number": 477,
      "id": "MDU6SXNzdWU1NTE5MzYwNDk=",
      "title": "Is format of message an implementation detail?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/477",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "MaxF12"
      ],
      "labels": [
        "API"
      ],
      "body": "In section 7.1 of API it says:\r\n\r\n> Message data is transferred as an array of bytes, and the resulting object contains both the byte array and the length of the array.\r\n`messageData := \"hello\".bytes()\r\n Connection.Send(messageData)`\r\n\r\nFor some languages that are dynamic typed (i.e. python) this limits the usability of the API as it adds an unnecessary extra step to each send.\r\nTo me this seems like it should be an implementation detail and not specified in the API.",
      "createdAt": "2020-01-19T15:10:56Z",
      "updatedAt": "2020-05-31T20:25:27Z",
      "closedAt": "2020-05-31T20:25:27Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What are the options other than raw bytes?",
          "createdAt": "2020-01-19T22:48:33Z",
          "updatedAt": "2020-01-19T22:48:33Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "In python you could just pass any type that gets automatically converted inside the API. For example, in our implementation you could just pass a string or integer that gets converted to bytes inside the implementation before sending.\r\nAlso, if there is a TLV framer, you could just pass a [type,value] tuple without having to go through the message context.",
          "createdAt": "2020-01-19T23:08:03Z",
          "updatedAt": "2020-01-19T23:26:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We generally consider this a case for framers. However, I think it's reasonable to assume that any of the objects used in a TAPS implementation should provide some way for the app to get at the underlying bytes (and therefore, at least implicitly, the length). I don't read this text as prohibiting the use of some object that is `bytes()`able.",
          "createdAt": "2020-01-22T20:22:17Z",
          "updatedAt": "2020-01-22T20:22:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this is an implementation detail that's irrelevant to the abstract API. Can we close this issue?",
          "createdAt": "2020-04-17T11:38:15Z",
          "updatedAt": "2020-04-17T11:38:15Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Requiring the data be accessible as a byte array is overly restrictive. Can we just remove \"Message data is transferred as an array of bytes, and the resulting object contains both the byte array and the length of the array.\" and the `messageData := \"hello\".bytes()` call?",
          "createdAt": "2020-04-17T15:40:28Z",
          "updatedAt": "2020-04-17T15:40:28Z"
        }
      ]
    },
    {
      "number": 486,
      "id": "MDU6SXNzdWU1NTQzMDUzMjk=",
      "title": "Appendix A.1. / Adding preference properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/486",
      "state": "CLOSED",
      "author": "theagilepadawan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "A.1. states: \r\n\r\n*\"As Selection Properties of type Preference will be added to a TransportProperties object quite frequently, implementations should provide special actions for adding each preference level i.e, TransportProperties.Add(some_property, avoid) is equivalent to TransportProperties.Avoid(some_property)\"*\r\n\r\nAs a TransportProperties object constitutes of Selection, Connection and Message Properties objects, I think it's more natural to make the action of adding a preference part of the API for Selection Properties: \r\n```TransportProperties.SelectionProperties.Avoid(some_property)```",
      "createdAt": "2020-01-23T17:40:08Z",
      "updatedAt": "2020-04-14T17:52:30Z",
      "closedAt": "2020-04-14T17:52:30Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems that, at least for now, only Selection Properties are of type \"Preference\". So indeed, this could streamline things a bit.",
          "createdAt": "2020-02-25T13:55:54Z",
          "updatedAt": "2020-02-25T13:55:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On second thought, this strikes me as an unnecessary detail. I don't think we have \"TransportProperties.SelectionProperties\", \"TransportProperties.MessageProperties\" etc. defined - we just have the categories represented by the document structure and headings. Of course, we could now go all the way and specify a namespace hierarchy as you describe here, but I don't think this is worth it.\r\n\r\nThat said, I think what you say does make more sense for implementations; but implementing it as you describe should be okay, as the code examples in the draft are just that - examples.",
          "createdAt": "2020-04-14T13:21:15Z",
          "updatedAt": "2020-04-14T13:21:15Z"
        }
      ]
    },
    {
      "number": 489,
      "id": "MDU6SXNzdWU1NTQ4NTg1NTc=",
      "title": "Fig. 4: fix terminology mismatch with API sec. 12",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/489",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "Fig. 4 isn't fully consistent with sec. 12 in the API document.\r\n\r\nA few things that stood out to me:\r\n- InitiateWithSend() is missing. I can see that this isn't trying to cover everything, but randomly leaving some things out makes it all a bit confusing IMO...\r\n- \"Connection Received\" reads as if it should really be the \"ConnectionReceived<>\" event in the API doc. So I would put these events there and use the \"<>\" to indicate them.\r\n- Same with \"Closed\"... this is actually an event, so why not write it as such, with the \"<>\"?\r\n- RendezvousDone is missing... should we include all events or not? Of course that would then also require adding Sent, Received, ...  maybe it would be better to indicate that events are events, but put a statement somewhere saying that not all events are shown.\r\n- In the same vein, I would replace \"Connection Ready\" with \"Ready<>\"\r\n- \"Conn. Finished\" reads as if it might be an event, but this event doesn't exist... I would just remove this\r\n",
      "createdAt": "2020-01-24T17:19:47Z",
      "updatedAt": "2020-01-27T09:37:05Z",
      "closedAt": "2020-01-27T09:37:05Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've added InitiateWithSend(), and removed Conn. Finished; you're right, these are confusing.\r\n\r\nThis diagram does not use the API draft's event notation, and I'm not sure it makes sense to introduce it here -- it would require a bit more expository text only to make a diagram that is an attempt to provide a high-level view provide a... less high-level view. (The expository text now says \"... some actions ... have been omitted for brevity and simplicity\" and I think that's the right approach.)\r\n\r\n",
          "createdAt": "2020-01-24T19:54:25Z",
          "updatedAt": "2020-01-24T19:54:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed!",
          "createdAt": "2020-01-25T07:09:35Z",
          "updatedAt": "2020-01-25T07:09:35Z"
        }
      ]
    },
    {
      "number": 494,
      "id": "MDU6SXNzdWU1NTU0OTQ2NzA=",
      "title": "Comments on DSCP text",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/494",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "- This issue comes from other discussion at the interim of what it means to map to DSCP classes, and proposes to fix two topics. \r\n- Replace reference\r\nOLD:\r\nDSCP Less than Best Effort [LE-PHB] PHB\r\nNEW:\r\nDSCP Less than Best Effort [RFC8622] PHB\r\n\u2014\r\nLow Latency/Interactive:\r\n- The current advice is wrong. An endpoint never should be assigning EF without understanding the implication of CAC and policing.\r\nOLD:\r\nTransport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign the DSCP Expedited Forwarding [RFC3246] PHB; \r\nNEW:\r\nTransport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing  SHOULD assign a DSCP Assured Forwarding (AF41,AF42,AF43,AF44) [RFC2597] PHB. Inelastic traffic that is expected to conform to the configured network service rate could be mapped to the DSCP Expedited Forwarding [RFC3246] or [RFC5865] PHBs.\r\n\u2014",
      "createdAt": "2020-01-27T10:50:33Z",
      "updatedAt": "2020-03-27T08:03:38Z",
      "closedAt": "2020-03-27T08:03:37Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "The new text resolve this issue.",
          "createdAt": "2020-03-27T08:03:37Z",
          "updatedAt": "2020-03-27T08:03:37Z"
        }
      ]
    },
    {
      "number": 507,
      "id": "MDU6SXNzdWU1NjkwNTgxNjI=",
      "title": "More text on clone",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/507",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Currently the \"Clone\" part of, e.g., TCP (section 10.1) only says:\r\n\"Calling Clone on a TCP Connection creates a new Connection with equivalent parameters. The two Connections are otherwise independent.\"\r\n\r\nThis text should reflect that equivalent behavior must be maintained upon later Connection configuration calls. And, there should be more text in general on cloning (see issue #441).\r\n",
      "createdAt": "2020-02-21T16:32:05Z",
      "updatedAt": "2020-12-11T16:18:51Z",
      "closedAt": "2020-12-11T16:18:51Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This text must refer to a new \"do I want a Connection that supports initiate followed by listen?\" property. This property will be added to address #508 - so I'll address this issue when the PR addressing #508 has landed.",
          "createdAt": "2020-03-04T13:13:39Z",
          "updatedAt": "2020-03-04T13:13:39Z"
        }
      ]
    },
    {
      "number": 508,
      "id": "MDU6SXNzdWU1NjkwNjkxMzE=",
      "title": "Discuss interaction between Listen() and ListenClone()",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/508",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "- Should ListenClone() fail for non-multiplexed transports\r\n- How to specify if a top-level listener can accept cloned (multiplexed) streams\r\n- Should ListenClone() be called ListenForClone()...?",
      "createdAt": "2020-02-21T16:52:53Z",
      "updatedAt": "2020-07-21T09:09:30Z",
      "closedAt": "2020-07-21T09:09:30Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a note to say that issue #507 waits for this issue to be addressed.",
          "createdAt": "2020-06-03T11:54:30Z",
          "updatedAt": "2020-06-03T11:54:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- Rename function\r\n- Trying to do this without a multiplexing transport should fail",
          "createdAt": "2020-06-19T15:24:15Z",
          "updatedAt": "2020-06-19T15:24:15Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping: issue #507 is waiting for this...",
          "createdAt": "2020-07-03T08:47:35Z",
          "updatedAt": "2020-07-03T08:47:35Z"
        }
      ]
    },
    {
      "number": 509,
      "id": "MDU6SXNzdWU1NzM4NTAzNzY=",
      "title": "ReceiveHandler per Receive?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/509",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Apple does this: https://developer.apple.com/documentation/network/nwconnection/2998572-receive\r\n\r\n...and it may be more convenient than what we currently have (or do we have it unspecified?  **My** interpretation of our text would have been to use only one receive handler associated to the Connection). E.g., if an application expects 3 different types of messages to be received in sequence, it can hand over three different receive handlers in Apple's case, and that seems useful.\r\n\r\nApple also has a \"completion\" handler per sent event, handed over as a parameter to \"send\". Is this necessary? Who needs 3 different \"Sent\" handlers for 3 different messages - shouldn't the \"sent\" handler rather be a singular per-Connection thing?",
      "createdAt": "2020-03-02T09:52:17Z",
      "updatedAt": "2020-06-19T15:07:13Z",
      "closedAt": "2020-06-19T15:07:13Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this gets into an implementation-specific area. If the language has an easy way to provide a unique completion/closure for a given invocation of Receive(), then I think it is preferable to do this to having a single function.\r\n\r\nIf anything, it may be nice to make a not for Received() and Sent() that they should, if supported by the language, provide this kind of linking between calls and events.",
          "createdAt": "2020-06-03T23:01:05Z",
          "updatedAt": "2020-06-03T23:01:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, and I assign this to Tommy since he offered (in an email) to write text. Thanks a lot!",
          "createdAt": "2020-06-04T07:24:34Z",
          "updatedAt": "2020-06-04T07:24:34Z"
        }
      ]
    },
    {
      "number": 510,
      "id": "MDU6SXNzdWU1NzM4NTM0OTg=",
      "title": "Combine some errors?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/510",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial",
        "ready for text"
      ],
      "body": "On a PreConnection, an application uses EITHER Initiate OR Listen OR Rendezvous. Therefore, it seems unnecessary to distinguish between three types of errors. Shouldn't we have a general per-PreConnection \"UnfulfilledError\" instead of the InitiateError + ListenError + RendezvousError, just to shorten things a bit?\r\n\r\nAn application needs more details (reasons), but it gets them as a parameter anyway when the new \"UnfulfilledError\" would occur.",
      "createdAt": "2020-03-02T09:57:23Z",
      "updatedAt": "2020-07-13T17:57:33Z",
      "closedAt": "2020-07-13T17:57:33Z",
      "comments": []
    },
    {
      "number": 515,
      "id": "MDU6SXNzdWU1NzYwOTg1Njg=",
      "title": "Bandwidth Efficiency as a term in API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/515",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I am going to query  /bandwidth efficiency/ - since this sounds like it should be measured in b/Hz, which isn't at all what this draft are talking about. In fact, I did not see anything in the text about the efficiency or the use of bandwith ... as I read, it is all about capacity sharing tradeoffs.\r\n\r\nI suspect the tyerm should be \"capacity-seeking\" or we just say latency-seeking rather than capacity-seeking? \r\n\r\n--\r\nAnd while I am digging here ... how about /to use multiple paths in parallel in order to maximize bandwidth/to use multiple paths in parallel in  maximize use of available capacity/.\r\n",
      "createdAt": "2020-03-05T09:09:47Z",
      "updatedAt": "2020-04-07T09:48:15Z",
      "closedAt": "2020-04-07T09:48:15Z",
      "comments": []
    },
    {
      "number": 516,
      "id": "MDU6SXNzdWU1Nzc3NDUxNDg=",
      "title": "More protocol-specific properties?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/516",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "future work",
        "help wanted"
      ],
      "body": "I suspect that we need more protocol-specific properties to be able to talk to various kinds of native protocol peers (other than TCP and UDP: these should already work fine with what we have, I believe).\r\n\r\nA concrete example: we're hiding stream numbers. In NEAT, we needed to make them configurable though, because we wanted a NEAT client to be able to talk to a native SCTP server, where an application may expect certain type of data to arrive via a certain stream number. I suspect that we may need something similar for a QUIC peer.\r\n\r\n- Should we address this?  (I'd say yes)\r\n- How .. is it a protocol-specific (per-Message) property?   (I'd say yes... and perhaps a per-Connection property too, with text explaining that the per-Message one automatically becomes the Connection default unless otherwise specified)\r\n- What other such things are we missing... what other expectations may e.g. a native QUIC or SCTP application have that we just cannot fulfil with our current system?",
      "createdAt": "2020-03-09T08:47:49Z",
      "updatedAt": "2020-05-29T16:23:57Z",
      "closedAt": "2020-05-29T16:23:57Z",
      "comments": []
    },
    {
      "number": 517,
      "id": "MDU6SXNzdWU1NzgwNDAzNTY=",
      "title": "Inconsistencies in text realted to selection algorithm and racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/517",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "The text on the selection algorithm is not fully consistent with the text on racing, as it is written as if the entire tree is available. NOticed this as we moved text to the implementation draft as a result of #429 .",
      "createdAt": "2020-03-09T16:40:24Z",
      "updatedAt": "2021-04-09T14:47:39Z",
      "closedAt": "2021-04-09T14:47:39Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "possibly overtaken by events...",
          "createdAt": "2021-02-26T16:55:51Z",
          "updatedAt": "2021-02-26T16:55:51Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue was overtaken by events and can be closed with no action.",
          "createdAt": "2021-04-09T14:47:39Z",
          "updatedAt": "2021-04-09T14:47:39Z"
        }
      ]
    },
    {
      "number": 518,
      "id": "MDU6SXNzdWU1ODg0NjM1MjI=",
      "title": "Architecture NiT: /assumes/",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/518",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "ready for text"
      ],
      "body": "I think the word /assumes/ is not a good choice of word in the arch draft.\r\nOLD:\r\nand it assumes an implementation that can use multiple IP addresses,\r\nmultiple protocols, multiple paths, and provide multiple application streams\r\nNEW:\r\nand it can provide benefit when an implementation can use multiple IP\r\naddresses, multiple protocols, multiple paths, and provide multiple\r\napplication streams.",
      "createdAt": "2020-03-26T14:28:15Z",
      "updatedAt": "2020-04-17T16:25:00Z",
      "closedAt": "2020-04-17T16:25:00Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done",
          "createdAt": "2020-04-17T16:25:00Z",
          "updatedAt": "2020-04-17T16:25:00Z"
        }
      ]
    },
    {
      "number": 519,
      "id": "MDU6SXNzdWU1ODg5NTQzMjE=",
      "title": "Architecture: normative arch language",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/519",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "Overall review: I think we need to keep the normative language for the key features that differentiate the API. I'd really like to use REQUIRED, RECOMMENDED, rather MUST and SHOULD - because these are not protocol operation requirements, but are implementation requirements to conform. This includes requirements based on Minset - where the WG dervied this API: This is after all why the WG worked on Minset as the basis of the API.\r\n\r\nI suggest we group all the requirements on architecture as short one or two sentence blocks (preferably as a bullet or definition list) collected into a single subsection, so they are easy to find and read and we say that these are the key architectural requirements. \r\n\r\nWe insert this new requirements text either their own section, or in section 1.3 (although I am open to other places where we can call-out the architectural requirements).\r\n\r\n----\r\n\r\nThe following are key requirements, that define the TAPS architecture:\r\n\r\n* It is RECOMMENDED that functionality that is common across multiple transport protocols is made accessible through a unified set of TAPS interface calls. As a baseline, a Transport Services system interface is REQUIRED to allow access to the minimal set of features offered by transport protocols {{?I-D.ietf-taps-minset}}.\r\n\r\n* A Transport Services system automates the selection of protocols and features and network, based on a set of Properties supplied through the TAPS interface. It is RECOMMENDED that a Transport Services system offers Properties that are common to multiple transport protocols. Specifying common Properties enables a system to appropriately select between protocols that offer equivalent features. This design permits evolution of the transport protocols and functions without affecting the programs using the system.\r\n\r\n* Specifying common Properties enables a Transport Services system to appropriately select an appropriate network interface. It is RECOMMENDED that a system offers Properties that are common to a variety network layer interfaces and paths. This design permits racing of different network paths without affecting the programs using the system.\r\n\r\n* Applications using the Transport Services system interface are REQUIRED to be robust to the automated selection provided by the system, including the possibility to express requirements and preferences that constrain the choices that can be made by the system. \r\n\r\n* If two different Protocol Stacks can be safely swapped, or raced in parallel (see Section 4.2.2), by the Transport Services system then they are considered to be \"equivalent\". Equivalent Protocol Stacks need to meet the requirements for racing  specified  in  section XX.\r\n\r\n* Applications using a Transport Services system MAY explicitly require or prevent the use of specific transport features (and transport protocols) and XXXinterfaces using the \"REQUIRED\" and \"PROHIBIT\" preferences. This allows an application to constrain the set of protocols and features that will be selected for the transport service. It is RECOMMENDED that the default usage by applications does not necessarily restrict this selection, so that the system can make informed choices (e.g., based on the availability of interfaces or set of transport protocols available for the specified remote endpoint).\r\n\r\n* When a Transport Services system races between two different Protocol Stacks, both SHOULD use the same security protocols and options. However, a Transport Services system MAY race different security protocols, e.g., if the application explicitly specifies that it considers them equivalent.\r\n\r\n* Transport Services systems MUST NOT automatically fall back from secure protocols to insecure protocols, or to weaker versions of secure protocols. A Transport Services system MAY allow applications to specify that fallback to a specific other version of a protocol is allowed.\r\n\r\n* It is RECOMMENDED that in normal use, a Transport Services system is designed so that all selection decisions result in consistent choices for the same network conditions when they have the same set of preferences. This is intended to provide predictable outcomes to the application using the transport service.\r\n\r\n---\r\n\r\nI would then suggest to use lower case within other parts of the document - except were pointed to from here,  (we could refer to the requirements subsection, if we thought necessary).",
      "createdAt": "2020-03-27T07:57:32Z",
      "updatedAt": "2020-05-26T17:55:52Z",
      "closedAt": "2020-05-26T17:55:52Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "for discussion at the interim, but IMO we could start the interim with a PR based on these suggestions and work from there.",
          "createdAt": "2020-04-06T13:14:34Z",
          "updatedAt": "2020-04-06T13:14:34Z"
        }
      ]
    },
    {
      "number": 520,
      "id": "MDU6SXNzdWU1OTI1OTU0ODc=",
      "title": "Reliable Data Transfer (Message) default - from Kyle Rose's review",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/520",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "List discussion:\r\n\r\n**Kyle:**\r\n> 7.4.7. Reliable Data Transfer (Message)\r\n> \r\n> * The default isn't \"true\", it's whatever the underlying connection had, right?\r\n> \r\n\r\n**@philsbln**:\r\n>  Ack\r\n\r\n**@mwelzl**:\r\n\r\n> I agree too, but doesn\u2019t this warrant some more discussion?\r\n> I think our defaults all translate into things that can work in some way when TCP is used - with \u201cReliable Data Transfer\u201d being an exception, as it just can\u2019t work in a UDP-only system. Are there others?  I think I\u2019ll open an issue for this one.\r\n> \r\n\r\n**@gorryfair**:\r\n\r\n> I don't agree at all - To me this was just the default behaviour of the API.\r\n> \r\n> I think the default needs to be \"reliable\" and an app will have to over-ride that to get datagram/unreliable operation. That doesn't mean if you have only UDP (for instance) that you can't offer TAPS, to me it simply means you always need to say that the app wants this service.",
      "createdAt": "2020-04-02T12:32:22Z",
      "updatedAt": "2020-04-17T09:27:24Z",
      "closedAt": "2020-04-17T09:27:24Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the conclusion of @gorryfair above - in which case we should leave things as they are. Other views?",
          "createdAt": "2020-04-02T12:33:16Z",
          "updatedAt": "2020-04-02T12:33:16Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that if the application does nothing then communication should be reliable. But I understand Kyle's comment as asking about the relationship to the selection property Reliable Data Transfer (Connection). If you for example set that to Avoid and the TAPS system selects SCTP as the protocol, then if you do not set Reliable Data Transfer (Message) on a message I assume it will be sent as an unreliable message. So in that sense the reliability of a message defaults to whatever is set for the connection, unless it is overridden by setting Reliable Data Transfer (Message). \r\n\r\nAnd the default for Reliable Data Transfer (Connection) is Require so what @gorryfair writes still holds but it is a different thing.",
          "createdAt": "2020-04-02T22:58:18Z",
          "updatedAt": "2020-04-02T23:05:05Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So if we agree upon Reliable Data Transfer (Connection), then it would seem less confusing for Reliable Data Transfer (Message) - to use the same logic. Does an apps writer need to know the data will be sent as an unreliable message? \r\n(I'm not sure I like \"avoid reliable data transfer\" as a meaningful concatenation of keywords BTW:-).",
          "createdAt": "2020-04-03T06:43:44Z",
          "updatedAt": "2020-04-03T06:43:44Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's see what needs to be done. Suggestion: the only textual change would be to add the following, at the beginning of Section 7.5, just before \"The following Message Properties are supported\":\r\n\r\n\"Connection Properties describe the default behavior for all Messages on a Connection. If a Message Property contradicts a Connection Property, it overrides the Connection Property for the specific Message. For example, if \"Reliable Data Transfer (Connection)\" is set to \"Avoid\" and a protocol with configurable per-Message reliability is used, setting \"Reliable Data Transfer (Message)\" to \"Prefer\" for a particular Message will ensure that this Message is reliably delivered. If the underlying protocol can not support this per-Message behavior, this Message Property choice will yield an error.\"",
          "createdAt": "2020-04-03T10:16:38Z",
          "updatedAt": "2020-04-03T10:16:38Z"
        }
      ]
    },
    {
      "number": 521,
      "id": "MDU6SXNzdWU1OTI2NjEwMDA=",
      "title": "IANA registry of property names or namespaces - from Kyle Rose's review",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/521",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "List discussion:\r\n\r\n**Kyle**:\r\n>  If we're not currently asking IANA to create a registry of property names or namespaces, should we provide a recommendation that such symbols not listed explcitly in this document be prefixed with some experimental identifier?\r\n\r\n**@philsbn**:\r\n> The IANA registry question was explicitly postponed, be maybe we should re-iterate it now.\r\n> The idea of having an \u201ex\u201c namespace was rejected in fear we end up with quasi-standard properties that have an x prefix then. \r\n> \r\n\r\n**Kyle**:\r\n> Which is worse? A complete free-for-all, or a recommendation to have the free-for-all confined to an X- namespace? Do properties starting with X- just offend engineering sensibilities?\r\n> \r\n> One \"right\" alternative is a documentation-required registry, but does that raise the bar too high? How about a TAPS wiki as a compromise? The important outcome is that properties be well-defined and not conflict with each other. Since these properties have entirely local effects (e.g., they don't get encoded as options and transmitted to the peer), we probably don't need the level of precision motivating option registries, for instance. Is there precedent at the IETF for a registry mechanism less formal that what IANA provides?\r\n> ",
      "createdAt": "2020-04-02T14:07:31Z",
      "updatedAt": "2020-06-19T15:35:18Z",
      "closedAt": "2020-06-19T15:35:18Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Anyone have any thoughts on this one?\n\n\nOn Thu, Apr 2, 2020 at 10:07 AM mwelzl <notifications@github.com> wrote:\n\n> List discussion:\n>\n> *Kyle*:\n>\n> If we're not currently asking IANA to create a registry of property names\n> or namespaces, should we provide a recommendation that such symbols not\n> listed explcitly in this document be prefixed with some experimental\n> identifier?\n>\n> *@philsbn*:\n>\n> The IANA registry question was explicitly postponed, be maybe we should\n> re-iterate it now.\n> The idea of having an \u201ex\u201c namespace was rejected in fear we end up with\n> quasi-standard properties that have an x prefix then.\n>\n> *Kyle*:\n>\n> Which is worse? A complete free-for-all, or a recommendation to have the\n> free-for-all confined to an X- namespace? Do properties starting with X-\n> just offend engineering sensibilities?\n>\n> One \"right\" alternative is a documentation-required registry, but does\n> that raise the bar too high? How about a TAPS wiki as a compromise? The\n> important outcome is that properties be well-defined and not conflict with\n> each other. Since these properties have entirely local effects (e.g., they\n> don't get encoded as options and transmitted to the peer), we probably\n> don't need the level of precision motivating option registries, for\n> instance. Is there precedent at the IETF for a registry mechanism less\n> formal that what IANA provides?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-tapswg/api-drafts/issues/521>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAYF7R6EZUMERZHOMAGBRCTRKSL3JANCNFSM4L2PKNQQ>\n> .\n>\n",
          "createdAt": "2020-04-15T14:31:48Z",
          "updatedAt": "2020-04-15T14:31:48Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see three straw man proposals:\r\n(1) Create a registry of property names or namespaces, AND explIcitly define a range for IANA assignment and a policy...\r\n(2) Recommend a prefix format in the document...\r\n(3) Do nothing and see what happens....\r\n... I think all three are possible ways forward. If TAPS succeeds in having high impact, I suspect we'd like to have done (1).\r\n",
          "createdAt": "2020-04-15T14:39:34Z",
          "updatedAt": "2020-04-15T14:39:34Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "This was my thought, as well. If we go with 1, however, we need to either have a low bar (spec required?) to support experimentation. If not, the easy path for implementors will be to invent their own names without documenting them anywhere, which is likely to produce the kinds of problems that the free-for-all in HTTP headers ended up with.\r\n\r\nOne potential idea is to declare a small set of experimental property names that will inevitably overlap between different implementations: this would enable easy experimentation but require implementors to move to a permanent, unique property name in order to proceed to interop. Thoughts? Maybe this one should be moved to the list.",
          "createdAt": "2020-04-15T21:25:55Z",
          "updatedAt": "2020-04-15T21:25:55Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am much in favour of @gorryfair's first proposal, as we already have namespaces and a default namespace.\r\n\r\n- For the namespace, I would prefer something with a low threshold as \"specification required\" and explicitly encouraging experiments within vendor namespaces\r\n- For the default namespace, I would prefer RFC required.\r\n\r\nIf there are enough +1 for this, I can make a PR",
          "createdAt": "2020-04-16T11:47:00Z",
          "updatedAt": "2020-04-16T11:47:11Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought the point was that there is really no requirement for all TAPS implementations to use the same name space. Yes, it easier for applications using different TAPS systems when those have at least a similar names. But it's really just a local decision and restricting this more than needed can also be seen as negative when people want to adapt TAPS but don't want to change their existing naming scheme.",
          "createdAt": "2020-04-16T13:35:37Z",
          "updatedAt": "2020-04-16T13:35:37Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... If we choose no registry - then we deny the possible possible outcome of a vision of some common set of params allowing apps to be common between systems.\r\n ... If we have a registry of names, the world can still diverge because nobody uses the registry and people use their existing naming scheme, or people fill the registry with flavours.\r\nOne choice forces a result one way, the other permits both ways. If I think of the choice this way, I like possibility of common names. Although that sounds like an architectural dream at this moment, I'd argue it to be the right thing to do.",
          "createdAt": "2020-04-16T14:08:52Z",
          "updatedAt": "2020-04-16T14:08:52Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I give a +1 to @gorryfair's first proposal too - I can't see how defining a namespace can be seen as negative, as people can always decide to ignore it if they really must, as Gorry says - what's the disadvantage with that?  So ... a +1 from me to @philsbn for starting a PR on this (but perhaps\u00a0post-interim, just in case we get a chance to discuss this)",
          "createdAt": "2020-04-16T17:41:00Z",
          "updatedAt": "2020-04-16T17:41:00Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll give a more specific example of an anti-pattern resulting from an absence of a path to standardization: the mess the sockets API has with respect to differing sockopts and ioctls across different implementations. A free-for-all will reduce the portability of code, make useful documentation harder to write, and result in errors that are repeated over and over again in multiple code bases. If TAPS is to be useful, these problems should be avoided to the degree possible.",
          "createdAt": "2020-04-16T17:48:45Z",
          "updatedAt": "2020-04-16T17:48:45Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "This is minimally addressed by #568.",
          "createdAt": "2020-06-19T15:35:18Z",
          "updatedAt": "2020-06-19T15:35:18Z"
        }
      ]
    },
    {
      "number": 522,
      "id": "MDU6SXNzdWU1OTI2NzI1NzY=",
      "title": "Idempotency vs replay-safe  (from Kyle Rose's review)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/522",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "_From Kyle:_\r\nidempotency != replay-safe. DELETE is idempotent, but not safe for replay because someone might have done a PUT or POST in the meantime.\r\n\r\nWhat I mean is maybe best illustrated by 0RTT in TLS or QUIC. If a user sends a 0RTT DELETE /object, followed by a PUT /object, then within the replay window and without any replay prevention at the application layer, an attacker could replay the 0RTT DELETE /object and cause the object to be deleted again. DELETE is idempotent but it's not safe to replay.",
      "createdAt": "2020-04-02T14:23:23Z",
      "updatedAt": "2020-04-17T17:05:15Z",
      "closedAt": "2020-04-17T17:05:15Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems to me to be a case of arrival of Message X, followed by Message Y, followed by Message X. I don't think that TFO, TLS or QUIC would by themselves do this - it's always about immediate repetition of the first Message only, isn't it?\r\n\r\nMaybe we should just clarify that idempotency in our case means that a Message may arrive multiple times **with nothing in between** on the same Connection. Thoughts?",
          "createdAt": "2020-04-02T14:25:23Z",
          "updatedAt": "2020-04-02T14:25:23Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I don't know if the draft should get into defining what \"idempotent\" means: it has a well-defined mathematical definition, but one that seems to be less well-defined in protocol design. IMO, just use less ambiguous phrasing.",
          "createdAt": "2020-04-02T19:43:14Z",
          "updatedAt": "2020-04-02T19:43:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, that. s/idempotent/repeatable ?",
          "createdAt": "2020-04-02T20:31:05Z",
          "updatedAt": "2020-04-02T20:31:05Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I would go with \"safely replayable\" to emphasize the attack aspect.",
          "createdAt": "2020-04-02T22:41:13Z",
          "updatedAt": "2020-04-02T22:41:13Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "For what it's worth: RFC 7231, Section 4.2.2 of HTTP defines idempotent clearly:\r\n\"A request method is considered \"idempotent\" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.\"\r\n\"safely repayable\" - would need a little more context to explain why it is safe .. maybe you could copy part of this definition.",
          "createdAt": "2020-04-03T06:34:14Z",
          "updatedAt": "2020-04-03T06:34:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we cite that section of RFC 7231 for idempotency, perhaps even quote the meaning that @gorryfair has copied here, and be done with this?",
          "createdAt": "2020-04-03T10:23:45Z",
          "updatedAt": "2020-04-03T10:23:45Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I think I'm not being clear about my objection here. I know what idempotent means, and agree that RFC 7231 captures it. (\"A request method is considered \"idempotent\" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request.\")\r\n\r\nThe issue is with an idempotent request that is repeated *with a different request in between.* DELETE, for instance, will do the same thing if multiple identical requests are performed, but if a PUT or POST occurs in between, the second DELETE will remove a different object than the one from the first DELETE.\r\n\r\nLet's say the user does this:\r\n\r\nPUT /object (with content 1)\r\nDELETE /object\r\nPUT /object (with content 2)\r\n\r\nThe state of /object after this sequence is that it exists with content 2.\r\n\r\nIdempotency admits the following:\r\n\r\nPUT /object (with content 1)\r\nDELETE /object\r\nPUT /object (with content 2)\r\nREPLAY: DELETE /object\r\n\r\nThe state of /object after this sequence is that it does not exist. Similarly:\r\n\r\nPUT /object (with content 1)\r\nPUT /object (with content 2)\r\nREPLAY: PUT /object (with content 1)\r\n\r\nThe state of /object after this sequence is that it exists with content 1.\r\n\r\nReplay safety would mean that the state after a sequence including a replayed request is identical to the state without the replayed request.",
          "createdAt": "2020-04-15T14:30:31Z",
          "updatedAt": "2020-04-15T14:30:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Then this is what I thought you meant in the first place!  Then I agree about \"safely replayable\" and will make a PR that explains what this is, and replaces idempotent with \"safely replayable\" everywhere.",
          "createdAt": "2020-04-16T07:50:06Z",
          "updatedAt": "2020-04-16T08:35:24Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "This seems to me to be a layering-perspective. I think we know how to fix this by using uniquely identifiable transactions e.g. delete \"last\" is never idempotent; whereas delete \"123462\" is because executing it twice has no effect; however ordering still has effect - because if \"123462\" doesn't exist when asked to delete this has no effect. As for me, I think we don't teach how to use datagrams/messages here.\r\n\r\nSo I don't mind what words are used - or where this refers to the transport service offered or the use of the transport service. A proposed change is likely good for me.",
          "createdAt": "2020-04-16T09:01:22Z",
          "updatedAt": "2020-04-16T09:01:22Z"
        }
      ]
    },
    {
      "number": 523,
      "id": "MDU6SXNzdWU1OTI2Nzg2MjM=",
      "title": "Registry for \"interface instance or type\"  (from Kyle Rose's review)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/523",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "_from Kyle_:\r\n> These type symbols really deserve an actual registry, or at least the start of one. Otherwise, we are likely to end up with a mess.\r\n\r\n**Philipp Tiesel**:\r\n> There is already one, but that one was not useful for our matters. \r\n",
      "createdAt": "2020-04-02T14:31:37Z",
      "updatedAt": "2020-04-27T22:18:47Z",
      "closedAt": "2020-04-27T22:18:47Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I'm not sure what Philipp's response means. Where is this registry, and why was it not useful?",
          "createdAt": "2020-04-15T14:23:20Z",
          "updatedAt": "2020-04-15T14:23:20Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Kyle Rose's review: https://mailarchive.ietf.org/arch/msg/taps/o1ehdiAwdqAG42xy2Gy5Cb62eYA/ ",
          "createdAt": "2020-04-17T15:16:14Z",
          "updatedAt": "2020-04-17T15:16:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This will be system/implementation specific in general, I'd say.",
          "createdAt": "2020-04-17T17:25:25Z",
          "updatedAt": "2020-04-17T17:25:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a sentence to 5.2.10 to indicate that this is implementation specific",
          "createdAt": "2020-04-17T17:26:25Z",
          "updatedAt": "2020-04-17T17:26:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mention that these should be documented?",
          "createdAt": "2020-04-17T17:29:48Z",
          "updatedAt": "2020-04-17T17:29:48Z"
        }
      ]
    },
    {
      "number": 524,
      "id": "MDU6SXNzdWU1OTI2ODQ2MzI=",
      "title": "What constitutes trust verification prior to the handshake?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/524",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Kyle Rose asked this question in his review, referring to section 5.3.2.",
      "createdAt": "2020-04-02T14:39:47Z",
      "updatedAt": "2020-04-15T18:44:34Z",
      "closedAt": "2020-04-15T18:44:34Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Session resumption...?",
          "createdAt": "2020-04-03T14:20:29Z",
          "updatedAt": "2020-04-03T14:20:29Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "I think I was quibbling with the word \"proceed\". Not sure why I didn't just say that in the review.\r\n\r\n> Trust verification callback: Invoked when a Remote Endpoint's trust must be validated before the handshake protocol can proceed.\r\n\r\nCredentials are typically exchanged as part of the handshake, which means the handshake has already begun, so I think it will read better if you change \"proceed\" to \"continue\".",
          "createdAt": "2020-04-15T12:44:22Z",
          "updatedAt": "2020-04-15T12:44:22Z"
        }
      ]
    },
    {
      "number": 525,
      "id": "MDU6SXNzdWU1OTI2ODcyOTc=",
      "title": "single messageContext object for both sends and receives",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/525",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "from Kyle Rose's review:\r\n\r\n> 7.3.3. SendError\r\n> \r\n> Is there a reason why a single messageContext object is used for both sends and receives? I probably missed the original discussion about this, but I'd like to understand the reasoning.\r\n> \r\n> (Maybe I should have said \"class\" instead of \"object\".) For example, the \"lifetime\" property makes sense as metadata for sends, but is completely irrelevant to the receiver. The same is true of several other message properties. It might make sense for an implementation to use a single type to represent metadata both for sends and receives, but is that also true for an abstract API?\r\n> ",
      "createdAt": "2020-04-02T14:43:26Z",
      "updatedAt": "2020-04-17T17:23:14Z",
      "closedAt": "2020-04-17T17:23:14Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that implementations would have two different messageContext subtypes for sending and receiving, but I also think that this may be an implementation issue and unnecessary detail for this abstract API. Others?",
          "createdAt": "2020-04-02T14:45:40Z",
          "updatedAt": "2020-04-02T14:45:40Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I you have a request/response protocol this actually gives you additional information by connecting these two messages together. ",
          "createdAt": "2020-04-03T14:18:31Z",
          "updatedAt": "2020-04-03T14:18:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also true. Maybe best to leave it as it is, then, and close this issue?",
          "createdAt": "2020-04-15T11:28:34Z",
          "updatedAt": "2020-04-15T11:28:34Z"
        }
      ]
    },
    {
      "number": 526,
      "id": "MDU6SXNzdWU1OTI2ODk5MjQ=",
      "title": "7.3.1 Sent   (from Kyle Rose's review)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/526",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Kyle wrote:\r\n> It seems like an abstract API would be helpful for the reference to the Message to which a Sent event applies: this seems like something many, many applications would need to do. With callbacks, the application can always curry in a reference to the original message (that's what my event system from ~2001 did), so maybe that should be the recommendation and the message reference removed...? I don't have a strong feeling here other than that if something is included then its use should be more well-defined.",
      "createdAt": "2020-04-02T14:46:54Z",
      "updatedAt": "2020-04-15T18:45:22Z",
      "closedAt": "2020-04-15T18:45:22Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "NONE",
          "body": "Upon re-reading this, I think I'm okay with what's there.",
          "createdAt": "2020-04-15T14:21:52Z",
          "updatedAt": "2020-04-15T14:21:52Z"
        }
      ]
    },
    {
      "number": 528,
      "id": "MDU6SXNzdWU1OTMyODkzMjM=",
      "title": "Create an enum for querying properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/528",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "From Kyle Rose:\r\n\r\n> 5.2. Specifying Transport Properties\r\n> \r\n> * Using the same enum (Require(d[sic])/Avoid/Ignore) for the queried output of selected properties seems like a shortcut that will lead to some confusion.\r\n> \r\n> Alternative: an output enum something like { Selected, Avoided, Ignored } independent of the input type. As long as you understand this and are still okay with the interface you've chosen, that is fine by me.\r\n\r\n@mwelzl says: I think this isn't very controversial, I believe we should just do this as he suggested. This issue is just a reminder for myself to do this.",
      "createdAt": "2020-04-03T10:41:32Z",
      "updatedAt": "2020-04-17T17:07:57Z",
      "closedAt": "2020-04-17T17:07:57Z",
      "comments": []
    },
    {
      "number": 531,
      "id": "MDU6SXNzdWU1OTUyNTM3NjI=",
      "title": "(hopefully) minor point about properties terminology",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/531",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Implementation draft sec 3:\r\n\"In the remainder of this document, we only refer to Selection Properties because they are the more typical case and have to be handled by all implementations.\r\n\r\nThe implementation stores these objects and properties as part of the Preconnection object for use during connection establishment.\"\r\n\r\nI don't understand these two sentences. In the API doc it seems we use the term Transport Properties for both selection and configuration properties. Why do we only talk about selection properties in this doc?\r\n\r\nAlso in the next sentence what's meant by \"objects and properties\"? I guess the object(s) that hold the properties? But then this is saying twice the same and we should only use one term to avoid confusion.",
      "createdAt": "2020-04-06T16:26:38Z",
      "updatedAt": "2020-07-13T17:55:25Z",
      "closedAt": "2020-07-13T17:55:25Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also in the next section 3.1:\r\n\"Once an application specifies its Transport Parameters\"\r\n\r\nI guess that should be Transport Properties instead?\r\n\r\nMaybe it would also be good to say here \"Once an application specifies its Transport Properties and Preference (required, prefer, ignore, avoid, prohibit - see section 5.2. of [draft-taps-arch])\".",
          "createdAt": "2020-04-06T16:30:27Z",
          "updatedAt": "2020-04-06T16:36:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree; I suspect that this is ancient leftover text that should be cleaned up.",
          "createdAt": "2020-04-15T11:26:28Z",
          "updatedAt": "2020-04-15T11:26:28Z"
        }
      ]
    },
    {
      "number": 533,
      "id": "MDU6SXNzdWU1OTUyNzc0NDc=",
      "title": "What's a path...?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/533",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "Impl draft, section 4.1.2:\r\n\"Each node will be summarized by a tuple of three elements: Endpoint, Path, and Protocol. The above example can now be written more succinctly as:\r\n\r\n1 [www.example.com:80, Any, TCP]\r\n  1.1 [www.example.com:80, Wi-Fi, TCP]\r\n    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]\r\n  1.2 [www.example.com:80, LTE, TCP]\r\n    1.2.1 [192.0.2.1:80, LTE, TCP]\r\n    1.2.2 [2001:DB8::1.80, LTE, TCP]\"\r\n\r\nlooking at the example I would not call this \"Endpoint, Path, and Protocol\" but \"Remote Endpoint, Local Endpoint or interface, and Protocol\".\r\n\r\nNot sure we have defined the term Path well but I would consider a path to consists of both the local and remote endpoint plus optionally maybe even some more information about the path characteristics that might be known for this endpoint pair.",
      "createdAt": "2020-04-06T17:04:31Z",
      "updatedAt": "2020-07-17T16:27:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, it is \"remote endpoint\", \"interface/local endpoint\", and \"protocol\".",
          "createdAt": "2020-04-06T17:12:02Z",
          "updatedAt": "2020-04-06T17:12:02Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "note that the wording needs to be fix at least in a few more places, so whoever puts the PR in should probably reach for the word path and ensure it's used correctly...",
          "createdAt": "2020-04-06T17:34:02Z",
          "updatedAt": "2020-04-06T17:34:13Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "especially 4.1.3.2. (Alternate Paths) wouldn't fit that well anymore and would probably need some rewriting...",
          "createdAt": "2020-04-06T17:38:37Z",
          "updatedAt": "2020-04-06T17:38:37Z"
        }
      ]
    },
    {
      "number": 536,
      "id": "MDU6SXNzdWU1OTU3MjgwODI=",
      "title": "Branching Order-of-Operations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/536",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "In section 4.1.4 in the impl draft, we have:\r\n\r\n\"The order of operations for branching, where lower numbers are acted upon first, should be:\r\n\r\n1. Alternate Paths\r\n2. Protocol Options\r\n3. Derived Endpoints\"\r\n\r\nHowever, I would say there is not really a strict ordering required. The text actually indicates that selection of the protocol is rather independent while there is usually a dependency between the interface and derived endpoint. I think this is related to my other issue about the use of the term path, because a path consists of both the local and remote endpoint and therefore there is of course a dependency. \r\n\r\nSo in summary I'm not sure how useful I find this whole section as currently written...",
      "createdAt": "2020-04-07T09:31:35Z",
      "updatedAt": "2020-07-17T16:28:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should conclude if anything more is needed here besides cleaning up the terminology, where Alternate Paths is not a good term - see  #533 .",
          "createdAt": "2020-06-18T16:34:57Z",
          "updatedAt": "2020-06-18T16:34:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Any implementation should have a consistent order of operations. This is a recommended example. Reference the arch text that says it needs to work the same way each time.",
          "createdAt": "2020-06-19T16:36:39Z",
          "updatedAt": "2020-06-19T16:36:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reference ICE/HE",
          "createdAt": "2020-06-19T16:36:50Z",
          "updatedAt": "2020-06-19T16:36:50Z"
        }
      ]
    },
    {
      "number": 537,
      "id": "MDU6SXNzdWU1OTU3Mzc2NzE=",
      "title": "Recommendations for Delayed Racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/537",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "Section 4.2.1  on delayed racing:\r\n\"For example, if the first child represents an IP address with a known route, and the second child represents another IP address, the delay between starting the first and second IP addresses can be based on the expected retransmission cadence for the first child's connection (derived from historical round-trip-time). Alternatively, if the first child represents a branch on a Wi-Fi interface, and the second child represents a branch on an LTE interface, the delay should be based on the expected time in which the branch for the first interface would be able to establish a connection, based on link quality and historical round-trip-time.\"\r\n\r\nWhat the reasoning for these two recommendations? I'm actually not sure what exactly is meant. Is the first case 3xRTT (-> initial RTO) and the second 1xRTT? Why?\r\n\r\nAlso in the next paragraph:\r\n\"Generally, branches between paths and protocols should have longer delays than branches between derived endpoints.\"\r\n\r\nWhat? Why?\r\n\r\nAnd then \r\n\"The maximum delay should be considered with regards to how long a user is expected to wait for the connection to complete.\"\r\n\r\nHow do I know this?\r\n",
      "createdAt": "2020-04-07T09:47:03Z",
      "updatedAt": "2020-08-14T15:05:54Z",
      "closedAt": "2020-08-14T15:05:54Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, maybe it's just me, but I can't parse \"retransmission cadence\", and the phrase with \"historical round-trip time\" is 1) confusing (I don't get what it means, but maybe that's due to me misunderstanding \"cadence\"?), and 2) seems to be missing an article.",
          "createdAt": "2020-04-15T11:18:44Z",
          "updatedAt": "2020-04-15T11:18:44Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I read this as examples of things to consider when implementing a happy-eyeballs style algorithm, rather than explicit recommendations. Maybe this fix is to make this more vague, rather than more explicit?",
          "createdAt": "2020-04-17T15:35:46Z",
          "updatedAt": "2020-04-17T15:35:46Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think @csperkins is right and the intention here is that these are just examples of things to consider. We should conclude if anything more is needed beyond making it more clear in the text that these are examples and fixing the other language issues.   ",
          "createdAt": "2020-06-18T16:40:12Z",
          "updatedAt": "2020-06-18T16:40:12Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue I agreed with was a desire to find simpler terms to describe these examples.",
          "createdAt": "2020-06-19T09:50:16Z",
          "updatedAt": "2020-06-19T09:50:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Refer to Happy Eyeballs for exact timing algorithm as the concrete reference (or ICE, etc).",
          "createdAt": "2020-06-19T16:05:01Z",
          "updatedAt": "2020-06-19T16:05:01Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be helpful to add some of the reasoning behind, e.g., \"Generally, branches between paths and protocols should have longer delays than branches between derived endpoints.\"",
          "createdAt": "2020-06-19T16:06:13Z",
          "updatedAt": "2020-06-19T16:06:13Z"
        }
      ]
    },
    {
      "number": 538,
      "id": "MDU6SXNzdWU1OTU3NDY3MzQ=",
      "title": "Interface for app-driven racing of \"unconnected\" protocols?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/538",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Impl draft Section 4.5: Handling racing with \"unconnected\" protocols\r\n\"In the case that the application signals that the initial Protocol Stack is failing for some reason and that another option should be attempted, the Connection can be updated to point to the next candidate Protocol Stack. This can be viewed as an application-driven form of Protocol Stack racing.\"\r\nHow does the application indicate that? I don't think this is covered by the API draft?\r\n\r\nAlso I would recommend to move this section as a subsection within 4.5. (Completing Establishment) or at least switch the order with the previous section (Establishing multiplexed connections) to get a better reading flow.",
      "createdAt": "2020-04-07T10:01:51Z",
      "updatedAt": "2020-06-19T16:54:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This may affect the API draft so we should conclude if the API draft needs to be updated. We do have the functionality in NEAT for racing with unconnected protocols so i think the text is based on that.",
          "createdAt": "2020-06-18T16:14:50Z",
          "updatedAt": "2020-06-18T16:14:50Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Change this to text about how a framer can be used to drive racing over UDP. We shouldn't have a special API for marking the current connection failed.",
          "createdAt": "2020-06-19T16:53:01Z",
          "updatedAt": "2020-06-19T16:53:01Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Action is to propose initial text and follow up at next interim.",
          "createdAt": "2020-06-19T16:54:57Z",
          "updatedAt": "2020-06-19T16:54:57Z"
        }
      ]
    },
    {
      "number": 539,
      "id": "MDU6SXNzdWU1OTU3NTA4Nzk=",
      "title": "Listeners and ports",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/539",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Impl draft section 4.6 (Implementing listeners):\r\n\"If no Local Endpoint is specified, the implementation should either use an ephemeral port or generate an error.\"\r\nDo we need an interface for the application to indicate that an ephemeral port should be used?",
      "createdAt": "2020-04-07T10:08:34Z",
      "updatedAt": "2020-04-16T10:42:21Z",
      "closedAt": "2020-04-16T10:42:21Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's implicit in the old socket API - accept just gives me a new socket, which I can use to continue communication, but I don't see the port numbers associated with this socket and never have to say that they are ephermal. I believe it's similarly implicit in ours. So ... what's missing?",
          "createdAt": "2020-04-08T06:17:49Z",
          "updatedAt": "2020-04-08T06:25:03Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text above says \"use an ephemeral port or generate an error\". So when would you throw an error? If the assumption is that always an ephemeral port should be used (no matter actually how the underlying interfaces works) that should be stated (in the API doc).",
          "createdAt": "2020-04-08T10:39:18Z",
          "updatedAt": "2020-04-08T10:39:18Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "If you do not use an \"ephemeral port\", and choose to specify the port - then you may get the error if it can't be completed.",
          "createdAt": "2020-04-08T10:58:34Z",
          "updatedAt": "2020-04-08T10:58:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... or if the system is out of resources for some reasons. Just like \"accept\" can fail in the normal socket API.",
          "createdAt": "2020-04-08T15:57:06Z",
          "updatedAt": "2020-04-08T15:57:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "That too.",
          "createdAt": "2020-04-08T16:07:22Z",
          "updatedAt": "2020-04-08T16:07:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak requested that I adapt the \"error\" text in the implementation draft too. In doing so, I noticed:\r\n\r\n- I don't understand @gorryfair's comment above, about choosing the specify the port. I think this kind of error was possible with sockets somehow, but this text talks about not specifying a Local Endpoint. Technically, I think not specifying a Local Endpoint yet specifying a port is not possible.\r\n\r\n- Regarding my own comment, any call may fail for reasons such as the system being out of resources; I think mentioning this in the text here doesn't add any value though.\r\n\r\nAs a result, I'll remove the part about the error from the text in my update to PR #556.",
          "createdAt": "2020-04-14T12:20:15Z",
          "updatedAt": "2020-04-14T12:20:15Z"
        }
      ]
    },
    {
      "number": 540,
      "id": "MDU6SXNzdWU1OTU3NjA3NDg=",
      "title": "Message Properties in API and Implementation draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/540",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "Implementation",
        "editorial",
        "ready for text"
      ],
      "body": "It might be worth to better align the sections on Message Properties in the API and Implementation draft. Note that e.g. \"Final\" has more implementation details in the API draft than in the implementation draft.",
      "createdAt": "2020-04-07T10:24:37Z",
      "updatedAt": "2020-07-13T17:56:54Z",
      "closedAt": "2020-07-13T17:56:54Z",
      "comments": []
    },
    {
      "number": 542,
      "id": "MDU6SXNzdWU1OTU3NjI2NzQ=",
      "title": "Batching Sends",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/542",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "In the implementation draft section 5.1.3 says that there should be an interface for the application to indicate batch sending. Section 7.7 specifies such an interface. Should the section in the implementation draft be updated or removed?",
      "createdAt": "2020-04-07T10:27:48Z",
      "updatedAt": "2020-07-13T17:55:58Z",
      "closedAt": "2020-07-13T17:55:58Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be removed. Mainly, it points out that batching reduces overhead, which is also stated in the API draft in section 7.7.",
          "createdAt": "2020-04-15T11:12:07Z",
          "updatedAt": "2020-04-15T11:12:07Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps it is still important for the implementation to know that it needs to support batching sends though? I would suggest adjusting the text so it reads from the implementations perspective. Something like \r\n\r\n> Since sending a Message may involve a context switch between the application and the transport system, sending patterns that involve multiple small Messages can incur high overhead if each needs to be enqueued separately. To avoid this, the application can indicate a batch of Send actions through the API. When this is used, the implementation should hold off on processing Messages until the batch is complete. ",
          "createdAt": "2020-04-15T12:47:55Z",
          "updatedAt": "2020-04-15T12:47:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree; this is a nice text proposal. PR #599 replaces the current text with your proposed one.",
          "createdAt": "2020-07-03T11:27:40Z",
          "updatedAt": "2020-07-03T11:27:40Z"
        }
      ]
    },
    {
      "number": 543,
      "id": "MDU6SXNzdWU1OTU3Njk3OTU=",
      "title": "minIncompleteLength when receiving data on streams",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/543",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Impl draft section 5.2 Receiving Messages:\r\n\"if, on the other hand, the top-level protocol only supports a byte-stream and no deframers were supported, the application must specify the minimum number of bytes of Message content it wants to receive (which may be just a single byte) to control the flow of received data.\"\r\nThis text says the application MUST specify minIncompleteLength, however, the API draft says that this values is optional. This should be further clarified and more guidance given in case the value is not set.",
      "createdAt": "2020-04-07T10:39:52Z",
      "updatedAt": "2020-05-29T15:18:18Z",
      "closedAt": "2020-05-29T15:18:18Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having looked at this and the API carefully, my suggestion would be to turn the semicolon preceding this statement into a full stop and remove all of this \"if, on the other hand, ....\" text in the implementation draft.",
          "createdAt": "2020-04-15T11:03:17Z",
          "updatedAt": "2020-04-15T11:03:17Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM.",
          "createdAt": "2020-04-16T13:48:49Z",
          "updatedAt": "2020-04-16T13:48:49Z"
        }
      ]
    },
    {
      "number": 545,
      "id": "MDU6SXNzdWU1OTU5NTM1NzY=",
      "title": "More guidance needed on Handling Path Changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/545",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mirjak"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Section 7.2 on Handling Path Changes in the implementation draft needs to be better aligned to the interface we are currently still discussing for multipath protocols. Currently it reads like an taps implementation can freely decide which paths to use when. That's probable not the case but in any case needs also more specific guidance. However, we probably need to leave this issue as a reminder for later when we have decided on the final interface for MP protocols. \r\n\r\nI would eventually like to separate sections for handover (two parallel paths), migration (move from one to the other but keep same protocol instance) and fallback (move form one protocol instance to another).\r\n\r\n",
      "createdAt": "2020-04-07T15:25:38Z",
      "updatedAt": "2020-07-17T16:31:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 546,
      "id": "MDU6SXNzdWU1OTU5NTk1MzA=",
      "title": "flushing cache state",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/546",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "Section 9.1 of the implementation draft says:\r\n\"Applications must have a way to flush protocol cache state if desired. This may be necessary, for example, if application-layer identifiers rotate and clients wish to avoid linkability via trackable TLS tickets or TFO cookies.\"\r\n\r\nHowever, my understanding is that protocol cache state is not application specific. I don't think a single application should be able to flush protocol specific state that set up based on an interaction with another application. If an application wants to avoid linkability due to TLS or TFO cookies, it should be enough to indicate in the selection properties that use of these feature is not prohibited, no?",
      "createdAt": "2020-04-07T15:33:49Z",
      "updatedAt": "2021-01-30T03:13:52Z",
      "closedAt": "2021-01-30T03:13:52Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The scope of caching may be good to discuss. For the particular example I agree that this could have been handled by prohibiting those mechanisms, but i think there may be other situations where you do want the ability to flush the cached state? ",
          "createdAt": "2020-06-18T16:20:21Z",
          "updatedAt": "2020-06-18T16:20:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Align with arch text that the boundary can be set by connection groups.",
          "createdAt": "2020-06-19T16:42:30Z",
          "updatedAt": "2020-06-19T16:42:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should this be closed? The statement quoted above, \"Applications must have a way to flush protocol cache state if desired. ...\" doesn't seem to exist in the Implementation draft anymore.\r\n\r\nI believe the PR that we discussed today may have addressed this (albeit in a different way: clarifying whether state should be sharable or not rather than explicitly flushing). Isn't this good enough?",
          "createdAt": "2021-01-29T17:48:28Z",
          "updatedAt": "2021-01-29T17:48:28Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think this was resolved by the PR merged today.",
          "createdAt": "2021-01-29T17:57:42Z",
          "updatedAt": "2021-01-29T17:57:42Z"
        }
      ]
    },
    {
      "number": 548,
      "id": "MDU6SXNzdWU1OTU5NjYxOTc=",
      "title": "Certificates and other security parameters",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/548",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Can we/do we need to add more guidance in the implementation draft on handling of certificates or other security related parameters?",
      "createdAt": "2020-04-07T15:43:10Z",
      "updatedAt": "2020-07-17T16:35:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can talk about the endpoint identities that need to be passed to security protocols for validation, etc. Probably talking about handling certificates is just \"pass directly to security protocols\".",
          "createdAt": "2020-07-17T16:35:37Z",
          "updatedAt": "2020-07-17T16:35:37Z"
        }
      ]
    },
    {
      "number": 549,
      "id": "MDU6SXNzdWU1OTU5NzYwMTI=",
      "title": "What's PRIMITIVENAME?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/549",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Section 10 of impl draft:\r\n\"Below, primitives in the style of \"CATEGORY.[SUBCATEGORY].PRIMITIVENAME.PROTOCOL\" (e.g., \"CONNECT.SCTP\") refer to the primitives with the same name in section 4 of [RFC8303].\"\r\n\r\nI know it's specified like this in RFC8303 but PRIMITIVENAME does not seem to be explained or used. Maybe I didn't look careful enough but to be honest I also didn't find the use of this nomenclature from RFC8303 very helpful...",
      "createdAt": "2020-04-07T15:56:49Z",
      "updatedAt": "2020-04-08T23:04:52Z",
      "closedAt": "2020-04-08T23:04:52Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to answer the comment of usefulness of this nomenclature: this allows back-tracking to the relevant spec., which (I believe) is valuable for people implementing a TAPS system. In the example of CONNECT.SCTP, RFC 8303 describes this as consisting of:\r\n>  Pass 1 primitive/event: 'Initialize', followed by 'Enable/Disable\r\n      Interleaving' (optional), followed by 'Associate'\r\n\r\nInitialize and Associate are obvious; naturally, they come from RFC 4960. Considering to use 'Enable/Disable Interleaving' (which is very important for a TAPS system - to implement priorities between streams) is perhaps less obvious, and the text points back at RFC 8260.",
          "createdAt": "2020-04-08T06:10:40Z",
          "updatedAt": "2020-04-08T06:10:40Z"
        }
      ]
    },
    {
      "number": 551,
      "id": "MDU6SXNzdWU1OTY1NDIxMjg=",
      "title": "Close for HTTP",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/551",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "In the implementation draft section 10.6 says:\r\n\" For HTTP/2, for example, closing the connection only closes a specific stream.\"\r\n\r\nShould the close call also close the TCP/transport connection if the last stream was closed? Otherwise how do I gracefully close a HTTP connection?",
      "createdAt": "2020-04-08T12:31:59Z",
      "updatedAt": "2020-07-03T08:57:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think so - I think the last call to close should close the underlying transport connection. Right? If so, I can write this.",
          "createdAt": "2020-07-03T08:57:00Z",
          "updatedAt": "2020-07-03T08:57:00Z"
        }
      ]
    },
    {
      "number": 552,
      "id": "MDU6SXNzdWU1OTY1NDQwOTM=",
      "title": "What HTTP/2 transport?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/552",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "In the implementation draft there is an own section (10.8) on HTTP/2 transport. However HTTP/2 seems to be covered by section 10.6. However, we should probably cover HTTP/3 as well.",
      "createdAt": "2020-04-08T12:35:13Z",
      "updatedAt": "2021-02-17T11:44:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on also covering HTTP/3. This is a related discussion:\r\nhttps://github.com/quicwg/ops-drafts/issues/203#issuecomment-777340483\r\n\r\nShould this all go in the QUIC mapping document? QUIC mapping is below our API, yet HTTP/3 is above... still, I think discussing it all in one document would be the best way forward.",
          "createdAt": "2021-02-17T11:44:08Z",
          "updatedAt": "2021-02-17T11:44:08Z"
        }
      ]
    },
    {
      "number": 553,
      "id": "MDU6SXNzdWU1OTY1NDUzNTM=",
      "title": "Implementation details for QUIC missing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/553",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "I'm sure people are aware of this but just to have an issue to track this: section 10.7. on QUIC in the implementation is incomplete.",
      "createdAt": "2020-04-08T12:37:14Z",
      "updatedAt": "2020-06-19T16:34:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 563,
      "id": "MDU6SXNzdWU2MDEyMzI5OTI=",
      "title": "Add signal that inbound data was 0-RTT",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/563",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "In section 5.3, there's a discussion of how to send data early to use a 0-RTT capability. Should there also be description of a signal that data arrived using 0-RTT? Section 8 of RFC 8446 suggests making this state clear so that applications can guard against replay attacks, etc.",
      "createdAt": "2020-04-16T16:36:14Z",
      "updatedAt": "2020-07-17T15:55:46Z",
      "closedAt": "2020-07-17T15:55:46Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that could be useful and I guess it would be easy enough to set a flag in the message-context of the received message. I guess we could even re-use the idempotent flag; or maybe a new one is more clear...",
          "createdAt": "2020-04-16T17:02:44Z",
          "updatedAt": "2020-04-16T17:02:44Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't this exactly the API's \"Early Data\" Receive Message Property, in Section 8.3.2?\r\nSee: https://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-interface.html#name-early-data\r\n",
          "createdAt": "2020-04-16T17:26:50Z",
          "updatedAt": "2020-04-16T17:26:50Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping: am I right, and this can be closed?",
          "createdAt": "2020-07-03T08:55:05Z",
          "updatedAt": "2020-07-03T08:55:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup!",
          "createdAt": "2020-07-17T15:55:46Z",
          "updatedAt": "2020-07-17T15:55:46Z"
        }
      ]
    },
    {
      "number": 567,
      "id": "MDU6SXNzdWU2MDIxMDk5NTU=",
      "title": "Three oddities in the abstract?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/567",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Odd English:\r\n/where endpoints have multiple interfaces and potential transport protocols to select from/where endpoints could select from multiple interfaces and potential transport protocols./\r\n\r\nWe use the words /abstract programming interface/ and the acronym /API/ but never tie these two together.\r\n\r\nI am not huge fan of: /lowest common denominator interface/ ... as an engineer, this sounds like a good thing, although /lowest/ isn't that clear, so I wonder if we can find a better term?",
      "createdAt": "2020-04-17T16:56:08Z",
      "updatedAt": "2020-04-21T07:52:16Z",
      "closedAt": "2020-04-21T07:52:16Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in PR",
          "createdAt": "2020-04-21T07:52:16Z",
          "updatedAt": "2020-04-21T07:52:16Z"
        }
      ]
    },
    {
      "number": 568,
      "id": "MDU6SXNzdWU2MDIxMjM1MDI=",
      "title": "Namespaces based on IANA protocol numbers registry",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/568",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API",
        "ready for text",
        "review"
      ],
      "body": "Just a minute, how can this be a MUST not colide when the registry is still open?:\r\n\r\nNamespaces for the keywords provided in the IANA protocol numbers registry (see https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) are reserved for Protocol Specific Properties an d MUST not be used for vendor or implementation specific properties.\r\n\r\nThe keyword in this registry is text that has no reserved format, except this registry appears to use upper case. New entries *could* be added to this registry in future, how can the vendor names be orthogonal. I can only see this if we the key - defined as a number 1-255; and vendor numb ears > 255. Or we declare lower case as significant, or some tag?\r\n\r\n",
      "createdAt": "2020-04-17T17:22:25Z",
      "updatedAt": "2020-06-19T15:43:16Z",
      "closedAt": "2020-06-19T15:43:16Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thought linked to #523.",
          "createdAt": "2020-04-17T17:42:15Z",
          "updatedAt": "2020-04-17T17:42:15Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Assign to me when I have the right permissions on the repo.",
          "createdAt": "2020-05-29T16:20:18Z",
          "updatedAt": "2020-05-29T16:20:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, someone beat me to it...",
          "createdAt": "2020-05-29T21:24:28Z",
          "updatedAt": "2020-05-29T21:24:28Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Anyone recall what we actually decided to do here? I'm thinking we want to express that IANA protocol keywords translated to lowercase and removing all characters not in [0-9a-z-] are reserved for the corresponding protocols, but how did we decide to prevent future collisions? Do we require a single parent prefix like \"x-\" or \"p-\" followed by a vendor-specific keyword?",
          "createdAt": "2020-06-19T12:51:21Z",
          "updatedAt": "2020-06-19T12:51:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add text to say they're not uppercase like the registry. Make sure we don't guarantee there can't be collisions.",
          "createdAt": "2020-06-19T15:21:46Z",
          "updatedAt": "2020-06-19T15:21:46Z"
        }
      ]
    },
    {
      "number": 569,
      "id": "MDU6SXNzdWU2MDIxMjY0MzM=",
      "title": "NiTs in section 1",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/569",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Section 1:\r\nThis section contains a RFC2119 keyword that precedes the definition!\r\n\r\nWe use the words /abstract programming interface/ and the acronym /API/ but never tie these together.\r\n\r\nNiTs:\r\n/provide applications a way to/provide a way for applications to/\r\n/as it comes at the cost of reduced portability/because it can reduce the portability./\r\n/How these abstract concepts/The way these abstract concepts/\r\n/is largely dependent on/mostly depends on/\r\n",
      "createdAt": "2020-04-17T17:28:08Z",
      "updatedAt": "2020-05-30T07:55:53Z",
      "closedAt": "2020-05-30T07:55:53Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A PR for this issue has already been merged.",
          "createdAt": "2020-05-30T07:55:53Z",
          "updatedAt": "2020-05-30T07:55:53Z"
        }
      ]
    },
    {
      "number": 571,
      "id": "MDU6SXNzdWU2MDIxNDU3NjY=",
      "title": "How do you add multiple IP addresses/interfaces to an endpoint?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/571",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "what happened if you add multiple addresses or interfaces to an endpoint: Does it overwrite the existing one or not?",
      "createdAt": "2020-04-17T18:05:38Z",
      "updatedAt": "2020-11-02T18:30:06Z",
      "closedAt": "2020-11-02T18:30:06Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I would say that it does not overwrite but simply add to a list of addresses. This is, among other things, because for a Listen() the remote endpoint can be used to filter incoming connections and I don't think it makes much sense to only be able to constrain it to a single address. ",
          "createdAt": "2020-05-03T15:05:35Z",
          "updatedAt": "2020-05-03T15:06:51Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @MaxF12 \u2013 but we should really make this explicit",
          "createdAt": "2020-05-05T14:26:14Z",
          "updatedAt": "2020-05-05T14:26:14Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion at interim: Clarification is needed. add() during preconnection will overwrite, and add() cannot be used in connection state. Also add a note in the text that e.g. specifying a specific IP address might restrict mobility or use of multiple paths and could cause the connection to fails when the IP address goes way rather than enabling some handover. Still open: Do we need a way to add of multiple addresses in the first place? This is used for filtering remote IP addresses for listener for multicast.",
          "createdAt": "2020-05-29T16:19:47Z",
          "updatedAt": "2020-05-29T16:19:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current API text doesn't use \"add\", but rather \"with...\":\r\n\r\n```\r\nRemoteSpecifier := NewRemoteEndpoint()\r\nRemoteSpecifier.WithIPv4Address(192.0.2.21)\r\nRemoteSpecifier.WithPort(443)\r\n```\r\n\r\nIt also implies that multiple is already allowed:\r\n\r\n```\r\nMultiple endpoint identifiers can be specified for each Local Endpoint and\r\nRemote Endpoint.  For example, a Local Endpoint could be configured with two\r\ninterface names, or a Remote Endpoint could be specified via both IPv4 and\r\nIPv6 addresses. These multiple identifiers refer to the same transport\r\nendpoint.\r\n```\r\n\r\nHow does that line up with the comment about `add()`, and having that replace?",
          "createdAt": "2020-07-16T17:58:55Z",
          "updatedAt": "2020-07-16T17:58:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As far as I can see, in the API draft we currently have add() for Properties and Security Parameters where each new add() overwrites the value for the old one.\r\nSo if we change this to add(), probably IP addresses should work the same.\r\nBut can't we just allow add() with a list of IP addresses instead of just with a single IP address?",
          "createdAt": "2020-07-17T15:49:58Z",
          "updatedAt": "2020-07-17T15:49:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- Allow adding an alias endpoint to an endpoint\r\n- Any one endpoint has at most one hostname\r\n- Any one endpoint has at most one port/service (if you need more, add an alias)\r\n- Any one endpoint has at most one address\r\n\r\nIf you need multiple source-specific multicast filters, use multiple connection objects",
          "createdAt": "2020-07-17T16:25:28Z",
          "updatedAt": "2020-07-17T16:25:28Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": " From @csperkins:\r\n\r\nThe Preconnection Object must be specified with both a Local Endpoint\r\n   and a Remote Endpoint, and also the transport properties and security\r\n   parameters needed for Protocol Stack selection.\r\nTo Rendezvous() we need multiple local and remote candidates. Should this be represented as either:\r\n\r\nRendezvous() taking two lists of Preconnection objects; or\r\nas two Preconnection objects each with multiple addresses, ports, etc.\r\nI suggest option 1, since this makes it easier to resolve a Preconnection to multiple preconnections, for NAT binding discovery.\r\n\r\nRelates to #571 but with also different types of endpoint.",
          "createdAt": "2020-09-11T15:08:03Z",
          "updatedAt": "2020-09-11T15:08:03Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm adding a point from @squarooticus here (and closing a separate issue that he opened, because this tackles the same problem space):\r\n\r\nIn the past, when I've designed transport abstraction APIs, I've always kept address family abstract, just as BSD sockets do. In this case, you've got WithIPv4Address and With IPv6Address as separate methods on the Endpoint type instead of just a single WithAddress method that takes an object of a type appropriate to the address family.\r\n\r\nSimilarly, you've got WithPort as a first-class method instead of making it part of the Endpoint, as BSD sockets does with sockaddr_in. What if you want to support both TCP and QUIC, but the QUIC endpoint is on a different port? The notion of \"port\" is similar between the two, making the use of the same name appropriate, but it is only by convention that they often match: they are completely different spaces implemented in entirely separate codepaths in every network stack. ICMP doesn't even have a port: what if you wanted to use that (or some other port-less protocol that, for instance, multiplexes via IPv6 host ID) with this interface.",
          "createdAt": "2020-09-16T07:14:17Z",
          "updatedAt": "2020-09-16T07:14:17Z"
        }
      ]
    },
    {
      "number": 575,
      "id": "MDU6SXNzdWU2MjczNjIzNzI=",
      "title": "Implementation NiTs from review",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/575",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "This reads oddly, is that better?:\r\n/Any violation of any of the layers should cause a protocol or path to be considered ineligible for use./\r\n/A violation of any of the layers should cause a protocol or path to be considered ineligible for use. /",
      "createdAt": "2020-05-29T15:46:11Z",
      "updatedAt": "2020-06-19T11:54:41Z",
      "closedAt": "2020-06-19T11:54:41Z",
      "comments": []
    },
    {
      "number": 576,
      "id": "MDU6SXNzdWU2MjczNjY1NTg=",
      "title": "Section 4.1.5 - minor wording NiTs?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/576",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "\r\nScavenger: This reads wrong to me, this is unutilised *capacity*\r\n/Highest available bandwidth/available capacity/\r\n\r\nWhy is /satisfy./ used for CR streaming? To me this implies admission-based QoS. Do we really mean this? Or should we say /expected/ here also?\r\n\r\n/Implementations process properties/\r\n- It would really have helped me to read this if we insert /the/ before properties.\r\n\r\n/As the available protocols and paths on a specific system and in a specific context may vary,/\r\nwould seem better as:\r\n/The available protocols and paths on a specific system and in a specific context can vary, therefore/\r\n\r\n/, by preferring protocols and paths that existing Connections with similar Properties are already using./\r\nshould be something like:\r\n/, by preferring protocols and paths that are already used by existing Connections that specified similar Properties./",
      "createdAt": "2020-05-29T15:50:43Z",
      "updatedAt": "2020-05-31T20:24:36Z",
      "closedAt": "2020-05-31T20:24:36Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR #583 (which includes text polishing).",
          "createdAt": "2020-05-30T09:06:58Z",
          "updatedAt": "2020-05-30T09:06:58Z"
        }
      ]
    },
    {
      "number": 577,
      "id": "MDU6SXNzdWU2MjczNjg2MTM=",
      "title": "4.2 Racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/577",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "In Section 4.2.1., I didn't really understand what \"immediate\" means from the text. I think it just needs one sentence.",
      "createdAt": "2020-05-29T15:53:59Z",
      "updatedAt": "2020-06-19T12:34:12Z",
      "closedAt": "2020-06-19T12:34:12Z",
      "comments": []
    },
    {
      "number": 578,
      "id": "MDU6SXNzdWU2MjczNjg4NzY=",
      "title": "Formalize definition of multipath Interactive",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/578",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Implementation",
        "ready for text"
      ],
      "body": "Get a better/more formal explanation of Interactive mode for multipath based on our experience with Siri, etc.",
      "createdAt": "2020-05-29T15:54:24Z",
      "updatedAt": "2020-07-18T23:47:54Z",
      "closedAt": "2020-07-18T23:47:54Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal from Christoph Paasch:\r\n\r\nThe connection should attempt to minimize the latency for interactive traffic patterns by\r\ntransmitting data across multiple paths. The goal of minimizing the latency will be balanced\r\nagainst the cost fo each of these paths, meaning that depending on the cost of the lower\r\nlatency path the scheduling might choose to use a higher latency path. Finally, the\r\nscheduling of the traffic can be done such that data may be transmitted on multiple paths\r\nin parallel to achieve the lowest latency possible.\r\n",
          "createdAt": "2020-06-18T16:36:01Z",
          "updatedAt": "2020-06-18T16:36:27Z"
        }
      ]
    },
    {
      "number": 579,
      "id": "MDU6SXNzdWU2MjczODExMjI=",
      "title": "5.1.1. Message Properties Editorial NiTs",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/579",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial",
        "review"
      ],
      "body": "5.1.1. Message Properties \r\n\r\nThis isn\u2019t really about /removing/ we need to express this differently, not sure what you wish to say:\u2028\r\n\r\nFor example, TCP cannot remove bytes from its send buffer, while in case of SCTP, such control over the SCTP send buffer can be exercised using the partial reliability extension [RFC8303]. \r\n\r\nand:\r\n\r\n/Final: when this is true, it means that a transport connection can be closed immediately after its transmission./\r\nI think this is:\r\n/Final: when this is true, it means that a transport connection can be closed immediately after transmission of the message./",
      "createdAt": "2020-05-29T16:15:42Z",
      "updatedAt": "2020-05-31T20:21:41Z",
      "closedAt": "2020-05-31T20:21:41Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR Update draft-ietf-taps-impl.md #582",
          "createdAt": "2020-05-30T08:51:12Z",
          "updatedAt": "2020-05-30T08:51:12Z"
        }
      ]
    },
    {
      "number": 580,
      "id": "MDU6SXNzdWU2MjczODUzNDc=",
      "title": "5.3 Is  \"Fast Open\" just one \"packet\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/580",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "The opening para reads to me like there is just one first packet. ... or is this actually more than one packets before the handshake complete?\r\n\r\n",
      "createdAt": "2020-05-29T16:23:15Z",
      "updatedAt": "2020-08-14T09:16:45Z",
      "closedAt": "2020-08-14T09:16:44Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is one packet for TCP, but it can be more for QUIC, TLS 1.3 (etc)",
          "createdAt": "2020-07-17T16:38:55Z",
          "updatedAt": "2020-07-17T16:38:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reference Connection Property \"Maximum Message Size Concurrent with Connection Establishment\"",
          "createdAt": "2020-07-17T16:41:29Z",
          "updatedAt": "2020-07-17T16:41:29Z"
        }
      ]
    },
    {
      "number": 584,
      "id": "MDU6SXNzdWU2MzAwNTA0NzI=",
      "title": "Rendezvous() text should be a bit more detailed",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/584",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "See this email thread:  https://mailarchive.ietf.org/arch/msg/taps/B5iPOvreJ49aSINAqrM04jNNOVk/\r\n\r\nCopy + pasting a relevant part from an email from @csperkins:\r\n\r\n\r\n```\r\nThis is one of the areas where the drafts likely need expanding, but I think the model is:\r\n\r\n1) application configures STUN (and maybe also TURN) local endpoints\r\n\r\n2) application calls Resolve() on these, to find server reflexive candidates\r\n\r\n3) application shares these candidates with its peer, via out-of-band means, and receives remote endpoint candidates from the peer\r\n\r\n4) application adds remote endpoints for the peer\u2019s candidates\r\n\r\n5) application calls Rendezvous(), which performs the ICE-style probing to find a working path, based on the candidates, then returns s Connection\r\n\r\nThis relies on the Endpoint abstraction supporting STUN, which is maybe implicit in the drafts. \r\n\r\n```\r\n\r\nTo me at least, it wasn't clear from the text that rendezvous() would kick off ICE-style probing. It's kind of obvious (when else would it happen?), but I think it would be good for the draft to spell this out.",
      "createdAt": "2020-06-03T14:35:12Z",
      "updatedAt": "2020-09-11T15:07:54Z",
      "closedAt": "2020-09-11T15:07:53Z",
      "comments": []
    },
    {
      "number": 588,
      "id": "MDU6SXNzdWU2NDE5Mzg3MjA=",
      "title": "Naming of different racing options.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/588",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial",
        "ready for text"
      ],
      "body": "Opening this to follow up on a comment by @mwelzl  on #587 that is now closed.\r\n\r\n\"Simultaneous\" and \"Staggered\" would be better names than \"Immediate\" and \"Delayed\". Just from these terms, I would normally think that \"Immediate\" means to start racing right away, whereas \"Delayed\" means that nothing would happen for some time. So these two terms are slightly misleading in my opinion.)",
      "createdAt": "2020-06-19T12:36:41Z",
      "updatedAt": "2020-07-16T20:44:00Z",
      "closedAt": "2020-07-16T20:44:00Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree this would be an improvement.",
          "createdAt": "2020-06-19T12:41:21Z",
          "updatedAt": "2020-06-19T12:41:21Z"
        }
      ]
    },
    {
      "number": 589,
      "id": "MDU6SXNzdWU2NDIwNDk1NDg=",
      "title": "multipath: when and how to open new subflows?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/589",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mirjak"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "Sorry we just merged the multipath part into the API doc but I think there is still an issue about this part:\r\n\r\n'Active: : The connection will negotiate the use of multiple paths if the chosen transport supports this. It will actively bring up paths based on the multipath policy ({{multipath-policy}}) selected by the application, as limited by the Interface Instance and Provisioning Domain Instance properties (see {{prop-interface}} and {{prop-pvd}}).\r\n\r\nPassive: : The connection will support the use of multiple paths if the remote endpoint requests it. The connection will not actively initiate the use of any new paths, but will accept paths initiated by the remote endpoint.'\r\n\r\nThis mixes two things which should be separated: requesting MP support actively (or just do it if requested by the other end) and opening of new subflows when MP support was negotiated successfully. I thought we wanted to take the later out (opening sub flows) and discuss that separately....?",
      "createdAt": "2020-06-19T15:24:42Z",
      "updatedAt": "2020-06-19T15:58:19Z",
      "closedAt": "2020-06-19T15:52:53Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just created PR #591 to remove the part about opening new subflows. Do we need to further discuss when/how to open subflows or do we leave this as open for now?",
          "createdAt": "2020-06-19T15:47:08Z",
          "updatedAt": "2020-06-19T15:47:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed by #591 ",
          "createdAt": "2020-06-19T15:52:53Z",
          "updatedAt": "2020-06-19T15:52:53Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree that interim (June 19) to not address opening of subflows in the API",
          "createdAt": "2020-06-19T15:58:19Z",
          "updatedAt": "2020-06-19T15:58:19Z"
        }
      ]
    },
    {
      "number": 595,
      "id": "MDU6SXNzdWU2NDIwOTY5MDY=",
      "title": "Protocol mappings for MPTCP",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/595",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Currently, the implementation document does not have mappings for MPTCP, even though MPTCP is part of minset.\r\nShould be boring, right? :)",
      "createdAt": "2020-06-19T16:35:15Z",
      "updatedAt": "2020-09-08T14:22:52Z",
      "closedAt": "2020-09-08T14:22:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should be taken care of by #605, yes",
          "createdAt": "2020-07-17T16:41:20Z",
          "updatedAt": "2020-07-17T16:41:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed byPR #605 ",
          "createdAt": "2020-09-08T14:22:52Z",
          "updatedAt": "2020-09-08T14:22:52Z"
        }
      ]
    },
    {
      "number": 608,
      "id": "MDU6SXNzdWU2NTkzNDcyMDQ=",
      "title": "Add properties to implementation protocol mappings",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/608",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "See discussion on #605",
      "createdAt": "2020-07-17T15:25:32Z",
      "updatedAt": "2020-10-02T16:43:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Provide a complete template that covers all functions/properties from the API. Indicate how the template should be used (e.g. leave out the parts that are not relevant for a particular protocol or include all fields and mark fields that are not relevant as such.",
          "createdAt": "2020-10-02T16:43:18Z",
          "updatedAt": "2020-10-02T16:43:18Z"
        }
      ]
    },
    {
      "number": 609,
      "id": "MDU6SXNzdWU2NTkzODQzNjk=",
      "title": "Rename \"add\" properties to \"set\" if they override",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/609",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "We should rename these if they are really setting and not adding.",
      "createdAt": "2020-07-17T16:09:36Z",
      "updatedAt": "2020-07-27T09:38:06Z",
      "closedAt": "2020-07-27T09:38:06Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The original idea to call it ```add``` was to emphasise that we add these properties to the set the system needs to consider. As we removed all Intents and decided to be much more conservative here, I agree ```set```is the better choice for the current API",
          "createdAt": "2020-07-25T07:49:30Z",
          "updatedAt": "2020-07-25T07:49:30Z"
        }
      ]
    },
    {
      "number": 610,
      "id": "MDU6SXNzdWU2NTk5OTY5NDU=",
      "title": "Allow to query for grouping",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/610",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "See the discussion in PR #607. I think this is best dealt with by merging PR #607 after a small fix, then doing a separate PR to address this.\r\n\r\nIMO the easiest way to do this is to allow to query a group number (a simple integer). Without grouping, every new Connection simply gets a new number. Having the same group number as any previous Connection(s) indicates group membership. This is how we did it in NEAT too.\r\n\r\nIf people agree with this, I can take care of this.\r\n",
      "createdAt": "2020-07-18T08:11:27Z",
      "updatedAt": "2020-07-21T09:13:58Z",
      "closedAt": "2020-07-21T09:13:57Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I remember the discussion in NEAT, to me it seems a good way to resolve the issue.",
          "createdAt": "2020-07-18T19:03:14Z",
          "updatedAt": "2020-07-18T19:03:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #607 now resolves this differently. It doesn't matter much, IMO the method in this PR also works fine.",
          "createdAt": "2020-07-19T09:47:45Z",
          "updatedAt": "2020-07-19T09:47:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I merged PR #607, which closes this issue.",
          "createdAt": "2020-07-21T09:13:57Z",
          "updatedAt": "2020-07-21T09:13:57Z"
        }
      ]
    },
    {
      "number": 612,
      "id": "MDU6SXNzdWU2NjM0NDUzMTI=",
      "title": "Allow setting multiple values for some Security Parameters",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/612",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "If calling Set() for Security Parameters overrides (#609), then the API should allow setting a Security Parameter to multiple values, e.g., using a list. This would be needed, e.g., to set multiple cipher suites.\r\n\r\nI don't think we need to make this overly formal. Adding one sentence to the Security Parameters section should be enough. \r\nRight?",
      "createdAt": "2020-07-22T03:27:34Z",
      "updatedAt": "2020-09-09T08:37:41Z",
      "closedAt": "2020-09-09T08:37:41Z",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also consider whether setting multiple values is not only needed for Security Properties, but also for Transport Properties like Interface and PvD. This one is more complex, as it comes with a ```(Preference, String)``` tuple.\r\n\r\nNot sure whether just adding a sentence and making ```set``` accept a list auf values is the right approach or if we should have an ```add``` call for that \u2013 The former is nicer in the API document, the latter seems more appropriate when thinking about how one would use the API",
          "createdAt": "2020-07-25T08:01:17Z",
          "updatedAt": "2020-07-25T08:01:17Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree that we want to enable setting multiple values for Interface and PvD, but I thought that's why their Type is \"Set (Preference, Enumeration)\" - I took this to mean that it's multiple Interfaces, each with a Preference. But reading the text again, maybe I misunderstood.\r\nIf I misunderstood, I think the best approach is to indeed allow specifying multiple (Preference, Enumeration) in a single Set() call.",
          "createdAt": "2020-07-26T16:23:54Z",
          "updatedAt": "2020-07-26T16:23:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #611",
          "createdAt": "2020-07-27T09:39:26Z",
          "updatedAt": "2020-07-27T09:39:26Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reopening this because I still think we should add a sentence to Section 5.3.1 of the API draft, perhaps simply saying that the implementation should support setting multiple values for a single Security Parameter.\r\nStill not sure about the Interface and PvD properties - I think that making set accept a list auf values, as suggested by @philsbln, is the right approach, but perhaps it's worth adding a sentence to explain this to their sections as well.",
          "createdAt": "2020-08-10T02:21:47Z",
          "updatedAt": "2020-08-10T02:21:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interface and PvD are already \"sets of tuples\". We could have a sentence to clarify that this is a \"collection\", or maybe just call it \"collection\". Maybe also add a sentence to the data types section to indicate that they can have collections. Mention in text that security parameters can take collections.",
          "createdAt": "2020-08-14T15:18:40Z",
          "updatedAt": "2020-08-14T15:18:40Z"
        }
      ]
    },
    {
      "number": 618,
      "id": "MDU6SXNzdWU2NzUxMzAzMDc=",
      "title": "Streams/Connections Relationship is unclear",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/618",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "I found the relationship between streams and connections to be extremely murky throughout the draft, and left it not really sure how I would control a streamed transport.\r\n\r\nSection 6.4 hints suggests that opening additional streams is an alternative implementation of Clone() for transports that can do so. Does this imply that if the peer stream limit does not allow new streams, the transport should open a connection instead? How does SetNewConnectionLimit() in Sec 6.2 relate to streamed transport -- are there two levels of listener: a stream listener and a connection listener? How would opening \"stream listeners\" relate to the maximum number of streams the peer could open (i.e. do I have to call listen() 8 times to allow the client to open 8 streams)? Or are there no stream listeners and these \"connections\" just sort of appear?\r\n\r\nSkimming the -impl draft, I can see there's some text here but it is not fitting together for me. There are at least three streamed transports and it would be helpful to explain how the API conceptualizes this, perhaps in a new section.",
      "createdAt": "2020-08-07T16:26:47Z",
      "updatedAt": "2020-09-11T16:30:38Z",
      "closedAt": "2020-09-11T16:30:38Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify, Listen() is called once and keeps receiving streams within the NewConnectionLimit.\r\n\r\nThe main thing to clarify is how the NewConnectionLimit applies to streams of a multiplexed transport.\r\n\r\nWe could look at having a limit of connections per endpoint in a group from a listener.",
          "createdAt": "2020-08-14T15:30:03Z",
          "updatedAt": "2020-08-14T15:30:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a property to section 7.1.",
          "createdAt": "2020-08-14T15:37:07Z",
          "updatedAt": "2020-08-14T15:37:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also make sure to have an early section being very explicit about the overall interaction model.",
          "createdAt": "2020-08-14T15:39:04Z",
          "updatedAt": "2020-08-14T15:39:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In section 4.1, we could add an example for explicit group management via clone, etc.",
          "createdAt": "2020-08-14T15:40:24Z",
          "updatedAt": "2020-08-14T15:40:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sigh, I will never self-assign an issue again *before* its discussion  :-)   but it's ok... I'll do it",
          "createdAt": "2020-08-14T15:43:30Z",
          "updatedAt": "2020-08-14T15:43:30Z"
        }
      ]
    },
    {
      "number": 619,
      "id": "MDU6SXNzdWU2NzUxMzgyNDg=",
      "title": "Priority Framework is confusing",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/619",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I'm not sure the priority framework really fits together.\r\n\r\nSec 6.4 says we 'should' do something that sounds like WFQ, but 7.1.5 allows the application to decide what happens. Meanwhile message priority suggests a strict priority-based scheduler.\r\n\r\nMeanwhile, in sec 8.1.3.2 \"Note that this property is not a per-message override of the  connection Priority - see Section 7.1.3.  Both Priority properties\r\n   may interact, but can be used independently and be realized by\r\n   different mechanisms.\" \r\n\r\nAt the risk of overindexing on a partly-baked draft in httpbis, how would I implement strict priority of HTTP/3 streams over a taps API that implements QUIC? Would I need to request strict priority in *both* connection priority and message priority? Or I guess connection priority would be sufficient?\r\n",
      "createdAt": "2020-08-07T16:36:41Z",
      "updatedAt": "2020-09-18T07:00:01Z",
      "closedAt": "2020-09-18T07:00:01Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We seem comfortable with the mechanisms in the API, but we should have more text connecting the various sections explaining priority.",
          "createdAt": "2020-08-14T15:54:41Z",
          "updatedAt": "2020-08-14T15:54:41Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My comment concerned \"7.1.3. Priority (Connection)\", my thought was this just influences the sender-side to control queuing within a connection group. If so, if it worth calling this property \"Group Priority\" and explain this is sender-side?",
          "createdAt": "2020-08-14T16:04:45Z",
          "updatedAt": "2020-08-14T16:04:45Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I find the priority framework perhaps overspecified at the connection level and underspecified at the message level, with the interaction between the two left explicitly unstated.\r\n\r\nI would almost rather see the priority type and meaning left completely implementation-specific; otherwise, my suspicion is that someone will write an application using numeric priorities, declare victory when it works fine on one platform, and not understand that the behavior is not universal.\r\n\r\nIn general, I think if TAPS is going to produce a consistent, easily-understandable, and portable API, it needs to stick to easily-understood abstractions. Message-level priority is sort of like the TCP URG mechanism (though better specified and more useful, for sure), but I'm thinking urgent messages sent explicitly out-of-band (e.g., new Connection) with implementation-specific QoS will produce more consistent, predictable, and understandable outcomes in the pessimal case.",
          "createdAt": "2020-09-10T16:49:35Z",
          "updatedAt": "2020-09-10T16:49:35Z"
        }
      ]
    },
    {
      "number": 620,
      "id": "MDU6SXNzdWU2NzUxMzkxMjA=",
      "title": "HTTP/1 pipelining vs new connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/620",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "mappings"
      ],
      "body": "I found myself continually asking how I would implement foo-over-http/x using this API, and stumbled over ambiguity regarding HTTP 1.1 pipelining. While it's certainly possible to order messages in the proper way using this API, if I was writing this agnostically to HTTP version, it appears it would gravitate to opening a pooled TCP connection for each request/response if we ended up on HTTP/1 [because each request/response would have a clone() call]. Maybe this is OK, but I found this conclusion to be jarring.",
      "createdAt": "2020-08-07T16:37:48Z",
      "updatedAt": "2021-02-25T09:47:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess the question is: why would it make sense to use this API agnostically to the HTTP version? It seems weird to me that someone would want to use a new stream (or something of that nature - a new \"Connection\", somehow grouped if possible - which is what the API offers) when implementing HTTP/1.1?\r\n\r\nCORRECTION: my answer here was based on thinking \"implement HTTP over TAPS\", not \"implement foo over HTTP over TAPS\". Whoever implements HTTP itself over TAPS should know what they're doing.",
          "createdAt": "2020-08-14T11:31:44Z",
          "updatedAt": "2020-08-14T15:58:36Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, there is an issue\u2026 we took quite some time to discuss this and I put a lot of effort in solving this with pooled connections, but it dropped out of the main API as we did not find an consensus how to tackle it.\r\n\r\nI guess writing an HTTP mapping document that extend taps in a way that brings HTTP with pipelining, racing, multi-streaming and multi-path under one message abstraction would be the right way forward. I am happy to help with that one.  ",
          "createdAt": "2021-02-25T09:47:56Z",
          "updatedAt": "2021-02-25T09:47:56Z"
        }
      ]
    },
    {
      "number": 621,
      "id": "MDU6SXNzdWU2NzUxNDA2MTQ=",
      "title": "API for enum values?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/621",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "sec 4.2.2\r\n\"implementations MUST provide a\r\n      method for the application to determine the entire set of possible\r\n      values for each property.\"\r\n\r\nIs this meant to be a requirement for a machine-readable API for learning the enum, or merely a requirement for documentation? i.e. is it satisfied if the values are in the man page or comments of the C header file?",
      "createdAt": "2020-08-07T16:40:39Z",
      "updatedAt": "2020-09-09T08:26:57Z",
      "closedAt": "2020-09-09T08:26:57Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a by-note, isn't this a great place to use \"REQUIRED\" and say whether it is required to specify or required to support :-).",
          "createdAt": "2020-08-12T10:50:51Z",
          "updatedAt": "2020-08-12T10:50:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal: Just remove \"however, implementations MUST provide a method for the application to determine the entire set of possible values for each property.\"\r\n\r\nThis is too implementation- and language- specific.",
          "createdAt": "2020-08-14T16:03:15Z",
          "updatedAt": "2020-08-14T16:03:15Z"
        }
      ]
    },
    {
      "number": 622,
      "id": "MDU6SXNzdWU2NzUxNDEwNTY=",
      "title": "Callback Registration API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/622",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "sec 5.\r\nI found it curious that there is no API here for registering callbacks, or mention that this is a precondition to connection. Surely event handlers are a prerequisite?",
      "createdAt": "2020-08-07T16:41:33Z",
      "updatedAt": "2020-08-14T16:07:34Z",
      "closedAt": "2020-08-14T16:07:34Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: OK to close",
          "createdAt": "2020-08-14T16:07:34Z",
          "updatedAt": "2020-08-14T16:07:34Z"
        }
      ]
    },
    {
      "number": 623,
      "id": "MDU6SXNzdWU2NzUxNDEyNjY=",
      "title": "List of endpoint attributes",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/623",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "sec 5.1\r\nI found it odd that there didn't appear to be any sort of formal list of attributes of an endpoint, just some examples.",
      "createdAt": "2020-08-07T16:41:59Z",
      "updatedAt": "2020-11-02T18:30:06Z",
      "closedAt": "2020-11-02T18:30:06Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should fix with #571 ",
          "createdAt": "2020-08-14T16:08:20Z",
          "updatedAt": "2020-08-14T16:08:20Z"
        }
      ]
    },
    {
      "number": 624,
      "id": "MDU6SXNzdWU2NzUxNDE1MDk=",
      "title": "Partial Coverage: Unclear Sentence",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/624",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "sec 5.2.7\r\nI am not sure what this sentence means: \"Disabling this property may enable to control checksum coverage later.\"",
      "createdAt": "2020-08-07T16:42:26Z",
      "updatedAt": "2020-09-07T20:29:26Z",
      "closedAt": "2020-09-07T20:29:26Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This text is confusing in several ways. Before I offer a rewrite, I have some questions, to which I'm sure others will be able to remind me of the reasons we arrived here.\r\n(a) I think the param in 5.2.7 and 5.2.8 may also be about a default for sending and receiving for the established connection, if so... each of these needs to supply an integer as per Section 8.1.3.6...? \r\n(b) If this isn't to establish the default, and only for influencing the selected protocol for a \"connection\", why do we have separate send and receive properties for partial coverage? (The only protocols I know can support this for both of the directions...)\r\n(c) I really don't understand how we arrived at \"8.1.3.6\". I think any practical use will need to be able to set the \"Corruption Protection Length\" for send and receive independently. Yet we finally only have one parameter.\r\n.... I'd be happy to propose text if someone can restore my understanding of what was intended.\r\n",
          "createdAt": "2020-08-12T10:36:29Z",
          "updatedAt": "2020-08-12T10:36:29Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair:\r\nRe: (a): I think this wasn't about an Integer, but about protocol choice (only for influencing the selected protocols, as you say under (b)).\r\nRe: (b): I think this was only a general thing before, and later divided (I don't fully remember why). I think, however, that it's a different thing to say \"I'm going to actively race this protocol\" and \"I'm going to also listen for incoming packets with this protocol\". So that's the distinction between these two, IIRC.\r\nRe: (c): What would a \"Corruption Protection Length\" parameter for receiving accomplish? With UDP-Lite, you only learn about it after the fact, but you can only generally accept to get such packets (as per 5.2.8), but then you can only learn about the length parameter that was used, not influence it, I think.",
          "createdAt": "2020-08-14T11:21:47Z",
          "updatedAt": "2020-08-14T11:21:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK on (a).\r\nYou describe (b) as somewhat useful, maybe the text should say this.\r\n\r\nOn (c) I still this still needs a send and receive number because SEND Minimum coverage and RECV Minimum coverage are two different things in RFC 3828, Sect 3.3.:\r\n\r\nA UDP-Lite receiver does not generally see the coverage value used in datagrams, it therefore needs to configure what min coverage it expects for the receiver stack to check before passing the datagram upwards (this could be per socket/connection). The receiver is probably clearer in RFC5097, Sect 1.3, which counts datagrams with the non-deliverable coverage \u201cEndpointViolCoverage\u201d.  \r\n\r\nAt the sender, each datagram needs to set an appropriate coverage (this typically needs to be per message).\r\n",
          "createdAt": "2020-08-14T14:07:51Z",
          "updatedAt": "2020-08-14T14:07:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just for the record, I agree with all points of @gorryfair above.",
          "createdAt": "2020-08-14T16:12:58Z",
          "updatedAt": "2020-08-14T16:12:58Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thought to now be addressed as a part of PR to API #642",
          "createdAt": "2020-08-17T12:52:04Z",
          "updatedAt": "2020-08-17T12:52:04Z"
        }
      ]
    },
    {
      "number": 625,
      "id": "MDU6SXNzdWU2NzUxNDIxNzE=",
      "title": "Clarify Use of Application Congestion Control",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/625",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial",
        "ready for text"
      ],
      "body": "sec 5.2.9\r\nIt would be helpful to say \"Applications that neither prohibit nor require congestion should query the result and disable their own congestion control if present in the transport\"",
      "createdAt": "2020-08-07T16:43:46Z",
      "updatedAt": "2020-09-11T16:09:02Z",
      "closedAt": "2020-09-11T16:09:02Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting, but we need to be careful in what we say. It seems safe, but not performant to do CC at multiple layers, and if it's done at a lower layer performance might be improved by not replicating the function at a higher layer...",
          "createdAt": "2020-08-12T10:47:14Z",
          "updatedAt": "2020-08-12T10:47:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Link to UDP guidelines document.\r\n\r\nJust mention that there are performance implications of multiple CC loops; don't just say \"disable CC\".",
          "createdAt": "2020-08-14T16:19:11Z",
          "updatedAt": "2020-08-14T16:19:11Z"
        }
      ]
    },
    {
      "number": 626,
      "id": "MDU6SXNzdWU2NzUxNDI3Nzg=",
      "title": "Problems with temporary local addresses",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/626",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "sec 5.2.12\r\nUsing temporary local addresses may break various mechanisms that prove address ownership (e.g QUIC resumption tokens) and therefore impair performance as the client has to re-verify its address.",
      "createdAt": "2020-08-07T16:44:52Z",
      "updatedAt": "2020-09-11T16:52:24Z",
      "closedAt": "2020-09-11T16:52:24Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The default is to use a temporary address for client local address; and to not use it for a server local address. This is the same as most socket APIs. What are you suggesting in the text, @martinduke?",
          "createdAt": "2020-08-07T16:56:41Z",
          "updatedAt": "2020-08-07T16:56:41Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "right, a QUIC resumption token will generally contain the client's IP address so that future connections no longer have to go through Retry and anti-amplification mechanisms, which reduce throughput.\r\n\r\nso IIUC 5.2.12 could say something like \"Clients that use temporary local addresses might invalidate server-provided tokens that validate the client's IP addresses (e.g. Sec 8.1.3 of quic-transport), increasing latency.\"",
          "createdAt": "2020-08-07T17:56:19Z",
          "updatedAt": "2020-08-07T17:56:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a one-sentence warning that using a temporary address has a potential performance impact on resumption.",
          "createdAt": "2020-08-14T16:36:29Z",
          "updatedAt": "2020-08-14T16:36:29Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we wish to refer to RFC 7721?",
          "createdAt": "2020-08-17T10:44:00Z",
          "updatedAt": "2020-08-17T10:44:00Z"
        }
      ]
    },
    {
      "number": 627,
      "id": "MDU6SXNzdWU2NzUxNzgwNzE=",
      "title": "Does stop() add value to the API?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/627",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "sec 6.2 \r\n\"After Stop() is called, the Listener can be disposed of.\" I don't understand the difference between calling listener.stop() and simply disposing of the object. Does this imply that there is a listener.start() that allows a configured listener to resume?",
      "createdAt": "2020-08-07T17:57:32Z",
      "updatedAt": "2020-09-11T16:24:34Z",
      "closedAt": "2020-09-11T16:24:34Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should just not talk about \"disposing\" here. Just remove the sentence.",
          "createdAt": "2020-08-14T16:40:01Z",
          "updatedAt": "2020-08-14T16:40:01Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Object disposal implies a language with synchronous destruction, something we can't assume. For something garbage collected, you'd need an explicit close method because you don't know when the object will be destroyed.",
          "createdAt": "2020-09-10T16:41:14Z",
          "updatedAt": "2020-09-10T16:41:14Z"
        }
      ]
    },
    {
      "number": 628,
      "id": "MDU6SXNzdWU2NzUxNzg3NjA=",
      "title": "Clarify idle timeout, specify keep alive enablement",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/628",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "sec 7.1.4\r\nIt would be helpful to clarify the relevance of control vs application data in the idle timeout -- for various reasons, the connection could stay alive regardless of how active the connection is (in fact, perhaps \"keepalive\" is a generally useful notion that can be exposed in the API?)",
      "createdAt": "2020-08-07T17:58:51Z",
      "updatedAt": "2020-10-23T11:44:47Z",
      "closedAt": "2020-10-23T11:44:47Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The timeout in 7.1.4 should include control data (like ACKs, etc). This should be clarified: \"data\" in this context is any transport data, not just application data.\r\n\r\nWe can have a simple boolean to enable keepalives as well.",
          "createdAt": "2020-08-14T16:47:02Z",
          "updatedAt": "2020-08-14T16:47:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aha, this should have been closed by PR #643, but \"responds to issue #628\" wasn't auto-detected by git. Manually closing now.",
          "createdAt": "2020-10-23T11:44:47Z",
          "updatedAt": "2020-10-23T11:44:47Z"
        }
      ]
    },
    {
      "number": 629,
      "id": "MDU6SXNzdWU2NzUxNzkxNDA=",
      "title": "minSendRate, minRecvRate",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/629",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "sec 7.1.8\r\nThis section is missing a reference to minSendRate and minRecvRate",
      "createdAt": "2020-08-07T17:59:36Z",
      "updatedAt": "2020-09-11T16:24:43Z",
      "closedAt": "2020-09-11T16:24:43Z",
      "comments": []
    },
    {
      "number": 630,
      "id": "MDU6SXNzdWU2NzUxNzk1MDk=",
      "title": "Event for PMTU changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/630",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "mirjak"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "sec 7.1.9.\r\nWe're going to need an event for MTU changes. These can't simply be Send errors because the Sent event might go first, or the transport might be sending a probe with padding that doesn't correspond to a message.",
      "createdAt": "2020-08-07T18:00:18Z",
      "updatedAt": "2020-10-02T16:05:03Z",
      "closedAt": "2020-10-02T16:04:55Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So does this mean MTU of the interface or PMTU of the path?\r\n- It seems simple to add an event for interface MTU changes.\r\n-  For the PMTU, this raises a few questions before we add:\r\n(i) I can see the motivation for an event for a decrease in PMTU, and that seems relatively easy to add ... and could also return the new upper limit\r\n(ii) Would the same also be true of an increase in the PMTU? If so, it could be helpful if the upper layer probably says how \"large\" it is interested in using - e.g., DPLPMTUD has the notion of MAX_PLPMTU as an upper bound on probing. ",
          "createdAt": "2020-08-12T10:14:42Z",
          "updatedAt": "2020-08-12T10:14:42Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PMTU of the path. I don't have a strong opinion on increases, but I would probably have an event for increases and not bother with the maximum. An unnecessary increase notification seems less expensive than another bit of API to specify the max.",
          "createdAt": "2020-08-12T15:25:13Z",
          "updatedAt": "2020-08-12T15:25:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just add a path changed event to the application (similar to the one in implementation).",
          "createdAt": "2020-08-14T16:51:48Z",
          "updatedAt": "2020-08-14T16:51:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add event to Section 7.3?",
          "createdAt": "2020-08-14T16:52:29Z",
          "updatedAt": "2020-08-14T16:52:29Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to be sure: This is a Path Changed Event, not a specific event relating to PMTU size.",
          "createdAt": "2020-08-14T16:55:13Z",
          "updatedAt": "2020-08-14T16:55:13Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New text looked good, I think this issue has been resolved.",
          "createdAt": "2020-10-02T14:29:17Z",
          "updatedAt": "2020-10-02T14:29:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#648 closed this.",
          "createdAt": "2020-10-02T16:05:02Z",
          "updatedAt": "2020-10-02T16:05:02Z"
        }
      ]
    },
    {
      "number": 631,
      "id": "MDU6SXNzdWU2NzUxNzk2OTc=",
      "title": "Peer user timeout",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/631",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "sec 7.2\r\nperhaps I'm not thinking of this correctly, but should there be a way to query the peer-offered user timeout?",
      "createdAt": "2020-08-07T18:00:46Z",
      "updatedAt": "2021-04-07T17:16:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks protocol-specific (it's not a generic transport function). QUIC could let you query it in a protocol-specific property.\r\n\r\nProposing moving to the QUIC mapping doc.",
          "createdAt": "2020-08-14T16:55:46Z",
          "updatedAt": "2020-08-14T16:55:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with addressing this in the QUIC mapping doc, but for clarification: this is protocol-specific already (it's about a protocol-specific TCP property), and I added a clarification that the API calls reflect the API specified in Section 3 of RFC 5482 (which doesn't include this functionality).\r\n\r\n=> I agree that allowing to query the peer's UTO might be useful, but it's probably not worth adding more text for this, as I also suspect that nobody will implement this for TCP anyway (even the underlying logic from RFC 5482 isn't widely available either AFAIK). If someone does, they are still free to allow querying whatever they like ... but IMO, we shouldn't make this document longer with more protocol-specific elements than we absolutely need to include.",
          "createdAt": "2020-09-09T09:40:13Z",
          "updatedAt": "2020-09-09T09:40:13Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we close the Peer user timeout with no-action?",
          "createdAt": "2021-04-07T17:16:23Z",
          "updatedAt": "2021-04-07T17:16:23Z"
        }
      ]
    },
    {
      "number": 632,
      "id": "MDU6SXNzdWU2NzUxODAyNjI=",
      "title": "Sent<> event after ack",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/632",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "sec 8.3.2.1\r\nReading the Sent event, I was pretty sure that reliable transports would deliver the event until the ack arrived. But Sec 10 most definitely does not say that. I would think that the ack would be a more useful signal, but maybe I'm in the rough on this -- certainly many transport implementations will not do this well.",
      "createdAt": "2020-08-07T18:01:58Z",
      "updatedAt": "2020-08-07T18:59:55Z",
      "closedAt": "2020-08-07T18:59:55Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We generally don't think that having the signal be based on getting an ack is the right thing to do. This won't always be possible, for one, and it isn't clear what to do.\r\n\r\nThe signal for the send completing is that the data is *sent*, which means that there was room in the window. If data can't be sent, this provides backpressure. Backpressure should operate at the layer of the transport's window more than the acking details.",
          "createdAt": "2020-08-07T18:25:37Z",
          "updatedAt": "2020-08-07T18:25:37Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense, I'll close this issue.",
          "createdAt": "2020-08-07T18:59:55Z",
          "updatedAt": "2020-08-07T18:59:55Z"
        }
      ]
    },
    {
      "number": 634,
      "id": "MDU6SXNzdWU2Nzc3MDEyNDk=",
      "title": "In Arch.... this sentence reads like a paper, rather than an Arch spec.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/634",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Architecture",
        "editorial"
      ],
      "body": "OLD:\r\nAmong the Functional and Optimizing Features, some were common across all or nearly all transport protocols, while others could be seen as features that, if specified, would only be useful with a subset of protocols, but would not harm the functionality of other protocols.\r\n\r\nSuggest NEW:\r\nSome Functional and Optimizing Features are common across all or nearly all transport protocols. Other features might only be useful with a subset of protocols, but would not harm the functionality of other protocols.\r\n",
      "createdAt": "2020-08-12T13:37:14Z",
      "updatedAt": "2020-09-07T20:29:26Z",
      "closedAt": "2020-09-07T20:29:26Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re-reading this in context, I proposed a simpler one-word addition as a part of PR #641.",
          "createdAt": "2020-08-17T09:47:32Z",
          "updatedAt": "2020-08-17T09:47:32Z"
        }
      ]
    },
    {
      "number": 635,
      "id": "MDU6SXNzdWU2Nzc3MDgyMTA=",
      "title": "Figure Legends in API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/635",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial",
        "ready for text"
      ],
      "body": "We should update the figure/table legends:\r\n\r\nadd: Table 1: /Selection Properties Preferences/\r\n\r\nIn Section 8.1.2.,\r\n\r\nadd: /Figure 1: Protocol Stack showing a Message Framer/\r\n\r\nIn Section 10,\r\n\r\n/Figure 1/Figure 2/\r\n",
      "createdAt": "2020-08-12T13:47:19Z",
      "updatedAt": "2020-09-09T08:29:06Z",
      "closedAt": "2020-09-09T08:29:06Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is for API, not Architecture. These sections are references to API, as far as I can tell.",
          "createdAt": "2020-08-13T16:59:19Z",
          "updatedAt": "2020-08-13T16:59:19Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not a native speaker, so I probably shouldn't even be making this suggestion ....  but: isn't the use of plural slighly odd in the first item ?\r\n\r\nin the PR, I have now proposed \"Selection Property Preference Levels\" instead of \"Selection Properties Preference Levels\".",
          "createdAt": "2020-09-03T07:07:49Z",
          "updatedAt": "2020-09-03T07:07:49Z"
        }
      ]
    },
    {
      "number": 636,
      "id": "MDU6SXNzdWU2NzkxNjE3Nzg=",
      "title": "Rendezvous() example in \u00a74.1.3 is simplistic",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/636",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API"
      ],
      "body": "The peer example showing how to use `Rendezvous()` in \u00a74.1.3 is overly simplistic. It's likely worth showing the interactions with STUN, etc.",
      "createdAt": "2020-08-14T13:35:28Z",
      "updatedAt": "2020-12-11T16:44:21Z",
      "closedAt": "2020-12-11T16:44:21Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. The example gives the reader no real indication of what the call to Rendezvous() does.\r\n\r\nI'm also not sure I would reference TCP simultaneous open in \u00a76.3. Given its dependence on time synchronization between peers, does anything actually use it, and is there any utility to it vs. one side listening and the other connecting, with the listener rejecting anything with the wrong getpeername()? STUN OTOH would be a great example of how TAPS could greatly simplify something that requires multiple explicit connections with BSD sockets for setup.",
          "createdAt": "2020-09-10T16:39:01Z",
          "updatedAt": "2020-09-10T16:39:01Z"
        }
      ]
    },
    {
      "number": 646,
      "id": "MDU6SXNzdWU2ODk3NDM1ODM=",
      "title": "should prop-cc be an enum?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/646",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "the api draft currently has congestion control as a Boolean, but it's not quite that simple.\r\n- Some applications might want \"least effort\" LEDBAT type behavior\r\n- Others might need a warning if the transport can't achieve a certain bit rate.\r\n- To get really fancy, there could be congestion controls parameterized for mobile, lossy links, etc.\r\n\r\nThe allowed values might be:\r\n{ none, best effort, least effort, fixed bit rate }\r\nor something to that effect.\r\n\r\nIt's always an option for the application to just do 'none' and implement odd congestion controls in the app, but it would be nice if we could bring high-level qualitative constraints into taps. On other hand existing APIs don't do much of this so perhaps it's too much to take on.",
      "createdAt": "2020-09-01T01:59:43Z",
      "updatedAt": "2020-09-01T15:56:00Z",
      "closedAt": "2020-09-01T15:56:00Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have to be careful about prescribing internals to the TAPS system (which takes away implementation flexibility and makes it more likely for the system to fail meeting a request), and focus on describing services instead.\r\n\r\nClearly, \"congestion control or not\" is a service, because the application really should take care of it if it isn't being offered.\r\nHowever, if the TAPS system is offering congestion control, then it shouldn't be the application's business to decide whether the TAPS system should implement the things you're asking for via congestion control, or via some other means (and we can always allow to query, for applications that really do care about this level of detail; but for these cases, as you say, it would also be possible to say 'none' and do it exactly as you wish in your application).\r\n\r\nSo, to be concrete about your points:\r\n- Scavenger-type behavior is encoded as a value of the capacity profile. The text there hints about using a DSCP value, but there should be nothing in the way of a TAPS system implementing this with LEDBAT, or using both LEDBAT and a DSCP value - or whatever other means it may have available.\r\n- This item about the bit rate is covered by the Generic Connection Property \"Bounds on Send or Receive Rate\".\r\n- Parametrizing congestion control per link is exactly the type of thing an application shouldn't be bothered about, but a TAPS system could automate below, depending on what it knows about the path.  Give it the freedom to do so!",
          "createdAt": "2020-09-01T06:59:10Z",
          "updatedAt": "2020-09-01T06:59:51Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl good point -- I didn't appreciate how these other controls interact.",
          "createdAt": "2020-09-01T15:56:00Z",
          "updatedAt": "2020-09-01T15:56:00Z"
        }
      ]
    },
    {
      "number": 647,
      "id": "MDU6SXNzdWU2OTEyNDA2NTQ=",
      "title": "retransmission vs. loss?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/647",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "We have an Excessive retransmissions event (section 7.3.2) which says this is only available for reliable transport. However, QUIC with datagram would also be able to generate a loss notification (even though data would not be retransmitted as there are ACKs anyway). Shouldn't this be an Excessive loss event instead?",
      "createdAt": "2020-09-02T17:24:13Z",
      "updatedAt": "2020-09-18T08:23:01Z",
      "closedAt": "2020-09-18T08:23:01Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we are making things to complicated now. I think we should leave the excessive retransmission for reliable transport. Talking about excessive loss there sounds awkward to me. Excessive loss sound more like multiple packets in a row (with possibly different content) being lost.\r\n \r\nThen we can add a loss notification event if we want, but then that should just apply to a single packet and a single loss.\r\n\r\nMaybe this is similar to what @mwelzl was saying in the pull request #650 but I found it hard to parse how that mapped to what was actually happening in the text updates.",
          "createdAt": "2020-09-10T08:11:42Z",
          "updatedAt": "2020-09-10T08:11:42Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought this was interesting to think through. However, after now thinking I'm really unsure \"excessive loss\" is a clear signal to provide or that it is desirable. \r\n\r\nAfter thinking I also really do not like \"excessive retransmissions\". This isn't well defined. Is that a count of packets retx, losses, congestion events, whatever. Is this for the lifetime of the connection, or per RTT, or something in between. And finally what can application usefully do with this? If it is multi-streamed is this for the aggregate connection or the stream, and how does the app react in each case? Some transports don't tell you (or can't) and then how does the app. react? Then why not \"excessive congestion\" for cases with ECN or where FEC was used in some way? What does \"excessive\" mean wrt to audio? etc? To me, there are far too many questions to yield a useful signal. \r\n\r\nMy feeling is that this has its origins in RFC1122, from an old style Internet and should be safely consigned to the same fate as the unhelpfully ambiguous \"source-quench\". Both are a bad idea.\r\n\r\nQUIC appears to complicate things, in reality this topic was already very complex for RTP, use of FEC, and SCTP, etc  I think it is unhelpful to expose a signal that has no clear semantic or interpretation. \r\n\r\nCan we please remove this from the API? \r\n",
          "createdAt": "2020-09-10T08:32:25Z",
          "updatedAt": "2020-09-10T08:32:25Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we want to remove it I have no objections, specific applications could always add something like this as extra functionality if they want. If we keep it, I agree we need to make it more clear.",
          "createdAt": "2020-09-10T09:16:13Z",
          "updatedAt": "2020-09-10T09:16:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I think this was hard to see because it was scattered across text updates in the PR - but: if all my text updates are accepted, we'd be left with the following:\r\n\r\n1) a notification of loss,\r\n2) a retransmission threshold to notify about 1), which is only relevant for reliable transfers (this covers the RFC 1122 TCP thing).\r\n\r\nItem 1) can be about a Message. The complex cases for RTP, FEC etc. are about signaling the right information back from the receiver - but this can be about every individual Message. Then, an application can construct a metric itself, like loss-per-second or max-number-of-consecutive-lost-messages-during-the-last-minute or whatever. Because it's an event, it's also easy to ignore.\r\n\r\nIs that not easy enough?  Again, if you like it, all my proposed text updates together already achieve this. Possibly, an efficient way to do it could be to accept them and merge the PR, and then fine-tune the text more if you want - if you agree with the general approach at all.\r\n\r\nIf we want to throw it out, sure, we can do this too... but I'm sceptical about throwing out useful QUIC abilities that TAPS users may want.",
          "createdAt": "2020-09-10T11:39:26Z",
          "updatedAt": "2020-09-10T11:39:26Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We discussed this at the interim and decided to remove the excessive retransmission notification entirely.",
          "createdAt": "2020-09-11T16:19:04Z",
          "updatedAt": "2020-09-11T16:19:04Z"
        }
      ]
    },
    {
      "number": 655,
      "id": "MDU6SXNzdWU2OTgyODcwODA=",
      "title": "Strange disappearing sentence compilation mistery",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/655",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly",
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "\u00a74.2: \"Although Connection Properties (see Section 7.1) can be set during pre-establishment, they may be changed later.\"\r\n\r\nFour sentences later:\r\n\r\n\"Connection Properties can be set on Preconnections\"",
      "createdAt": "2020-09-10T17:42:48Z",
      "updatedAt": "2020-10-23T15:46:06Z",
      "closedAt": "2020-10-23T15:46:06Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unrelated, but about the same text: I notice something weird here, regarding compilation.\r\n\r\nLooking at https://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-interface.html  I see:\r\n`They are used to inform decisions made during establishment and to fine-tune the established connection.Section 8.1.3).`\r\n... which is broken at the end.\r\n\r\nHowever, looking at https://github.com/ietf-tapswg/api-drafts/blob/master/draft-ietf-taps-interface.md  I see:\r\n`They are used to inform decisions made during establishment and to fine-tune the established connection.\r\nThe behavior of the selected protocol stack(s) when sending Messages is controlled by Message Properties (see {{message-props}}).`\r\n\r\n... which is much better.\r\nSince the last manual commit is 2 days ago, this must be a strange compilation mistake.",
          "createdAt": "2020-09-11T11:10:42Z",
          "updatedAt": "2020-09-11T11:10:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #673 has addressed Kyle's point - so this is now about something else. Please see my comment above.",
          "createdAt": "2020-09-11T17:24:15Z",
          "updatedAt": "2020-09-11T17:24:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `.md` file is the correct copy. We can close this.",
          "createdAt": "2020-10-23T15:46:06Z",
          "updatedAt": "2020-10-23T15:46:06Z"
        }
      ]
    },
    {
      "number": 656,
      "id": "MDU6SXNzdWU2OTgyOTQ5NDI=",
      "title": "Address family and port abstraction",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/656",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "In the past, when I've designed transport abstraction APIs, I've always kept address family abstract, just as BSD sockets do. In this case, you've got WithIPv4Address and With IPv6Address as separate methods on the Endpoint type instead of just a single WithAddress method that takes an object of a type appropriate to the address family.\r\n\r\nSimilarly, you've got WithPort as a first-class method instead of making it part of the Endpoint, as BSD sockets does with sockaddr_in. What if you want to support both TCP and QUIC, but the QUIC endpoint is on a different port? The notion of \"port\" is similar between the two, making the use of the same name appropriate, but it is only by convention that they often match: they are completely different spaces implemented in entirely separate codepaths in every network stack. ICMP doesn't even have a port: what if you wanted to use that (or some other port-less protocol that, for instance, multiplexes via IPv6 host ID) with this interface.",
      "createdAt": "2020-09-10T17:50:57Z",
      "updatedAt": "2020-09-16T07:14:31Z",
      "closedAt": "2020-09-16T07:14:31Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #571 - this should in principle be covered by the PR answering #571. We think it should be made clear that EndPoints are abstract entities and can have more than just ports, addresses, ... etc.",
          "createdAt": "2020-09-11T16:35:13Z",
          "updatedAt": "2020-09-11T16:35:13Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, we can either move this point over to #571 and close this, or leave it open as a placeholder once that one has been resolved to see if everything is covered. Your choice.",
          "createdAt": "2020-09-15T22:09:14Z",
          "updatedAt": "2020-09-15T22:09:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moved; closing.",
          "createdAt": "2020-09-16T07:14:31Z",
          "updatedAt": "2020-09-16T07:14:31Z"
        }
      ]
    },
    {
      "number": 657,
      "id": "MDU6SXNzdWU2OTgyOTg3NTM=",
      "title": "Early binding  -> privacy considerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/657",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "I would reword this text in \u00a75.1:\r\n\r\n> The API explicitly does not require the application to resolve names, though there is a tradeoff between early and late binding of addresses to names. Early binding allows the API implementation to reduce connection setup latency, at the cost of potentially limited scope for alternate path discovery during Connection establishment, as well as potential additional information leakage about application interest when used with a resolution method (such as DNS without TLS) which does not protect query confidentiality.\r\n\r\nsuch that the tradeoff is listed in a (new) privacy considerations section, leaving the description of the reduced connection setup latency in early binding here as a functional justification.",
      "createdAt": "2020-09-10T17:54:23Z",
      "updatedAt": "2020-10-02T15:12:43Z",
      "closedAt": "2020-10-02T15:12:43Z",
      "comments": []
    },
    {
      "number": 658,
      "id": "MDU6SXNzdWU2OTgzMjE2MjU=",
      "title": "To abstract or not to abstract? That is the question",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/658",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API"
      ],
      "body": "Selection property querying is better than it was, but querying still feels odd:\r\n\r\n* Using \"has been applied\" to mean \"on\" or \"in use\" or \"active\" necessitates a bunch of explanatory text in \u00a75.2 that would otherwise be unnecessary.\r\n\r\n* Reporting \"true\" for properties that are \"on\" or \"in use\" or \"active\" is very UNIX-y, but less abstract than I'd like to see here. At least we're not encoding -1 as a special return value anymore. A perhaps suitably abstract interface here would be something like:\r\n\r\n```\r\ntp := Connection.GetTransportProperties()\r\nif tp.has('reliability'): ...\r\n```\r\n",
      "createdAt": "2020-09-10T18:14:15Z",
      "updatedAt": "2021-02-26T16:53:08Z",
      "closedAt": "2021-02-26T16:53:08Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Welcome, author!",
          "createdAt": "2020-09-11T16:27:24Z",
          "updatedAt": "2020-09-11T16:27:24Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh. Can I insert a GIF of a pile of books falling on me?",
          "createdAt": "2020-09-15T22:08:28Z",
          "updatedAt": "2020-09-15T22:08:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, make SecurityParameters more abstract (don't do \"strings\" that look like Python).",
          "createdAt": "2020-10-23T16:01:24Z",
          "updatedAt": "2020-10-23T16:01:24Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also, make SecurityParameters more abstract (don't do \"strings\" that look like Python).\r\n\r\nI made a change in the third commit of #658. LMK if that matches your expectations.",
          "createdAt": "2021-01-28T20:16:46Z",
          "updatedAt": "2021-01-28T20:16:46Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Er, I mean #687. @tfpauly ",
          "createdAt": "2021-02-17T22:11:34Z",
          "updatedAt": "2021-02-17T22:11:34Z"
        }
      ]
    },
    {
      "number": 659,
      "id": "MDU6SXNzdWU2OTgzMjI2NzQ=",
      "title": "Example needed for session cache management",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/659",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In \u00a75.3.1.",
      "createdAt": "2020-09-10T18:15:21Z",
      "updatedAt": "2020-11-02T17:11:55Z",
      "closedAt": "2020-11-02T17:11:55Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is missing pseudo-code.",
          "createdAt": "2020-10-23T15:48:49Z",
          "updatedAt": "2020-10-23T15:48:49Z"
        }
      ]
    },
    {
      "number": 660,
      "id": "MDU6SXNzdWU2OTgzMjM5OTQ=",
      "title": "Unclear text near end of \u00a75.2",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/660",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I am having difficult parsing:\r\n\r\n> even if this default could lead to a connection failure, as, for example, an application needs to be explicitly designed to support a connectionless mode. In this case, the application can recognize the failure and explicitly specify a different set of Protocol Selection Properties that result in a usable protocol.",
      "createdAt": "2020-09-10T18:16:32Z",
      "updatedAt": "2020-09-11T16:14:59Z",
      "closedAt": "2020-09-11T16:14:59Z",
      "comments": []
    },
    {
      "number": 661,
      "id": "MDU6SXNzdWU2OTgzMjkwNjI=",
      "title": "Preference level interaction",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/661",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "> Therefore, the transport system SHOULD race the path first, ignoring the protocol preference if a specific protocol does not work on the path.\r\n\r\nPresumably this is true only if:\r\n\r\n* A candidate protocol has no property marked `Prohibit`\r\n* All candidate protocols have every property marked `Require`\r\n\r\nI know we rejected any attempt to allow the user to encode preference ordering in the transport selection properties, but should a single order be normatively specified in this document? Right now, there is only one rule and that is \"prefer paths over protocol properties\", which might be fine, but it's unclear how this would work in practice.",
      "createdAt": "2020-09-10T18:21:22Z",
      "updatedAt": "2020-09-11T16:43:50Z",
      "closedAt": "2020-09-11T16:43:50Z",
      "comments": []
    },
    {
      "number": 662,
      "id": "MDU6SXNzdWU2OTgzNDg4NTM=",
      "title": "SecurityParameters probably needs a rework",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/662",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "The SecurityParameters section seems to be describing an abstract API that assumes the underlying security protocol is TLS. I have a few questions that might motivate a rework:\r\n\r\n* What if I want to race TLS/TCP against QUIC, and have different credentials for each\r\n* What if I want to race two TLS connections against each other, and have different credentials for each?\r\n* What if I have multiple supported groups?\r\n* What if my security protocol authenticates peer identities some way other than challenge/response?\r\n* How does this API relate to the work done in draft-ietf-taps-transport-security? There's a nice section in appendix B describing the relation to minset, but no equivalent for this.\r\n\r\nI'm not sure if something completely generic is possible here. It might be that the interface to the underlying security protocol might need to be specific to the state machine for the protocol itself. You could potentially do something like:\r\n\r\n```\r\nep1_tls := TLS_Parameters(private_key=priv1, cert_chain=pub1, ca_list=public_ca_list, ...)\r\nSecurityParameters.Register(RemoteEP1, ep1_tls)\r\nep2_tls := TLS_Parameters(priv_op_cb=curry(sign_with_hsm, hsm_handle1), cert_chain=pub2, \\\r\n    auth_peer_cb=curry(verify_with_hsm, hsm_handle1), ...)\r\nSecurityParameters.Register(RemoteEP2, ep2_tls)\r\n```",
      "createdAt": "2020-09-10T18:41:08Z",
      "updatedAt": "2020-10-23T16:04:57Z",
      "closedAt": "2020-10-23T16:04:57Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "FTR:\r\n\r\nI have come completely 180\u00b0 on this after a discussion about the security implications of \"racing\" security parameters in the interim. This should be resolved in favor of specifying a single set of security parameters which then constrain the rest of protocol and path selection. Text should be added to clarify that this is how security parameters affect protocol selection.",
          "createdAt": "2020-10-02T16:04:50Z",
          "updatedAt": "2020-10-02T16:05:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed in interim, we should keep things with a single identity, etc. ALPN is an exception, but the current semantics don't prevent having ALPN that is conditional to transports.\r\n\r\nWe may want to mention the identity issues or refer back to the architecture security considerations in the API security considerations.",
          "createdAt": "2020-10-23T16:04:24Z",
          "updatedAt": "2020-10-23T16:04:24Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided that if an application wants to race protocols using different trust anchors or identities, the application needs to explicitly support that through some assertion that all identities are equivalent, e.g., by packaging them in a container that TAPS considers to be a single identity for its purposes.",
          "createdAt": "2020-10-23T16:04:57Z",
          "updatedAt": "2020-10-23T16:04:57Z"
        }
      ]
    },
    {
      "number": 663,
      "id": "MDU6SXNzdWU2OTgzNTE3ODk=",
      "title": "\"Entangled\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/663",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\"Entangled\" appears eight times in the doc and its effect is never precisely defined. The doc should specify in an easily-consumable format (e.g., a table, but not necessarily a table) exactly which properties are shared between cloned connections and which aren't.",
      "createdAt": "2020-09-10T18:43:45Z",
      "updatedAt": "2020-09-11T16:20:17Z",
      "closedAt": "2020-09-11T16:20:17Z",
      "comments": []
    },
    {
      "number": 664,
      "id": "MDU6SXNzdWU2OTgzNTYyNTQ=",
      "title": "Message framers form a pipeline",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/664",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "In \u00a78.1.2 \u00b63, the doc says:\r\n\r\n> the Message Framer can intercept all calls to Send() or Receive() on a Connection to add Message semantics\r\n\r\nbut this doesn't seem to be conceptually compatible with the text at the top of \u00a78.1.2.1, which says:\r\n\r\n> Multiple Framers may be added.\r\n\r\nI think the way most developers would think about this is as a pipeline: you feed data into the top-level framer with Send, which then percolates downward through the pipeline to the bottom-level framer, which then sends it to the transport.",
      "createdAt": "2020-09-10T18:47:18Z",
      "updatedAt": "2020-10-02T16:23:15Z",
      "closedAt": "2020-10-02T16:23:15Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this should be easy to address, by rephrasing:\r\n`Multiple Framers may be added.`\r\nas:\r\n`Multiple Framers may be added. In this case, Framers that are added in addition to already existing Framers call each other.`\r\n\r\n... BUT \"call each other\" is surely a terrible way to put this, and there must be a way to say this cleanly and neatly, in line with how the code really goes. THIS, I suspect, is a very simple thing for @tfpauly to do, and hence I assigned it to him.",
          "createdAt": "2020-09-17T13:35:06Z",
          "updatedAt": "2020-09-17T13:35:06Z"
        }
      ]
    },
    {
      "number": 665,
      "id": "MDU6SXNzdWU2OTgzNjAyNTA=",
      "title": "Infinite lifetime and reliability",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/665",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "> For example, a Connection must provide reliability to allow setting an infinite value for the lifetime property of a Message.\r\n\r\nWhy? Even an unreliable connection can block forever if congestion control is in place. Maybe a better illustration is: what should the TTL on a UDP message be? Is there a maximum? If so, how do you know what it is or specify it? Maybe a better example is warranted here.",
      "createdAt": "2020-09-10T18:50:23Z",
      "updatedAt": "2020-09-11T16:20:35Z",
      "closedAt": "2020-09-11T16:20:35Z",
      "comments": []
    },
    {
      "number": 666,
      "id": "MDU6SXNzdWU2OTgzNjg5NTM=",
      "title": "Message properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/666",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "Shouldn't the default value for every message property basically be \"inherit\", i.e., from the connection?\r\n\r\n\u00a78.1.3.3:\r\n\r\n> If true, it specifies that the receiver-side transport protocol stack only delivers the Message to the receiving application after any existing previous ordered Message that was passed to the same Connection via the Send Action.\r\n\r\nThis is a bit awkwardly worded. If this is supported for both reliable and unreliable transports (unclear?), then:\r\n\r\n* For reliable transports, this means that this message will not be delivered to the application until all previous ordered messages on the connection are delivered.\r\n* For unreliable transports, this means that any message prior to this one in ordering but received subsequently will not be delivered to the application.\r\n",
      "createdAt": "2020-09-10T18:57:51Z",
      "updatedAt": "2020-10-23T15:39:33Z",
      "closedAt": "2020-10-23T15:39:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple things here. Default: interesting idea, I tend to say \"yes\".\r\n\r\nAbout \u00a78.1.3.3:\r\nThis is meant to support both reliable and unreliable transports - why this unclear (why wouldn't it support both)?\r\nIIRC this was me, borrowing the wording from SCTP which also covers both of these cases (reliable and unreliable). I like your description (at least the one for reliable transports), but I think it's good to be explicit about the relationship to the Send Action. How about this, maybe simpler to read and still generic:\r\n\r\n`The order in which Messages were submitted for transmission via the Send Action will be preserved for all Messages on a Connection that have this Message Property set to true.`\r\n",
          "createdAt": "2020-09-11T11:42:44Z",
          "updatedAt": "2020-09-11T11:42:44Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "...will be preserved on delivery via Receive<> events for all Messages... ?",
          "createdAt": "2020-09-15T22:08:04Z",
          "updatedAt": "2020-09-15T22:08:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We got us a deal!  :-)   Seriously, this is better and clearer, thanks!  Will fix",
          "createdAt": "2020-09-15T22:09:32Z",
          "updatedAt": "2020-09-15T22:09:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seeing the number of this issue, it's clear to me that you chose the wrong issue when you wrote \"For the love of Satan\".",
          "createdAt": "2020-09-18T07:02:07Z",
          "updatedAt": "2020-09-18T07:02:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a note regarding #680: you said that the default for every message property should basically be \"inherit\"; checking them carefully one by one showed me that this is only a reasonable decision for three of them: Ordered, Reliable Data Transfer (Message) and Message Capacity Profile Override.\r\n\r\nE.g., a default of using less than a full checksum doesn't and probably shouldn't exist anywhere. Any default other than \"False\" for \"Final\" (last Message of the connection) really doesn't make a lot of sense (only the application would know that it has only one Message to send).  ... and so forth.",
          "createdAt": "2020-09-18T08:17:12Z",
          "updatedAt": "2020-09-18T08:17:12Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "You are technically correct, which is the best kind of correct. I basically meant that message properties that are used to override the same property at the connection level should default to \"inherit\".",
          "createdAt": "2020-09-18T14:02:40Z",
          "updatedAt": "2020-09-18T14:02:40Z"
        }
      ]
    },
    {
      "number": 667,
      "id": "MDU6SXNzdWU2OTgzNzQxNDA=",
      "title": "Fragmentation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/667",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "I'm not 100% sure, but I believe the DF bit applies only to intermediate hops, not to the originating machine. E.g., if you have DONTFRAG set on your socket (or at the system level via pmtud) and shove 60K into a sendto() call, the kernel will still happily chop your datagram into multiple <=1500 octet packets. So, the text in \u00a78.1.3.9 is probably misleading.\r\n",
      "createdAt": "2020-09-10T19:02:51Z",
      "updatedAt": "2020-10-23T15:39:33Z",
      "closedAt": "2020-10-23T15:39:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure if this makes the text misleading? The text only says that \"a message should be sent and received as a single packet without network-layer fragmentation, if possible.\"\r\nIt may not be possible...  there's also this sentence: \"When used with transports supporting this functionality and running over IP version 4, the Don't Fragment bit will be set.\"   - consider the first half of the sentence: the functionality is constrained to being offered only over transports that provide this precise functionality.",
          "createdAt": "2020-09-11T11:53:00Z",
          "updatedAt": "2020-09-11T11:53:00Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the text is literally correct, but misleading in that it implies a level of actionability that doesn't appear to be in evidence. Unless you have a means to know path MTU, you can't adjust your message length to avoid fragmentation or drop, so what good does this do other than result in drops vs. path fragmentation in IPv4? This will have zero effect on IPv6, for instance.",
          "createdAt": "2020-09-11T16:32:55Z",
          "updatedAt": "2020-09-11T16:32:55Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm confused about the confusion. What is being asked?",
          "createdAt": "2020-09-14T12:18:42Z",
          "updatedAt": "2020-09-14T12:18:42Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I'm asking for an example of where this property would make a difference to the wire image, other than in the DF-set case on IPv4 where intermediate hops will drop rather than fragment.",
          "createdAt": "2020-09-15T22:06:36Z",
          "updatedAt": "2020-09-15T22:06:36Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this is really mainly about DF / IPv4.\r\n\r\nBut, if you think of a protocol like SCTP which stuffs messages into packets, this protocol could theoretically decide that message X should not be placed such that the first half of it goes into packet 1 and the next half into packet 2, but that packet 1 should just be shorter and the whole message X should go into packet 2 instead. This is transport-layer fragmentation, not network-layer fragmentation, though.\r\n\r\nPerhaps \"network-layer\" should be removed from the text? This should be safe to do as long as we don't make any promises.",
          "createdAt": "2020-09-16T07:12:49Z",
          "updatedAt": "2020-09-16T07:12:49Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we should conflate transport segmentation of data with network-layer fragmentation. These have different purposes. A source host still has the choice to fragment at the network-layer to the PMTU, by the way, even when DF is set - as in IPv6.\r\n\r\nProtocols like STUN might use this to control which packets are sent with fragmentation at the sender to the PMTU, and which carry control packets to probe for a larger PMTU.",
          "createdAt": "2020-09-16T07:19:45Z",
          "updatedAt": "2020-09-16T07:19:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure the host can at the network layer anyway; we're not giving any guarantees against that. Fine not to conflate - but then the semantics of the text in \u00a78.1.3.9 really only translates into: \"in case of IPv4, DF=1\". I think this is fine - it seems Kyle wants more, but why? Or should the text more bluntly say \"IPv4 DF=1\" perhaps?",
          "createdAt": "2020-09-16T09:22:42Z",
          "updatedAt": "2020-09-16T09:22:42Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Michael, that's basically what I'm arguing. The only lever TAPS has is over intermediate hop behavior on IPv4, reducing the whole property to \"sets DF=1 on IPv4\".\r\n\r\nI also agree with Gorry re: segmentation vs. fragmentation. Do we need text re: segmentation for protocols like SCTP and QUIC?",
          "createdAt": "2020-09-16T12:16:06Z",
          "updatedAt": "2020-09-16T12:16:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The minset part for the transport layer thing is called \"request not to bundle messages\"; the minset appendix currently identifies that the \"No Fragmentation\" message property conflates this with network layer fragmentation. I suggest that I'll fix this, by:\r\n\r\n1. changing the \"No Fragmentation\" text a little bit, just to more bluntly state that this is really only about IPv4 DF\r\n2. adding a Message Property that has just the transport-layer \"request not to bundle messages\" semantics.\r\n\r\nThat should do the trick, I believe.",
          "createdAt": "2020-09-17T13:42:00Z",
          "updatedAt": "2020-09-17T13:42:00Z"
        }
      ]
    },
    {
      "number": 668,
      "id": "MDU6SXNzdWU2OTgzNzYxNjM=",
      "title": "Reply mapping to connection",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/668",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "\u00a78.2.2 says:\r\n\r\n> By using the replyMessageContext, the transport system is informed that the message to be sent is a response and can map the response to the same underlying transport connection or the stream from which the request was received.\r\n\r\nBut it appears the Connection object is still required to call Send, so what value does this provide? I.e., how are you supposed to use replyMessageContext from the example?",
      "createdAt": "2020-09-10T19:04:48Z",
      "updatedAt": "2020-10-23T16:36:42Z",
      "closedAt": "2020-10-23T16:36:42Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree - it seems to me now that this really adds no value. What am I missing?  I'm assigning @philsbln because he was among the first to propose this... maybe he can explain",
          "createdAt": "2020-09-16T07:02:25Z",
          "updatedAt": "2020-09-16T07:02:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ping  :)",
          "createdAt": "2020-10-17T11:01:10Z",
          "updatedAt": "2020-10-17T11:01:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: We will remove all \"reply/replies\" from the API doc.",
          "createdAt": "2020-10-23T16:14:48Z",
          "updatedAt": "2020-10-23T16:14:48Z"
        }
      ]
    },
    {
      "number": 669,
      "id": "MDU6SXNzdWU2OTgzOTQ1NTk=",
      "title": "Partial and interleaved receives",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/669",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\u00a78.3.2.2 says:\r\n\r\n> This event does not support delivering discontiguous partial Messages.\r\n\r\nWhat happens if a ReceivedPartial event is dispatched on an unreliably connection, but the rest of the message never shows up? Is it the case that another call to Receive will result in two events being sent: Received (or ReceivedPartial) for the new message, and a ReceiveError for the original message? Or can two messages effectively be interleaved and delivered in whatever order the constituent packets arrive?\r\n\r\n\r\n",
      "createdAt": "2020-09-10T19:22:57Z",
      "updatedAt": "2020-10-02T15:09:29Z",
      "closedAt": "2020-10-02T15:09:29Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you elaborate on the error case that's on your mind?  Because it's unclear to me - I would say that ordering obviously needs to be preserved within a message, while inter-message ordering is a different issue (controlled by the msgOrdered Message Parameter). How is this not clear from saying that delivering discontiguous partial Messages is not supported?",
          "createdAt": "2020-09-11T12:08:02Z",
          "updatedAt": "2020-09-11T12:08:10Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's say you send the following:\r\n\r\nM1 M2 M3 N1 N2 N3\r\n\r\nwhere M=M1.M2.M3 is one message and N=N1.N2.N3 is another message. The receiver subsequently gets:\r\n\r\nM1 N1 N2 N3\r\n\r\nMy reading of the draft is that the receiver will see\r\n\r\nReceivedPartial<M1>\r\nReceivedPartial<N1>\r\nReceivedPartial<N2>\r\nReceived<N3>\r\n\r\nIf M2 and M3 subsequently arrive, it sounds like the receiver will never get ReceivedPartial<M2> or Received<M3> because \"this event does not support delivering discontiguous partial Messages.\" But what makes the receiving TAPS logic decide not to wait for M2 or M3 and to start delivering N?",
          "createdAt": "2020-09-15T22:02:54Z",
          "updatedAt": "2020-09-15T22:02:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`If M2 and M3 subsequently arrive, it sounds like the receiver will never get ReceivedPartial or Received because \"this event does not support delivering discontiguous partial Messages.\"`\r\n\r\nThis is not how I would have interpreted the sentence. It talks about the message itself being discontiguous - so, e.g., delivering M1 followed by M3 would never happen. I don't see a reason why a different message couldn't be delivered, in pieces or not, after a ReceivedPartial call - every receive call comes with a message context, so the messages can be separated.\r\n\r\nI can try to make this clearer, maybe by adding an example like yours here to the draft....",
          "createdAt": "2020-09-16T06:57:53Z",
          "updatedAt": "2020-09-16T06:57:53Z"
        }
      ]
    },
    {
      "number": 670,
      "id": "MDU6SXNzdWU2OTg0MDA5NzM=",
      "title": "Connection termination clarity",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/670",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\u00a79 says:\r\n\r\n> Close terminates a Connection after satisfying all the requirements that were specified regarding the delivery of Messages that the application has already given to the transport system. For example, if reliable delivery was requested for a Message handed over before calling Close, the transport system will ensure that this Message is indeed delivered. If the Remote Endpoint still has data to send, it cannot be received after this call.\r\n\r\n* The transport system can't ensure that: it can ensure that either the message is delivered before clean shutdown or the connection will be broken without a clean shutdown.\r\n\r\nLater, it says:\r\n\r\n> 1) data could not be delivered after a timeout\r\n\r\n\"Deliver\" in the context of transports is a term of art that means \"the stack handed the data over to the application\". The local endpoint has no way of knowing when or if this has happened: the remote endpoint will happily ACK packets until the rxbuf is full, without delivering a single byte of data to the application. What is the actual condition under which this will fire?\r\n\r\n> 2) the other side has aborted the Connection\r\n\r\nI think this wants to be more general, because this will happen (e.g., in TCP) even if a MITM sends a RST. Maybe just \"the connection is otherwise broken\".",
      "createdAt": "2020-09-10T19:29:44Z",
      "updatedAt": "2020-09-11T16:20:56Z",
      "closedAt": "2020-09-11T16:20:56Z",
      "comments": []
    },
    {
      "number": 671,
      "id": "MDU6SXNzdWU2OTg0MDMwMTg=",
      "title": "Closed<> followed by ConnectionError<>",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/671",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\u00a710 contradicts itself in one paragraph:\r\n\r\n> **No events will occur on a Connection after it is Closed**; i.e., after a Closed<> event, an InitiateError<> or ConnectionError<> on that connection. To ensure this ordering, Closed<> will not occur on a Connection while other events on the Connection are still locally outstanding (i.e., known to the interface and waiting to be dealt with by the application). **ConnectionError<> can occur after Closed<>**, but the interface must gracefully handle all cases where the application ignores these errors.\r\n\r\nIt seems like Closed<> can and should be it: the stack should refuse any further interaction with userspace for this connection after that point.",
      "createdAt": "2020-09-10T19:31:58Z",
      "updatedAt": "2020-09-11T16:28:42Z",
      "closedAt": "2020-09-11T16:28:42Z",
      "comments": []
    },
    {
      "number": 672,
      "id": "MDU6SXNzdWU2OTkxOTg5MTM=",
      "title": "Perform a final edit pass on all three docs: normalize capitalization/spelling of keywords, formatting, pseudocode syntax, etc.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/672",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API",
        "Architecture",
        "Implementation",
        "editorial",
        "ready for text"
      ],
      "body": "When you're talking about an API object (as a proper noun), capitalize it the way it has been introduced in the doc. When you're talking about the abstract object (e.g., in reference to the arch doc), don't capitalize it like the corresponding API object.\r\n\r\nMostly adding this as a placeholder for myself. I volunteer to do a sweep before WGLC.",
      "createdAt": "2020-09-11T11:28:39Z",
      "updatedAt": "2021-07-12T21:21:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a note, to remember... I just saw that the implementation draft is full of these, regarding the term \"Connection\"    :(   The API offers a \"Connection\", but the underlying TCP thing should be a \"connection\".",
          "createdAt": "2020-10-19T10:56:58Z",
          "updatedAt": "2020-10-19T10:56:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Waiting for all other issues to close.",
          "createdAt": "2021-01-29T16:10:38Z",
          "updatedAt": "2021-01-29T16:10:38Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While looking about capitalisation, one should also double-check for syntax consistency of our pseudo-code.",
          "createdAt": "2021-02-26T17:51:59Z",
          "updatedAt": "2021-02-26T17:51:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A cleanup note for this pass: some text refers to Properties (of any kind) using Their Name In Capitals, regularly in the text like here, whereas some text uses `Quotation Marks`. This should be unified. Also, should we refer to Properties by the name of their heading in the document (I think this is what we now have everywhere) or by their actual name?",
          "createdAt": "2021-04-15T12:06:13Z",
          "updatedAt": "2021-04-15T12:06:13Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I reworded the title to better reflect what I'm going to do. I agree that consistency is the ultimate goal here. A laundry list of the things I should be sure to check would be helpful, so feel free to list some other items in the comments.",
          "createdAt": "2021-04-15T12:13:18Z",
          "updatedAt": "2021-04-15T12:13:18Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also s/TAPS/something else/g",
          "createdAt": "2021-07-08T09:39:00Z",
          "updatedAt": "2021-07-08T09:39:00Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "I realize I never submitted this comment after the last meeting. Thankfully, it somehow survived several restarts of Firefox.\r\n\r\nI'm going to drop some questions here for discussion during today's meeting:\r\n\r\n* Should we use backticks (\\`...\\`) consistently for anything that is intended to be interpreted as pseudocode, e.g., for all types as well as values? Or is there some other heuristic? I advocate drawing the line at some point closer to code than Object classes like Preconnections, Connections, Events, Errors, etc., as those are directly used *only* in the text; but I'd like to get aligned on a heuristic short of that.\r\n** An example of the kind of thing I'm dithering about is `[]Type`.\r\n** What about `Initiate()`, `Listen()`, etc., where referenced in text? Those seem like code snippets that should use backticks.\r\n* Should we use backticks for property names at their initial definition (i.e., the `: propertyName` line)?\r\n* There are a bunch of instances in which backticks are used to reference property names in text, such as `Reliable Data Transfer (Connection)`: I presume these should either be changed to the actual property name and left in backticks, or have the backticks removed. Preferences?\r\n* I have alpha-substituted some of the dashed references (`{...}` and `{#...}`) with the camelCase names. I can do this for the others, but since they don't end up in the output it would only be for ease of further editing. Does anyone care?",
          "createdAt": "2021-07-12T21:21:19Z",
          "updatedAt": "2021-07-12T21:21:19Z"
        }
      ]
    },
    {
      "number": 675,
      "id": "MDU6SXNzdWU2OTk1NTkyMzY=",
      "title": "Preconnection needs to support multiple Local and Remote Endpoints",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/675",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "The `Preconnection.Rendezvous()` call needs multiple local and remote candidate endpoints. \r\n\r\nThis means `NewPreconnection()` should take lists of `LocalEndpoint` and `RemoteEndpoint` objects (section 5) and there should be ways of adding/removing `LocalEndpoint` and `RemoteEndpoint` objects from a `Preconnection`\r\n\r\nRelates to #571 ",
      "createdAt": "2020-09-11T17:22:10Z",
      "updatedAt": "2020-12-11T16:26:52Z",
      "closedAt": "2020-12-11T16:26:52Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Pairs of? Local and remote endpoints probably need to be linked.",
          "createdAt": "2020-10-02T15:35:19Z",
          "updatedAt": "2020-10-02T15:35:19Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#697 updates the description of `Endpoint` to say:\r\n>   An Endpoint cannot have multiple identifiers of a same type set.\r\n>   That is, an endpoint cannot have two IP addresses specified.  Two\r\n>   separate IP addresses are represented as two Endpoint Objects\r\n\r\nThat's fine, but it prevents a single `Preconnection` being used in `Rendezvous()` when there are multiple candidates. For `Rendezvous()` to work, we need to relax this restriction and allow multiple addresses of the same type to be added to an endpoint. \r\n\r\n@tfpauly what's the rationale for the change in #697 ?",
          "createdAt": "2020-11-02T20:03:45Z",
          "updatedAt": "2020-11-02T20:04:57Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I remember having multiple addresses on an endpoint would also benefit multicast. ",
          "createdAt": "2020-11-11T19:40:21Z",
          "updatedAt": "2020-11-11T19:40:21Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln the explanation for how multicast is handled didn't change at all here, btw.",
          "createdAt": "2020-11-12T03:51:22Z",
          "updatedAt": "2020-11-12T03:51:22Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins I think it would make most sense to either:\r\n- Use the alias approach, where one endpoint can have a list of aliases that are equivalent options, or\r\n- Let the preconnection have multiple endpoint objects for rendezvous\r\n\r\nThe definition of a single endpoint object is a lot easier to keep track of and understand if it is a single address or equivalent identifier.",
          "createdAt": "2020-11-12T03:53:39Z",
          "updatedAt": "2020-11-12T03:53:39Z"
        }
      ]
    },
    {
      "number": 676,
      "id": "MDU6SXNzdWU2OTk1NjI4OTg=",
      "title": "Preconnection.Resolve() needs work",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/676",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "In \u00a76.3 we have:\r\n\r\n>    If the endpoints are suspected to be behind a NAT, Rendezvous() can\r\n>    be initiated using Local and Remote Endpoints that support a method\r\n>    of discovering NAT bindings such as Session Traversal Utilities for\r\n>    NAT (STUN) [RFC8489] or Traversal Using Relays around NAT (TURN)\r\n>    [RFC5766].  In this case, the Local Endpoint will resolve to a\r\n>    mixture of local and server reflexive addresses.  The Resolve()\r\n>    action on the Preconnection can be used to discover these bindings:\r\n>    ```[]Preconnection := Preconnection.Resolve()```\r\n>    The Resolve() call returns a list of Preconnection Objects, that\r\n>    represent the concrete addresses, local and server reflexive, on\r\n>    which a Rendezvous() for the Preconnection will listen for incoming\r\n>    Connections.  These resolved Preconnections will share all other\r\n>    Properties with the Preconnection from which they are derived, though\r\n>    some Properties may be made more-specific by the resolution process.\r\n\r\nThis doesn't work, because `Preconnection.Rendezvous()` takes only a single `Preconnection`. The `Resolve()` action on a `Preconnection` should rather be on a `LocalEndpoint` or `RemoteEndpoint`.",
      "createdAt": "2020-09-11T17:26:19Z",
      "updatedAt": "2020-12-11T16:42:19Z",
      "closedAt": "2020-12-11T16:42:19Z",
      "comments": []
    },
    {
      "number": 677,
      "id": "MDU6SXNzdWU2OTk1Njc3MDE=",
      "title": "Remove \"excessive retransmissions\" event",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/677",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "per consensus at the Sep 11 interim.",
      "createdAt": "2020-09-11T17:31:41Z",
      "updatedAt": "2020-10-02T15:10:05Z",
      "closedAt": "2020-10-02T15:10:05Z",
      "comments": []
    },
    {
      "number": 681,
      "id": "MDU6SXNzdWU3MTM2OTcyMzM=",
      "title": "Behavior of Framers in Connection Groups",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/681",
      "state": "CLOSED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "How do framers behave in connection groups? I.e. do all connections share one framer object or does the framer object get duplicated when a connection gets cloned? If it does get duplicated, does it keep its current state? \r\n\r\nThis might mostly be an implementation detail but I think it should be mentioned in section 6.4 of API. ",
      "createdAt": "2020-10-02T15:11:52Z",
      "updatedAt": "2020-10-02T16:23:14Z",
      "closedAt": "2020-10-02T16:23:14Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: same type of framer is plausible default (but new instances), but in general a framer should be per connection. State is not shared across connections.\r\n\r\nBigger problem: framers are added to preconnections, not connections, so how is this done with cloning?\r\n(perhaps: add list of framers as parameter added to the clone call)",
          "createdAt": "2020-10-02T15:31:41Z",
          "updatedAt": "2020-10-02T15:31:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've thought about it, and Idon't think we actually have a bigger problem here:\r\n\r\nOn an initiated Connection/ConnectionGroup, the provenance of the Framers is Preconnection.AddFramer() -> Preconnection.Initiate().\r\n\r\nOn a Listener, the provenance of the Framers is Preconnection.AddFramer() -> Preconnection.Listen() -> Listener.Clone().\r\n\r\nIn a Rendezvous situation, there is (unless I'm missing something) always a Preconnection from which a Framer can ultimately be inherited.",
          "createdAt": "2020-10-02T15:46:26Z",
          "updatedAt": "2020-10-02T15:46:26Z"
        }
      ]
    },
    {
      "number": 684,
      "id": "MDU6SXNzdWU3MTM3NDYyNDM=",
      "title": "Framer Dynamics",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/684",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "Per discussion at the interim on 2 October:\r\n\r\nWe might want to split the framer stack (currently implicit in the Preconnection) into an explicit object in the interface, in order to support framer dynamicism.\r\n\r\nConcretely:\r\n\r\n- add a FramerStack object, and have AddFramer be a call on that. (Optionally, a new Preconnection comes with an empty FramerStack, and Preconnection.AddFramer just passes through to its internal FramerStack.)\r\n- Initiate, Listen, and Clone optionally take a FramerStack object that *replaces* the existing FramerStack.\r\n- Connection gains a ReplaceFramerStack call, which *replaces* the existing FramerStack as soon as the send buffer is empty, pushing back any unconsumed received bytes/objects and re-deframing them \r\n\r\nI'm not convinced this will work, but csperkins@ had some good arguments about why this would be useful for WebRTC like things.\r\n\r\n@tfpauly (and everyone else, of course): wdyt?",
      "createdAt": "2020-10-02T16:23:32Z",
      "updatedAt": "2020-10-23T16:33:12Z",
      "closedAt": "2020-10-23T16:33:11Z",
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it is a good idea to have different FramerStacks for different Connections coming from the same Preconnection (so through clone).\r\nHaving one framer that can determine what kind of connection is underlying and then switches its behavior accordingly seems to go against the concept of framers being very compartmentalized  so developers can just grab them off the shelf and pluck them in. \r\n\r\nI am not sure that you need to be able to hand over a FramerStack on initiate and listen or change them out on active connections.",
          "createdAt": "2020-10-02T16:49:06Z",
          "updatedAt": "2020-10-09T15:32:27Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "from the interim: ReplaceFramerStack is a box of dragons (hello, concurrency) so we probably shouldn't do it in the general case.",
          "createdAt": "2020-10-23T16:30:28Z",
          "updatedAt": "2020-10-23T16:30:28Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "and we don't need the rest of this in the general case, so closing.",
          "createdAt": "2020-10-23T16:33:11Z",
          "updatedAt": "2020-10-23T16:33:11Z"
        }
      ]
    },
    {
      "number": 685,
      "id": "MDU6SXNzdWU3MTM3NTQ5NDI=",
      "title": "Complete example for TCP implementation mapping",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/685",
      "state": "OPEN",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "This should follow the template to be developed in #608 ",
      "createdAt": "2020-10-02T16:37:01Z",
      "updatedAt": "2020-10-02T16:38:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 688,
      "id": "MDU6SXNzdWU3MjgzMjE1MjU=",
      "title": "Provide examples for path changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/688",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Provide examples of why we don't tear down path changes",
      "createdAt": "2020-10-23T15:38:49Z",
      "updatedAt": "2021-01-29T17:36:24Z",
      "closedAt": "2021-01-29T17:36:24Z",
      "comments": []
    },
    {
      "number": 689,
      "id": "MDU6SXNzdWU3MjgzMjE1OTA=",
      "title": "Provide examples on how path changes are handled",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/689",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-23T15:38:54Z",
      "updatedAt": "2020-10-23T15:39:25Z",
      "closedAt": "2020-10-23T15:39:25Z",
      "comments": []
    },
    {
      "number": 690,
      "id": "MDU6SXNzdWU3MjgzMjMzMzY=",
      "title": "Remove the term \"TAPS\" from drafts",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/690",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API",
        "Implementation",
        "editorial"
      ],
      "body": "TAPS -> Transport Services",
      "createdAt": "2020-10-23T15:41:25Z",
      "updatedAt": "2020-12-16T21:46:39Z",
      "closedAt": "2020-12-16T21:46:39Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I realize that this is a silly discussion to have, and I just don't care... but I *am* curious: why?",
          "createdAt": "2020-10-27T22:39:52Z",
          "updatedAt": "2020-10-27T22:39:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, mainly because we say \"Transport Services\" throughout and the term \"TAPS\" isn't defined. But also because I don't and never have understood how \"TAPS\" is an abbreviation of \"Transport Services\". If we want to abbreviate it, let's just use \"TS\".",
          "createdAt": "2020-10-28T15:32:03Z",
          "updatedAt": "2020-10-28T15:32:03Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey, I needed a 4-letter acronym for a working group, that was all, and I didn't want to have a discussion about something that I considered so unimportant.... also, taps signals the end of the day, when everyone is to go to sleep:\r\nhttp://usscouts.org/mb/taps.asp\r\n\r\nSo yeah... as you can see, I really don't care, I was just curious. Let's just use \"transport services\" throughout. And next time I form a WG I'll really think hard to make a good acronym.  :-)",
          "createdAt": "2020-10-28T15:45:02Z",
          "updatedAt": "2020-10-28T15:45:02Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to \"transport services\" everywhere.\r\n(actually i liked the name of the WG Michael!)",
          "createdAt": "2020-10-30T10:00:13Z",
          "updatedAt": "2020-10-30T10:00:13Z"
        },
        {
          "author": "JohnGrantNineTiles",
          "authorAssociation": "NONE",
          "body": "I'd always assumed the AP was from API.",
          "createdAt": "2020-11-06T15:47:25Z",
          "updatedAt": "2020-11-06T15:47:25Z"
        }
      ]
    },
    {
      "number": 691,
      "id": "MDU6SXNzdWU3MjgzMjk2NTA=",
      "title": "Update references to minset and security survey",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/691",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Architecture",
        "Implementation",
        "editorial",
        "ready for text"
      ],
      "body": "We have RFCs now!",
      "createdAt": "2020-10-23T15:50:45Z",
      "updatedAt": "2020-10-27T22:37:19Z",
      "closedAt": "2020-10-27T22:37:19Z",
      "comments": []
    },
    {
      "number": 693,
      "id": "MDU6SXNzdWU3MjgzNTg3OTI=",
      "title": "WebRTC <-> TAPS Mapping Document",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/693",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins",
        "zaheduzzaman"
      ],
      "labels": [
        "mappings"
      ],
      "body": "We should have a clarified mapping document (not in the primary draft) to address WebRTC, etc.",
      "createdAt": "2020-10-23T16:34:34Z",
      "updatedAt": "2020-10-28T08:00:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WebRTC requires, e.g., RTP and DataChannel on the same port. Need to be clear how this fits into TAPS.",
          "createdAt": "2020-10-23T16:35:44Z",
          "updatedAt": "2020-10-23T16:35:44Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a note to say that NEAT is able to talk to a WebRTC peer; Michael Tuexen made sure that this would work and tested it.\r\n\r\nI don't remember if there were many specific things necessary just for that... but I do remember one thing: Michael was concerned about peers that would make an assumption based on the stream number certain comunication arrives at - e.g. an SCTP server that assumes that stream 13 is only used for evil text messages (I'm coming up with a nonsense example as Halloween gets close). If we don't expose the stream number as such, we can't reasonably talk to such a server.\r\n\r\nTAPS currently doesn't expose stream numbers, and if we don't absolutely have to, I don't think we should. I also suspect that stream numbers do *not* play a role for WebRTC - but I don't know... so I thought I'd write this here just in case.",
          "createdAt": "2020-10-28T07:59:22Z",
          "updatedAt": "2020-10-28T08:00:00Z"
        }
      ]
    },
    {
      "number": 694,
      "id": "MDU6SXNzdWU3MjgzNjA1MTI=",
      "title": "Mention framer \"passthrough\" mode in implementation ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/694",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "ready for text"
      ],
      "body": "The implementation draft should explain that a framer can go into a passthrough/inactive mode once it has finished (like SOCKS, STARTTLS, CONNECT).\r\n",
      "createdAt": "2020-10-23T16:37:22Z",
      "updatedAt": "2021-01-29T17:32:37Z",
      "closedAt": "2021-01-29T17:32:37Z",
      "comments": []
    },
    {
      "number": 698,
      "id": "MDU6SXNzdWU3NDY0MTMxODI=",
      "title": "Migrate CI pipeline from CircleCI to GitHub Actions",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/698",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [],
      "body": "ID-Template has Github Actions support; integrating the CI pipeline on the same site as the source repository simplifies debugging when we run into eventual issues with the pipeline (as I did recently with CircleCI in the QUIC ops drafts).",
      "createdAt": "2020-11-19T09:44:41Z",
      "updatedAt": "2020-12-11T16:22:02Z",
      "closedAt": "2020-12-11T16:22:02Z",
      "comments": []
    },
    {
      "number": 701,
      "id": "MDU6SXNzdWU3NTU3MjAzODI=",
      "title": "Network Policies",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/701",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "In Sec 2:\r\n\r\nShould Section 3.2 also talk about network policies, e.g. a certain network supports a DSCP that the application desires?",
      "createdAt": "2020-12-03T00:45:23Z",
      "updatedAt": "2021-06-11T16:05:47Z",
      "closedAt": "2021-06-11T16:05:47Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed in Feb 2021 interim, this seems like a rabbithole. Gorry will figure out whether it is and write language if not, or close if so.",
          "createdAt": "2021-02-26T17:01:35Z",
          "updatedAt": "2021-02-26T17:01:35Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to add a couple of lines of text here to bullet 2 that discusses how you might learn that an attached network supports certain features - e.g. through a PvD, routing advertisement, or local discovery method, and suggest that this could enable a system to know which paths have specific characteristics.",
          "createdAt": "2021-04-07T17:14:56Z",
          "updatedAt": "2021-04-07T17:14:56Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose this as a starter:\r\n\r\nWhen additional information (such as Provisioning Domain (PvD) information {{RFC7556}}) is provided about the networks over which an endpoint can operate, this can inform the selection between alternate network paths. Such information includes network segment PMTU, set of supported DSCPs, expected usage, cost, etc. The usage of this information by the Transport Services API is generally independent of the specific mechanism/protocol that was used to receive the information (e.g. zero-conf, DHCP, or IPv6 RA).\r\n\r\nThoughts... ?",
          "createdAt": "2021-05-13T11:43:56Z",
          "updatedAt": "2021-05-13T11:43:56Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tried to create a PR to add some policy to the path selection #836",
          "createdAt": "2021-05-19T13:10:45Z",
          "updatedAt": "2021-05-19T13:10:45Z"
        }
      ]
    },
    {
      "number": 702,
      "id": "MDU6SXNzdWU3NTU3MjM3NTE=",
      "title": "\"fails to connect\" poorly defined",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/702",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Section 4.2.2 says \"If a child node fails to connect before...\" without really defining if this means completing the handshake, or making some progress. 4.3.1 does a better job, but for readability there ought to be a reference or rewording in 4.2.2.",
      "createdAt": "2020-12-03T00:53:37Z",
      "updatedAt": "2021-02-26T17:10:15Z",
      "closedAt": "2021-02-26T17:10:15Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "/to connect/ is problematic for me also, but /establish connectivity/ is less problematic, although always good to explain!",
          "createdAt": "2020-12-03T08:54:08Z",
          "updatedAt": "2020-12-03T08:54:08Z"
        }
      ]
    },
    {
      "number": 703,
      "id": "MDU6SXNzdWU3NTU3MjQ1NzQ=",
      "title": "What is a \"confirmed\" route?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/703",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "In Sec 4.5 of taps-impl:\r\n\r\n\"An implementation should consider such a protocol stack to be established as soon as a local route to the peer endpoint is confirmed.\"\r\n\r\nWhat does this mean for an unconnected protocol? That there is an entry in the route table, or that it's received a packet?",
      "createdAt": "2020-12-03T00:55:41Z",
      "updatedAt": "2021-02-26T16:41:11Z",
      "closedAt": "2021-02-26T16:41:11Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch: This appears to be rough sentence. The term \"confirmed\" occurs only once, and a \"local route\" is something quite different to what is intended!\r\n\r\nWe do talk about establishing connectivity with a remote endpoint... maybe that might work?",
          "createdAt": "2020-12-03T08:52:52Z",
          "updatedAt": "2020-12-03T08:52:52Z"
        }
      ]
    },
    {
      "number": 704,
      "id": "MDU6SXNzdWU3NTU3MjU4NzA=",
      "title": "Define multipath terms",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/704",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Before distinguishing between protocols that do \"multipath\" and \"migrating between paths\", it might help to define these terms. This is tripping is up in QUIC, and IIRC the original \"Multipath TCP\" was pretty much the migration case.\r\n\r\nSomething like, \"In this section we distinguish between 'multipath' protocols and protocols that allow migration between paths. The first means <blah blah>...\"",
      "createdAt": "2020-12-03T00:59:17Z",
      "updatedAt": "2021-04-09T15:08:58Z",
      "closedAt": "2021-04-09T15:08:58Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is in section 7.2 of taps-impl.",
          "createdAt": "2020-12-03T00:59:41Z",
          "updatedAt": "2020-12-03T00:59:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We define multipath (by policy in section 6.1.7 handover, interactive, aggregate) in the API doc. Section 4.2 in Implementation should use these definitions. ",
          "createdAt": "2021-02-26T17:18:22Z",
          "updatedAt": "2021-02-26T17:18:22Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wanted to fix this now, but stumbled over the following sentence in the implementation draft:\r\n\r\n> If the Protocol Stack includes a transport protocol that also supports multipath connectivity with migration support, the Transport Services implementation should also inform the Protocol Instance of potentially new paths that become permissible based on the Selection Properties passed by the application.\r\n\r\nThis talks about the protocol below the transport services system; do multipath-supporting protocols with *no* migration support exist? I struggle to imagine a scheduler that wouldn't make this happen... e.g. lowest latency scheduling, but with the exception: if a path becomes completely unavailable, keep going?  :-)\r\n\r\nLooking at the three policies in section 6.1.7 of our API, clearly, migration should work with all of them (and \"Handover\" is limited in that it doesn't do anything else, but it's gotta be a subset of the others anyway, I'd say).\r\n\r\nAm I missing something?  Just checking...",
          "createdAt": "2021-03-25T09:09:18Z",
          "updatedAt": "2021-03-25T09:09:18Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the example of no migration support would be a multipath protocol that is not able to add new paths, so SCTP without support for the ADD_ADDR extension perhaps? Not sure this is a case we need to worry about though... ",
          "createdAt": "2021-03-25T10:48:07Z",
          "updatedAt": "2021-03-25T10:48:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, a multipath protocol that doesn't do multipath  :-)",
          "createdAt": "2021-03-25T10:49:41Z",
          "updatedAt": "2021-03-25T10:49:41Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, it can do multipath with the paths you give it from the beginning :) \r\nPossibly something else was intended with the text from the beginning, but this is what I could think of...",
          "createdAt": "2021-03-25T10:57:59Z",
          "updatedAt": "2021-03-25T10:57:59Z"
        }
      ]
    },
    {
      "number": 705,
      "id": "MDU6SXNzdWU3NTU3MjY4NzA=",
      "title": "Close Connection Groups?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/705",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Should taps-interface provide a way to close a connection group? I don't see an obvious way to close an HTTP/2 or QUIC connection just using connection-level commands.\r\n\r\nYou could make TAPS automatically close a connection if all user streams are closed, but that's... not great?",
      "createdAt": "2020-12-03T01:01:52Z",
      "updatedAt": "2021-01-29T17:03:20Z",
      "closedAt": "2021-01-29T17:03:20Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the problem with closing a connection (I presume you mean the underlying transport's one, not the one exposed by TAPS) once all user streams (i.e., grouped TAPS Connections) are closed? I think this would obviously happen. If I, as a user, want to avoid delay for connection establishment and tear-down, I'm not closing my Connection...\r\n\r\nElse, closing a group containing multiple open Connections in one go would be a matter of issuing \"Close\" for all of them... e.g., by checking the Connection's group number, in a loop. We could spec that as part of the API, but it doesn't seem to be extremely useful to me, as this function could very easily be written on top of the TAPS API.",
          "createdAt": "2020-12-07T08:23:20Z",
          "updatedAt": "2020-12-07T08:23:20Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 07/12/2020 08:23, mwelzl wrote:\n>\n> What's the problem with closing a connection (I presume you mean the \n> underlying transport's one, not the one exposed by TAPS) once all user \n> streams (i.e., grouped TAPS Connections) are closed? I think this \n> would obviously happen. If I, as a user, want to avoid delay for \n> connection establishment and tear-down, I'm not closing my Connection...\n>\n> Else, closing a group containing multiple open Connections in one go \n> would be a matter of issuing \"Close\" for all of them... e.g., by \n> checking the Connection's group number, in a loop. We could spec that \n> as part of the API, but it doesn't seem to be extremely useful to me, \n> as this function could very easily be written on top of the TAPS API.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/ietf-tapswg/api-drafts/issues/705#issuecomment-739756757>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABYLLETB56J3XFQS3LDUM3DSTSGIPANCNFSM4ULILOCA>.\n>\nThis works for me,\n\nGorry\n\n",
          "createdAt": "2020-12-07T08:59:34Z",
          "updatedAt": "2020-12-07T08:59:34Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alternative discussed: make ConnectionGroup an explicit object (as opposed to just a []Connection), and add (at least) an AbortGroup call on it.\r\n\r\nAnother option: add AbortGroup to a Connection, which aborts all connections in the group.\r\n\r\nDiscussion at December interim leans toward the second: don't create a new object for only one operation.",
          "createdAt": "2020-12-11T17:12:55Z",
          "updatedAt": "2020-12-11T17:12:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, make sure to be clear that Abort() does NOT close all entangled Connections. \r\n(same thing for Close())",
          "createdAt": "2020-12-11T17:13:23Z",
          "updatedAt": "2020-12-11T17:13:23Z"
        }
      ]
    },
    {
      "number": 706,
      "id": "MDU6SXNzdWU3NTU3Mjg0Mzg=",
      "title": "Flushing protocol state is not in the interface",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/706",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "csperkins",
        "philsbln",
        "martinduke"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Section 9.1 of taps-impl loosely refers to the need for an interface to \"flush protocol state\" to preserve anonymity, but such a capability is not in taps-interface.",
      "createdAt": "2020-12-03T01:05:51Z",
      "updatedAt": "2021-01-29T16:55:17Z",
      "closedAt": "2021-01-29T16:55:17Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't like this text: \r\n\"Applications must have a way to flush protocol cache state if desired. This may be necessary, for example, if application-layer identifiers rotate and clients wish to avoid linkability via trackable TLS tickets or TFO cookies.\"\r\n\r\nThose of you who know me, would immediately see a \"MUST\"...\"if desired.\"  and a \"may be necessary\". My suggestion is that this digs too deep, and we should remove the text. I could also live with something more neutral though:\r\n\r\nNote: There are case where applications need to flush protocol cache state, for example, if application-layer identifiers rotate and a client wishes to avoid linkability of trackable TLS tickets or TFO cookies.",
          "createdAt": "2020-12-03T08:46:58Z",
          "updatedAt": "2020-12-03T08:46:58Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine to have the more neutral sentence proposed by Gorry. I don't think we should specify an interface for it but I think it's good to mention.",
          "createdAt": "2020-12-03T10:37:36Z",
          "updatedAt": "2020-12-03T10:37:36Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the best approach is to make it more neutral. The other option would be to say that this interface is implementation specific. For sure, we do not want it in the API I think.",
          "createdAt": "2020-12-03T11:22:08Z",
          "updatedAt": "2020-12-03T11:22:08Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have no opinion on Gorry's comment, but I'm a bit mystified by the \"shouldn't be in the API doc\" argument. Perhaps I'm not understanding the purpose of taps-interface? I thought it was a qualitative description of the controls offered to the application, which this clearly would be!",
          "createdAt": "2020-12-03T15:14:59Z",
          "updatedAt": "2020-12-03T15:14:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would define taps as an interface to control network connections. So flushing state is a good thing in some scenarios for privacy but not really needed to handle network connections.",
          "createdAt": "2020-12-03T15:24:12Z",
          "updatedAt": "2020-12-03T15:24:12Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also #721 -- this surfaced that we have drifted on connection group versus context, which we need to fix in arch.",
          "createdAt": "2020-12-11T17:50:10Z",
          "updatedAt": "2020-12-11T17:50:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Martin to write a PR against API to propose a context API that would provide the intent of this functionality.\r\n\r\nAlternative is to NOP this in the API doc (\"connection contexts are too implementation specific to expose in a general way\" or similar)",
          "createdAt": "2020-12-11T17:51:43Z",
          "updatedAt": "2020-12-11T17:51:43Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A second alternative is a one-bit fix: a selection property that requires a given connection to be in a separate connection context (which implies a separate connection group) from other connections created in the preconnection.",
          "createdAt": "2020-12-11T17:55:03Z",
          "updatedAt": "2020-12-11T17:55:03Z"
        }
      ]
    },
    {
      "number": 707,
      "id": "MDU6SXNzdWU3NTU3MzIzMzI=",
      "title": "Issues with TCP-specific considerations (taps-impl 10.1)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/707",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "- I don't think you mean that TAPS should throw a ConnectionError on a TCP Retransmission Timeout!\r\n\r\n- I'm somewhat concerned about half-close, though this might just be editorial. An HTTP/3 implementation needs to send FIN when it's done requesting, for instance (I realize that HTTP/3 is not TCP, but I imagine the semantics are the same). So I think it would send its request with a end-of-message, According to the \"Send\" description, TAPS will send CLOSE.TCP automatically after the FIN.\r\n\r\nA regular \"Close\" will trigger a \"Closed\" event which tells the application it isn't getting more data, so I _guess_ this just barely works if TAPS sends CLOSE.TCP but not Closed, and waits for the Close command from the app? Like I said, I'm not sure this is wrong, but it's not clearly stated how an app that needs half-close functionality should implement that.",
      "createdAt": "2020-12-03T01:15:36Z",
      "updatedAt": "2021-01-29T17:42:37Z",
      "closedAt": "2021-01-29T17:42:37Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really really don't think that TAPS should cause any Error on a TCP Retransmission Timeout!\r\n- This happens for many reasons, and isn't an upper-layer issue.\r\n",
          "createdAt": "2020-12-03T08:42:02Z",
          "updatedAt": "2020-12-03T08:42:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the half-closed scenario, I think you're onto something there. Let's see how this would work, for a client sending a message followed by a FIN, and the server answering:\r\n(Note: all \"close\" calls \"from above\" have complete \"all is over\" semantics, to be able to also work with protocols which do *not* support half-closed connections (such as SCTP).)\r\n\r\nClient:\r\nSend, Message marked as Final. According to the implementation draft, this causes CLOSE.TCP, which will transmit the FIN to the server. As you suggest, the CLOSE.TCP would not invoke Closed, and instead wait for the Close command from the app - this makes sense and would work like that, but indeed it's not stated anywhere, so this text should be added.\r\n\r\nServer:\r\nIf this is a native TCP server, there's no problem.\r\nIf this is a TAPS server, then there's no way for the server to know for the server-side transport system that it should not issue a Closed event to the application upon the FIN coming with the Final Message. After the Closed event, the application cannot write anymore. Game over.\r\n\r\nHow do we handle the server case? E.g., we could add yet another selection property: \"Allow writing after Closed\". Not exactly beautiful ... but is there any other way to do it?",
          "createdAt": "2020-12-07T09:22:38Z",
          "updatedAt": "2020-12-09T10:34:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 7:\r\n\r\nWhether the connection can be used to receive data. A connection cannot be used for reading if the connection was created with the Selection Property Direction of Communication set to unidirectional send or if a Message marked as Final was received, see Section 8.3.3.3. The latter is only supported by certain transport protocols, e.g., by TCP as half-closed connection.",
          "createdAt": "2020-12-11T16:55:53Z",
          "updatedAt": "2020-12-11T16:55:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also: \r\n\r\n8.3.3.3. Receiving Final Messages\r\nThe Message Context can indicate whether or not this Message is the Final Message on a Connection. For any Message that is marked as Final, the application can assume that there will be no more Messages received on the Connection once the Message has been completely delivered. This corresponds to the Final property that may be marked on a sent Message, see Section 8.1.3.5.",
          "createdAt": "2020-12-11T16:56:16Z",
          "updatedAt": "2020-12-11T16:56:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "technically solved in API (\"the best kind of solved\") by existing text in 8.3.3.3, section 10.1 still needs work in impl.",
          "createdAt": "2020-12-11T16:57:04Z",
          "updatedAt": "2020-12-11T16:57:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I write this here so people don't miss it:\r\nThere is this statement in the API doc, describing the Close call, which my PR for this issue will remove: \"If the Remote Endpoint still has data to send, it cannot be received after this call.\"\r\n\r\nWe can allow reading until Closed fires. For protocols such as SCTP that do not support half-closed connections, Closed would have to fire immediately upon calling Close.",
          "createdAt": "2021-01-12T09:05:35Z",
          "updatedAt": "2021-01-12T09:05:35Z"
        }
      ]
    },
    {
      "number": 708,
      "id": "MDU6SXNzdWU3NTU3MzgwMjk=",
      "title": "SCTP Connection Objects description is unclear",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/708",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Sec 10.6 of taps-impl is pretty confusing:\r\n\r\n> \r\nConnection objects represent a flow of SCTP messages between a client and a server, which may be an SCTP association or a stream in a SCTP association. How to map Connection objects to streams is described in [NEAT-flow-mapping]; in the following, a similar method is described. To map Connection objects to SCTP streams without head-of-line blocking on the sender side, both the sending and receiving SCTP implementation must support message interleaving [RFC8260]. Both SCTP implementations must also support stream reconfiguration. Finally, both communicating endpoints must be aware of this intended multiplexing.\r\n\r\n..\r\n\r\nthere's yet more.\r\n\r\nMaybe I should read NEAT-flow-mapping, or remind myself about the details of SCTP, but I think the third sentence (To map Connection Objects...) is not well-constructed.\r\n\r\nThere are three conditions here: both SCTPs must:\r\n\r\n- support 8260,\r\n\r\n- support stream reconfiguration, AND\r\n\r\n- know what's going on.\r\n\r\nBut what do these conditions enable?\r\n\r\nIs it mapping connections to streams at all?\r\n\r\nIs it mapping them without HOL blocking (i.e., if not met, I still can map but there is HOL blocking)?\r\n\r\nSomething else?",
      "createdAt": "2020-12-03T01:30:39Z",
      "updatedAt": "2021-05-04T14:24:16Z",
      "closedAt": "2021-05-04T14:24:16Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Guilty as charged!  I wrote this and I can fix it.\r\nMeanwhile, I'll explain:\r\n8260 => to reduce HOL blocking delay.\r\nstream reconfiguration => to save memory and be able to re-use stream numbers, and to realize the role of a FIN (stream reset = FIN)\r\nknow what's going on => yes, but this is an application requirement ... the applications on both sides must be able to handle this. E.g., a server written over a TAPS system could just listen on all protocols, including streams, and get whatever kind of Connection (including, possibly, one that's really only a stream) - and then answer on it (I actually tested exactly this with NEATPy). This server can handle this easily. Another server could be a native TCP server, certainly not expecting SCTP, let alone Connections riding on streams - this server could not handle this. The client application, when connecting, must know what it's doing. I can make a PR to explain these matters in the text.",
          "createdAt": "2020-12-11T14:55:09Z",
          "updatedAt": "2020-12-11T14:55:09Z"
        }
      ]
    },
    {
      "number": 712,
      "id": "MDU6SXNzdWU3NjE3MTc5NjM=",
      "title": "Transport system -> Transport Services system?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/712",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation",
        "editorial"
      ],
      "body": "# Configuration-time errors\r\n\r\n\"The transport system should have a list of supported protocols available\"... I think this means that the TAPS implementation does this, not that the kernel has any tabular notion of transport properties. If so, I have further suggestions for the wording here.",
      "createdAt": "2020-12-10T23:43:25Z",
      "updatedAt": "2020-12-16T21:46:22Z",
      "closedAt": "2020-12-16T21:46:22Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes; I think we had once agreed that this should be \"Transport Services system\" everywhere, and we (or at least I) have been sloppy with this in the API and Implementation drafts. Thanks, this comment makes it clear to me why it's important to use this term correctly.\r\n",
          "createdAt": "2020-12-11T09:30:54Z",
          "updatedAt": "2020-12-11T09:30:54Z"
        }
      ]
    },
    {
      "number": 713,
      "id": "MDU6SXNzdWU3NjE3MjE2NjU=",
      "title": "Privacy considerations section",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/713",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "I would consolidate the privacy impacting behaviors of TAPS into a single section. An example is under\r\n\r\n# Remote Endpoint Candidates\r\n\r\nResolving the remote is not a local operation.  It will involve a directory service, and can require communication with the remote to rendezvous and exchange peer addresses.  This can expose some or all of the candidate locals to the remote.\r\n\r\nEven though this document is informational rather than normative, this section is conceptually normative in the sense that it tells you how to build a TAPS implementation; anything not related to the how would ideally be moved somewhere else, maybe with a forward reference, both for clarity as well as for ease of finding information related to security- and privacy-related best practices.",
      "createdAt": "2020-12-10T23:50:32Z",
      "updatedAt": "2021-02-26T17:23:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Work here is to \r\n\r\n- rename Security Considerations to Privacy and Security Considerations\r\n- review the implementation draft and create a list of privacy-impacting implementation behaviors\r\n- understand whether there are any implementation-specific behaviors that are not already covered by privacy and security in the API document, and if so, add them to privacy considerations in this draft or in API",
          "createdAt": "2021-02-26T17:23:15Z",
          "updatedAt": "2021-02-26T17:23:15Z"
        }
      ]
    },
    {
      "number": 714,
      "id": "MDU6SXNzdWU3NjE3MzIwMDg=",
      "title": "\"Racing\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/714",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Is \"racing\" really the right term? It might be a term of art that applies even in cases like this, but many of the relationships between different branches in the tree are based on preference rather than lowest latency. I don't feel strongly about this, but I don't know if this has been brought up yet, so I figured I'd mention it.",
      "createdAt": "2020-12-11T00:10:49Z",
      "updatedAt": "2021-03-25T10:38:43Z",
      "closedAt": "2021-03-25T10:38:43Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it may seem a bit misleading, but I think it's ok - it's just the word we use for it, and the term and how we use it is quite clearly defined in the Architecture draft, section 4.2.2. Just my 2c",
          "createdAt": "2020-12-11T09:34:24Z",
          "updatedAt": "2020-12-11T09:34:24Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like \"racing\" - it's just a term....",
          "createdAt": "2021-02-26T17:20:29Z",
          "updatedAt": "2021-02-26T17:20:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Racing is defined in the architecture document; add a reference back there.\r\n",
          "createdAt": "2021-02-26T17:24:38Z",
          "updatedAt": "2021-02-26T17:24:38Z"
        }
      ]
    },
    {
      "number": 715,
      "id": "MDU6SXNzdWU3NjE3MzQxMzE=",
      "title": "Use of protocol, protocol stack",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/715",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Throughout the document, the term \"protocol\" is used in lots of different ways. In some cases, it clearly refers to the underlying transport. In other places, it refers to the top-level protocol that the application directly interacts with. In yet other places, it seems to refer to the whole protocol stack, sometimes including the framers. I feel like the document would benefit from a scrub of these usages, and maybe even a glossary describing what exactly is meant by these terms.",
      "createdAt": "2020-12-11T00:15:37Z",
      "updatedAt": "2021-02-26T17:27:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Use Protocol Stack and Protocol Instance from section 4.2 of Arch; I'll do this on my review pass.",
          "createdAt": "2021-02-26T17:27:53Z",
          "updatedAt": "2021-02-26T17:27:53Z"
        }
      ]
    },
    {
      "number": 716,
      "id": "MDU6SXNzdWU3NjE3MzY4ODY=",
      "title": "Unconnected -> Connectionless",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/716",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "UDP is best described as connectionless, not unconnected: it has no notion of a connection, where \"unconnected\" might imply a particular usage pattern for a protocol that also supports connections.",
      "createdAt": "2020-12-11T00:19:39Z",
      "updatedAt": "2021-02-26T17:33:28Z",
      "closedAt": "2021-02-26T17:33:28Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "YES! UDP is \"connectionless\"; confusing APIs do support a \"connected mode\". Please remove unconnected.",
          "createdAt": "2020-12-11T08:00:19Z",
          "updatedAt": "2020-12-11T08:00:19Z"
        }
      ]
    },
    {
      "number": 717,
      "id": "MDU6SXNzdWU3NjE3MzkyNTA=",
      "title": "Partial final message",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/717",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Under\r\n\r\n# Receiving Messages\r\n\r\nthe doc says:\r\n\r\n> If a Connection becomes finished before a requested Receive action can be satisfied, the implementation should **deliver any partial Message content outstanding**, or if none is available, an indication that there will be no more received Messages.\r\n\r\nEmphasis mine. This is a key enabler of truncation attacks, so the interface should only do this if the application is well aware of the implications of receiving partial messages and/or if the partial nature of the message is made clear to the application.",
      "createdAt": "2020-12-11T00:23:10Z",
      "updatedAt": "2021-02-22T14:25:34Z",
      "closedAt": "2021-02-22T14:25:34Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps would also need to spell-out what constitutes a truncation attack? ",
          "createdAt": "2020-12-11T16:42:55Z",
          "updatedAt": "2020-12-11T16:42:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should go into API security considerations to tell apps to be careful to not assume that when a connection closes that their received data was complete and/or well-formed.",
          "createdAt": "2020-12-11T18:01:11Z",
          "updatedAt": "2020-12-11T18:01:11Z"
        }
      ]
    },
    {
      "number": 718,
      "id": "MDU6SXNzdWU3NjE3NDQ3NTc=",
      "title": "Some random comments/suggestions/questions",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/718",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "# Implementing Connection Establishment\r\n\r\nI'm having difficult parsing \"At this point, any constraints or requirements the application may have on the connection are available from pre-establishment.\" I'm not even sure what meaning is intended. Available? To what and for what?\r\n\r\n# Structuring Options as a Tree\r\n\r\nIs this really a forest? I.e., is a `2` possible when, for instance, you have a choice of two hostnames? If so, there should be an example illustrating that.\r\n\r\n# Derived Endpoints\r\n\r\nThe last example in the section should be augmented to show multiple hostnames as described by the preceding paragraph.\r\n\r\nAdditionally, I think stating that there is a clear/natural dependency relationship between branching operations such that later operations depend on earlier decisions could simplify and clarify the justification for the suggested order of operations.\r\n\r\n# Sorting Branches\r\n\r\n\"Scavenger\" implies LEDBAT to me: it will take whatever is currently not being used but will defer to everything else. I'm not sure that notion aligns with the preference described.\r\n\r\n# Handling of data for fast-open protocols\r\n\r\nIs the intent of:\r\n\r\n> It is also possible that protocol stacks within a particular leaf node use 0-RTT handshakes without any safely replayable application data. For example, TCP Fast Open could use a Client Hello from TLS as its 0-RTT data, shortening the cumulative handshake time.\r\n\r\nthat a protocol higher in the stack (or a framer?) could use 0-RTT even if the application doesn't want 0-RTT? Are there any security or privacy implications to this? Should there be a mechanism to disable this entirely?\r\n\r\n# Defining Message Framers\r\n\r\nI do not understand the syntax employed here. Is `MessageFramer` in:\r\n\r\n```\r\nMessageFramer -> Start(Connection)\r\nMessageFramer -> Stop(Connection)\r\n```\r\n\r\na global object or something? It appears to be generating a Start event with the Connection object to the system, but isn't the framer the receiver of such an event? (Nit: isn't Event<> with angle brackets the syntax here?)\r\n\r\n# Specific Transport Protocol Considerations\r\n\r\n> Protocols also define a notion of Data Unit\r\n\r\ndoesn't seem quite right. Protocols possess a property of application-layer data unit, usually as an intrinsic property that is a direct consequence of the protocol design. They don't really define it so much as end up with it. Maybe this is too much of a nit, but it reads weirdly.\r\n\r\n# UDP\r\n\r\nThe use of \"unconnected\" (or \"connectionless\") directly adjacent to the phrase \"UDP connections\" is driving me batty. I understand that the TAPS interface provides only a Connection object, but we should not ever use lowercase-c \"connection\" to refer to UDP, and be clear when we mean the uppercase-C \"Connection\" object in relation to an underlying UDP transport.\r\n\r\n",
      "createdAt": "2020-12-11T00:33:11Z",
      "updatedAt": "2021-02-26T17:34:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "> Implementing Connection Establishment\r\n\r\nI rust just read this as \"The Implementation now has all constrains it needs to know for attempting to establish a connection in the form of Preconnection parameters (endpoints, security parameters and transport properties) and can now continue.\"\r\n\r\n> Handling of data for fast-open protocols\r\n\r\nI would imagine that if 0-RTT is set to prohibit that applies to the entire stack (including framers).\r\n\r\n> Defining Message Framers\r\n\r\nThis is a bit confusing, but basically, as far as I understand, there is the MessageFramer which is part of the TAPS Implementation (this creates the events and has the methods MakeConnectionReady, MakeConnectionClosed etc.) and there is the framer implementation (which is the part the users of the TAPS implementation write themselves, this receives the events and then calls the methods on the MessageFramer). It might be good to find another term for MessageFramer to make that difference more clear. \r\n\r\n\r\n",
          "createdAt": "2021-01-30T16:28:52Z",
          "updatedAt": "2021-01-30T16:28:52Z"
        }
      ]
    },
    {
      "number": 721,
      "id": "MDU6SXNzdWU3NjI2NzcyMjU=",
      "title": "Align Connection Group terminology in the Architecture with the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/721",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Connection Groups used to be about state and context sharing as well as entanglement. Now it's about entanglement. We need to rename Connection Groups (\"connection contexts\"?) in the architecture to replace the existing \"group\" concept, and to retain \"connection group\" in the API for entanglement.",
      "createdAt": "2020-12-11T17:42:35Z",
      "updatedAt": "2021-02-26T17:09:42Z",
      "closedAt": "2021-02-26T17:09:42Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems like this could be 360 degrees of rotation in our thinking? (which could be OK, NEAT was written to specify both contexts and flow groups). Let's try some definitions here and see if we converge...",
          "createdAt": "2021-01-28T16:01:40Z",
          "updatedAt": "2021-01-28T16:01:40Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think #723 brings this back in synch again so no need to rename, possibly the last part of this section in architecture should be removed though as we do not have fine-grained control\r\n\r\n> The interface to specify a Connection Group can expose fine-grained tuning for which properties and cached state is allowed to be shared with other Connections. For example, an application might want to allow sharing TCP Fast Open cookies across groups, but not TLS session state.",
          "createdAt": "2021-01-28T21:17:00Z",
          "updatedAt": "2021-01-28T21:17:00Z"
        }
      ]
    },
    {
      "number": 726,
      "id": "MDU6SXNzdWU3OTUyNzY1ODY=",
      "title": "Is it time for QUIC?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/726",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "mappings"
      ],
      "body": "QUIC beat TAPS to the RFC Ed queue. Should the implementation draft provide a specific considerations sections for QUIC?\r\n\r\nIn my mental model of TAPS, providing a common API for QUIC implementations is one of the main reasons for TAPS adoption.",
      "createdAt": "2021-01-27T16:59:04Z",
      "updatedAt": "2021-01-28T17:54:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure.... here's why: QUIC hasn't yet been around long by API standards, and although I do have hopes, it's clearly going to be a while before QUIC's API is at the same maturity, and I'd hate to hold-up TAPS while we get that perfected. Would it be worth considering opening and \"quick-ly\" adopting an ID specifically to do this?",
          "createdAt": "2021-01-28T15:21:15Z",
          "updatedAt": "2021-01-28T15:21:15Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think what we agreed before was to stick to the protocols from RFC8303 for the implementation draft and that other protocols, including QUIC, would be covered in their own mapping documents. I think that is still a good decision.",
          "createdAt": "2021-01-28T15:36:07Z",
          "updatedAt": "2021-01-28T15:36:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe we had previously decided to use the mapping documents, as @abrunstrom indicates. Marking as such.",
          "createdAt": "2021-01-28T17:54:40Z",
          "updatedAt": "2021-01-28T17:54:40Z"
        }
      ]
    },
    {
      "number": 731,
      "id": "MDU6SXNzdWU4MTA1ODgxNjI=",
      "title": "Closing state not defined",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/731",
      "state": "CLOSED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "The Closing state is mentioned in the interface draft, but is not defined anywhere as far as I can tell. The state machine diagram includes only Establishing, Established, and Closed.",
      "createdAt": "2021-02-17T22:31:01Z",
      "updatedAt": "2021-04-09T15:54:02Z",
      "closedAt": "2021-04-09T15:54:02Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great catch, thanks!\r\n\r\nJudging from the outcome in this discussion:\r\nhttps://github.com/ietf-tapswg/api-drafts/issues/182\r\n...this sounds like an omission in the state machine diagram.",
          "createdAt": "2021-02-17T23:20:53Z",
          "updatedAt": "2021-02-17T23:20:53Z"
        }
      ]
    },
    {
      "number": 732,
      "id": "MDU6SXNzdWU4MTQ5MjkxNzk=",
      "title": "Closing multistreaming transports",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/732",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Inspired by the discussion in #722, I don't think we adequately addressed #705.\r\n\r\nAbstracting away from current designs, in a connection group there are four possible termination actions:\r\n- Clean close a connection\r\n- Abort a connection\r\n- Clean close a connection group\r\n- Abort a connection group\r\n\r\nTAPS has all but the third.\r\n\r\nQUIC has three of these; SCTP has two (three with RFC 6525); HTTP/2, IIUC, in principle has all four, though I believe RFC 7540 doesn't envision HTTP/2 ever initiating TCP RST. There is an added complication that in some protocols these are half-closes or half-aborts.\r\n\r\nI think we're trying to be too cute by not offering all four of these. Let's just have all of them (which means adding CloseGroup) and then figure out how the protocol mappings respond to actions they don't actually support. For example\r\n1. Non-streaming protocols simply apply the close or abort to each of their connections.\r\n2. When QUIC gets CloseGroup, it sends clean close on all connections and then sends group abort. (Note that apps with mandatory streams [like HTTP3] can't use this functionality)\r\n3. When SCTP with 7525 gets ConnectionAbort, it does ConnectionClose instead\r\n4. When SCTP without 7525 gets ConnectionClose or ConnectionAbort, it's a NOP.\r\n5. When HTTP/2 gets AbortGroup, it sends GOAWAY followed by a CloseGroup.",
      "createdAt": "2021-02-23T23:44:20Z",
      "updatedAt": "2021-03-21T02:12:48Z",
      "closedAt": "2021-03-21T02:12:48Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm copy+pasting my answer from the PR here.  I'm not against \"let's just have all of them and then figure out how...\", but I'm also not sure if we need to get so complex? Perhaps....    I'll just leave this text here for consideration:\r\n\r\n[paste from #722]\r\n\r\nAbout stream abort: not quite, I think. Using a \"stream abort\" would mean that the TCP-like half-closed behavior wouldn't work - you couldn't send a stream reset and then expect to receive something on a stream. However, that isn't possible anyway, because SCTP streams are only unidirectional. And, there's only a guarantee of a notification by a returning \"stream reset\" because we define it in this PR.\r\n\r\nI agree that this is bigger and should be separate from this PR... but what's your plan? Do we really have a big problem here? In the end, it's a matter of having the right semantics at the API level. This began with just picking the strictest possible semantics: no half-closed connections, calling \"close\" means that what the app already gave to the transport system for transmission before the call will still be sent, but the app cannot expect to send or receive anything after this call. This way, SCTP (which doesn't allow half-closed associations) is covered, and the behavior is \"correct\" for TCP as well. These semantics also work for SCTP streams with stream reset as above.\r\n\r\nSo... altogether, I thought we'll be safe if we just go strict.\r\n\r\nNow, quite recently, the wording was changed a bit, because of the need to support TCP half-closed connections (which is implemented via the \"Final\" Message Property). I felt a bit uneasy about this change, but in the end I couldn't see how things would go wrong with the wording that we now have in the API draft.\r\n\r\nMy high-level view is that we still have this rather strict thing, and then there is the option to use \"Final\", with no guarantee of it working (because we don't know if we get a protocol that supports half-closed connections). But there may be a devil in the details on how we worded it... definitely worth another careful look.",
          "createdAt": "2021-02-24T00:07:07Z",
          "updatedAt": "2021-02-24T00:07:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that our treatment of half and full closes is alright, although it doesn't give us away to do a QUIC STOP_SENDING frame, for example.\r\n\r\nI think the close and abort semantics are quite clear to the application developer, but it's not sufficient to have them at the Connection level because it can lead to many messages where one would suffice. I don't like that we've merged the SCTP SHUTDOWN and ABORT chunks, for instance.",
          "createdAt": "2021-02-24T01:00:48Z",
          "updatedAt": "2021-02-24T01:00:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: the need for more primitives to do, e.g., STOP_SENDING, I agree.\r\n\r\nRe: close and abort not being sufficient: I agree.\r\n\r\nRe: merging SCTP SHUTDOWN and ABORT chunks: that sounds like a mistake that we shouldn't have made. Which text in which draft gives you this impression? I checked the implementation draft, it talks about CLOSE.SCTP (for Close) and ABORT.SCTP (for Abort), and all of this is preceded by \"Below, terms in capitals with a dot (e.g., \"CONNECT.SCTP\") refer to the primitives with the same name in section 4 of [RFC8303].\"  In RFC 8303, these terms refer back to the Shutdown and Abort primitives of RFC 4960 (the current spec at the time RFC 8303 was written), where it is explained that these work using the SHUTDOWN and ABORT chunks... so where is the mistake?\r\n",
          "createdAt": "2021-02-24T11:25:35Z",
          "updatedAt": "2021-02-24T11:25:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">Which text in which draft gives you this impression?\r\n\r\nIIUC, for multistreaming protocols Connection.Close() and Connection.Abort() apply to streams while Connection.AbortGroup() applies to the protocol connection/association. We lack a Connection.CloseGroup() and therefore there is no way to trigger a SHUTDOWN chunk.\r\n\r\nIn practice, since stream closing capabilities are slim in SCTP, we can repurpose Close() and Abort(), but this seems conceptually messier.",
          "createdAt": "2021-02-24T15:07:42Z",
          "updatedAt": "2021-02-24T15:07:42Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "discussed at 2021-02-26 interim: we are indeed being a little too cute by pretending an application isn't going to interact with groups. Decision is to add CloseGroup(). ",
          "createdAt": "2021-02-26T16:24:30Z",
          "updatedAt": "2021-02-26T16:24:30Z"
        }
      ]
    },
    {
      "number": 737,
      "id": "MDU6SXNzdWU4MTc1NDA3NDg=",
      "title": "what does connected mean?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/737",
      "state": "OPEN",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2021-02-26T17:37:18Z",
      "updatedAt": "2021-05-19T13:37:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this is any help, RFC8085 said:\r\n\"Many operating systems also allow a UDP socket to be connected, i.e.,\r\n   to bind a UDP socket to a specific pair of addresses and ports.  This\r\n   is similar to the corresponding TCP sockets API functionality.\r\n   However, for UDP, this is only a local operation that serves to\r\n   simplify the local send/receive functions and to filter the traffic\r\n   for the specified addresses and ports.\"",
          "createdAt": "2021-05-19T13:37:22Z",
          "updatedAt": "2021-05-19T13:37:22Z"
        }
      ]
    },
    {
      "number": 738,
      "id": "MDU6SXNzdWU4MTc1NDU1NTk=",
      "title": "argh unbreak circleci again",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/738",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-26T17:44:51Z",
      "updatedAt": "2021-07-08T13:34:27Z",
      "closedAt": "2021-07-08T13:34:27Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't that resolved? Close?",
          "createdAt": "2021-05-05T12:17:14Z",
          "updatedAt": "2021-05-05T12:17:14Z"
        }
      ]
    },
    {
      "number": 743,
      "id": "MDU6SXNzdWU4NTEyNDgyNTU=",
      "title": "Is the \"candidate tree\" concept actually normative?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/743",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Section 4 paragraph 3: \"This document structures candidates for racing as a tree\". This statement is true, but it doesn't say whether this structure is a necessary outcome of the architecture and the design of the interface, or merely a terminological convention that makes it much easier to discuss. I think it's the latter.  \r\n\r\nAt the least, this sentence should be clarified to make it clear that the tree structure in section 4 (and subsequent) is terminological, not normative. To make this clearer, I'd also create a new \"operations on candidate trees\" sections, containing sections 4.1.2, 4.1.3, 4.1.4, and 4.1.5.",
      "createdAt": "2021-04-06T09:41:55Z",
      "updatedAt": "2021-05-04T14:53:18Z",
      "closedAt": "2021-05-04T14:53:18Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clarify that this document uses tree terminology, and that implementations can, but don't need to, reflect that in their data structures.",
          "createdAt": "2021-04-09T16:02:39Z",
          "updatedAt": "2021-04-09T16:02:39Z"
        }
      ]
    },
    {
      "number": 744,
      "id": "MDU6SXNzdWU4NTEzNzQ5MDE=",
      "title": "mutability of Preconnection objects is unclear (Sec 2)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/744",
      "state": "OPEN",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Preconnections are mutable, until they are not. The second paragraph of section 2 states \"bundles of properties an application can both read and write\", which seems to conflict with this. Para should lead with the fact of mutable mutability over the preconnection lifecycle, not \"is mutable\".",
      "createdAt": "2021-04-06T12:29:05Z",
      "updatedAt": "2021-04-09T16:09:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Connection/Listener makes a deep copy that is now immutable, but the original object is still mutable.",
          "createdAt": "2021-04-09T16:05:06Z",
          "updatedAt": "2021-04-09T16:05:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`the implementation should ensure that the copy of the properties held by the Connection or Listener is immutable.`\r\n\r\n`the implementation should ensure that the copy of the properties held by the Connection or Listener is not modified by changes the application makes to the original Preconnection object.`",
          "createdAt": "2021-04-09T16:09:45Z",
          "updatedAt": "2021-04-09T16:09:45Z"
        }
      ]
    },
    {
      "number": 746,
      "id": "MDU6SXNzdWU4NTE0MDI2NDY=",
      "title": "Editorial issues on 5.1.1. Message Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/746",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "I believe these are all editorial.\r\n\r\nFirst, this list needs some front matter: \"protocols should implement each of the following Message Properties on send as follows\" or similar.\r\n\r\n- \"Ordered\" should state that protocols that do not support configurable ordering may ignore the property.\r\n- \"Final\" should note that it is not mandatory to close the connection after a Final message.\r\n- \"Corruption Protection Length\" should note that it can be ignored basically everywhere but UDP-Lite. \r\n\r\nOne open question: is it an error to send a Message after a Final message, and does the protocol implementation need to handle this itself?",
      "createdAt": "2021-04-06T13:03:07Z",
      "updatedAt": "2021-04-09T16:34:17Z",
      "closedAt": "2021-04-09T16:34:17Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... \"Corruption Protection Length\" should note that it can be ignored basically everywhere but UDP-Lite. ... In protocols such as UDP-Lite, various tunnels would, DCCP allows, etc. \r\n",
          "createdAt": "2021-04-06T13:07:25Z",
          "updatedAt": "2021-04-06T13:07:25Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be an error to send a Message after a Final message and the implementation of the transport services system should handle it. If it is not an error, then it will fail sometimes and sometimes not depending on if the connection is closed or not, that seems less useful to me.",
          "createdAt": "2021-04-06T19:46:02Z",
          "updatedAt": "2021-04-06T19:46:02Z"
        }
      ]
    },
    {
      "number": 747,
      "id": "MDU6SXNzdWU4NTE0MDMzMDY=",
      "title": "\"meaning of the Message\" in 5.1.2 Send Completion is unclear",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/747",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "I stared at this sentence for a while before I thought I'd made sense of it. PR forthcoming but I think this might need a little discussion.",
      "createdAt": "2021-04-06T13:03:55Z",
      "updatedAt": "2021-04-09T15:19:32Z",
      "closedAt": "2021-04-09T15:19:32Z",
      "comments": []
    },
    {
      "number": 749,
      "id": "MDU6SXNzdWU4NTE0MTM2Njg=",
      "title": "What if there's no context switch penalty for sending messages? (Sec 5.1.2)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/749",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Section 5.1.2: \"the implementation should hold off on processing Messages until the batch is complete\" assumes that there is indeed a context-switch penalty. Batch semantics are only for hints to the implementation/protocol stack, and this advice only applies when that hint allows the stack to reduce context switch penalty. Correct?\r\n\r\n(If so, this should be noted explicitly)",
      "createdAt": "2021-04-06T13:16:02Z",
      "updatedAt": "2021-04-09T16:34:16Z",
      "closedAt": "2021-04-09T16:34:16Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually 5.1.3.\r\nThis reads odd to me, I'd expected myself more like: \"When this is used, the implementation can defer the processing Messages until the batch is complete.\"\r\n(eliminating \"off on\", also from this sentence?)",
          "createdAt": "2021-04-06T13:21:04Z",
          "updatedAt": "2021-04-06T13:21:04Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, I think your text reads better @gorryfair, should it be \"... defer the processing of Messages ...\" though? I think it also solves the question from @britram as it is now expressed as an opportunity for the implementation.",
          "createdAt": "2021-04-06T19:35:05Z",
          "updatedAt": "2021-04-06T19:35:05Z"
        }
      ]
    },
    {
      "number": 750,
      "id": "MDU6SXNzdWU4NTE0MjA5MTM=",
      "title": "Framer changes and send/receive buffers (Sec 6.1)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/750",
      "state": "OPEN",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Dynamic framer add and passthrough (last two paragraphs of section 6.1) assume synchronous operation; what happens to bytes in the send/receive buffers when the framer stack changes? \r\n\r\nThere either needs to be an explicit mutex here (allowing the framer/implementation to lock the buffers at the exact point the framer change happens, not allowing any bytes to be processed while the dynamic framer decision is made), or some way to annotate in a buffer the replay point after which a dynamic reframing is necessary.\r\n\r\nAre we going to leave this up to implementors to figure out, or should we point out that here be dragons?",
      "createdAt": "2021-04-06T13:23:56Z",
      "updatedAt": "2021-04-09T16:18:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should clarify that these operations within the data path of the stack should be synchronized.",
          "createdAt": "2021-04-09T16:18:37Z",
          "updatedAt": "2021-04-09T16:18:37Z"
        }
      ]
    },
    {
      "number": 751,
      "id": "MDU6SXNzdWU4NTE0MjI0Njg=",
      "title": "How do I know what subnet I'm on? (Sec 9.2)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/751",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Section 9.2: \"These items can be cached on a per-address and per-subnet granularity\"; should we mention that local subnets may need more than mere address information, including other information such as BSSID to differentiate local networks with common NAT ranges?",
      "createdAt": "2021-04-06T13:25:40Z",
      "updatedAt": "2021-04-09T16:24:07Z",
      "closedAt": "2021-04-09T16:24:07Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing without action; the text was referring to remote address/subnet mainly.",
          "createdAt": "2021-04-09T16:24:07Z",
          "updatedAt": "2021-04-09T16:24:07Z"
        }
      ]
    },
    {
      "number": 752,
      "id": "MDU6SXNzdWU4NTI2MDM2NzQ=",
      "title": "Nit: Section 2 - do we need one line of intro?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/752",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "For me at least, it would be nice for the implementation draft to also initially remind readers that the Connection objects are relevant to all transports, including those that are not themselves connection-oriented.\r\n",
      "createdAt": "2021-04-07T16:55:56Z",
      "updatedAt": "2021-05-10T16:47:41Z",
      "closedAt": "2021-05-10T16:47:41Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thought to be fixed in #783",
          "createdAt": "2021-04-13T06:46:02Z",
          "updatedAt": "2021-04-13T06:46:02Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #783",
          "createdAt": "2021-05-10T16:47:41Z",
          "updatedAt": "2021-05-10T16:47:41Z"
        }
      ]
    },
    {
      "number": 753,
      "id": "MDU6SXNzdWU4NTI2MDQyNDg=",
      "title": "Nit: Section 3.1: No such protocol\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/753",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "I\u2019ll argue this \u201cbut no such protocol is available on the host running the transport system\u201d\r\n is asking for a feature, so I think the text ought to read:\r\n\u201cbut no such feature is available in any protocol  the host running the transport system\u201d\r\n",
      "createdAt": "2021-04-07T16:56:41Z",
      "updatedAt": "2021-07-08T13:45:46Z",
      "closedAt": "2021-07-08T13:45:46Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"but no protocol available on the host offers such a feature\"",
          "createdAt": "2021-04-09T16:25:59Z",
          "updatedAt": "2021-04-09T16:25:59Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was fixed in the already merged PR.",
          "createdAt": "2021-07-08T13:45:46Z",
          "updatedAt": "2021-07-08T13:45:46Z"
        }
      ]
    },
    {
      "number": 754,
      "id": "MDU6SXNzdWU4NTI2MDQ3NTM=",
      "title": "Nit: Section 3.2: We don\u2019t mention layers...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/754",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "We don\u2019t mention layers in the text before:\r\n\u201cA violation of any of the layers should cause\u201d\r\n- Is this better as:\r\n- \u201d A violation that occurs at any of the policer layers should cause\u201d\r\n",
      "createdAt": "2021-04-07T16:57:21Z",
      "updatedAt": "2021-04-09T16:26:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 755,
      "id": "MDU6SXNzdWU4NTI2MDUzMTI=",
      "title": "This use of \u201cremote\u201d on its own offends me...",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/755",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "The use of \u201cremote\u201d on its own offends me:\r\n\u201cSome types of remote might \u2026\u201d\r\ncould we make this \u201cRemote Endpoint\u201d to ease my reading? or whatever else is intended?\r\n\r\nSimilarly can we change \u201clocals\u201d and \u201cremote\u201d here to something that is defined:\r\n\u201cThis can expose some or all of the candidate locals to the remote\u201d\r\n",
      "createdAt": "2021-04-07T16:58:08Z",
      "updatedAt": "2021-05-20T09:05:30Z",
      "closedAt": "2021-05-20T09:05:30Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Remote Endpoint",
          "createdAt": "2021-04-09T16:27:24Z",
          "updatedAt": "2021-04-09T16:27:24Z"
        }
      ]
    },
    {
      "number": 756,
      "id": "MDU6SXNzdWU4NTI2MDYxNTM=",
      "title": "Structuring Options as a Tree?: what is an option?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/756",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "\u201c4.1.2. Structuring Options as a Tree\u201d\r\n- I don\u2019t like \u201coptions\u201d on its own, I think this needs some other word with it!\r\n- what is an option v. an connection attempt? \r\n\u201cWhen an implementation responsible for connection establishment needs to consider multiple options,\u201d\r\n\u2026or is something optional here (v. what is meant by 4.1.1.3.3)?\r\n\u2026 or actually is this \u201cAlternatives for Structuring as a Tree\u201d? \r\n (help me please!)\r\n",
      "createdAt": "2021-04-07T16:59:14Z",
      "updatedAt": "2021-05-04T14:53:18Z",
      "closedAt": "2021-05-04T14:53:18Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we do this in #743 ?",
          "createdAt": "2021-04-09T16:28:20Z",
          "updatedAt": "2021-04-09T16:28:20Z"
        }
      ]
    },
    {
      "number": 757,
      "id": "MDU6SXNzdWU4NTI2MTAyMzk=",
      "title": "Nit: should be unreliably transmitted.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/757",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "I was bound to complain that we don't WANT to be more unreliable,...\r\n\"then the Message should be unreliably transmitted.\"\r\nCan we say:\r\n...\"then the Message should be sent using an unreliable transport.\"",
      "createdAt": "2021-04-07T17:04:32Z",
      "updatedAt": "2021-05-26T11:42:51Z",
      "closedAt": "2021-05-26T11:42:51Z",
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clearly better, but perhaps \"unreliable transport\" is also not the best? Would \"then the Message should be sent without any reliability guarantees\" be better? ",
          "createdAt": "2021-04-09T08:11:41Z",
          "updatedAt": "2021-04-09T08:11:41Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Much better - now perfect!!!",
          "createdAt": "2021-04-09T10:46:23Z",
          "updatedAt": "2021-04-09T10:46:23Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR: Not unreliable, but no reliability guarantees. #837",
          "createdAt": "2021-05-19T13:26:36Z",
          "updatedAt": "2021-05-19T13:26:36Z"
        }
      ]
    },
    {
      "number": 758,
      "id": "MDU6SXNzdWU4NTI2MTExNTQ=",
      "title": "What is a \"throw\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/758",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "\"Once in use, UDP throws \"soft errors\" (ERROR.UDP(-Lite)) upon receiving ICMP notifications indicating failures in the network.\"\r\n- please explain what is intended by throw, (I think I know), but it's not explained.",
      "createdAt": "2021-04-07T17:05:44Z",
      "updatedAt": "2021-05-26T11:42:51Z",
      "closedAt": "2021-05-26T11:42:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"generates\"",
          "createdAt": "2021-04-09T16:29:33Z",
          "updatedAt": "2021-04-09T16:29:33Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thought fixed in  #837",
          "createdAt": "2021-05-19T13:27:20Z",
          "updatedAt": "2021-05-19T13:27:20Z"
        }
      ]
    },
    {
      "number": 759,
      "id": "MDU6SXNzdWU4NTQwMTg4MzM=",
      "title": "Should resolve() have a callback?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/759",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I might be confused, but resolve() in Sec 5.3 of -api (Rendezvous) sure sounds like something that is asynchronous and needs a callback. Or is this just the stack's instantaneous view of these addresses?",
      "createdAt": "2021-04-08T23:37:33Z",
      "updatedAt": "2021-04-09T14:26:17Z",
      "closedAt": "2021-04-09T14:26:17Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quote from the same section:\r\n\r\n> If successful, the Rendezvous() Action returns a Connection object via a RendezvousDone<> Event:\r\n> Preconnection -> RendezvousDone<Connection>\r\n\r\nand further down, after some text introducing it:\r\n> Preconnection -> EstablishmentError<reason?>\r\n\r\nDid you just miss these, or were you expecting something more?",
          "createdAt": "2021-04-09T07:17:32Z",
          "updatedAt": "2021-04-09T07:17:32Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oof, I just missed it.",
          "createdAt": "2021-04-09T14:26:17Z",
          "updatedAt": "2021-04-09T14:26:17Z"
        }
      ]
    },
    {
      "number": 760,
      "id": "MDU6SXNzdWU4NTQwMTk0OTc=",
      "title": "Should clone() have a callback?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/760",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Clone() is analogous to Initiate(), so why doesn't it return ready events like initiate()?",
      "createdAt": "2021-04-08T23:39:17Z",
      "updatedAt": "2021-04-15T11:49:02Z",
      "closedAt": "2021-04-15T11:49:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be OK because Initiate doesn't generate the Ready event, etc, but the Connection does. Both Initiate and Clone return a Connection.\r\n\r\nWe can try to clarify this.",
          "createdAt": "2021-04-09T15:26:02Z",
          "updatedAt": "2021-04-09T15:26:02Z"
        }
      ]
    },
    {
      "number": 761,
      "id": "MDU6SXNzdWU4NTQwMTk4NDQ=",
      "title": "Should CloseGroup() and/or AbortGroup() generate events?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/761",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "these are analogous to connection-level things that generate events.",
      "createdAt": "2021-04-08T23:40:12Z",
      "updatedAt": "2021-06-11T16:22:19Z",
      "closedAt": "2021-06-11T16:22:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can clarify that Close/Abort causes an event on the connection. We should also state that CloseGroup/AbortGroup causes same the event on all Connections that are grouped.\r\n\r\nClose -> Closed\r\nCloseGroup -> Closed x N\r\nAbort -> ConnectionError(aborted)\r\nAbortGroup -> ConnectionError(aborted) x N",
          "createdAt": "2021-04-09T15:30:00Z",
          "updatedAt": "2021-04-09T15:43:32Z"
        }
      ]
    },
    {
      "number": 762,
      "id": "MDU6SXNzdWU4NTQwMjEyNDE=",
      "title": "Can you close a Preconnection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/762",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "From reading -api I am not certain of the lifecycle of preconnections?\r\n\r\nIs it\r\n-Generate preconnection\r\n- initiate() or listen()\r\n- preconnection is immediately destroyed?\r\n\r\nor\r\n-Generate preconnection\r\n- initiate() or listen()\r\n- initiate()/listen()\r\n- ...\r\n\r\nEither way, there ought to be a way for taps to throw away this state, either because we never called initiate/listen (1st case) or we're done creating new connections (2nd case).\r\n\r\nOr is TAPS not holding any state, with the application fully responsible for holding the object? I'm playing with treating connections and preconnections as socket-style file descriptors, and that model won't work without a preconnection.destroy() or whatever. But maybe that model is just wrong!",
      "createdAt": "2021-04-08T23:44:09Z",
      "updatedAt": "2021-06-02T15:49:20Z",
      "closedAt": "2021-06-02T15:49:20Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The preconnection is reusable for many initiate() calls.\r\n\r\nWe may want to mention something in Appendix A (https://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-interface.html#section-appendix.a) about the fact that if you're in C, you'll need to add extra API calls to free your objects.",
          "createdAt": "2021-04-09T15:50:14Z",
          "updatedAt": "2021-04-09T15:51:07Z"
        }
      ]
    },
    {
      "number": 763,
      "id": "MDU6SXNzdWU4NTQyNDgxNzM=",
      "title": "Align Implementation with API",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/763",
      "state": "OPEN",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly",
        "abrunstrom"
      ],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Obvious as it is, I believe it's good to have this here as a reminder: the API is about to get finished, and when it is, someone should go through the Implementation draft and make sure that it's fully in line with the latest API version.",
      "createdAt": "2021-04-09T07:24:16Z",
      "updatedAt": "2021-04-09T16:30:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 772,
      "id": "MDU6SXNzdWU4NTYwNDY0NzY=",
      "title": " Is Appendix A  actually implementation?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/772",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Question: I just wonder if Appendix A. actually more  implementation, rather than API (interface). \r\n\r\nIf more needs to be said in future, wouldn\u2019t this appear as implementation details, so maybe the annexe might better be a part of that?\r\n",
      "createdAt": "2021-04-12T14:38:51Z",
      "updatedAt": "2021-04-13T06:35:49Z",
      "closedAt": "2021-04-13T06:35:49Z",
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "As I've said previously, I do not think so. \"Implementation\" for these drafts really refers to how a working Transport Services system should behave, while \"interface\" refers to how a user should interact with a Transport Services implementation. The type information contained in this appendix is part of the description of the Transport Services interface.",
          "createdAt": "2021-04-12T14:52:48Z",
          "updatedAt": "2021-04-12T14:52:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, to me this appendix is a small collection of hints on how to make the step from this abstract API to a concrete API, whereas the implementation draft is about what happens underneath.",
          "createdAt": "2021-04-12T15:56:36Z",
          "updatedAt": "2021-04-12T15:56:36Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, let\u2019s close this question, the text is needed somewhere, so it can be here.\n\nGorry\n\n> On 12 Apr 2021, at 16:56, mwelzl ***@***.***> wrote:\n> \n> \ufeff\n> Yes, to me this appendix is a small collection of hints on how to make the step from this abstract API to a concrete API, whereas the implementation draft is about what happens underneath.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2021-04-13T06:17:35Z",
          "updatedAt": "2021-04-13T06:17:35Z"
        }
      ]
    },
    {
      "number": 773,
      "id": "MDU6SXNzdWU4NTYwNTg2ODI=",
      "title": "Editorial API NiTa",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/773",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Editorial: This text at the end of the intro reads odd to me:\r\n\u2018This\r\n   specific transport stack choice is discouraged for general use, because it can reduce the portability.\u2019\r\nI think it should read more like:\r\n\u2018This choice, which only permits using a\r\n   specific transport stack is discouraged for general use,\r\n   because it can reduce the portability.\u2019\r\n\u2014\u2014\r\nEditorial; Is a Connection an instance of the stack?\r\nThe current text says:\r\n\u2018A Connection represents a transport Protocol Stack on which data can\r\n   be sent to and/or received from a Remote Endpoint\u2019\r\n- This may be better as?:\r\n\u2018A Connection represents an instance if a transport Protocol Stack on which data can\r\n   be sent to and/or received from a Remote Endpoint\u2019\r\n\u2014\u2014\r\n\u2018Editorial \u2018through a Message Framer which finds message\u2019\r\nShould this be:\r\n\u2018through a Message Framer that finds message\u2019",
      "createdAt": "2021-04-12T14:51:37Z",
      "updatedAt": "2021-04-14T09:54:47Z",
      "closedAt": "2021-04-14T09:54:47Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR #784",
          "createdAt": "2021-04-13T06:56:17Z",
          "updatedAt": "2021-04-13T06:56:17Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in PR #784",
          "createdAt": "2021-04-14T09:54:43Z",
          "updatedAt": "2021-04-14T09:54:43Z"
        }
      ]
    },
    {
      "number": 774,
      "id": "MDU6SXNzdWU4NTYwNTk5NTM=",
      "title": "What is \"entangled\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/774",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "I don\u2019t actually understand the difference between a connection in a Connection Group and an \u201centangled connection\u201d ? \r\n\r\nBoth terms are used in API, but in different ways (possibly by different authors) - do we really really need the word \u201centangled\u201d??  if we do we need, can we define and explain this.\r\n",
      "createdAt": "2021-04-12T14:53:01Z",
      "updatedAt": "2021-05-04T14:38:46Z",
      "closedAt": "2021-05-04T14:38:46Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that having the word is good as it indicates a deeper relationship than mere \"grouping\". Just based on terms, I'd (correctly) imagine that I can define priorities between members of a group, and that they somehow belong together... as in: Close with a common call, etc. ... but I don't think that I would expect, just from this term, that changing a property on one of them affects all the others.  Hence the phrasing: \"The connections within a group are 'entangled' with each other\".\r\nHowever, I agree that in most other places, we should talk about \"groups\" instead. I can try to fix this.",
          "createdAt": "2021-04-12T16:02:52Z",
          "updatedAt": "2021-04-12T16:02:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good - we should add that explanation upfront in the definitions then also?",
          "createdAt": "2021-04-13T06:45:31Z",
          "updatedAt": "2021-04-13T06:45:31Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Yes, I think so.]\r\nEDIT: no, now I don't think so anymore.   (see #775)",
          "createdAt": "2021-04-13T11:05:24Z",
          "updatedAt": "2021-04-15T12:16:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have addressed this in PR #794. Note that the text interchangeably talked about both Connections and Connection Properties as being \"entangled\". I have now written this such that the term \"entanglement\" applies to Connection Properties only, whereas Connections in a group are, well, members of the same Connection Group.",
          "createdAt": "2021-04-15T12:23:41Z",
          "updatedAt": "2021-04-15T12:23:41Z"
        }
      ]
    },
    {
      "number": 775,
      "id": "MDU6SXNzdWU4NTYwNjEwNDA=",
      "title": "What's a callback?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/775",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "We have a \u201c Terminology and Notation\u201d section, but we don\u2019t define these terms:\r\n\r\nClone: Calling Clone on a Connection yields a group of Connections: the parent Connection on which Clone was called, and a resulting cloned Connection. \r\n\r\nEntangled connection:   if we do we need this term, we should define and explain what is different.\r\n\r\nCallback: can we have a one line definition that explains the different with respect to an event that an application can also asynchronously receive.\r\n",
      "createdAt": "2021-04-12T14:54:04Z",
      "updatedAt": "2021-05-26T11:45:56Z",
      "closedAt": "2021-05-26T11:45:56Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can take care of the first two; regarding callbacks, I think there should also be at least one sentence somewhere explaining the need (why are Events not good enough for security?).  I remember that this was clearly said, and I remember understanding it  :)   but by now, I have forgotten, and I can't find the rationale written anywhere.",
          "createdAt": "2021-04-15T06:55:33Z",
          "updatedAt": "2021-04-15T06:57:00Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I looked at this now, I felt that such definitions would seem a bit out of place in the \"Terminology and Notation\" section; rather, if we need to define it globally, the concepts of Cloning and Entanglement should be defined where we also define what our Connections are, what Transport Properties are, etc.  - and this is in -arch.\r\n\r\nThoughts?",
          "createdAt": "2021-04-15T12:14:02Z",
          "updatedAt": "2021-04-15T12:14:02Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This isn't need for entangled with the way used in PR #774",
          "createdAt": "2021-04-16T16:18:48Z",
          "updatedAt": "2021-04-16T16:18:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm adding the arch label so people notice  :-)",
          "createdAt": "2021-05-05T12:18:36Z",
          "updatedAt": "2021-05-05T12:18:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The one action remaining is defining \"callback\" within the scope of section 4.3.",
          "createdAt": "2021-05-07T15:53:51Z",
          "updatedAt": "2021-05-07T15:53:51Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like this will be addressed.",
          "createdAt": "2021-05-26T11:45:56Z",
          "updatedAt": "2021-05-26T11:45:56Z"
        }
      ]
    },
    {
      "number": 776,
      "id": "MDU6SXNzdWU4NTYwNjMxNTg=",
      "title": "UDP-Lite and Zero UDP Checksum (sect  6.1.1 and 7.1.3.6)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/776",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API"
      ],
      "body": "The Required Minimum Corruption Protection Coverage for Receiving  current text says:\r\n\r\n   This property specifies the minimum number of bytes in a received\r\n   message that need to be covered by a checksum.  A special value of 0\r\n   means that no checksum is permitted.  A receiving Endpoint will not\r\n   forward messages to the application that have less coverage.  The\r\n   application is responsible for handling any corruption within the\r\n   non-protected part of the message [RFC8085].\r\n\r\n- I have thought, and there seem to be various problems with how this finally emerged:\r\n\r\n1. in the UDP-Lite API, the. Value 0 indicates full coverage, not zero coverage. If the zero is intentionally redefined this way, what is the expected value for full coverage?\r\n2. The words \u201cNo checksum is permitted\u201d can be read in multiple ways.... if this means a message can be received without checking a checksum, then this should be said.\r\n3. Finally, can we specify the receiver outcome when the API requires x bytes of coverage, but the message header protects fewer bytes, is the message discarded, as per UDP-Lite?\r\n\r\nSection 7.1.3.6.  Sending Corruption Protection Length,\r\n4. is the zero case interpreted differently to UDP-LIte?\r\n5. Note: I THINK setting the to zero presently forces IPv4, (since UDP for IPv6 requires a checksum except for an upper-layer that explicitly performs this function).\r\n",
      "createdAt": "2021-04-12T14:56:09Z",
      "updatedAt": "2021-05-26T11:36:33Z",
      "closedAt": "2021-05-26T11:36:33Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have updated your comment to use numbers so I can answer it a little easier here.\r\n\r\n1. It's defined as a special value (see: \"Type: Integer, with special value Full Coverage\"). This answers 4) too: in UDP-Lite, also on sending, \"0\" indicates full coverage, whereas here it means the opposite \"that no checksum is required\".\r\n[side note, it says \"non-negative\" for sending, in 7.1.3.6, but it should say so for receiving, in 6.1.1, as well].\r\n\r\n2. I agree.\r\n\r\n3. I think this would be good to specify, yes, and I agree that it should be discarded. Clearly, since this is called \"*required* minimum corruption protection length\", it is a promise that must be kept.\r\n\r\n4. see above\r\n\r\n5. I'm lost (yes I'm aware that IPv6 has no checksum, but still). Are you talking about 0 as I write here (\"no checksum required\"), or 0 as in UDP-Lite (requiring full checksum coverage) ?",
          "createdAt": "2021-04-15T06:35:09Z",
          "updatedAt": "2021-04-15T06:35:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ping @gorryfair ",
          "createdAt": "2021-05-07T15:55:22Z",
          "updatedAt": "2021-05-07T15:55:22Z"
        }
      ]
    },
    {
      "number": 777,
      "id": "MDU6SXNzdWU4NTYwNjM3ODc=",
      "title": "Editorial: is Constant-Rate Streaming a path characteristic  or appl traffic?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/777",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "\r\nThe current text says:\r\n   Constant-Rate Streaming:  The application expects to send/receive\r\n      data at a constant rate after Connection establishment.  Delay and\r\n      delay variation should be minimized at the expense of efficient\r\n      use of the available capacity.  This implies that the Connection\r\n      might fail if the desired rate cannot be maintained across the\r\n      Path.  \r\n\r\n- this last sentence sounds a little like the app needs to maintain the rate, rather than the path is expected to offer the rate. Could we change the last sentence to:\r\n- /This implies that the Connection might fail if the Path is unable to maintain the desired rate.  /\r\n",
      "createdAt": "2021-04-12T14:56:50Z",
      "updatedAt": "2021-04-14T09:44:36Z",
      "closedAt": "2021-04-14T09:44:36Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR #784",
          "createdAt": "2021-04-13T07:05:45Z",
          "updatedAt": "2021-04-13T07:05:45Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was fixed in PR #784",
          "createdAt": "2021-04-14T09:44:36Z",
          "updatedAt": "2021-04-14T09:44:36Z"
        }
      ]
    },
    {
      "number": 778,
      "id": "MDU6SXNzdWU4NTYwNjU0NzA=",
      "title": "Update ref to dplpmtud",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/778",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial",
        "ready for text"
      ],
      "body": "\r\nI-D.ietf-tsvwg-datagram-plpmtud is now a RFC.\r\n",
      "createdAt": "2021-04-12T14:58:34Z",
      "updatedAt": "2021-04-14T09:56:22Z",
      "closedAt": "2021-04-14T09:56:22Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR #784",
          "createdAt": "2021-04-13T06:56:36Z",
          "updatedAt": "2021-04-13T06:56:36Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in PR #784",
          "createdAt": "2021-04-14T09:56:22Z",
          "updatedAt": "2021-04-14T09:56:22Z"
        }
      ]
    },
    {
      "number": 779,
      "id": "MDU6SXNzdWU4NTYwNjY4NzQ=",
      "title": "Priority property \"represents a hierarchy of priorities\"?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/779",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "\r\nThe text reads quire off when it says a priority property represents a hierarchy of priorities:\r\n   This property represents a hierarchy of priorities.  \r\n\r\n- Could this better be: \u2018A priority property is organised within a hierarchy of priorities. \u2018?\r\n",
      "createdAt": "2021-04-12T14:59:59Z",
      "updatedAt": "2021-05-04T14:40:00Z",
      "closedAt": "2021-05-04T14:40:00Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When reading \"hierarchy\", it's easy to think that there may be priority sub-groups within priority groups, or something of that nature. Yet, this is not the case, it's just a flat priority assignment. Hence, to me, mentioning \"hierarchy\" here is misleading altogether. Therefore, I think we'd be much better off removing this sentence, i.e. replacing:\r\n\r\n> This property represents a hierarchy of priorities. It can specify the priority of a Message, relative to other Messages sent over the same Connection.\r\n\r\nwith\r\n\r\n> This property specifies the priority of a Message, relative to other Messages sent over the same Connection.\r\n",
          "createdAt": "2021-04-15T07:05:58Z",
          "updatedAt": "2021-04-15T07:06:21Z"
        }
      ]
    },
    {
      "number": 780,
      "id": "MDU6SXNzdWU4NTYwNjc5NTY=",
      "title": "To me, Safely Replayable text seems unclear ( 7.1.3.4.)",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/780",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "The current text says:\r\n\r\n   If true, Safely Replayable specifies that a Message is safe to send\r\n   to the Remote Endpoint more than once for a single Send Action.  It\r\n   marks the data as safe for certain 0-RTT establishment techniques,\r\n   where retransmission of the 0-RTT data may cause the remote\r\n   application to receive the Message multiple times.\r\n\r\n   For protocols that do not protect against duplicated messages, e.g.,\r\n   UDP, all messages need to be marked as \"Safely Replayable\".  To\r\n   enable protocol selection to choose such a protocol, \"Safely\r\n   Replayable\" needs to be added to the TransportProperties passed to\r\n   the Preconnection.  If such a protocol was chosen, disabling \"Safely\r\n   Replayable\" on individual messages MUST result in a SendError.\r\n\u2014\r\nI think this could perhaps be misleading, and suggest:\r\n- 1. I would like to change /UDP/directly over UDP/ .... because clearly it is possible that a transport such as QUIC also uses UDP, but provides this sort of protection above the UDP layer.\r\n- 2. This is still written from the perspective of the protocol. I think it is important here to also therefore add a sentence then clarifies that the application might be able to designed to detect and ignore such duplication. \u2018Protection from replay of messages could be provided by an application when a transport system replays messages\u2019.\r\n",
      "createdAt": "2021-04-12T15:01:08Z",
      "updatedAt": "2021-05-04T14:27:14Z",
      "closedAt": "2021-05-04T14:27:14Z",
      "comments": []
    },
    {
      "number": 781,
      "id": "MDU6SXNzdWU4NTYwNjg4NDA=",
      "title": "More thoughts on network Fragmentation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/781",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API"
      ],
      "body": "Issue: this describes network Fragmentation, but does not really help a user of the transport system know when to request this property.\r\n\r\nThe current text says:\r\n   This property specifies that a message should be sent and received as\r\n   a single packet without network-layer fragmentation, if possible.\r\n   This only takes effect when the transport uses a network layer that\r\n   supports this functionality.  When it does take effect, setting this\r\n   property to true will cause the Don't Fragment bit to be set in the\r\n   IP header, and attempts to send a message with this property set to a\r\n   size greater than the transport's current estimate of its maximum\r\n   packet size (\"singularTransmissionMsgMaxLen\") will result in a\r\n   \"SendError\".\r\n\r\nI was guilty of writing one version of this, which I  now think has become wrong. I think this should read:\r\n\r\nThis property specifies that a message should be sent and received as\r\nwithout network-layer fragmentation. When running over IPv4, setting this property to\r\ntrue will also cause the Don't Fragment bit to be set in the IP  header. It also requests to not perform network-layer source fragmentation.  An attempt to send a message with this property set and a size greater than the transport's current estimate of its maximum\r\npacket size (\"singularTransmissionMsgMaxLen\") will result in a \"SendError\".\r\n\r\nThis function is needed when PMTUD OR PLPMTUD is implemented above the transport system. It might also be used to avoid blackholing when using a path that does not forward fragmented packets.\r\n",
      "createdAt": "2021-04-12T15:02:02Z",
      "updatedAt": "2021-05-19T13:01:30Z",
      "closedAt": "2021-05-19T13:01:30Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Linked to #782 ",
          "createdAt": "2021-04-12T15:04:42Z",
          "updatedAt": "2021-04-12T15:04:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume that this is about the Message Property with name \"noFragmentation\", in section 7.1.3.9: \"No Network-Layer Fragmentation\".\r\n\r\nYour proposed update makes three types of changes that I see:\r\n\r\n1) it removes \"as a single packet\" in \"should be sent and received as a single packet without network-layer fragmentation\".  Why?  But anyway, I'd be ok with removing it, I don't think this matters.\r\n\r\n2) it adds this sentence: \"It also requests to not perform network-layer source fragmentation.\"\r\nI think this is good.\r\n\r\n3) it removes qualifiers like \"This only takes effect when the transport uses a network layer that supports this functionality.\", \"if possible\", and \"When it does take effect\". Why? What happens, then, when this is requested, but the Transport Services system runs over TCP?  I believe that you may have mistaken this for being a Selection Property.\r\n\r\nI understand that you're concerned with PMTUD and PLPMTUD being able to operate; I suggest that you take a look at the selection properties in section 4.2 to see if you're ok with what they offer, or if something needs to be extended there.",
          "createdAt": "2021-04-14T07:36:24Z",
          "updatedAt": "2021-04-14T07:36:24Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. Let's keep \"as a single packet\" - it adds context.\r\n2. OK.\r\n3. I want us to think on this point.  I'm OK with keeping or removing:  \"This only takes effect when the transport uses a network layer that supports this functionality.\", \"if possible\", because indeed this needs the cooperation of a stack that allows this. \r\n\r\n.... In mentioning PMTUD, and avoiding blackholes,  I wanted examples of how this might be a useful thing for the application to want to use. I'd be even happier to also suggest another reason why this might be needed.\r\n\r\n... A few more comments and I'll make a PR;-)\r\n\r\nGorry\r\n",
          "createdAt": "2021-04-14T09:27:52Z",
          "updatedAt": "2021-04-14T09:27:52Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We agree about 1 and 2. Do we agree about 3? It sounds like we do. But what is it you're asking, or suggesting to change?  Confused about 3)  :-)\r\n\r\nRegarding \"I'd be even happier to also suggest another reason why this might be needed\": I don't understand what's on your mind, but if you can think of useful text, I'd say just propose it in a PR, to be in the right place, and we can discuss it more clearly.",
          "createdAt": "2021-04-14T11:00:36Z",
          "updatedAt": "2021-04-14T11:00:36Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, I'll make a PR.",
          "createdAt": "2021-04-14T11:14:52Z",
          "updatedAt": "2021-04-14T11:14:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made two PRs one on seg; one on frag #834 . This deviates a little to the above, but I think it is clean - I'd love review.\r\n\r\nUDP would allow no Seg; No Frag; - both are the same, UDP does not segment.\r\nUDP-O would allow either; No frag (allowing transport seg); or no Seg.\r\nQUIC, TCP would always do no frag; -- does no Seg is not possible?\r\nSCTP would do no Frag (note it would still send frags, but avoid their usage).",
          "createdAt": "2021-05-13T11:15:52Z",
          "updatedAt": "2021-05-13T11:15:52Z"
        }
      ]
    },
    {
      "number": 782,
      "id": "MDU6SXNzdWU4NTYwNjk2NDE=",
      "title": "No Segmentation  ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/782",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API"
      ],
      "body": "Issue: No Segmentation  property - To me, the final text seems unclear about how it operates.:\r\n\r\n   When set to true, this property requests the network layer at the\r\n   sending endpoint to not fragment the packets generated by the\r\n   transport layer.  When running over IPv4, setting this property to\r\n   true will also cause the Don't Fragment bit to be set in the IP\r\n   header.  When this property is set, an attempt to send a message size\r\n   greater than the transport's current estimate of its maximum packet\r\n   size (singularTransmissionMsgMaxLen) will result in a SendError.\r\n   This only takes effect when the transport and network layer support\r\n   this functionality.\r\n\r\n- Is this really about the network fragmenting packets? - I do not think it is. To me, this is about the transport system segmenting packets.  I think this should read:\r\n\r\n  When set to true, this property requests the transport system at the\r\n   sending endpoint to not segment a single message into multiple IP packets.  \r\n   When this property is set, an attempt to send a message\r\n   greater in size than the transport's current estimate of its maximum packet\r\n   size (singularTransmissionMsgMaxLen) will result in a SendError.\r\n   When set to true, this also implies that noFragmentation is also set to true. \r\n   This only takes effect when the transport layer supports\r\n   this functionality. Requiring this property prevents use of transports such as TCP.\r\n",
      "createdAt": "2021-04-12T15:02:55Z",
      "updatedAt": "2021-05-19T13:01:01Z",
      "closedAt": "2021-05-19T13:01:01Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Linked to #781 ",
          "createdAt": "2021-04-12T15:05:08Z",
          "updatedAt": "2021-04-12T15:05:08Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good: I think you're right that this should not be about network-layer fragmentation.\r\n\r\nBad: The last sentence tells me that you wish for this to be a Selection Property, not (as it now is) a Message Property. From the minset appendix, we can see that the present property maps to \"Request not to bundle messages\" from SCTP; checking in RFC 8303, I find that this is the \"no-bundle flag\" of the send call, which we find in RFC 4960.  So that's what it is - a per-message request at the transport layer.\r\n\r\nSo, I suggest to update the text as follows (this only replaces the first two sentences with your new first sentence):\r\n\r\n> When set to true, this property requests the transport system at the sending endpoint to not segment a single message into multiple IP packets. When this property is set, an attempt to send a message size greater than the transport's current estimate of its maximum packet size (singularTransmissionMsgMaxLen) will result in a SendError. This only takes effect when the transport and network layer support this functionality.\r\n\r\n... and, if you NEED to be able to choose a transport that supports this functionality, look at the selection properties to see if you need to make a change to them. I'm not sure: we currently have \"Preservation of Message Boundaries\" there (\"This property specifies whether the application needs or prefers to use a transport protocol that preserves message boundaries.\"), why is this not good enough?",
          "createdAt": "2021-04-14T07:22:31Z",
          "updatedAt": "2021-04-14T07:22:31Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK. Similarly to the Frag text, I added the last sentence to try to tease-out what happens when you call the function. So, in this case what do what to happen for TCP?\r\n* The message fails when sending with TCP - because it always segments?\r\n* The message sends, because TCP always segments?\r\n* Something else?\r\n\r\nI'd really like a good example also of when the app would gain from setting this, possibly we could give an example of where setting this was useful? (e.g. an endpoint that wanted a single execution to process an entire packet?",
          "createdAt": "2021-04-14T09:41:32Z",
          "updatedAt": "2021-04-14T09:41:32Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume that you're talking about a message exceeding singularTransmissionMsgMaxLen. The current description is clear about this:\r\n> When this property is set, an attempt to send a message size greater than the transport's current estimate of its maximum packet size (singularTransmissionMsgMaxLen) will result in a SendError.\r\nI.e., a request from the application to send a message > singularTransmissionMsgMaxLen should fail, irrespective of the underlying transport. I say this just for context, to clarify that this is a discussion of the above sentence.\r\n\r\nNow, let's think about whether this is a good design decision - should it REALLY fail in case of TCP?\r\nI would say that the answer only is \"yes\" if guaranteeing \"no fragmentation\" is really useful for the application (which is the question you ask at the end).\r\n\r\nGoing back via the minset appendix and RFC 8303 allowed me to find the \"no-bundle flag\" of SCTP before, and now I started to dig for signs of its usefulness (assuming that we should be able to learn something from the design decisions that were made for SCTP). This made me understand that I made a mistake in the minset appendix, as I recently tried to adjust it to match updated names of Properties: this property does NOT fit the \"no-bundle flag\", because the \"no-bundle flag\" is essentially the same as enabling/disabling Nagle (with per-message control). We implement this via the capacity profile, it's a different thing.\r\n\r\nIndeed, the \"No Segmentation\" functionality is not in minset, nor in RFC 8303 - neither SCTP nor TCP offer it. UDP does, implicitly, via the SEND call as described in RFC 8304. I can only imagine that an extremely time-critical application may want to execute this kind of control when knowing that it runs over UDP, but such an application could just make sure that their messages don't exceed the readable singularTransmissionMsgMaxLen property. Then that's a pretty UDP-specific implementation, I'd say, eliminating the need for a general \"no segmentation\" request that won't have a meaning anywhere else.\r\n\r\nAm I missing something?  If everything I write above is correct, we should remove this property, UNLESS someone deems this super useful (i.e., just reading and adhering to singularTransmissionMsgMaxLen wouldn't be enough) when the underlying protocol is QUIC.",
          "createdAt": "2021-04-14T12:06:46Z",
          "updatedAt": "2021-04-14T12:06:46Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now I think I've teased this apart - I also now want to understand if we need to offer this as an important service (rather than a corner case). If there is no push-back; I think we could remove this and only leave \"no fragmentation\".",
          "createdAt": "2021-04-15T09:21:25Z",
          "updatedAt": "2021-04-15T09:21:25Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Try top build on #793 with a new PR. I'll also do a PR against fragmentation... #782 ",
          "createdAt": "2021-05-13T10:53:57Z",
          "updatedAt": "2021-05-13T10:55:26Z"
        }
      ]
    },
    {
      "number": 785,
      "id": "MDU6SXNzdWU4NTcxMzkwODk=",
      "title": "prioritize path over protocol selection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/785",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Section 4.2: \" In such cases, implementations SHOULD prioritize Selection Properties that select paths over those that select protocols.\"\r\n\r\nI think I agree to this recommendation but it comes a little out of nowhere and we should probably provide some reasoning, especially as this is normative.",
      "createdAt": "2021-04-13T16:41:00Z",
      "updatedAt": "2021-05-11T19:13:04Z",
      "closedAt": "2021-05-11T19:13:04Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposing to change text to address the application developer: to expect that the path selection properties would be preferred over protocol selection properties.\r\n\r\nWe should also explain a bit of the rationale, to explain that path properties are generally more sensitive around policy/expense.",
          "createdAt": "2021-05-07T16:00:45Z",
          "updatedAt": "2021-05-07T16:00:45Z"
        }
      ]
    },
    {
      "number": 788,
      "id": "MDU6SXNzdWU4NTc3NTg5NzU=",
      "title": "Are message framers entangled in a connection group?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/788",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This is not fully clear from section 5.4., however, if connections in a group are each QUIC streams, I think it should be possible to use different framers on each stream. So it might be okay that a framers is copied when clone is called but changing a framer on one connection should not change the framer on the other connection in a group...?",
      "createdAt": "2021-04-14T10:29:58Z",
      "updatedAt": "2021-05-04T14:38:46Z",
      "closedAt": "2021-05-04T14:38:46Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also an related editorial comment (that could be addressed in the same PR eventually): this section on groups only at the very end has a paragraph starting with \"Note that calling Clone() can result in on-the-wire signaling...\" which kind of explains that groups are supposed to be used for multistream protocol but can also be mapped to separate connection if the protocol doesn't not support multiplexing of stream on one connection. I think this information should be added at the very beginning of this section.",
          "createdAt": "2021-04-14T10:33:24Z",
          "updatedAt": "2021-04-14T10:33:24Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, now looking at the framer section, I guess you would rather like to already set the new framer before you clone a connection...?",
          "createdAt": "2021-04-14T10:44:46Z",
          "updatedAt": "2021-04-14T10:44:46Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with everything you say here; about your last suggestion, maybe a framer should be an optional argument of the clone call?",
          "createdAt": "2021-04-14T14:39:50Z",
          "updatedAt": "2021-04-14T14:39:50Z"
        }
      ]
    },
    {
      "number": 789,
      "id": "MDU6SXNzdWU4NTc3NzQ3NzE=",
      "title": "MUST ignore setting properties that does not exists",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/789",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "Section 6 says. \"Attempts to set Specific Protocol Properties on a protocol stack not containing that specific protocol are simply ignored, and do not raise an error\"\r\n\r\nShould this be normative?\r\n\r\n\"Attempts to set Specific Protocol Properties on a protocol stack not containing that specific protocol MUST be ignored, and MUST NOT raise an error\"\r\n\r\nI note that this a random sentence where spotted that normative language could be used. I don't look for these kind of occasion systematically...",
      "createdAt": "2021-04-14T10:50:12Z",
      "updatedAt": "2021-06-11T15:37:28Z",
      "closedAt": "2021-06-11T15:37:27Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I could see a case that the first requirement to ignore, I think this actually a requirement for predictable interop? (in which case we could motivate that?)\r\n- I am much less sure of the second MUST, and think an error notification is not an interop issue?",
          "createdAt": "2021-04-15T09:06:10Z",
          "updatedAt": "2021-04-15T09:06:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The first MUST is definitely important for code portability, and so I think this is a good suggestion.\r\n\r\nI'm also less sure of the second MUST, but I think it's good to keep: yes, errors can be ignored by an application, but they can also lead to application code like:\r\n\r\nadjust QUIC properties\r\nif error: adjust TCP properties\r\n\r\nIf an application absolutely must do this and must find out what's going on, it can, it's ok for a Transport Services system to make everything readable... but throwing errors in addition is yet another hint for a programmer to start developing code like this. We should discourage such code. That's why I'd keep the MUST NOT   (as a counter-example, \"SHOULD NOT\" would mean that there would have to be a good reason for the designer of a Transport Services system to make an exception - what would such a reason be?  \"This particular function of this particular protocol is so important, I think here I should really throw an error after all?\"   - Nah...).",
          "createdAt": "2021-04-15T11:30:26Z",
          "updatedAt": "2021-04-15T11:30:26Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nSpecific Protocol Properties are defined in a transport- and implementation-specific way, and MUST NOT be assumed to apply across different protocols. Attempts to set Specific Protocol Properties on a protocol stack not containing that specific protocol are simply ignored, and do not raise an error;\r\n```\r\n\r\n```\r\nSpecific Protocol Properties are defined in a transport- and implementation-specific way, and MUST NOT apply across different protocols.\r\n```",
          "createdAt": "2021-05-07T16:03:37Z",
          "updatedAt": "2021-05-07T16:03:37Z"
        }
      ]
    },
    {
      "number": 790,
      "id": "MDU6SXNzdWU4NTc3NzU4MTg=",
      "title": "Priority for single stream",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/790",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Section 7.2.6. says \" for example, if a transport stack that only provides a single in-order reliable stream is selected, prioritization information can only be ignored.\"\r\n\r\nI don't think this is entirely true as you can still decide in which order you schedule independent messages on one stream.",
      "createdAt": "2021-04-14T10:51:39Z",
      "updatedAt": "2021-05-04T14:39:32Z",
      "closedAt": "2021-05-04T14:39:32Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't get this. The sentence says \"in-order\". Scheduling them from buffer A into buffer B in accordance with priorities won't help when everything leaves buffer B in a fixed sequence.",
          "createdAt": "2021-04-14T14:47:47Z",
          "updatedAt": "2021-04-14T14:47:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about a less complex sentence: ...\"for example, if the transport system selects a stack that only provides a single in-order reliable stream, the prioritization information is ignored.\"",
          "createdAt": "2021-04-14T15:31:35Z",
          "updatedAt": "2021-04-14T15:31:35Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "message on the taps \"layer\" are independent. so the order an application calls send on these message doesn't have to be the same order the messages are send on an \"in-order stream\"",
          "createdAt": "2021-04-14T15:55:12Z",
          "updatedAt": "2021-04-14T15:55:12Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, now I see what you mean. Hmmm...  looking at the text, it seems that we could just delete this sentence and the problem is solved?",
          "createdAt": "2021-04-14T16:03:52Z",
          "updatedAt": "2021-04-14T16:03:52Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think what was intended with the example was to show that the set priorities may not have any effect. Perhaps we should instead just add \"and the set priorities may not have any effect\" if we want to be explicit? Removing it also works though.",
          "createdAt": "2021-04-14T16:46:43Z",
          "updatedAt": "2021-04-14T16:46:43Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think just add that!",
          "createdAt": "2021-04-14T18:07:42Z",
          "updatedAt": "2021-04-14T18:07:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm for removing it (I think I wrote this sentence btw :-)  ).  Giving this example just throws off someone who thinks about this case like Mirja did here - even if we say \"may not apply\", the reader may (correctly) think \"but why, in this case they CAN well apply!\". So I don't find that helpful.\r\n\r\nFor context, the full current statement is:\r\n> A Transport Services system gives no guarantees about how its expression of relative priorities will be realized; for example, if a transport stack that only provides a single in-order reliable stream is selected, prioritization information can only be ignored. However, the Transport Services system will seek to ensure that performance of relatively-prioritized connections and messages is not worse with respect to those connections and messages than an equivalent configuration in which all prioritization properties are left at their defaults.\r\n\r\nand I believe that we say everything we need to say if we just change this into:\r\n\r\n> A Transport Services system gives no guarantees about how its expression of relative priorities will be realized. However, the Transport Services system will seek to ensure that performance of relatively-prioritized connections and messages is not worse with respect to those connections and messages than an equivalent configuration in which all prioritization properties are left at their defaults.\r\n",
          "createdAt": "2021-04-15T07:17:42Z",
          "updatedAt": "2021-04-15T07:17:42Z"
        }
      ]
    },
    {
      "number": 791,
      "id": "MDU6SXNzdWU4NTc3ODA5NTM=",
      "title": "be more concrete about receiving",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/791",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Reading 7.3.2 I found the concepts there quite abstract. I think it would really help to be a bit more specific and e.g. take UDP and TCP as examples basically saying some like: as UDP is consider a message based protocol, each received datagram will trigger receive() of a complete message. As TCP is stream-based all TCP segments will be delivered by ReceivedPartial().",
      "createdAt": "2021-04-14T10:58:39Z",
      "updatedAt": "2021-07-08T14:50:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My impression here is that we could use some examples for different protocols for sending and receiving (for messages, datagrams, and raw streams).\r\n\r\nThis could be a 7.4 Examples section.",
          "createdAt": "2021-05-07T16:07:25Z",
          "updatedAt": "2021-05-07T16:07:25Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we need to do this - can we just close this?",
          "createdAt": "2021-07-08T14:50:14Z",
          "updatedAt": "2021-07-08T14:50:14Z"
        }
      ]
    },
    {
      "number": 792,
      "id": "MDU6SXNzdWU4NTc3ODM1NDI=",
      "title": "Clarify handling of receive errors",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/792",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "Actually handling of receive error is also not fully clear to me. Section 7.3.2.3 says:\r\n\"A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or parsed\"\r\n\r\nHowever, I assume that this error should rather not be called if a transport is reliable because the assumption is that the packet will be retransmitted, right?\r\n\r\nE.g. in case of QUIC if a packet cannot be decrypted would that trigger an error or not? I assume not, because the QUIC stack cannot even know if a packet contained any payload data, right?",
      "createdAt": "2021-04-14T11:02:10Z",
      "updatedAt": "2021-06-11T16:11:51Z",
      "closedAt": "2021-06-11T16:11:51Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this is not very clear - to me, the cases that you describe are cases that should not throw this error, because it's a problem of the underlying protocol and not relevant to the application (what's an application going to do with it anyway?).\r\n\r\nI can only see two relevant cases of errors:\r\n1. the one example that we already give: \"a Message that was being partially received previously, but had not completed, encountered an error and will not be completed.\"  - note that this does not assume a fully reliable transfer, because in this case, the underlying stack would solve it, and the fact that there are retransmissions shouldn't be relevant to the application. So this means \"you got a partial message from me before, but now I can tell you that you won't get the rest\".\r\n2. the case discussed in #776: a minimum checksum coverage range was required for reception, but this promise was not kept => the Transport Services system will have to be discard the incoming message.\r\n\r\nThere may well be others, but it's probably good to give these two examples, not only one, to make it clearer what kinds of errors are covered by this, and to explicitly state that this is only about errors that are relevant to the application, not protocol-internal reception errors.",
          "createdAt": "2021-04-15T07:58:06Z",
          "updatedAt": "2021-04-15T07:58:06Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is how I see it. These errors should be actionable by the upper layer, in contrast something that fails an auth check is not actionable by an upper layer protocol.\n\nA different  other use is for logging ... to diagnose fault, where you could want to see what isn\u2019t processed by the lower layers. This is not the use I see here.\n\nGorry\n\n> On 15 Apr 2021, at 08:58, mwelzl ***@***.***> wrote:\n> \n> \ufeff\n> I agree that this is not very clear - to me, the cases that you describe are cases that should not throw this error, because it's a problem of the underlying protocol and not relevant to the application (what's an application going to do with it anyway?).\n> \n> I can only see two relevant cases of errors:\n> \n> the one example that we already give: \"a Message that was being partially received previously, but had not completed, encountered an error and will not be completed.\" - note that this does not assume a fully reliable transfer, because in this case, the underlying stack would solve it, and the fact that there are retransmissions shouldn't be relevant to the application. So this means \"you got a partial message from me before, but now I can tell you that you won't get the rest\".\n> the case discussed in #776: a minimum checksum coverage range was required for reception, but this promise was not kept => the Transport Services system will have to be discard the incoming message.\n> There may well be others, but it's probably good to give these two examples, not only one, to make it clearer what kinds of errors are covered by this, and to explicitly state that this is only about errors that are relevant to the application, not protocol-internal reception errors.\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2021-04-15T10:27:42Z",
          "updatedAt": "2021-04-15T10:27:42Z"
        }
      ]
    },
    {
      "number": 798,
      "id": "MDU6SXNzdWU4NzI5Njg2ODU=",
      "title": "S1.1: Definition of Tuple refers to property before it is defined",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/798",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "S1.1, Definition of Tuple refers to property before it is defined",
      "createdAt": "2021-04-30T17:50:24Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:07Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This must be about the sentence: \"The composition of types and their order depends on the property and is fixed for the property.\"\r\n\r\nI wonder if this could be addressed by just removing this sentence? I'm not sure it's really needed.",
          "createdAt": "2021-05-05T12:24:50Z",
          "updatedAt": "2021-05-05T12:24:50Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep. Will remove the sentence.",
          "createdAt": "2021-07-08T09:33:58Z",
          "updatedAt": "2021-07-08T09:33:58Z"
        }
      ]
    },
    {
      "number": 799,
      "id": "MDU6SXNzdWU4NzI5ODA1MjY=",
      "title": "S2. Very long bullets are hard to read",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/799",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "The list of what the interface provides is in the form of one sentence per bullet. That makes some sentences very long with many commas. I find this hard to read, particularly the first and fourth bullet. Maybe allow multiple sentences per bullet for some of them?",
      "createdAt": "2021-04-30T17:56:54Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": []
    },
    {
      "number": 800,
      "id": "MDU6SXNzdWU4NzI5ODg1ODk=",
      "title": "Remove use of the word TAPS?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/800",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "TAPS is used in a few places in the document. I think we said to remove and replace that at some point in time.",
      "createdAt": "2021-04-30T18:01:27Z",
      "updatedAt": "2021-07-08T09:39:16Z",
      "closedAt": "2021-07-08T09:39:16Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suggestion: add this to #672 in a comment, and close this issue.",
          "createdAt": "2021-06-04T09:01:21Z",
          "updatedAt": "2021-06-04T09:01:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, and noted in #672.",
          "createdAt": "2021-07-08T09:39:16Z",
          "updatedAt": "2021-07-08T09:39:16Z"
        }
      ]
    },
    {
      "number": 801,
      "id": "MDU6SXNzdWU4NzMwMDM3Nzg=",
      "title": "S3.1.3 Wrong event handler in code exampe",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/801",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-30T18:10:07Z",
      "updatedAt": "2021-07-08T13:50:23Z",
      "closedAt": "2021-07-08T13:50:23Z",
      "comments": []
    },
    {
      "number": 802,
      "id": "MDU6SXNzdWU4NzMwMTcxOTU=",
      "title": "S3.2: Reference to single namespace is unclear",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/802",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Introductory text says \"All Transport Properties, regardless of the phase in which they are used, are organized within a single namespace.\" But later in the text multiple name spaces are mentioned. Even if they are not related to the phase, this does not seem consistent.",
      "createdAt": "2021-04-30T18:16:42Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "reworked this section to avoid the namespace issue altogether.",
          "createdAt": "2021-07-08T09:43:40Z",
          "updatedAt": "2021-07-08T09:43:40Z"
        }
      ]
    },
    {
      "number": 803,
      "id": "MDU6SXNzdWU4NzMwMjU4NTg=",
      "title": "S3.2.2: Enumeration is a basic type so the two bullets do not read correctly",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/803",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-30T18:19:51Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": []
    },
    {
      "number": 804,
      "id": "MDU6SXNzdWU4NzMwMzc0Nzg=",
      "title": "S4: Why are only SecurityParameters optional in NewPreconnection?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/804",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "For other parameters you have to pass in an empty object if you do not want to set anything but not for SecurityParameters. Unclear why the parameters are treated differently?",
      "createdAt": "2021-04-30T18:26:08Z",
      "updatedAt": "2021-06-02T15:48:43Z",
      "closedAt": "2021-06-02T15:48:43Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- Make security parameters non-optional\r\n- Remove \"Transport Properties MUST always be specified while security parameters are OPTIONAL.\"\r\n- Define that there is an implementation-specific security parameter to disable security",
          "createdAt": "2021-05-07T16:16:22Z",
          "updatedAt": "2021-05-07T16:16:22Z"
        }
      ]
    },
    {
      "number": 805,
      "id": "MDU6SXNzdWU4NzMwNTYzODA=",
      "title": "S4.2 Use of recommended ",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/805",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Text that discusses the recommended default values for Selection Properties uses the word \"recommended\" in multiple places. It is unclear to me if any of them should be \"RECOMMENDED\". Otherwise using another word may make it more clear.",
      "createdAt": "2021-04-30T18:36:52Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Recommended -> suggested?",
          "createdAt": "2021-05-07T16:19:16Z",
          "updatedAt": "2021-05-07T16:19:16Z"
        }
      ]
    },
    {
      "number": 806,
      "id": "MDU6SXNzdWU4NzMwNzU0MDc=",
      "title": "S4.2.2. Default for Preservation of Message Boundaries",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/806",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "I am sure this has been discussed, but reading now it seems strange to me to use \"Prefer\" as the default for a Selection Property that affects how the application interacts with the API. Using \"Prefer\" means that I do not know what service I will get when using the default settings? In this case I do not know if I get messages or not if I use the defaults.",
      "createdAt": "2021-04-30T18:46:10Z",
      "updatedAt": "2021-05-08T08:20:13Z",
      "closedAt": "2021-05-08T08:20:13Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be Ignore as a default.",
          "createdAt": "2021-05-07T16:23:34Z",
          "updatedAt": "2021-05-07T16:23:34Z"
        }
      ]
    },
    {
      "number": 807,
      "id": "MDU6SXNzdWU4NzMyMDE0MDc=",
      "title": "S4.2.3. What makes Configure Per-Message Reliability special?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/807",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "For this property we state. \"This property applies to Connections and Connection Groups.\" But I think this is true for all Selection Properties, so it read strangely to me to point it out for only one property. Particularly the part about the Connection Groups. It makes you wonder if the other properties do not apply to Connection Groups. I guess it is here because the Property relates to messages, but maybe the text can be reformulated and the part about Connection Groups can be removed.\r\n\r\nMaybe something like \"This property specifies whether an application considers it useful to indicate its reliability requirements on a per-Message basis for the Messages within the Connection.\" or \"This property specifies whether an application considers it useful to specify different reliability requirements for individual Messages in a Connection. ",
      "createdAt": "2021-04-30T19:55:28Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A clarification:\r\n* I'm pretty sure that the statement \"This property applies to Connections and Connection Groups.\" comes from me - I had originally written this for all properties where it applies like this, the only different one being per-Message priority. Then we changed this at some point, to only make per-Message priority stand out, and removed that statement everywhere. In the process, we (probably I) must have overlooked this one. So yes, this statement doesn't fit and should be removed.\r\n* Anna's second paragraph above proposes an update to the only remaining sentence describing this property. I suggest to use her second suggestion.",
          "createdAt": "2021-06-16T07:58:49Z",
          "updatedAt": "2021-06-16T07:58:49Z"
        }
      ]
    },
    {
      "number": 808,
      "id": "MDU6SXNzdWU4NzM0MjQxNjk=",
      "title": "Be more clear about Setting Message Properties on Preconnections and Connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/808",
      "state": "OPEN",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "In 3.2 it is clear that you can set Message Properties on Connections and Preconnections, but the rest of the document is not very clear about this.\r\n\r\nIn 4.2 for instance the text only talks about setting Selection Properties and Connection Properties on PreConnections. \r\n\r\nIn 7.1.3 the text says \"Connection Properties describe the default behavior for all Messages on a Connection\". But I think that Message Properties set on a Connection or PreConnection may also describe the default behavior so this relationship should be clarified. Also, the Message Property defaults given for Properties that do not depend on other Properties sets the defaults for all Messages in a Connection I assume? I also assume that a Message Property set on a Message Context overrides a Message Property set on a PreConnection or Connection, but this is also not specified.\r\n\r\nIn 5.4. Connection Groups, I assume that setting Message Properties on a Connection applies to all Connections in the Connection Group? This is not clear. ",
      "createdAt": "2021-04-30T22:08:21Z",
      "updatedAt": "2021-06-16T10:47:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, I agree. If you set a message property dynamically on a connection, though, I don't think it would affect the group\u2014I could have one stream in a multiplexed protocol have separate behavior, such as priority.",
          "createdAt": "2021-05-07T16:41:30Z",
          "updatedAt": "2021-05-07T16:41:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to tfpauly. But this is already written in 5.4, maybe you missed it (Anna)?   \"Message Properties are also not entangled. For example, changing Lifetime (see Section 7.1.3.1) of a Message will only affect a single Message on a single Connection.\"",
          "createdAt": "2021-06-16T07:39:04Z",
          "updatedAt": "2021-06-16T07:39:04Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am fine with an update of a Message Property to a connection applying only to that connection. Priority is not a good example as it is already a special case, but my main issue was that we need to be more clear about the behavior in the specification. \r\n\r\n@mwelzl the issue is about setting a Message Property on a Connection. The text you refer to talk about setting Message Properties on a message. You could interpret the first part as a general statement, but the way the text is structured it is easy to think it refers to setting Message Properties on a message so I think we should be explicit also about setting Message Properties on a Connection. Could be a second example.",
          "createdAt": "2021-06-16T10:28:59Z",
          "updatedAt": "2021-06-16T10:28:59Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So after looking at the text again, I think the example talking about setting Message Properties on a message should be removed, see comment in the pull request.",
          "createdAt": "2021-06-16T10:47:14Z",
          "updatedAt": "2021-06-16T10:47:14Z"
        }
      ]
    },
    {
      "number": 809,
      "id": "MDU6SXNzdWU4NzM0MzcxOTU=",
      "title": "S4.2.5. Relation to UDP for Use of 0-RTT Session Establishment and use of safelyReplayable",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/809",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API"
      ],
      "body": "The text says \r\n> Note that disabling this property has no effect for protocols that are not connection-oriented and do not protect against duplicated messages, e.g., UDP.\r\n\r\nWhat does disabling mean? Does this mean mean that it is valid to set this property to \"Prohibit\" but still set \"safelyReplayable\" to \"Require\" on the PreConnection. Should that not be an error?\r\n\r\nThis is also related to #780. The use of safelyReplayable for both reliable and unreliable services makes the text a bit confusing. Would it not be sufficient to state that if you do not Require Reliable Data Transfer you have to be prepared to deal with duplication?",
      "createdAt": "2021-04-30T22:29:58Z",
      "updatedAt": "2021-05-08T19:20:37Z",
      "closedAt": "2021-05-08T19:20:37Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should remove this sentence in 4.2.5:\r\n\r\n```\r\nNote that disabling this property has no effect for protocols that are not connection-oriented and do not protect against duplicated messages, e.g., UDP.\r\n```",
          "createdAt": "2021-05-07T16:48:39Z",
          "updatedAt": "2021-05-07T16:48:39Z"
        }
      ]
    },
    {
      "number": 810,
      "id": "MDU6SXNzdWU4NzM0Mzg2NDE=",
      "title": "S4.2.7, S4.2.8 Full Checksum Coverage - Names of the Properties do not seem intutive",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/810",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Why is the name not rather something like perMsgChecksumFullSend?",
      "createdAt": "2021-04-30T22:33:52Z",
      "updatedAt": "2021-06-11T16:12:21Z",
      "closedAt": "2021-06-11T16:12:21Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Happy with a change if making this more consistent.",
          "createdAt": "2021-05-10T13:17:18Z",
          "updatedAt": "2021-05-10T13:17:18Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are some related changes in  #839",
          "createdAt": "2021-05-19T15:36:52Z",
          "updatedAt": "2021-05-19T15:36:52Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom :  Did the merged PR 839 happen to address this? - If not please make a PR.",
          "createdAt": "2021-05-26T11:48:24Z",
          "updatedAt": "2021-05-26T11:48:24Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair PR 839 updated the name, but still found it confusing so made a PR.",
          "createdAt": "2021-06-11T12:32:34Z",
          "updatedAt": "2021-06-11T12:32:34Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See review.",
          "createdAt": "2021-06-11T12:50:58Z",
          "updatedAt": "2021-06-11T12:50:58Z"
        }
      ]
    },
    {
      "number": 811,
      "id": "MDU6SXNzdWU4NzM0NDA2OTM=",
      "title": "S4.2.11. Interface Instance or Type - text clarification needed",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/811",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I can not parse the \"to all remote systems\" part of the following sentence.\r\n\r\n> An implementation should provide all types that are supported on the local system to all remote systems, to allow applications to be written generically.",
      "createdAt": "2021-04-30T22:39:38Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so let's remove it.",
          "createdAt": "2021-07-08T10:01:37Z",
          "updatedAt": "2021-07-08T10:01:37Z"
        }
      ]
    },
    {
      "number": 812,
      "id": "MDU6SXNzdWU4NzM0NDM3MTg=",
      "title": "S4.2.14. Multipath Transport - why different?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/812",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "I know we have discussed Multipath Transport many times, but when reading is seems strange when you get to Multipath Transport and here there is no option to \"Require\" this property, only to \"Prefer\" it. We should at least say why. It is perhaps intuitive that you do not need to distinguish between Avoid and Prohibit, but not why Require would not be useful.",
      "createdAt": "2021-04-30T22:49:01Z",
      "updatedAt": "2021-07-08T10:46:11Z",
      "closedAt": "2021-07-08T10:46:11Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a sentence after this to explain why \"require\" wouldn't make sense:\r\n\r\n```\r\nEnumeration values other than \"Disabled\" are interpreted as a preference for choosing protocols that can make use of multiple paths. \r\n```",
          "createdAt": "2021-05-07T16:53:12Z",
          "updatedAt": "2021-05-07T16:53:12Z"
        }
      ]
    },
    {
      "number": 813,
      "id": "MDU6SXNzdWU4NzM0NDkyNTQ=",
      "title": " 6. Managing Connections - overlapping bullets",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/813",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I do not understand the relationship between bullets four and five. They seem to overlap?",
      "createdAt": "2021-04-30T23:05:10Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom : Anna, is this resolved by this PR: Re-group managing properties & protocol instances #863?",
          "createdAt": "2021-07-02T07:24:40Z",
          "updatedAt": "2021-07-02T07:24:40Z"
        }
      ]
    },
    {
      "number": 814,
      "id": "MDU6SXNzdWU4NzM0NDk5NDA=",
      "title": "S7.1.3.3. Ordered - Default seems to point to wrong Selection Property",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/814",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-30T23:07:11Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": []
    },
    {
      "number": 815,
      "id": "MDU6SXNzdWU4NzM0NjEyNzA=",
      "title": "S7.3.2.1. - send replies and map responses to their requests",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/815",
      "state": "OPEN",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "The text below is a bit confusing as there are no details about how to to send replies and map responses to their requests in Section 7.1.1. This can be easily fixed by clarifying what Section 7.1.1 provides details on. But I was also wondering if there should be some more details on how to send replies and map responses to their requests somewhere?\r\n\r\n> The messageContext is provided to enable retrieving metadata about the message and referring to the message, e.g., to send replies and map responses to their requests. See Section 7.1.1 for details.\r\n\r\n",
      "createdAt": "2021-04-30T23:29:48Z",
      "updatedAt": "2021-07-08T11:49:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note: this will be in \u00a79.3.2.1. after #869 merge.",
          "createdAt": "2021-07-08T11:49:51Z",
          "updatedAt": "2021-07-08T11:49:51Z"
        }
      ]
    },
    {
      "number": 816,
      "id": "MDU6SXNzdWU4NzM0NjI0NjI=",
      "title": "S7.3.2.2. ReceivedPartial Example",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/816",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I assume the example can only happen if preserveOrder is not required? As Require is the default for preserveOrder this should be made clear in the example.",
      "createdAt": "2021-04-30T23:33:35Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": []
    },
    {
      "number": 817,
      "id": "MDU6SXNzdWU4NzM0NjM2ODU=",
      "title": "S7.3.3.1. UDP(-Lite)-specific Property: ECN - Motivation",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/817",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I think this protocol specific Property is only included because it comes from RFC8923? Should be made clear in the text.",
      "createdAt": "2021-04-30T23:37:38Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "closedAt": "2021-07-08T11:26:08Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes.\r\nJust for clarification: RFC 8923 takes this from RFC 8304, which takes it from RFC 8085.",
          "createdAt": "2021-06-11T11:07:57Z",
          "updatedAt": "2021-06-11T11:07:57Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about something like: \" [RFC8293] following the guidance in [RFC8085] \"?",
          "createdAt": "2021-06-11T12:07:44Z",
          "updatedAt": "2021-06-11T12:07:44Z"
        }
      ]
    },
    {
      "number": 818,
      "id": "MDU6SXNzdWU4NzM0NjUzOTE=",
      "title": "8. Connection Termination - Introduction",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/818",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "This section would benefit from some introductory sentences on the different ways to terminate a connection, i.e. local and remote actions and Connection errors.",
      "createdAt": "2021-04-30T23:43:25Z",
      "updatedAt": "2021-06-11T16:22:20Z",
      "closedAt": "2021-06-11T16:22:20Z",
      "comments": []
    },
    {
      "number": 819,
      "id": "MDU6SXNzdWU4NzM0NjczMzQ=",
      "title": "EstablishementError or InitiateError? Both names are used.",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/819",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-30T23:50:20Z",
      "updatedAt": "2021-07-08T11:26:32Z",
      "closedAt": "2021-07-08T11:26:32Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EstablishmentError. Fixed in an upcoming PR.",
          "createdAt": "2021-07-08T10:28:27Z",
          "updatedAt": "2021-07-08T10:28:41Z"
        }
      ]
    },
    {
      "number": 820,
      "id": "MDU6SXNzdWU4NzM0NjkzMjQ=",
      "title": "Convenience Functions - options rather than requirements",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/820",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "The appendix text about convenience functions talks about \"implementations should\" provide various things. This reads strangely to me. I think these are not requirements and the text should be more in the form of it can be useful for implementations to provide various things.",
      "createdAt": "2021-04-30T23:58:14Z",
      "updatedAt": "2021-07-08T11:26:32Z",
      "closedAt": "2021-07-08T11:26:32Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about: \" implementations can provide special actions for adding each preference level i.e, TransportProperties.Set(some_property, avoid) would be equivalent to TransportProperties.Avoid(some_property):...\"",
          "createdAt": "2021-06-11T13:03:37Z",
          "updatedAt": "2021-06-11T13:03:37Z"
        }
      ]
    },
    {
      "number": 821,
      "id": "MDU6SXNzdWU4NzM0NzA0MjE=",
      "title": "B.2.3. unreliable-datagram profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/821",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API"
      ],
      "body": "Why are the settings for reliability, preserveOrder, congestionControl Ignore rather than Avoid? The current profile will match SCTP equally well as UDP.",
      "createdAt": "2021-05-01T00:01:42Z",
      "updatedAt": "2021-06-18T09:26:24Z",
      "closedAt": "2021-06-18T09:26:24Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To me, there are multiple ways a DG service cabn be used. I think there are at least two distinct cases here:\r\n* A datagram usage that WANTS full control, e.g. because something like RTP is layered above that handles these things, and any lower layer additions might interfere with these mechanisms.\r\n* A datagram usage that PREFS no hinderance, but does not mind how these are handled as long as the packets get through - i.e. connects.\r\n",
          "createdAt": "2021-05-13T10:19:50Z",
          "updatedAt": "2021-05-13T10:19:50Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm OK with:\r\nreliability | avoid\r\npreserveOrder | avoid\r\nCan't this be ignore?:\r\ncongestionControl |  Ignore\r\n\r\n\r\n",
          "createdAt": "2021-06-11T13:27:35Z",
          "updatedAt": "2021-06-11T13:27:35Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged",
          "createdAt": "2021-06-18T09:26:24Z",
          "updatedAt": "2021-06-18T09:26:24Z"
        }
      ]
    },
    {
      "number": 822,
      "id": "MDU6SXNzdWU4NzM0NzMwNTc=",
      "title": "Minset recieve data - mapping seems strange",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/822",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "> Receive data (with no message delimiting): \"Received\" Event (Section 7.3.2.1). See Section 7.1.2 for handling Message framing\r\nin situations where the Protocol Stack only provides a byte-stream transport.\r\n\r\nWhy is the part about Message framing here where we talk about receiving a byte stream rather than in the Receive message mapping?",
      "createdAt": "2021-05-01T00:08:38Z",
      "updatedAt": "2021-05-07T15:26:22Z",
      "closedAt": "2021-05-07T15:26:22Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree. PR #824 removes this sentence. The text talking about Receive message mapping already mentions Message Framers and points to Section 7.1.2.",
          "createdAt": "2021-05-05T13:03:21Z",
          "updatedAt": "2021-05-05T13:03:21Z"
        }
      ]
    },
    {
      "number": 823,
      "id": "MDU6SXNzdWU4NzM0NzQ0NzA=",
      "title": "Minor editorial nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/823",
      "state": "CLOSED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "abrunstrom"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Also spotted some further small nits while reviewing the document, will create a pull request for those.",
      "createdAt": "2021-05-01T00:12:42Z",
      "updatedAt": "2021-05-07T15:26:51Z",
      "closedAt": "2021-05-07T15:26:51Z",
      "comments": []
    },
    {
      "number": 835,
      "id": "MDU6SXNzdWU4OTQyNTE5OTE=",
      "title": "Capacity profile discussion in 4.1.3 doesn't match capacity profile in the API draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/835",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "The Capacity Profile in the API draft (now) lists these possible choices: Default, Scavenger, Low Latency/Interactive, Low Latency/Non-Interactive, Constant-Rate Streaming and Capacity-Seeking.\r\n\r\nThe text in section 4.1.3 only discusses Scavenger, Low Latency/Interactive, and Constant-Rate Streaming.\r\n",
      "createdAt": "2021-05-18T10:57:38Z",
      "updatedAt": "2021-06-18T09:25:52Z",
      "closedAt": "2021-06-18T09:25:52Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aha - I could offer to align the Capacity Profile classes?",
          "createdAt": "2021-05-18T13:05:12Z",
          "updatedAt": "2021-05-18T13:05:12Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See a PR to align Capacity profile with API #858 ",
          "createdAt": "2021-06-14T09:31:09Z",
          "updatedAt": "2021-06-14T09:31:09Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved",
          "createdAt": "2021-06-18T09:25:52Z",
          "updatedAt": "2021-06-18T09:25:52Z"
        }
      ]
    },
    {
      "number": 842,
      "id": "MDU6SXNzdWU5MDQwNDgzMTQ=",
      "title": "How does the application express preference for derived endpoints?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/842",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "In the impl draft, I'm supposed to build a tree based on, in order\r\n\r\n(1) \"path\": AFAICT this means \"interface\". The -api draft provides in interface preference framework in 4.2.11. (BTW if it really means interface maybe we should say 'interface').\r\n\r\n(2) Protocol: almost all of 4.2 in -api explains how to express this. (with an assist in -impl 4.1.3 explaining how to handle PREFER vs. AVOID)\r\n\r\n(3) \"derived endpoint\" I gather this is basically multiple addresses coming back from remote endpoint resolution. But where is the construct in -api that allows applications to express a preference here?",
      "createdAt": "2021-05-27T18:07:57Z",
      "updatedAt": "2021-06-11T17:21:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 843,
      "id": "MDU6SXNzdWU5MTg2NjU3MTc=",
      "title": "Where are events sent?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/843",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "In the interface draft, Section 1.1:\r\n```\r\n*  An Object sends an Event:\r\n         Object -> Event<>\r\n```\r\nWhere is the event sent? Perhaps `An Object generates an Event that needs to be processed by the application`?",
      "createdAt": "2021-06-11T12:08:12Z",
      "updatedAt": "2021-07-08T11:26:32Z",
      "closedAt": "2021-07-08T11:26:32Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: add \"to the application\"  (but double check, related to framers)",
          "createdAt": "2021-06-11T16:43:05Z",
          "updatedAt": "2021-06-11T16:43:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could alternatively say the same another way around: \"Applications can use these events...\" (i.e. avoid saying *only* applications do this).",
          "createdAt": "2021-06-11T16:45:24Z",
          "updatedAt": "2021-06-11T16:45:24Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "Section 6 in impl-draft has the parts where the framer objects receive events. There is no terminology section in implementation, so not sure if the terminology section in API should cover it as well. ",
          "createdAt": "2021-06-11T16:49:32Z",
          "updatedAt": "2021-06-11T16:49:32Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already say this in the intro text to this section, but I can tweak the structure and add some additional text to make this more clear.",
          "createdAt": "2021-07-08T10:35:03Z",
          "updatedAt": "2021-07-08T10:35:03Z"
        }
      ]
    },
    {
      "number": 844,
      "id": "MDU6SXNzdWU5MTg2NzAzOTc=",
      "title": "Number or symbols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/844",
      "state": "OPEN",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API"
      ],
      "body": "In the interface draft, section 1.1:\r\n```\r\n   *  Integer: Instances take positive or negative numeric integer\r\n      values, or sometimes special non-numeric (symbolic) values.\r\n   *  Numeric: Instances take positive or negative numeric values, or\r\n      sometimes special non-numeric (symbolic) values.\r\n```\r\nDo we need to conflate numeric types and enumerations, or can numbers be numbers?",
      "createdAt": "2021-06-11T12:12:47Z",
      "updatedAt": "2021-06-11T16:48:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From interim: add a clarification on what this is about, why it (symbolic values) is there.",
          "createdAt": "2021-06-11T16:48:05Z",
          "updatedAt": "2021-06-11T16:48:05Z"
        }
      ]
    },
    {
      "number": 846,
      "id": "MDU6SXNzdWU5MTg2ODgzMTk=",
      "title": "unified interface to datagram and connection-oriented transports",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/846",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Interface, Section 2, \"A unified interface to datagram and connection-oriented transports, allowing use of a common API for connection-establishment and closing\". Should this be \"\u2026to datagram and stream-oriented transports\"?\r\n\r\nAt what point do we explain that `Connection` and `Preconnection` are also used for connectionless protocols? This change would finesse the question here, leaving it for Section 3, or we can restructure the draft to clarify earlier.\r\n",
      "createdAt": "2021-06-11T12:29:20Z",
      "updatedAt": "2021-07-08T13:50:23Z",
      "closedAt": "2021-07-08T13:50:23Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes to (1): Datagram protocols can be connection-oriented or not; however the point here seems to be either:\r\n/interface to datagram and stream-oriented transports/ or\r\n/interface to both connection-less and connection-oriented transports/\r\n... I'd favour the first, it's clear enough and doesn't use terms that we later re-use.\r\n\r\nAlso to (2): I think we could insert a specific sentence after: \" A Connection represents an instance of a transport Protocol Stack on which data can be sent to and/or received from a Remote Endpoint (i.e., depending on the kind of transport, connections can be bi-directional or unidirectional). \" \r\nThat explicitly says something like:\r\n\"This connections are presently consistently to the application, irrespective of whether the underlying transport is connection-less and connection-oriented.\"\r\n",
          "createdAt": "2021-06-11T12:59:39Z",
          "updatedAt": "2021-06-11T12:59:39Z"
        }
      ]
    },
    {
      "number": 849,
      "id": "MDU6SXNzdWU5MTg3NTc5MDM=",
      "title": "API summary does more than summarise",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/849",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Section 3.2 of interface feels out of place as a subsection of \"API Summary\" - should it be part of Section 4.2 instead? Or a new top-level section between the current Sections 3 and 4?",
      "createdAt": "2021-06-11T13:32:14Z",
      "updatedAt": "2021-07-08T12:00:44Z",
      "closedAt": "2021-07-08T12:00:44Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The latter (new top-level section ) may be easiest.",
          "createdAt": "2021-06-11T13:41:00Z",
          "updatedAt": "2021-06-11T13:41:00Z"
        }
      ]
    },
    {
      "number": 850,
      "id": "MDU6SXNzdWU5MTg3NjA4NDM=",
      "title": "Can we give the tables names in Appendix B?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/850",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "They are currently just called \"Table\"",
      "createdAt": "2021-06-11T13:34:46Z",
      "updatedAt": "2021-07-08T11:26:32Z",
      "closedAt": "2021-07-08T11:26:32Z",
      "comments": []
    },
    {
      "number": 851,
      "id": "MDU6SXNzdWU5MTg3Njc3MzU=",
      "title": "Scope of the Interface Definition",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/851",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Section 3.3 of interface doesn't fit in an \"API summary\" \u2013\u00a0it feels like it should be a top-level section.",
      "createdAt": "2021-06-11T13:40:50Z",
      "updatedAt": "2021-07-08T12:00:44Z",
      "closedAt": "2021-07-08T12:00:44Z",
      "comments": []
    },
    {
      "number": 852,
      "id": "MDU6SXNzdWU5MTg3OTUzMTI=",
      "title": "Using Multicast Endpoints",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/852",
      "state": "OPEN",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "GrumpyOldTroll"
      ],
      "labels": [
        "API"
      ],
      "body": "The interface draft, section 4.1.1, talks about multicast endpoints, but doesn't mention whether such endpoints can be used with Rendezvous(). ",
      "createdAt": "2021-06-11T14:04:17Z",
      "updatedAt": "2021-07-08T22:18:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is your proposal?",
          "createdAt": "2021-06-11T14:19:46Z",
          "updatedAt": "2021-06-11T14:19:46Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't have thought this is unambiguous, so I'm not quite sure what text is needed that would clarify this.\r\n\r\nTo me at first blush this seems covered by the Rendezvous description in 5.3, between what Rendezvous does in the 4th paragraph:\r\n\r\n\"If there are multiple Local Endpoints or Remote Endpoints configured, then initiating a Rendezvous() action will systematically probe the reachability of those endpoint candidates following an approach such as that used in Interactive Connectivity Establishment (ICE) [RFC5245].\"\r\n\r\nAnd what happens if it doesn't work in the final paragraph:\r\n\r\n\"An EstablishmentError occurs either when the Properties and Security Parameters of the Preconnection cannot be fulfilled for rendezvous or cannot be reconciled with the Local and/or Remote Endpoints, when the Local Endpoint or Remote Endpoint cannot be resolved, when no transport-layer connection can be established to the Remote Endpoint, or when the application is prohibited from rendezvous by policy:\"\r\n\r\nAbsent an ICE-like mechanism that works with multicast (is there such a thing?) I don't see how someone would expect anything other than this error condition if they did this.\r\n\r\nWas there a context to this question?  It wouldn't have occurred to me there was another possible answer that needed an explanation to avoid confusion on this point, but maybe there's a case I haven't considered?",
          "createdAt": "2021-06-12T00:49:55Z",
          "updatedAt": "2021-06-12T00:51:25Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more, I think there's an ASM vs. SSM question here. \r\n\r\nFor SSM, the model of receivers call `Listen()` and sender calls `Initiate()` makes a lot of sense, and matches the asymmetry of the underlying data flows.\r\n\r\nFor ASM, things are more symmetric, and `Rendezvous()` might be the right abstraction.",
          "createdAt": "2021-06-14T11:14:33Z",
          "updatedAt": "2021-06-14T11:14:33Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm finding it hard to think we need to combine \"rendezvous\" and \"multicast\". ",
          "createdAt": "2021-06-14T12:12:58Z",
          "updatedAt": "2021-06-14T12:12:58Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "rendezvous is for peer-to-peer connections, and ASM multicast is peer-to-peer",
          "createdAt": "2021-06-14T12:21:30Z",
          "updatedAt": "2021-06-14T12:21:30Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unsure about this... ASM can also be used unidirectionally also, it's just not source-specific. I had other things in mind with Rendezvous. Anyway, others may think differently.",
          "createdAt": "2021-06-14T13:00:18Z",
          "updatedAt": "2021-06-14T13:00:18Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ASM is deprecated interdomain ([RFC 8815](https://www.rfc-editor.org/rfc/rfc8815.html)).  Within a domain I don't think it needs a rendezvous?  Or at least I don't know of anyone trying to use it that way.\r\n\r\nI take @csperkins point that it's possible someone could want to build something for a peer to peer multicast use case. If they do so, I'm guessing this would include some kind of ICE-like underlying rendezvous protocol that can support multicast, and at that point a rendezvous operation might reasonably start working.\r\n\r\nTo me this looks like a function of whether there's an ICE-like protocol that can perform a rendezvous for the endpoints, so it's correct to avoid calling out non-support of rendezvous inside the multicast endpoint description so that it doesn't need to be specifically updated if the situation changes, though in practice today it will fail due to being unsupported if someone tries it with today's rendezvous protocol implementations.  (At least, I assume so?  Haven't tried it...)",
          "createdAt": "2021-06-15T16:30:38Z",
          "updatedAt": "2021-06-15T16:30:38Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I read `Rendezvous()` as setting up a peer-to-peer connection, not as necessarily running a specific rendezvous protocol. For unicast, it needs something like ICE, I agree. For ASM, I was assuming a `Rendezvous()` would just turn into a multicast group that I could send to/receive from with no additional signalling, whereas SSM multicast needs explicit send-to-group and receive-from-group calls. Do we have different models for how this works?",
          "createdAt": "2021-06-15T22:42:33Z",
          "updatedAt": "2021-06-15T22:42:33Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand the claim that SSM would require explicit send-to-group or receive-from-group calls.  To me if you've made a local endpoint with a group address, the connection is non-sending, and if you made a remote endpoint with a group address, the connection is non-receiving.\r\n\r\nWith that said: a search for \"multicast stun\" did find what seems like a non-IETF STUN usage proposal that does something with multicast, so maybe somebody's using it?  I have no idea: https://ieeexplore.ieee.org/document/7275794\r\n\r\nAnyway, my starting assumption was that if you make a multicast group endpoint and give it a \"withStunServer\" and use it in a preconnection that you Rendezvous(), you'll get an error unless the stack and the server thinks it knows what to do with that, in which case sending or receiving will just work if there's a remote app that did the opposite.\r\n\r\nIn the (unlikely?) case the stack does support it, like with unicast, I guess I'd assume if you did a sending preconnection (remote group address), you'd want to do the withStunServer on the remote endpoint, and if you did a receiving preconnection (local group address), you'd do the withStunServer on the local endpoint.\r\n\r\nI guess also I'd assume that if you'd like bidirectional ASM, you'll want to make 2 separate connections, one for sending (with the group address as the remote endpoint) and the other for receiving (with the group address as the local endpoint), and on the receive one you won't provide a remote address.\r\n\r\nAFAICT all the above is sort of implicit in what's already written in the spec, and I'm not sure it needs spelling out if that sort of usage would work in a stack that cared to implement it.\r\n\r\nBut I do worry I'm missing something, and it could be annoying to find out in 5 years that the API structurally doesn't work with any kind of Rendezvous because it was specified wrong.  And on that score I'm worried that I might not be fully understanding what happens in a Rendezvous.  And when I tried to follow the pseudocode example in section 3.1.3, I noticed there's a complicated bit that's just comments as an exercise for the reader, which perhaps contains some assumptions I haven't really understood:\r\n\r\n~~~\r\n// ...Send the ResolvedLocal list to peer via signalling channel\r\n// ...Receive a list of RemoteCandidates from peer via signalling channel\r\n~~~\r\n\r\nAnyway, does anyone know what the STUN/TURN servers actually do here?  Taking a step back from what I'd expect out of an API that did support it, I'd think defining a new usage for STUN is probably out of scope for this doc, if it's not written up and deployed somewhere already.",
          "createdAt": "2021-06-16T03:56:06Z",
          "updatedAt": "2021-06-16T03:56:06Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For SSM, the model of `Initiate()` to create a send-only connection and `Listen()` to create a receive-only connection makes sense and matches the semantic of the multicast group. The sender creates the group, and everyone else listens in.\r\n\r\nFor ASM, the underlying group is peer-to-peer and members can both send and receive. It's symmetric. To me, that doesn't fit the asymmetric model of `Initiate()` and `Listen()`, and seems a better conceptual fit for a `Rendezvous()` semantic. \r\n\r\nA `Rendezvous()` will typically devolve to STUN/ICE for unicast, but I don't see that it has to use STUN, and I don't see that it would use STUN for multicast. The key difference is that `Rendezvous()` is peer-to-peer while `Initiate()`/`Listen()` are client-server, and I view ASM as peer-to-peer and SSM as closer to client-server.\r\n\r\n",
          "createdAt": "2021-06-24T11:24:04Z",
          "updatedAt": "2021-06-24T11:24:04Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok, thanks for explaining.  I guess the idea here is to have bidirectional ASM represented as a single connection object instead of 2 separate ones?\r\n\r\nI guess that's a way to consider it, but I think this conflicts with the local/remote endpoint concept, more than it conflicts with Initiate/Listen, with the problem being that you both receive with the group address and send to the group address.\r\n\r\nIn general, for a UDP connection it's possible to just Initiate, followed by both Send and Receive, correct?  So the trick here if we need a bidirectional Connection for multicast (whether ASM or SSM) would maybe be to do something like \"preconnection.BidirMulticastEndpoint(endpoint).WithASM()\" (with default as SSM-only, pulled from the addresses in the remote endpoint and using ASM only if WithASM was called), and then call Initiate, with both Receive and Send available.\r\n\r\nThat would be doable, either now or as a later (or optional) extension if it seems useful enough.  But either way, Initiate() seems to me like a better fit a sending or bidirectional UDP than Rendezvous().",
          "createdAt": "2021-06-28T05:11:54Z",
          "updatedAt": "2021-06-28T05:11:54Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Ah, ok, thanks for explaining. I guess the idea here is to have bidirectional ASM represented as a single connection object instead of 2 separate ones?\r\n\r\nYes.\r\n\r\n> In general, for a UDP connection it's possible to just Initiate, followed by both Send and Receive, correct?\r\n\r\nI guess so, although UDP also doesn't fit well with the model - the actual semantics depend on the upper layer protocol implemented over UDP, and plain UDP isn't useful except as a substrate. For QUIC you want Initiate/Listen, but I'd argue that Rendezvous is the right model for unicast RTP since it's naturally peer-to-peer and wants NAT traversal. \r\n\r\n`Initiate()` for bidirectional UDP would work, but I'm not sure I agree that it's right.",
          "createdAt": "2021-06-28T19:38:30Z",
          "updatedAt": "2021-06-28T19:38:30Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, after one more pass at reading Rendezvous text in the draft I'm starting to get it.  That's an interesting point about generalized peer to peer connections, I don't think I had grasped that difference between this API and the way sockets are used.\r\n\r\nBacking up a bit further, I think I'm also finally understanding something I missed in an earlier comment from more than a year ago when somebody tried to make the case that Listen() should be the call the sender side of a multicast connection makes, and Initiate() should be the receiver side.  That position makes more sense to me now that I'm finally realizing this API is trying to normalize the concept of clients vs servers vs peers at the app layer, rather than describing socket-like things to do.\r\n\r\nI think maybe there is a wider issue here that this naming scheme is fundamentally confusing when you're looking at a non-TCP-like app.  Maybe \"Listen()\" should be renamed to \"ServerInitiate()\", \"Initiate()\" should be renamed to \"ClientInitiate()\", and \"Rendezvous()\" should be renamed to \"PeerInitiate()\"?\r\n\r\nUnder that naming scheme it would make complete sense for a multicast sender doing a ServerInitiate to get an immediate unidirectional sending Connection object, whereas it makes no sense at all to get that behavior out of a call named \"Listen\".\r\n\r\nI guess this probably needs a list discussion.  Now that you've got me understanding what the viewpoint was that drove these comments, I think the right thing to do is probably to fix all 3 drafts to make it explicit that the these APIs are designed to support 2 different kinds of connections (Client-Server or Peer-Peer) with 3 different roles, and to start the connection with a call that explicitly declares the role this connection object will be playing, and to name the initiation calls to match that.\r\n\r\nIf that ends up matching with the wg consensus, then I agree the multicast section needs to be refactored to make ServerInitiate() be similar to the action from today's Initiate(), and ClientInitiate() to be the action from today's Listen(), and that in this case a PeerInitiate() would be good to specify also, as well as adding a call to add a GroupEndpoint (with an ASM/SSM selector) that can be used to support bidirectional multicast traffic.  To me this sounds like a design improvement to the API, and thus the right thing to do.\r\n\r\nIf the group vetoes that direction and chooses to stick with the current naming scheme that describes things that map onto socket behaviors, then I think it's better to stick with the current approach.\r\n\r\nAlso, the claim that UDP is only useful as a substrate seems at odds with the text in the current draft.  The explanation of what a connection is explicitly mentions plain UDP as one possibility:\r\nhttps://ietf-tapswg.github.io/api-drafts/draft-ietf-taps-arch.html#section-4.1.2\r\n\r\n\"Connection: A Connection object represents one or more active transport protocol instances that can send and/or receive Messages between local and remote systems. It holds state pertaining to the underlying transport protocol instances and any ongoing data transfers. This represents, for example, an active Connection in a connection-oriented protocol such as TCP, or a fully-specified 5-tuple for a connectionless protocol such as UDP.\"\r\n\r\nThis reinforces my suspicion that this issue is not specifically about multicast, but rather about the confusing names of the connection initiation operations, where multicast is one example that highlights the problem well.\r\n\r\nI'm glad you raised the issue, I think I'm finally starting to understand what you mean and I think there is a very good point in here that rates to make this API better :)  But we probably need to take this to the list, I don't think this should be taken as a minor \"fix up the multicast section\" point, if I'm understanding it correctly.",
          "createdAt": "2021-06-29T19:37:05Z",
          "updatedAt": "2021-06-29T19:38:53Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are several things in this discussion that I don't understand (just because I don't know enough about multicast), so take my answer with a grain of salt. This said, I believe I understand that your proposal of ServerInitiate() etc. can make sense and be \"cleaner\" (more general). I do understand that, as you say, it makes no sense at all to obtain an immediate unidirectional sending Connection object from a call named \"Listen\".\r\n\r\nHowever, for unicast client-server communication, \"ServerInitiate()\" is an odd term, IMO. I think it's common for people to think of an \"active\" open and a \"passive\" open. The key distinction here, at the interface level, is that \"active\" sends something towards a destination - you give it a destination address, but for \"passive\", you don't. So then, \"ServerInitiate\" sounds like it might just be \"listen\", yet it does something active, i.e. it MIGHT signal something to a destination (though, when used as a unicast server \"listen\", it won't be given a destination address, so that couldn't happen... but why is it not called \"Listen\", then?). \"Rendezvous\" is of course more symmetric, but the term makes it explicit that this is neither a \"normal\" active open nor a passive open. Terminology like \"ServerInitiate\" is just strangely ambiguous in a unicast case, IMO.\r\n\r\nTechnically, if I want to rename API\u00a0primitives for such usage, I can easily solve this by introducing new Actions like ServerInitiate etc., which do nothing but hand over the calls (i.e., ServerInitiate calls Listen, etc.). Wouldn't it be a way out to suggest this as a solution for implementers?\r\n\r\nIf this is broader than multicast, this suggestion can be placed outside the multicast section. E.g.: make an appendix called \"Alternative Action and Event Names for Connection Establishment\", and refer to it from mulitple places - in the \"normal\" establishment text, there could be statements like this: \"The terminology here (Initiate(), Listen() etc.) is based on a unicast model. There are communication models where these terms are misleading: for example, (...something...). It is therefore recommended to additionally offer the same Actions with a different set of terms for non-unicast communication. Appendix XX introduces these Action names and their mapping.\"\r\n\r\nWould this be a viable approach?",
          "createdAt": "2021-07-05T09:37:07Z",
          "updatedAt": "2021-07-05T09:37:07Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess in this model I would think ServerInitiate() calls Initiate() if there's a multicast remote endpoint, but calls Listen() if there's a unicast local endpoint and no multicast remote endpoint.  I guess I doubt it's worth it if it's done as an appendix instead of making the concepts of Server and Client and Peer more central in the API.\r\n\r\nMaybe I should look for a smaller scope that's more multicast-specific.  I guess another alternative would be to add a few things to the Preconnection just for Rendezvous, like \"AddBidirectionalGroup\" that takes a remote endpoint with a group address, then Rendezvous would make Send use the group address.\r\n\r\nI guess another reasonable alternative would be to just say \"Rendezvous is not supported for multicast endpoints.  Bidirectional communication should be implemented with separate connections for sending and receiving.\"",
          "createdAt": "2021-07-05T20:06:27Z",
          "updatedAt": "2021-07-05T20:06:27Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, would \"Rendezvous is not supported for multicast endpoint\" take all this complexity away? Then this would sound like a good way to go, for me - based on your earlier argument that interdomain ASM is deprecated.  But ... I'm stepping on very thin ice here. Better for others to chime in.",
          "createdAt": "2021-07-05T21:53:34Z",
          "updatedAt": "2021-07-05T21:53:34Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, it wouldn't change the fact that the API does not highlight the different kinds of roles of an app in a connection (like server or client), but rather refers to socket behaviors such as listening, and so I think the API is not as effective as it could be.  It also would add a little bit of complexity for NORM implementors if we ever get any, because the NACKs can be sent between peers for data recovery according to the spec IIRC, and for a use case like this they would be obliged to use multiple unidirectional Connection objects instead of a single bidirectional object.  There could be other similar use cases where between-peer communication within the domain (most likely on the same LAN) could be helpful.\r\n\r\nHowever, that's kind of a corner case that doesn't hurt all that badly, and this change would be much smaller for the current API.\r\n\r\nI guess I'll add that as a PR and call it a fix for this issue, as there wasn't much traction on the idea of normalizing the app mode behavior.  Thanks for the comments.",
          "createdAt": "2021-07-08T03:36:23Z",
          "updatedAt": "2021-07-08T03:36:23Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You say \"there wasn't much traction on the idea\" but it was just me. Maybe people haven't been following this conversation - it may still be worth bringing the general API change idea to the list, as you first suggested.",
          "createdAt": "2021-07-08T06:55:12Z",
          "updatedAt": "2021-07-08T06:55:12Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This doesn't seem to be converging on something that most people  really  need - so do you think we need to make a move to do something small in a PR that avoids this becoming a rat-hole. ",
          "createdAt": "2021-07-08T16:05:06Z",
          "updatedAt": "2021-07-08T16:05:06Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I submitted a PR (originally misnamed for solving 872 instead of 852):\r\nhttps://github.com/ietf-tapswg/api-drafts/pull/871\r\n\r\nI do still think it's a fine idea to make connections explicitly play a Server, Client, or Peer role instead of inferring them from the socket activities that are named, and that the raising of this issue helped me to understand that approach to thinking about the possibility of an API with such a structure.  However, to make such a change just to support this use would be the tail wagging the dog, I think.\r\n\r\nA separate change could be proposed under a separate issue (along with clarification that a Peer connection may or may not have to use an underlying rendezvous protocol, as opposed to calling it Rendezvous and leaving that explanation implicit).  I would support such a suggestion and offer to add support for the Peer usage in multicast if it got traction.  But I'm not going to push it myself if the others I polled offline don't see the utility, and I think we can live without the use case as a practical matter.\r\n\r\nAnd without such a change, I think offering to \"Rendezvous\" on a multicast connection (just meaning establishing 2-way peer to peer connectivity, without reference to an underlying rendezvous protocol that could support it across nats the way the ICE-based stuff does for unicast) would add unnecessary confusion if done without a broader and more explicit change to make the role-based (as opposed to activity-based) way of thinking about connections more central in the normal API usage.",
          "createdAt": "2021-07-08T22:08:35Z",
          "updatedAt": "2021-07-08T22:18:23Z"
        }
      ]
    },
    {
      "number": 854,
      "id": "MDU6SXNzdWU5MTg3OTg2NDY=",
      "title": "Endpoint aliases and protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/854",
      "state": "CLOSED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "britram"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Interface, section 4.1.2:\r\n```\r\n   In order to scope an alias to a specific transport protocol, an\r\n   Endpoint can specify a protocol identifier.  These identifiers MUST\r\n   only be set for aliases.\r\n\r\n   RemoteSpecifier.WithProtocol(QUIC)\r\n```\r\nWhy the limitation to aliases? Specifying a protocol might limit the utility of connection racing, so should perhaps be discouraged, but does it break anything to specify a protocol for a non-alias Endpoint?",
      "createdAt": "2021-06-11T14:07:17Z",
      "updatedAt": "2021-07-08T11:26:32Z",
      "closedAt": "2021-07-08T11:26:32Z",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: suggest to remove the second sentence.",
          "createdAt": "2021-06-11T16:57:51Z",
          "updatedAt": "2021-06-11T16:57:51Z"
        }
      ]
    },
    {
      "number": 859,
      "id": "MDU6SXNzdWU5MTg5NTg0MTk=",
      "title": "When are objects frozen?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/859",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Discussion at the 11 Jun 2021 Interim:\r\n\r\nThe content of any objects passed as part of NewPreconnection(), Initiate(), Listen(), or Rendezvous() is frozen at the moment of Initiate/Listen/Rendezvous.\r\n\r\nThus, objects sent to NewPreconnection (Endpoints and Properties) are mutable, and it might be possible (depending on the implementation) to change them in the preconnection by modifying the object directly. Applications should either\r\n(1) Instantiate the connection before modifying Endpoint or Property objects for another preconnection.\r\n(2) If there are open preconnections that will initiate further connections, create new instances of Properties and Endpoints to modify their attributes in a different preconnection.\r\n\r\nThere are other ways to do this. For example, NewPreconnection() could do a deep copy of the properties and endpoints, and therefore reusing or freeing the argument objects would always be safe. But this was not the sense of the group at the interim.\r\n\r\nWhile this issue is uncomfortably close to the \"implementation dependent\", not having fixed assumptions about this increasing the friction of switching platforms using TAPS, and would probably be the source of nasty bugs.",
      "createdAt": "2021-06-11T16:30:12Z",
      "updatedAt": "2021-07-08T10:46:49Z",
      "closedAt": "2021-07-08T10:46:49Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reference: (https://mailarchive.ietf.org/arch/msg/taps/ZHCc4sLCXb2984hwob_F5aiZXsY/)",
          "createdAt": "2021-06-11T16:31:40Z",
          "updatedAt": "2021-06-11T16:31:40Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Comment by @MaxF12 in the interim chat:\r\n\r\nAlso in section 2 in the impl draft it says \"Preconnection objects should be implemented as bundles of properties that an application can both read and write. Once a Preconnection has been used to create an outbound Connection or a Listener, the implementation should ensure that the copy of the properties held by the Connection or Listener is immutable.\" which I assume means that the properties the bundle is made of can also be overwritten",
          "createdAt": "2021-06-11T17:01:03Z",
          "updatedAt": "2021-06-11T17:01:03Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "to be clear, IMO the draft is quite clear about freezing at Initiate(), but it is not clear about NOT freezing at NewPreconnection().",
          "createdAt": "2021-06-11T17:01:05Z",
          "updatedAt": "2021-06-11T17:01:05Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At Interim, we heard that this might be fixed by emphasising in the preconception text  that everything is frozen (aka deep-copied) at Initiate.",
          "createdAt": "2021-06-11T17:01:44Z",
          "updatedAt": "2021-06-11T17:01:44Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will also point out that this sits somewhat uneasily with Sec 3.1 of taps-impl, where we should fail the preconnection immediately if nothing matches the desired properties. What if I change the desired properties after getting the preconnection?\r\n\r\nIt's not insurmountable, but it's conceptually not very clean.",
          "createdAt": "2021-06-11T22:26:45Z",
          "updatedAt": "2021-06-11T22:26:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke I think this is only because you assume that \"we should **fail the preconnection** immediately\".  Nowhere does it say that \"the preconnection\" should fail - it just says that trying to make meaningless changes should result in an error. This could be the function call that intends to make a change failing, not the object itself becoming unusable.\r\n\r\nOr am I misreading your concern?\r\n\r\nTo be clear, my view on this is:\r\n- create a preconnection: If you do it wrong, you get a failure and you don't get one. You can try again.\r\n- change something on a preconnection: if you do it wrong, the change fails, but the preconnection object doesn't \"fail\" or disappear, it's just unaffected.\r\n\r\nThat's probably not how you read the text in this section - what should change? Best to make a suggestion directly inside PR #860, I think.",
          "createdAt": "2021-06-16T08:42:18Z",
          "updatedAt": "2021-06-16T08:42:18Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would like to have the discussion about what the right thing to do here in the issue, and the wordsmithing in the PR.\r\n\r\nIt's not meaningless changes. It's adding constraints that reduce the pool of protocols to zero.\r\n\r\nNone of this is impossible to implement in code, but what you suggest is the following is quite inelegant:\r\n- App instantiates satisfiable transport properties\r\n- App instantiates a preconnection with that TP, success\r\n- App changes the transport properties -- so you are proposing that each preconn with a reference to the properties would check that they are still satisfiable; if yes, then accept the change; if not, ignore it?\r\n\r\nAlternatively, the initiate/listen command could fail due to the updated properties\r\nOr, the preconnection could fail when the properties become unsatisfiable\r\nOr, the transport properties object itself could fail, if it is aware of the protocol choices.\r\nOr, objects passed to the preconnection could be immutable.\r\n\r\n****************\r\n\r\nZooming out for a bit, I don't see the preconnection object as adding a ton of value as currently specified. Perhaps it's too late to rethink that. Anyway that discussion is too big for this issue.",
          "createdAt": "2021-06-16T18:33:43Z",
          "updatedAt": "2021-06-16T18:33:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, first, just to be clear, by suggesting to move this to the PR I didn't mean to be dismissive about your comment!  I just thought it's an easy fix - it seems not, my apologies!\r\n\r\nSo, let's keep discussing here. I still see things very differently. First, your bullet list begins with \"App instantiates satisfiable transport properties\".  The way I regard these properties is: they are atomary elements of an object. Attributes of a Preconnection object, in OO language terms. Members of a Preconnection record (or struct), in more old fashioned language terms. Not objects in their own right - and a Preconnection doesn't get a reference to them, it \"contains\" them (i.e., memory allocated for each).\r\n\r\nSo - the Preconnection's the thing that's instantiated, and the properties \"belong\" to it. Then, the statement from bullet 3: \"each preconn with a reference to the properties would check...\" - is wrong in my view of the world (I agree that this would otherwise be quite inelegant).\r\n\r\nSo here are my answers to the possible failures, in \"my\" context:\r\n> Alternatively, the initiate/listen command could fail due to the updated properties\r\nYes.\r\n\r\n>Or, the preconnection could fail when the properties become unsatisfiable\r\nNo: the preconnection per se doesn't fail, the call to create it may, and a call to make a change to one of its properties may.\r\n\r\n>Or, the transport properties object itself could fail, if it is aware of the protocol choices.\r\nA \"transport properties object\" doesn't exist from my point of view.\r\n\r\n>Or, objects passed to the preconnection could be immutable.\r\nBut where do we say that \"objects\" are passed to a preconnection?\r\n\r\nSo... either I'm totally wrong, or you're thinking of a very obscure language (you said C, which isn't SO obscure?), or the current draft is extremely ambiguous ... but then, about what?  If others agree with my view of the world, then there must be something very bad in the text that misled you. We should fix it!\r\n\r\nRegarding \"Zooming out\": why, what's the issue?  I don't personally think it matters very much if we define that changing things on a Preconnection can already fail or not, if that's what disturbs you - but we need to be able to hand over some input to the racing algorithm before trying to initiate or listen on a Connection. How else would you do it?  I can see no way around collecting the application's requirements / requests somewhere, in some sort of data structure, and handing that over.",
          "createdAt": "2021-06-16T19:32:04Z",
          "updatedAt": "2021-06-16T19:32:04Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hi, first, just to be clear, by suggesting to move this to the PR I didn't mean to be dismissive about your comment! I just thought it's an easy fix - it seems not, my apologies!\r\n\r\nNo worries!\r\n\r\n> So, let's keep discussing here. I still see things very differently. First, your bullet list begins with \"App instantiates satisfiable transport properties\". The way I regard these properties is: they are atomary elements of an object. Attributes of a Preconnection object, in OO language terms. Members of a Preconnection record (or struct), in more old fashioned language terms. Not objects in their own right - and a Preconnection doesn't get a reference to them, it \"contains\" them (i.e., memory allocated for each).\r\n\r\nI think that's a fine approach, but it is not what we discussed at the interim. Your proposal would make the properties \"immutable\" once the preconnection formed.\r\n\r\ntp := TransportProperties.new()\r\npc1 := Preconnection.new(tp)\r\ntp.SetProperty(foo, true)\r\npc2 := Preconnection.new(tp)\r\n\r\nDo pc1 and pc2 have the same properties?  At the interim, we said yes! You're arguing no. FWIW, I agree with you, but this is something we should work out. Gorry's PR, IIUC, is trying to capture the interim's consensus.\r\n\r\n> So... either I'm totally wrong, or you're thinking of a very obscure language (you said C, which isn't SO obscure?), or the current draft is extremely ambiguous ... but then, about what? If others agree with my view of the world, then there must be something very bad in the text that misled you. We should fix it!\r\n>\r\n\r\nI believe the text is ambiguous enough that we may not have actual consensus on how this is supposed to work. To some extent we can say it's \"implementation dependent\" but IMO this would be a bad place for apps to have to flex to different data models.\r\n \r\n> Regarding \"Zooming out\": why, what's the issue? I don't personally think it matters very much if we define that changing things on a Preconnection can already fail or not, if that's what disturbs you - but we need to be able to hand over some input to the racing algorithm before trying to initiate or listen on a Connection. How else would you do it? I can see no way around collecting the application's requirements / requests somewhere, in some sort of data structure, and handing that over.\r\n\r\nYour perception of what the preconnection is doing is not what the group told me at the interim. See also my \"preconnection confusion\" email.\r\n\r\nThe preconn takes localEndpoints, remoteEndpoints, transportProperties, and securityProperties.\r\n\r\nIt simply stores all of this stuff, except for checking that the properties are satisfiable. It does *not* build a candidate tree, does not resolve FQDNs, and definitely does not do any racing. Two things:\r\n1) I object to TAPS taking a bunch of data in the preconnection and just storing it well before it's needed. Just send it on Initiate()!\r\n2) The preconnection could be much more active, building the candidate tree so that it's ready for racing. At the maximum, it could begin name resolution.\r\n\r\nThis is getting long so maybe I should write an email.\r\nIt may be that everyone is on the same page but me and we just need to clarify, or perhaps there is no true consensus on these points. They are kind of subtle when you're reviewing the drafts, but when I tried to implement them I found these concepts to be quite vaguely written and inconvenient to code in a low-level language.\r\n\r\n",
          "createdAt": "2021-06-16T20:05:34Z",
          "updatedAt": "2021-06-16T20:05:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe we can narrow things down again. This is a core piece of what you wrote:\r\n>tp := TransportProperties.new()\r\n>pc1 := Preconnection.new(tp)\r\n>tp.SetProperty(foo, true)\r\n>pc2 := Preconnection.new(tp)\r\n>\r\n>Do pc1 and pc2 have the same properties? At the interim, we said yes! You're arguing no.\r\n\r\nAha! I get it now. I think I misunderstood things at the interim, then, and the deep copy should already apply when creating a Preconnection. Would that be better?  (I think we should hear more voices!)\r\n\r\nTowards the end of your answer above, you say:\r\n> It simply stores all of this stuff, except for checking that the properties are satisfiable. It does not build a candidate tree, does not resolve FQDNs, and definitely does not do any racing\r\n\r\n... and I agree. However, you suggest other possibilities towards the end (your two things).\r\n\r\nFirst, don't they contradict each other?  FWIW, I don't think it would be against the current spec if a TAPS implementation started doing things early when it a Preconnection is created... I agree, name resolution could be one of the things to do right away, why wait. But, doing this requires handing over information early. Anyway I don't think we should *guarantee* that a TAPS system does anything before Initiate() (in the active open case) is called... but making it possible requires handing over data early.\r\n\r\nHm. I have a feeling that I'm sowing seeds of confusion. Do I represent the group consensus, or have I been misunderstanding things? I'm not sure anymore. It would be better for others to chime in.",
          "createdAt": "2021-06-16T20:55:28Z",
          "updatedAt": "2021-06-16T20:55:28Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that we should from more voices. One quick point:\r\n>the deep copy should already apply when creating a Preconnection. Would that be better? \r\n\r\nConceptually, it's much cleaner. Unfortunately, it also means I'm doing a deepcopy twice: once from the object into the preconnection, and then again from the preconnection to the connection. Sounds expensive!\r\n\r\nWhich is why I'm gravitating to one of the two options. Either (1) build the candidate tree in the preconnection, so the connection doesn't need any of that stuff, or (2) don't store it needlessly in the preconn, to avoid a deep copy.\r\n\r\nAll this said, I am disinclined to blow up the whole conceptual model at this stage in the life of the doc, where Apple already has some deployed code.",
          "createdAt": "2021-06-16T21:04:28Z",
          "updatedAt": "2021-06-16T21:04:28Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A quick glance at Apple's NetworkFramework makes me believe they don't have the concept of the Preconnection at all, which is informative to me.",
          "createdAt": "2021-06-16T21:05:56Z",
          "updatedAt": "2021-06-16T21:05:56Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, things might be different to the way I thought, so....\r\n\r\nI didn't think it was ever wise to do:\r\n\r\ntp := TransportProperties.new()\r\npc1 := Preconnection.new(tp)\r\ntp.SetProperty(foo, true)\r\npc2 := Preconnection.new(tp)\r\nc1 := pc1.Initiate()\r\nc2 := pc2.Initiate()\r\n\r\nBut it did seem OK to do:\r\n\r\ntp := TransportProperties.new()\r\npc1 := Preconnection.new(tp)\r\nc1 := pc1.Initiate()\r\n\r\ntp.SetProperty(foo, true)\r\npc2 := Preconnection.new(tp)\r\nc2 := pc2.Initiate()\r\n\r\nI thought it was OK to add remote information to a preconnection, as a part of some out of band signalling. To do clever traversal stuff.\r\n\r\nGorry\r\n\r\n",
          "createdAt": "2021-06-17T07:59:54Z",
          "updatedAt": "2021-06-17T07:59:54Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we want to forbid the first and allow the second, then the answer would be to make pc1 do a deep copy of tp when created.\r\n\r\nThough doing two deep copies seems unnecessarily expensive.\r\n \r\n> Well, things might be different to the way I thought, so....\r\n> \r\n> I didn't think it was ever wise to do:\r\n> \r\n> tp := TransportProperties.new()\r\n> pc1 := Preconnection.new(tp)\r\n> tp.SetProperty(foo, true)\r\n> pc2 := Preconnection.new(tp)\r\n> c1 := pc1.Initiate()\r\n> c2 := pc2.Initiate()\r\n> \r\n> But it did seem OK to do:\r\n> \r\n> tp := TransportProperties.new()\r\n> pc1 := Preconnection.new(tp)\r\n> c1 := pc1.Initiate()\r\n> \r\n> tp.SetProperty(foo, true)\r\n> pc2 := Preconnection.new(tp)\r\n> c2 := pc2.Initiate()\r\n> \r\n> I thought it was OK to add remote information to a preconnection, as a part of some out of band signalling. To do clever traversal stuff.\r\n> \r\n> Gorry\r\n\r\n",
          "createdAt": "2021-06-17T16:30:26Z",
          "updatedAt": "2021-06-17T16:30:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm probably confused, but I don't understand why we can't rely on the usual programming language semantics for whether parameters are passed by reference, copied, etc. Preconnections and transport properties are just structs, and whatever value they have when `Initiate()` is called is used.",
          "createdAt": "2021-06-24T11:09:52Z",
          "updatedAt": "2021-06-24T11:09:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I very much agree with @csperkins that this is down to programming language semantics. The preconnection is just a \"struct\", a bunch of data grouped together. Let's not overcomplicate it.",
          "createdAt": "2021-06-24T23:04:20Z",
          "updatedAt": "2021-06-24T23:04:20Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please can we try amend our text to explain a little more that this is the case?\r\n I think this (possibly with my example above) clarifies what the purpose is, and we might be able to close this after we have that. My suggestion is a small explanation on re-use of a previous pre-connection after section 3.1.2.",
          "createdAt": "2021-06-28T08:07:28Z",
          "updatedAt": "2021-06-28T08:43:17Z"
        }
      ]
    },
    {
      "number": 864,
      "id": "MDU6SXNzdWU5MzI4NDc5OTU=",
      "title": "Are scoped IPv6 address (and zone indexes in particular) supported?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/864",
      "state": "OPEN",
      "author": "dhobsd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Sections 4.1 and 4.1.3 introduce `WithIPv6Address` to configure an Endpoint Object. The address supplied in examples appears to be an address literal. However, Section 1.1 does not define any types explicitly associated with an internet address -- `Integer` or `Numeric` could work, but I don't think that's the intent for these APIs, either. Section 3.2.2 does not extend this. \r\n\r\nIt's unclear whether this literal is intended to support IPv6 scoped addresses as described in [RFC4007]. While this RFC describes a textual representation (possibly not in line with the goals of the API), [RFC6874] describes how to represent zone indexes in an address literal.\r\n\r\nIf zone indexes are not intended to be supported, this could be clarified by, when \"IPv4 and IPv6 address\" is mentioned in section 4.1, also citing [RFC791] and [RFC4007] with the respective address family.\r\n\r\nIf zone indexes _are_ intended to be supported, ambiguity exists around the use of `WithIPv6Address` and `WithInterface` on a Local Endpoint, where the supplied address has a zone index that does not match the supplied interface. This could be clarified by:\r\n\r\n 1. Defining type names that represent IPv4 and IPv6 addresses in section 1.1.\r\n 2. Specifying the properties of an address literal supported by that type (referencing [RFC791] for IPv4 and both [RFC4007] and [RFC6874] for IPv6).\r\n 3. Clarifying in section 4.1 that \"IPv4 or IPv6 address\" are of the respective type described in section 1.1 when used in `WithIPv4Address` or `WithIPv6Address`.\r\n 4. Clarifying the behavior of zone index and interface choices on a Local Endpoint in a new section 4.1.4. This may tie in to #859 to some extent in that this is unlikely to be discoverable until `Initiate` is called.\r\n\r\n[RFC791]: https://datatracker.ietf.org/doc/html/rfc791\r\n[RFC4007]: https://datatracker.ietf.org/doc/html/rfc4007\r\n[RFC6874]: https://datatracker.ietf.org/doc/html/rfc6874",
      "createdAt": "2021-06-29T15:42:07Z",
      "updatedAt": "2021-07-08T11:53:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(note this is in \u00a76.1/6.1.3 post-#869)",
          "createdAt": "2021-07-08T11:53:21Z",
          "updatedAt": "2021-07-08T11:53:21Z"
        }
      ]
    },
    {
      "number": 865,
      "id": "MDU6SXNzdWU5MzI5MjM1NTk=",
      "title": "Should Endpoint Object identifiers be discoverable?",
      "url": "https://github.com/ietf-tapswg/api-drafts/issues/865",
      "state": "OPEN",
      "author": "dhobsd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "It feels to me like there's a bit of a gap between how software ought to discover Endpoint Object identifiers for Remote Endpoints versus Local Endpoints. Remote Endpoint identifiers are likely to be defined by the kind of software being used acting on some user input (web browser requesting a page, DNS server recursing, etc.), and these identifiers are resolved through existing internet architecture. Importantly, there's not really any way to check a valid input would work until `Initiate` for a Remote Endpoint.\r\n\r\nThis isn't really true for identifiers on Local Endpoints. While it's true that discovering these things is system-specific, a TAPS API implementation ought to provide a vehicle for discovering what inputs are valid. Two reasons I think it's reasonable to support discovery of local addresses and interfaces include:\r\n\r\n * It'd be unfortunate for TAPS-consuming software to rely on system-specific APIs to implement a UX for configuring that software.\r\n * Given diversity of public cloud offerings and wide use of multi-cloud deployments, it's reasonable to expect folks to want to dynamically discover what local network addresses and interfaces exist in their environment.\r\n\r\nIf the intent is to not define an API to discover these identifiers, the document should be clarified to discuss what Errors can be returned by `WithInterface` and `WithIPv[46]Address` Actions on Local Endpoints. (This is coming from a perspective that \"error early, error often\" is a best practice, which is admittedly subjective.)\r\n\r\nIf there is agreement to add (for example) `GetInterfaces` and `GetIPv[46]Addresses` Actions on a Local Endpoint, these should be documented. Further, the `WithInterface` and `WithIPv[46]Address` Actions on a Local Endpoint should be described to return an Error when the supplied input would not exist in the results returned by the corresponding `Get<identifier>` call at the time the `With<identifier>` Action was called.\r\n\r\nIn either case, it would be useful to mention that a successful invocation of a `With<identifier>` Action is not a guarantee that initiating the precondition will succeed.",
      "createdAt": "2021-06-29T17:04:35Z",
      "updatedAt": "2021-07-05T23:51:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This all makes sense to me, and sounds like some things should indeed be added. I'm a little afraid that adding \"GetInterface\" could cause a rat tail of \"GetWhateverElse\" ideas... is there a good way to keep that from happening? Something more generic, perhaps - \"GetLocalSystemProperties\", and explain that such properties could, e.g., contain a list of interfaces?\r\n\r\nRegarding early failure, I agree with your suggestions too; note that, even though a Preconnection itself is just a passive data structure (or Object holding data), the call to create it can already fail (some details are in section 3.1 of the implementation draft). I think that's the earliest type of failure that we specify (and since this is an abstract API, I'm not sure if we should start specifying that calls to define an Endpoint (which is where \"WithInterface\" and such are found) could fail too - the endpoints could just be a 100% passive data structure that's handed over, there might not be any calls involved...  so I think it's enough to specify failure of the Preconnection creation).",
          "createdAt": "2021-07-05T10:44:34Z",
          "updatedAt": "2021-07-05T10:44:34Z"
        },
        {
          "author": "dhobsd",
          "authorAssociation": "NONE",
          "body": "> I'm a little afraid that adding \"GetInterface\" could cause a rat tail of \"GetWhateverElse\" ideas.\r\n\r\nI think that's a fair concern, and I think a `GetLocalSystemProperties` API could work. Two concerns with a single API entry point for Local Endpoint identifier discovery:\r\n\r\n * It provides no means for enumerating interface(s) by address(es) or vice versa without some argument signifying how the caller wants the data returned.\r\n * It's more likely to cause future API and ABI versioning headaches for implementers when new identifiers are deemed useful for discovery, and require changing the returned data structure.\r\n \r\nI'm not sure how to effectively allay concerns about adding a billion discovery APIs. I don't think discovery is needed for Transport Properties: I see that as a TAPS API implementer's documentation problem (and consumer's reading-the-documentation problem), and maybe that's worth a sentence of rationale somewhere. I also do not think that a service <-> port discovery API is particularly useful in modern systems (and there are many service discovery protocols to choose from for the cases they are).\r\n\r\n`GetWhateverElse` would then have to reference a yet-to-be-defined local transport concept; since a Local Endpoint is effectively defined by a 3-tuple of interface, address, and port, I think it's unlikely new discovery APIs would be requested / added frequently.\r\n\r\n> the endpoints could just be a 100% passive data structure that's handed over, there might not be any calls involved... so I think it's enough to specify failure of the Preconnection creation\r\n\r\nGreat point! If the system changes between discovery and `Initiate` such that a previously-valid Preconnection is now invalid, the inverse is also possible. Happy to scope this issue only to the point of discovery APIs.",
          "createdAt": "2021-07-05T23:51:27Z",
          "updatedAt": "2021-07-05T23:51:27Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4MDAwNTM4",
      "title": "Add initial cut at security configuration API. ",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-08T15:17:47Z",
      "updatedAt": "2018-02-09T20:33:38Z",
      "closedAt": "2018-02-09T20:33:34Z",
      "mergedAt": "2018-02-09T20:33:34Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU1NTA3NTM=",
          "commit": {
            "abbreviatedOid": "4f09dbb"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-09T20:20:57Z",
          "updatedAt": "2018-02-09T20:20:57Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "11a28142c71f9ff89c5d5b11ca10e083a5a9d8b5",
      "headRepository": "chris-wood/taps-apidrafts",
      "headRefName": "caw/security-apis",
      "headRefOid": "77aff3aef0e9f4ffd4545b398f4fc68726f03693",
      "mergeCommit": {
        "oid": "721346fbb412180a1dd38fbf9527138beafaa5d0"
      }
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY5NDE3MzI4",
      "title": "Harmonize Intents and Post Sockets concepts",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/48",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This should fix the different styles in Transport and Send Parameter from Issue #34 ",
      "createdAt": "2018-02-15T16:19:48Z",
      "updatedAt": "2018-04-11T13:23:26Z",
      "closedAt": "2018-02-16T13:21:42Z",
      "mergedAt": "2018-02-16T13:21:42Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcxNzM2MjE=",
          "commit": {
            "abbreviatedOid": "3acb7ef"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "From a quick look, no objections on my part. I'll review in more detail and align with the preconnection changes in #42 once this is merged.",
          "createdAt": "2018-02-16T13:15:46Z",
          "updatedAt": "2018-02-16T13:15:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcxNzQ5NTI=",
          "commit": {
            "abbreviatedOid": "3acb7ef"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine by me... little things here and there, but altogether this seems ok IMO",
          "createdAt": "2018-02-16T13:21:23Z",
          "updatedAt": "2018-02-16T13:21:23Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f24d9cb85e9ea2fc7f269fc183ec721a3bd1ff15",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "harmonized-parameters",
      "headRefOid": "3acb7efb406a1cf6cbee9f1af02fa8e1ac02d56d",
      "mergeCommit": {
        "oid": "49bde0959aea630e20780b5fc91b63329d3a41bc"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY5NjkyOTc1",
      "title": "Connectable",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/49",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "Incorporate Preconnection into the architecture and API draft.\r\n\r\nCloses #42 ",
      "createdAt": "2018-02-16T18:22:32Z",
      "updatedAt": "2018-04-11T13:23:28Z",
      "closedAt": "2018-02-16T23:46:19Z",
      "mergedAt": "2018-02-16T23:46:18Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good. I pushed a commit to complete the change of the list style to include the implementation concepts section.",
          "createdAt": "2018-02-16T23:45:35Z",
          "updatedAt": "2018-02-16T23:45:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyNzM4NTQ=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-16T18:30:54Z",
          "updatedAt": "2018-02-16T18:42:43Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "May be good to note that the Local Endpoint is an optional part of the pre-connection properties",
              "createdAt": "2018-02-16T18:30:54Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 32,
              "body": "I like the diagram! Thanks for adding this.",
              "createdAt": "2018-02-16T18:31:06Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 42,
              "body": "I'd like to not lose the original intent of the text before, that captured the idea that this \"Connection\" still works for stateless protocols like UDP, just by maintaining the five-tuple path. A note to say that the readiness of the connection to send and receive may or may not be based on protocol handshakes would be good.",
              "createdAt": "2018-02-16T18:32:55Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 71,
              "body": "Yeah, we should remove \"in a properties\"",
              "createdAt": "2018-02-16T18:41:56Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyODM1MjE=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:03:15Z",
          "updatedAt": "2018-02-16T19:03:16Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "+1; but I find the \"Content Received\" arrow pointing at Content, which has a Send() arrow going back to Connection confusing.",
              "createdAt": "2018-02-16T19:03:15Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyODM4MjM=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:04:19Z",
          "updatedAt": "2018-02-16T19:04:20Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "This is from long ago, when I once read the whole thing and inserted such comments throughout; you may want to do a cleanup, there are several such minor comments from me in the text.",
              "createdAt": "2018-02-16T19:04:20Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyODUxMDA=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-16T19:08:48Z",
          "updatedAt": "2018-02-16T19:11:14Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Should be \"These properties all apply...\"",
              "createdAt": "2018-02-16T19:08:48Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyODM2MzY=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:03:38Z",
          "updatedAt": "2018-02-16T19:11:58Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Also i guess e.g. DNS resolution in done by the connection (not the preconception), right? In this case there a change that the connection fails even before an active transport protocol instance has been established. And the other question is, can a connection have more than one active protocol instance? I'd say yes, as you could emulate multipath by using e.g. two TCP connections.  ",
              "createdAt": "2018-02-16T19:03:38Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 68,
              "body": "Did we already decide if we want to keep this supperclass \"Endpoint\" or not?",
              "createdAt": "2018-02-16T19:05:18Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 71,
              "body": "Would ICE create new endpoints or add additional information to an existing endpoint? In both cases I think this definition is to limited by only relating a remote to the application's view...",
              "createdAt": "2018-02-16T19:07:24Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 42,
              "body": "Replying to myself.... I guess DNS resolution is done during Initiate() and if that fails no connection is established, right? I still wondering if there are cases where you have a connection but no active protocol instance (yet or anymore)...",
              "createdAt": "2018-02-16T19:09:28Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            },
            {
              "originalPosition": 156,
              "body": "Should there also be an action to indicate that the application will not send any further data but is still willing to receive data?",
              "createdAt": "2018-02-16T19:11:51Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTAwMTM=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:25:26Z",
          "updatedAt": "2018-02-16T19:25:27Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "No; this is explained in minset - exactly why I hesitate to move stuff to the appendix, people don't seem to read the appendix   :)    if you want to support a broad set of transport connections, you need these primitives to only expose the most limiting semantics of all of them. What you describe is a TCP specialty, it's the result of half-closed connections. If you expose this, and someone wants to use it, you limit the system to only support protocols that can do half-closed connections. Worse, you need to initially ask \"will you want to use the primitive that still lets you receive after closing?\" in order to choose the right set of protocols (or simply never use a protocol that can't do half-closed connections, when half-closed connections aren't terribly useful anyway).",
              "createdAt": "2018-02-16T19:25:26Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTIwMjI=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:32:19Z",
          "updatedAt": "2018-02-16T19:32:19Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "About the \"you could emulate multipath by using e.g. two TCP connections\" bit: this is exactly the email conversation I just have / had with Tommy - I think that should be possible, but it would need us to add something to the API such that the application can say \"my peer can handle this\".",
              "createdAt": "2018-02-16T19:32:19Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTUyNDA=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:43:53Z",
          "updatedAt": "2018-02-16T19:43:54Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Yup - will fix",
              "createdAt": "2018-02-16T19:43:54Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTc4NzU=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:53:08Z",
          "updatedAt": "2018-02-16T19:53:08Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "@tfpauly good point, will fix\r\n@mirjak DNS resolution is done in Initiate(), and you'll get an error event if it doesn't resolve to something you can connect to. I haven't thought whether a Connection can support multiple underlying protocol instances, but the case where there is no longer an active protocol instance seems needed to represent a closed connection.",
              "createdAt": "2018-02-16T19:53:08Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTg0NjQ=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:55:10Z",
          "updatedAt": "2018-02-16T19:55:10Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Not sure, but splitting Endpoint is coming in a separate pull request later (or, more likely, tomorrow)",
              "createdAt": "2018-02-16T19:55:10Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTk5MTA=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:00:17Z",
          "updatedAt": "2018-02-16T20:00:17Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "For ICE I think we need: 1) `fn expand_candidates(p : Preconnection) -> List<Preconnection>` which can take a partially specified preconnection and expand it to a list of all possible candidates that match, so that list can be passed to the peer by the application; and 2) `fn initiate(peer_candidates : List<Preconnection>) ` which allows you to specify the remote candidates. I'll write this up, but it won't be today.",
              "createdAt": "2018-02-16T20:00:17Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDAyNjc=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:01:37Z",
          "updatedAt": "2018-02-16T20:01:37Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "@mwelzl I see what you mean... will think whether I can improve",
              "createdAt": "2018-02-16T20:01:37Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDA5NTc=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:03:57Z",
          "updatedAt": "2018-02-16T20:03:57Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "re resolution: I think whether this happens before or after Initiate() should be left up to an implementation. I could certainly see implementations that take action during Preconnect() in order to reduce Initiate() latency, and warming up the local name cache is one of those possible actions...",
              "createdAt": "2018-02-16T20:03:57Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDMxODc=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:12:27Z",
          "updatedAt": "2018-02-16T20:12:27Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "I agree with @mwelzl that this action is of limited utility for non-TCP stacks, and we could easily leave this out for London, but in general I don't think it's a problem to add actions which express application intent but which some/many stacks will treat as a no-op. I see `EndOfData()` (it's hard to name this, cf. socket's terrible `shutdown()`) as precisely this kind of thing -- it expresses an application-layer semantic, but some/many/most protocols might ignore it, and that's also okay as long as it doesn't cause incorrect operation of those protocols. (UDPLite's \"checksum coverage\" is a perfect example of this -- it's useless in TCP, and useless in UDP unless it's 0, but it doesn't express \"don't checksum this\", it expresses \"the application is tolerant of corruption of this data\". Same same.)\r\n\r\n",
              "createdAt": "2018-02-16T20:12:27Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDM5NzE=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM with @tfpauly's changes",
          "createdAt": "2018-02-16T20:15:55Z",
          "updatedAt": "2018-02-16T20:15:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDY5MzQ=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:28:17Z",
          "updatedAt": "2018-02-16T20:28:17Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "No sorry, this is different: if you write an application that sends data where it may be fine to not use a checksum, but you get a checksum, nothing bad happens. If you write an application where you issue close but you do expect to be able to read afterwards, but you can't, this is semantically different. Application 1 must ensure that communication is really over and it doesn't expect anything anymore from app 2 when the it closes - otherwise, the sent data from app2 is lost. So, at the end of the connection, you're in fact unreliable.\r\n\r\nThis isn't a big problem in practice, and that's why TCP's half-closed connections are somewhat obscure - but if you rely on them being there, your application can break. If you don't get \"checksum disabled\", nothing will ever break.",
              "createdAt": "2018-02-16T20:28:17Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDcxOTA=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:29:18Z",
          "updatedAt": "2018-02-16T20:29:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "@britram this may be an optimisation hint we allow, but I'd like when resolution occurs to be deterministic by default",
              "createdAt": "2018-02-16T20:29:18Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDc4ODg=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:31:48Z",
          "updatedAt": "2018-02-16T20:31:48Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "yep, agreed, that's why it's a different action: `EndOfData()`, not `Close()`. Also agree that `Close()` should mean the connection should be torn down and no further reads or writes are expected (with the caveat, of course, that in an asynchronous API the API cannot guarantee that no `Received<>` event will fire after `Close()` is called).",
              "createdAt": "2018-02-16T20:31:48Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDkxMDQ=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:36:44Z",
          "updatedAt": "2018-02-16T20:36:45Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "(and I should point out that you still have to `Close()` after `EndOfData()`... it's all a bit obscure though, so I'd be happy to drop it for London)",
              "createdAt": "2018-02-16T20:36:44Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMDkxNjQ=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T20:37:00Z",
          "updatedAt": "2018-02-16T20:37:00Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Oh sure, that can happen. No problem though. The specific rules we had written up about this in NEAT for an active close were: \"Triggered by calling neat_shutdown();\r\non_writable() will never be called again, calling neat_write() returns error\r\non_readable() can be called\"",
              "createdAt": "2018-02-16T20:37:00Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMTU5Njk=",
          "commit": {
            "abbreviatedOid": "ed40903"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T21:04:30Z",
          "updatedAt": "2018-02-16T21:04:30Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Thinking more about this - perhaps we should add this information (about the read-callback potentially still firing) to the description of the call?  I left it out on purpose to avoid making this text unnecessarily complex, but if you think it helps then we could include this, for \"close\" and \"abort\" ?",
              "createdAt": "2018-02-16T21:04:30Z",
              "updatedAt": "2018-02-16T23:44:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczNDg5NTY=",
          "commit": {
            "abbreviatedOid": "ed782a8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-16T23:45:07Z",
          "updatedAt": "2018-02-16T23:45:07Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9763b86c37458de762e578e87308d24a3ddd692b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "connectable",
      "headRefOid": "ed782a8a3b48b17c9b468c644a82b49dc22e9846",
      "mergeCommit": {
        "oid": "bf1e053342b68a17367c8f21a152b6776cfe1ea8"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY5NzUwMTEy",
      "title": "cleaned up things a bit, removed some intents, inserted several comme\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/50",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This ends my promised pass - I hope that in particular the app intents people can take a look at some of my comments (I wrote them inline as \\[MICHAEL: blabla])",
      "createdAt": "2018-02-16T23:33:20Z",
      "updatedAt": "2018-04-11T13:22:40Z",
      "closedAt": "2018-02-17T00:26:33Z",
      "mergedAt": "2018-02-17T00:26:33Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "changed base to master since #49 landed",
          "createdAt": "2018-02-16T23:48:08Z",
          "updatedAt": "2018-02-16T23:48:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczNDc4MDY=",
          "commit": {
            "abbreviatedOid": "7dfb401"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T23:36:41Z",
          "updatedAt": "2018-02-16T23:36:42Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "I like this property, but I left it out because I wasn't sure I knew of any protocols that supported it...",
              "createdAt": "2018-02-16T23:36:41Z",
              "updatedAt": "2018-02-17T00:24:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczNDgxOTI=",
          "commit": {
            "abbreviatedOid": "7dfb401"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T23:39:18Z",
          "updatedAt": "2018-02-16T23:39:18Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "yeah, I thought about adding a simple Get(k string) interface{} metadata accessor, but we'd need to add metadata language to the receive section. I can do this after this PR and preconnection land...",
              "createdAt": "2018-02-16T23:39:18Z",
              "updatedAt": "2018-02-17T00:24:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczNDkyMDA=",
          "commit": {
            "abbreviatedOid": "7dfb401"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T23:46:58Z",
          "updatedAt": "2018-02-16T23:46:58Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "SCTP does. RFC 7053. It's really quite a special thing... I think you have to be quite an advanced application writer doing advanced juggling with the Sent event to make use of this (Sent will fire when it the transport buffer below drains, which will happen faster when ACKs come in faster). But let them have all the things that can reduce their latency, I'd say.",
              "createdAt": "2018-02-16T23:46:58Z",
              "updatedAt": "2018-02-17T00:24:49Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bf1e053342b68a17367c8f21a152b6776cfe1ea8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mwelzl-edits",
      "headRefOid": "fa7b80c24a10f4e399d7a1676f87ce1d8bc9eae6",
      "mergeCommit": {
        "oid": "b082a62d8cdcb72928a020edae0030ad8c11384f"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY5ODM1Njc5",
      "title": "Update Security-related API sketch.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/51",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-18T15:39:23Z",
      "updatedAt": "2018-02-18T15:39:29Z",
      "closedAt": "2018-02-18T15:39:29Z",
      "mergedAt": "2018-02-18T15:39:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "760999d5c89a0ee9a1b38401d01125869669adbc",
      "headRepository": "chris-wood/taps-apidrafts",
      "headRefName": "caw/security-apis",
      "headRefOid": "ceeffe4e9f8cb727acb523200ddc5fb22e37880f",
      "mergeCommit": {
        "oid": "20e73906635f2a6ebca14e06686dfdce69a07235"
      }
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY5ODQxOTY2",
      "title": "Separate Endpoint into LocalEndpoint and RemoteEndpoint",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/52",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These commits separate Endpoint into LocalEndpoint and RemoteEndpoint types, and update the rest of the documents to match.\r\n\r\nCloses #43 ",
      "createdAt": "2018-02-18T18:02:15Z",
      "updatedAt": "2018-04-11T13:23:30Z",
      "closedAt": "2018-02-23T20:32:11Z",
      "mergedAt": "2018-02-23T20:32:11Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since the previous comment was on a now-hidden commit:\r\n\r\nI agree that a raw Endpoint that isn't Remote or Local may not be used in any of the externally-facing APIs to create a Connection. From an API standpoint, it's fine to require a specific type of the general class.\r\n\r\nAll I'm arguing is that in our list of concepts and definitions, we need to define that there is a basic concept of an Endpoint, that isn't necessarily local or remote, since local and remote only become relevant in the context of a connection, or some communication. Having a definition of Remote and Local Endpoints without ever saying what an endpoint is (or duplicating the definitions, saying Local: See the generic parts of Remote) seems unnecessary.\r\n\r\nAlso, from an implementation standpoint, the Endpoint really isn't as trivial as you're saying. It's not just a matter of displaying. Since we don't use sockaddrs in the exposure of the address form of endpoint, the Endpoint does the following:\r\n\r\nCan create hostname/address from a string, which automatically parses into a hostname, IPv4, or IPv6 address. If the IPv6 address is a mapped v4 address, it parses that out.\r\nCreate port with a string or number (\"http\" or \"80\")\r\nExtract address byte encoding for use in forming packets\r\nExtract port in either network or host byte order\r\nExtract IP address family\r\nDo subnet or DNS name segment matching and comparisons between endpoints (are these two in the same slash #)\r\nAllow definition of custom endpoint subclasses that can resolve into standard types\r\nAll of these operations are useful for both local and remote endpoints, such as when you are filling out or parsing headers within the protocol stack. If as an implementation, I was told to make the LocalEndpoint and RemoteEndpoint completely different classes in a strongly typed language, I would need to redefine all of these? If they're not subclasses of the same Endpoint generic class, at least they both implement the template/protocol of an Endpoint so we can re-use some logic.\r\n\r\nTo that end, defining the concept of Endpoint first, then explaining Remote and Local Endpoint, still makes sense in the architecture.",
          "createdAt": "2018-02-20T15:28:09Z",
          "updatedAt": "2018-02-20T15:28:09Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly I'd say that what you described about the use of endpoint should probably be noted in the implementation draft. I'm still not sure if Endpoint should be noted in the architecture because it's not an architectural concept but rather an implementation issue, but I think I'm okay to define it for sake of having a good definition we can refer to.\r\n\r\n@csperkins I'm still wondering if we generate new remotes in the resolution step or if we store all we know about one actual endpoint in the same remote. If we get multiple IP addresses for the same URL, is that multiple hosts serving the same content, or one entity that is presumably distributed over multiple physical (frontend) host, or one host having multiple addresses. My answer would be, as we don't know the actually setup, we should keep all information we learned based on the initial input provided for the Remote within that Remote object. I guess this goes all back to the (StackEvo) question: what is an endpoint? So maybe good to have a definition...\r\n\r\n",
          "createdAt": "2018-02-21T10:45:51Z",
          "updatedAt": "2018-02-21T10:45:51Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...fwiw i'm holding off on my big editorial pass until this lands...",
          "createdAt": "2018-02-21T15:05:04Z",
          "updatedAt": "2018-02-21T15:05:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak I think that while the concept is most critical for the implementation, it still affects the application developer that uses the API. If, as a developer, I want to create a Remote or Local Endpoint, I need to know how to specify my address/hostname/port (which needs to be common types between the two). We also have application level tests that do things like create a listener, extract the local endpoint, and then create a connection back to ourselves over loopback, using the the local as a remote. It would be strange if that wasn't possible.\r\n\r\nMainly, I'm just arguing we should define the existence of a generic \"address/hostname/service\" blob from the start for clarity. Removing the definition of the base endpoint concept didn't make the remote or local endpoints stronger definition; it just removed clarifying text that's general to both.",
          "createdAt": "2018-02-21T15:11:26Z",
          "updatedAt": "2018-02-21T15:11:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly on reflection, putting endpoint into the architecture seems okay, but I'm still unconvinced we need it in the API. Or, at least, before we add Endpoint to the API, we need to more clearly understand the range of different endpoint types to really see what's common between them. I wonder if things like, e.g., LocalEndpoints obtained via a TURN server, break some of the assumptions of commonality.\r\n\r\n@mirjak I was thinking that `resolve(RemoteEndpoint)` would return a list of `RemoteEndpoint` objects. Maybe they should reference what they were resolved from, but I don't think we have any way of knowing whether they refer to the same host or not.",
          "createdAt": "2018-02-22T13:29:14Z",
          "updatedAt": "2018-02-22T13:29:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins I agree on the point for the API document. I don't think we need to have the generic endpoint there for now, as long as the architecture explains the relationship.\r\n\r\nWith regards to resolution, our implementation takes an endpoint, and resolves it into a set of endpoints (of a different type, generally; used for bonjour service -> hostname, hostname -> address, v4 address -> NAT64 translated v6 address, etc). We've found it useful for the endpoint to track the \"parent\" endpoint it was derived from, mainly so that when protocols that care about the original hostnames need to access them (like TLS for cert validation, or SOCKS for figuring out the original hostname to request to the proxy), it's available. Also useful for doing per-domain policy evaluation for flows.",
          "createdAt": "2018-02-22T15:40:56Z",
          "updatedAt": "2018-02-22T15:40:56Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly ack - will try to write this up tomorrow (today was a write-off due to lecturing...)",
          "createdAt": "2018-02-22T22:47:24Z",
          "updatedAt": "2018-02-22T22:47:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good!",
          "createdAt": "2018-02-23T20:31:49Z",
          "updatedAt": "2018-02-23T20:31:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc0MTkzNDg=",
          "commit": {
            "abbreviatedOid": "569be5e"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Arch document probably shouldn't CamelCase RemoteEndpoint and LocalEndpoint; otherwise, this is good, thanks!",
          "createdAt": "2018-02-18T22:38:54Z",
          "updatedAt": "2018-02-18T22:39:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "was this an overcorrection to CamelCase? Spaces (we should use \"Local Endpoint\", \"Remote Endpoint\" in the architecture draft; whether we camelcase in the API or just call things Local and Remote is a separate discussion",
              "createdAt": "2018-02-18T22:38:54Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc0MjA0NTE=",
          "commit": {
            "abbreviatedOid": "569be5e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-18T23:05:31Z",
          "updatedAt": "2018-02-18T23:05:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agreed that this should be \"Local Endpoint\" and \"Remote Endpoint\"",
              "createdAt": "2018-02-18T23:05:31Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc0MjA2Mjg=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-18T23:10:15Z",
          "updatedAt": "2018-02-18T23:10:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think a DNS name is sufficient for an Endpoint, unless that's referring to the DNS Service name. It needs to be a DNS hostname + port. I think listing out the types as we had with endpoint is still necessary and useful.\r\n\r\nMy concern with removing the overall definition of an Endpoint is that we lose the common place to discuss the fact that an endpoint is not simply one type (hostname + port, or address + port, or anything else), but an abstract representation of something that may correspond via resolution or advertisement to one or more other endpoints.\r\n\r\nWhat precisely is the advantage of removing the definition of the concept of an endpoint? It's still a term that is not really standardized, and without defining it, I think we're losing a fundamental type. It's essentially the equivalent of sockaddr for sockets\u2014a type that indeed has meaning in multiple contexts, not just in remote/local dichotomies. If we don't specify this carefully, we risk interpretations of endpoints to be just one set of things (like how sockets used just addresses) that will pigeonhole us later on.",
              "createdAt": "2018-02-18T23:10:15Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc0MjA3Mjg=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-18T23:12:46Z",
          "updatedAt": "2018-02-18T23:12:46Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I don't really like this change either\u2014when we're racing Endpoints (which now have no definition...), they're not using \"the\" original Remote or Local Endpoint, they're using new sets of derived local and remote Endpoints, which don't necessarily carry the full meaning of what is defined as the Local Endpoint and Remote Endpoint to the application. Specifically, I may have a \"Local Endpoint\" to hold my local state, and a \"Remote Endpoint\" to define the hostname, certificate policy, etc, for my peer; but the Endpoints representing what I resolved for my Remote Endpoint are sub-addresses that don't need their own state in the same way, but are still different entities, since I am trying different addresses.",
              "createdAt": "2018-02-18T23:12:46Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc0MjA4NDY=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The API changes are OK, but I think the removal of text in the architecture makes concepts fuzzier than they were before. While the higher level of concepts of Local and Remote for state storage are useful, as an implementer, the first thing I'm going to do is have a basic type for my address/hostname/port storage, and that's an important unit to talk about when building connection attempt trees. Removing this concept will just make it harder to write the implementation.",
          "createdAt": "2018-02-18T23:15:39Z",
          "updatedAt": "2018-02-18T23:15:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc1MjEyMjQ=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-19T12:06:29Z",
          "updatedAt": "2018-02-19T12:06:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "on reflection -- i think one of the reasons I thought of this as an implementation detail is precisely because it's a `sockaddr`, but this...\r\n\r\n> What precisely is the advantage of removing the definition of the concept of an endpoint? It's still a term that is not really standardized, and without defining it, I think we're losing a fundamental type.\r\n\r\n... is compelling to me.\r\n\r\n",
              "createdAt": "2018-02-19T12:06:29Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc2NzI5NTc=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-19T23:01:24Z",
          "updatedAt": "2018-02-19T23:01:25Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Right, just as we want to live a post-sockets world (lower case post-sockets, here), we also want to live in a post-sockaddr world. \r\n\r\nFor example, dealing with byte structures like sockaddrs in languages like Swift is really a pain. Using an Endpoint object with methods that replace the basic sockaddr fields is way easier.",
              "createdAt": "2018-02-19T23:01:24Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc3NDM1MjA=",
          "commit": {
            "abbreviatedOid": "569be5e"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-20T08:53:25Z",
          "updatedAt": "2018-02-20T08:53:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Fixed.",
              "createdAt": "2018-02-20T08:53:25Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc3NDY0NjQ=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-20T09:03:50Z",
          "updatedAt": "2018-02-20T09:03:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Remote Endpoint should be defined by name and port, I agree. That was an oversight that I've fixed. \r\n\r\nFor Endpoint, we need to be clear that RemoteEndpoint is an abstract type that can represent several different types of remote endpoint, and that name+port is just one example. Similarly for LocalEndpoint. And I'm certainly not advocating `struct sockaddr` style anything. But, it's still not clear to me what a generic Endpoint would include? \r\n\r\nI expect `LocalEndpoint` and `RemoteEndpoint` may well have some common methods (e.g., they'd both implement `Display` in a Rust implementation), but I don't see use cases for a generic `Endpoint`. All the cases that I can immediately think of, it matters whether it's a local or remote endpoint, so having a common super type doesn't give us anything.\r\n\r\nThis is not to say that I'm against `Endpoint` in principle, I'd just like a use case before adding it.",
              "createdAt": "2018-02-20T09:03:50Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc3NDg2Mjg=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-20T09:11:46Z",
          "updatedAt": "2018-02-20T09:11:46Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I think there are two issues here.\r\n\r\nFirstly, should \"Endpoint Racing\" be a concept, or are we just describing Path Racing in a little more detail here? I suspect the latter.\r\n\r\nSecond, and independent of whether `Endpoint` exists as a super-type of `RemoteEndpoint` and `LocalEndpoint`, how does the racing relate to endpoints. I guess we pass in a list of RemoteEndpoint objects, each of which is resolved to one or more additional `RemoteEndpoint` objects, then we race connections to those remote endpoint? I'm note sure I understand the comment about \"don't necessarily carry the full meaning\"?",
              "createdAt": "2018-02-20T09:11:46Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTc4NjcxMjk=",
          "commit": {
            "abbreviatedOid": "9cf5e3e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-20T15:27:32Z",
          "updatedAt": "2018-02-20T15:27:32Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I agree that a raw Endpoint that isn't Remote or Local may not be used in any of the externally-facing APIs to create a Connection. From an API standpoint, it's fine to require a specific type of the general class.\r\n\r\nAll I'm arguing is that in our list of concepts and definitions, we need to define that there is a basic concept of an Endpoint, that isn't necessarily local or remote, since local and remote only become relevant in the context of a connection, or some communication. Having a definition of Remote and Local Endpoints without ever saying what an endpoint is (or duplicating the definitions, saying Local: See the generic parts of Remote) seems unnecessary.\r\n\r\nAlso, from an implementation standpoint, the Endpoint really isn't as trivial as you're saying. It's not just a matter of displaying. Since we don't use sockaddrs in the exposure of the address form of endpoint, the Endpoint does the following:\r\n- Can create hostname/address from a string, which automatically parses into a hostname, IPv4, or IPv6 address. If the IPv6 address is a mapped v4 address, it parses that out.\r\n- Create port with a string or number (\"http\" or \"80\")\r\n- Extract address byte encoding for use in forming packets\r\n- Extract port in either network or host byte order\r\n- Extract IP address family\r\n- Do subnet or DNS name segment matching and comparisons between endpoints (are these two in the same slash #)\r\n- Allow definition of custom endpoint subclasses that can resolve into standard types\r\n\r\nAll of these operations are useful for both local and remote endpoints, such as when you are filling out or parsing headers within the protocol stack. If as an implementation, I was told to make the LocalEndpoint and RemoteEndpoint completely different classes in a strongly typed language, I would need to redefine all of these? If they're not subclasses of the same Endpoint generic class, at least they both implement the template/protocol of an Endpoint so we can re-use some logic.\r\n\r\nTo that end, defining the concept of Endpoint first, then explaining Remote and Local Endpoint, still makes sense in the architecture.",
              "createdAt": "2018-02-20T15:27:32Z",
              "updatedAt": "2018-02-23T20:06:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTgyMjA3MjE=",
          "commit": {
            "abbreviatedOid": "ce769cc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-21T14:48:47Z",
          "updatedAt": "2018-02-21T14:48:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkwNDMyMzM=",
          "commit": {
            "abbreviatedOid": "5d18658"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-23T20:31:51Z",
          "updatedAt": "2018-02-23T20:31:51Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "368c4f3403af69f4496d438d5fbe95ede3935256",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-endpoint-type",
      "headRefOid": "5d186580f2576994c488ccf2364564b6a574bd3a",
      "mergeCommit": {
        "oid": "d8603ca8aad6e205e13af2594a135667e6cd8e4d"
      }
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNDYyODg1",
      "title": "Handle accept for unconnected protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/67",
      "state": "MERGED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-21T12:59:39Z",
      "updatedAt": "2018-04-11T13:23:31Z",
      "closedAt": "2018-02-24T14:03:22Z",
      "mergedAt": "2018-02-24T14:03:22Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good!",
          "createdAt": "2018-02-24T14:02:55Z",
          "updatedAt": "2018-02-24T14:02:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTgzNDE4MDg=",
          "commit": {
            "abbreviatedOid": "e87d6ff"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-21T20:05:53Z",
          "updatedAt": "2018-02-21T20:06:02Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Looks good! I find the sentence \"Implementations should perform the processing...\" to be a bit vague. What I think you mean is that the implementation should wait for incoming packets for the unconnected protocol on the listening port, and then create Connections for the complete five-tuples matching each new packet as accepted connections to the application. (That's at least the approach we use, and I think we discussed already).",
              "createdAt": "2018-02-21T20:05:53Z",
              "updatedAt": "2018-02-24T13:02:26Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b52599537c7879214ed2411078754c51cff02008",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tj/unconnected-accept",
      "headRefOid": "510fb8b3208d49ac7b6a83c89eb65ae6293a73a8",
      "mergeCommit": {
        "oid": "991a50ea62e357276f280f91d984768acdbc62f7"
      }
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNTM1NTYy",
      "title": "Add text for Specific Protocol Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/70",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #68 ",
      "createdAt": "2018-02-21T17:20:25Z",
      "updatedAt": "2018-04-11T13:23:29Z",
      "closedAt": "2018-02-21T19:18:04Z",
      "mergedAt": "2018-02-21T19:18:04Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTgzMjUzMDg=",
          "commit": {
            "abbreviatedOid": "7673ab8"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-02-21T19:17:58Z",
          "updatedAt": "2018-02-21T19:17:58Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0ed0ece5191315e32c99ff98b82d425da11b6d26",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/specific-protocol-properties",
      "headRefOid": "7673ab8122522110a538a1d9712d723077c9fb5c",
      "mergeCommit": {
        "oid": "730f080926cac3ed6d5dcdc13e34c9ccb97ed37d"
      }
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNjc3OTE4",
      "title": "Add text for UDP Send",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/71",
      "state": "CLOSED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-22T07:49:23Z",
      "updatedAt": "2020-09-11T16:31:07Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "730f080926cac3ed6d5dcdc13e34c9ccb97ed37d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tj/udp-send",
      "headRefOid": "f590e40147cba5b681e872213dc685d06c218278",
      "closedAt": "2018-10-05T19:16:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The main point of this new text seems to be around how UDP socket API allows sending and receiving on multiple addresses; however, that same effect can be handled by UDP Connections with fully bound five-tuples (and UDP Listeners). Should this instead add text on how to map the abstraction of UDP connections onto traditional unconnected socket implementations?",
          "createdAt": "2018-02-23T22:42:08Z",
          "updatedAt": "2018-02-23T22:42:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@adventureloop @tfpauly is there any reason not to just deconflict and land this one?",
          "createdAt": "2018-04-16T08:13:41Z",
          "updatedAt": "2018-04-16T08:13:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Timing out, pushing to ietf-01.",
          "createdAt": "2018-04-30T10:18:14Z",
          "updatedAt": "2018-04-30T10:18:14Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems OBE; @adventureloop, can you send an updated PR if this is still current?",
          "createdAt": "2018-10-05T19:16:55Z",
          "updatedAt": "2018-10-05T19:16:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNTA4MzY4",
          "commit": {
            "abbreviatedOid": "f590e40"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-27T16:25:09Z",
          "updatedAt": "2018-06-27T16:28:06Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Typo on Guidlines -> Guidelines",
              "createdAt": "2018-06-27T16:25:09Z",
              "updatedAt": "2018-06-27T16:28:06Z"
            },
            {
              "originalPosition": 6,
              "body": "Exposing per-send addresses is specifically not exposed right now in the API, and I think this is intentional. We can treat all UDP flows as \"connected\" so that sends and receives stay simple, and we can have back pressure from per-flow interface queues. I believe we can make an argument in this text that everything that can be expressed with an unconnected UDP socket is expressible with Listeners and Connections.",
              "createdAt": "2018-06-27T16:27:59Z",
              "updatedAt": "2018-06-27T16:28:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxMTkwMjc2",
      "title": "Replace Content with Message",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/85",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture",
        "review"
      ],
      "body": "Option for addressing #79: replace Content in the architecture with Message (where appropriate); use more general concepts like data in the background/design explanation, use Message in the concepts section, and refer to a Message's content when we need to talk about the bytes specifically in this Message.",
      "createdAt": "2018-02-24T18:12:40Z",
      "updatedAt": "2018-04-11T13:23:33Z",
      "closedAt": "2018-02-25T21:58:52Z",
      "mergedAt": "2018-02-25T21:58:52Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkxNTc1MzE=",
          "commit": {
            "abbreviatedOid": "b8bbef1"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-02-25T21:49:31Z",
          "updatedAt": "2018-02-25T21:49:31Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d2800d04f0dafe7d67fc86f17a61ba5e083fb2d4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-message",
      "headRefOid": "b8bbef1ad7a1099c2af95864e517034fd4d14c7f",
      "mergeCommit": {
        "oid": "bbbb21d996cbed19f87b0c826cf070397263881b"
      }
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNDM1NTQ4",
      "title": "Brian's Monday editorial pass on API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/96",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes all outstanding London API issues except #92 and #93",
      "createdAt": "2018-02-26T17:07:32Z",
      "updatedAt": "2018-04-11T13:22:37Z",
      "closedAt": "2018-02-26T22:00:25Z",
      "mergedAt": "2018-02-26T22:00:25Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkzODg4OTU=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-26T17:17:46Z",
          "updatedAt": "2018-02-26T17:24:18Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "The previous items in the list were complete sentences, where these last two (\"Explicit support...\" and \"Atomic transmission...\") are not; either way works, but we should be consistent.",
              "createdAt": "2018-02-26T17:17:47Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 186,
              "body": "Capitalize Path Selection here, since it is a term from the architecture?",
              "createdAt": "2018-02-26T17:19:12Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 180,
              "body": "Capitalize Protocol and Path Selection here, since they are terms from the architecture?",
              "createdAt": "2018-02-26T17:19:36Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 992,
              "body": "Is there a dangling \"Th\" here?",
              "createdAt": "2018-02-26T17:23:36Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0MzA3MDQ=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T19:17:02Z",
          "updatedAt": "2018-02-26T19:17:02Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "will do...",
              "createdAt": "2018-02-26T19:17:02Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0Mjg3NjE=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-26T19:11:38Z",
          "updatedAt": "2018-02-26T19:42:25Z",
          "comments": [
            {
              "originalPosition": 985,
              "body": "Interesting idea to make this whole choice per-message. I'm not 100% sure about everything here - e.g. the value choices (\"constant rate\" in particular). But we should make progress, and I think this is a fine discussion to postpone until after London.",
              "createdAt": "2018-02-26T19:11:38Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 1103,
              "body": "What the receiver gets with this call may or may not coincide with what the sender has handed over as a message. The application must be able to figure out where a message begins and ends. No problem to do this generically, via framers and de-framers, but simply receiving a \"message\" doesn't tell the receiver anything about the sender's message size, and hence this paragraph makes no sense to me.",
              "createdAt": "2018-02-26T19:24:56Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 1191,
              "body": "\"after a connection has failed after establishment\" seems recursive, as such failure would be the result of the timeout. Suggestion: \"...how long to wait before aborting a Connection during establishment, or before deciding that a connection has failed after establishment.\"",
              "createdAt": "2018-02-26T19:30:56Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 1228,
              "body": "Why \"may be\"?  The ones above just read \"...is read-only\", which seems better.",
              "createdAt": "2018-02-26T19:32:16Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 1224,
              "body": "Why \"may be\"?  The ones above just read \"...is read-only\", which seems better.",
              "createdAt": "2018-02-26T19:32:32Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            },
            {
              "originalPosition": 1238,
              "body": "In issue #69, I proposed the following text as a replacement for this:\r\n\r\n***\r\nIn order to specify Specific Protocol Properties, Transport System implementations MAY offer applications to attach a set of options to the Preconnection object, associated with a specific protocol. For example, an application could specify a set of TCP Options to use if and only if TCP is selected by the system. Such properties MUST NOT be assumed to apply across different protocols.\r\n***\r\n\r\nIf you don't agree with the RFC21119 style keywords, don't capitalize them. If you generally don't agree with this text replacement, at least remove \", and options around Acknowledgement Stretching\", please.",
              "createdAt": "2018-02-26T19:34:37Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NTY4MjI=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:35:10Z",
          "updatedAt": "2018-02-26T20:35:10Z",
          "comments": [
            {
              "originalPosition": 1224,
              "body": "This one seems like `setsockopt(SO_SNDBUF)` to me... i.e., since the maximum non-partial size is a function of stack and system buffers, you might be able to change it. Happy to \"is read only\" this for London though.",
              "createdAt": "2018-02-26T20:35:10Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NTc1OTQ=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:37:18Z",
          "updatedAt": "2018-02-26T20:37:18Z",
          "comments": [
            {
              "originalPosition": 1238,
              "body": "ACK. I'd like to keep the part about not raising errors though...",
              "createdAt": "2018-02-26T20:37:18Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NTk0NTM=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:43:07Z",
          "updatedAt": "2018-02-26T20:43:07Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "Partial messages are different than deframed messages. However, the two play nicely together: if you have a non-framing Protocol Stack with vanilla TCP on top, and you have a deframer that knows how to split the stream into application layer messages, you might still end up in a situation where the framer says \"hey, I got a length-prefixed thing that says it's 24MB\" and the system only supports buffering messages 512kB at a time. So the deframer would chop the stream up into buffer-sized Partials and pass them up.\r\n\r\n(Indeed, in the degenerate case where you're running on vanilla TCP and you don't pass a deframer down, the system default deframer would treat the entire stream as a single giant message, and pass partials down according to its own buffering and scheduling requirements)...\r\n\r\nNot really clear what the problem is. Suggest we defer to London.",
              "createdAt": "2018-02-26T20:43:07Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NjEyNTI=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:48:54Z",
          "updatedAt": "2018-02-26T20:48:54Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "I'm fine with deferring the discussion to London, but until then I consider this paragraph as wrong and don't think it should be added. We're trying to kick out stuff for which we don't have consensus - so: first convince me, then add it, not vice versa.",
              "createdAt": "2018-02-26T20:48:54Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NjE0ODQ=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:49:38Z",
          "updatedAt": "2018-02-26T20:49:38Z",
          "comments": [
            {
              "originalPosition": 1238,
              "body": "Ah, sure, yes, I missed this in my suggested text update.",
              "createdAt": "2018-02-26T20:49:38Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NjI4MjY=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:53:47Z",
          "updatedAt": "2018-02-26T20:53:47Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "I'd really like to see this left in, and I thought it had been discussed and agreed in Cambridge? Either way, let's discuss more for sure, but I think is necessary to have a document that actually works for these protocol use cases. If we decide some other way, we can change it, but I think we need this text in here for London.\r\n\r\n@mwelzl one point to re-iterate is that the notion of Message does not need to match between the two sides\u2014it's just a matter of how a local side parses bytes on a connection into chunks.",
              "createdAt": "2018-02-26T20:53:47Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NjI5NTU=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T20:54:14Z",
          "updatedAt": "2018-02-26T20:54:15Z",
          "comments": [
            {
              "originalPosition": 985,
              "body": "yeah i kind of hate \"instantaneous capacity profile\" as a name (\"timeliness\" isn't great either, though\"); inclined to leave this as is and revisit after we decide on #90.",
              "createdAt": "2018-02-26T20:54:14Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0Njk3OTA=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:14:53Z",
          "updatedAt": "2018-02-26T21:14:54Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "so it's clear that we need partial message support on both send and receive, simply because there are buffers in the world. we handwaved on this wildly in previous revisions of this document (and allowed ourselves to do so because \"content\"). this corrects that.\r\n\r\nI... really don't understand your objection here, Michael (\"this paragraph is bad\" is not extremely helpful). Can you help me out a bit? Is the problem the interplay between deframers and partial messages? Is the text just bad?",
              "createdAt": "2018-02-26T21:14:53Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzAwNTc=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:15:44Z",
          "updatedAt": "2018-02-26T21:15:44Z",
          "comments": [
            {
              "originalPosition": 985,
              "body": "Sure, I agree",
              "createdAt": "2018-02-26T21:15:44Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzAxNTg=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:16:01Z",
          "updatedAt": "2018-02-26T21:16:01Z",
          "comments": [
            {
              "originalPosition": 1191,
              "body": "Oops, missed this one. Fixed.",
              "createdAt": "2018-02-26T21:16:01Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzE4Mzg=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:21:13Z",
          "updatedAt": "2018-02-26T21:21:13Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "Okay. As it's written it doesn't make sense to me - I absolutely agree with having stuff that actually works, but so does NEAT, and NEAT doesn't need this...  maybe I'm missing out on one of your use cases.\r\n\r\nBrian's \"indeed, ...\" bracket above describes exactly what's on my mind: in this case, why would you need to consider this a partial message, and give a \"reference to the full message it belongs to\"?  This seems unnecessary to me.  Can we agree on phrasing this as optional? Phrasing it as factual (as it is now) indicates that there is no other way, which would IMO mean \"no vanilla TCP\". I would be fine with \"In this case, the Message object passed may contain some reference to the full Message it belongs to, as well as the byte range of the data content within the partial Message.\"",
              "createdAt": "2018-02-26T21:21:13Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzM0Mzc=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:26:05Z",
          "updatedAt": "2018-02-26T21:26:05Z",
          "comments": [
            {
              "originalPosition": 1224,
              "body": "Let's go for \"is read only\". JFYI, the background for this (see minset) is indeed an unchangeable value that comes from the transport protocol. E.g., even if you allow fragmentation, UDP has a fixed limit for the size of the message that you can give it.",
              "createdAt": "2018-02-26T21:26:05Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzM3MDY=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:27:03Z",
          "updatedAt": "2018-02-26T21:27:03Z",
          "comments": [
            {
              "originalPosition": 1228,
              "body": "Same rationale as above - a function of the transport protocol, imposing a max value.",
              "createdAt": "2018-02-26T21:27:03Z",
              "updatedAt": "2018-02-26T21:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk0NzUzODc=",
          "commit": {
            "abbreviatedOid": "0720e80"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-26T21:32:25Z",
          "updatedAt": "2018-02-26T21:32:25Z",
          "comments": [
            {
              "originalPosition": 1103,
              "body": "735da31582ec00bbebfd9cd4fa5d04f70a6bad61 contains an attempt to make this more explicit (and to note that vanilla TCP is of course supported). If making \"full message reference\" optional is better, happy to do that. (and done, in 050b051613e8e37b609fe556e3e5f0819329867c)",
              "createdAt": "2018-02-26T21:32:25Z",
              "updatedAt": "2018-02-26T21:33:41Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "09f5fdef146338bb8f2ffb39999dad011abaa425",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "bht-editorial-00",
      "headRefOid": "050b051613e8e37b609fe556e3e5f0819329867c",
      "mergeCommit": {
        "oid": "cfff1738316812f5ff79cf4d79ef1b3f771088ff"
      }
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNDcxNDI4",
      "title": "fix #92 (in Notation); add note on Receive callback.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/99",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-26T19:39:43Z",
      "updatedAt": "2018-04-11T13:22:38Z",
      "closedAt": "2018-02-26T19:41:48Z",
      "mergedAt": "2018-02-26T19:41:48Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "note this one has an edit about Receive callbacks that only makes sense once #96 lands...",
          "createdAt": "2018-02-26T19:40:08Z",
          "updatedAt": "2018-02-26T19:40:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5562cf0be52edbc13e2eb4cb61037559f3cb0562",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "error-handling-92",
      "headRefOid": "701224eed43d5192c1213486e9a8ef58465c2186",
      "mergeCommit": {
        "oid": "08c1ba3afb61c567e9c4f2c077b2574b96289ab5"
      }
    },
    {
      "number": 105,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNjE0OTE1",
      "title": "add API summary (fix #93), ednote cleanup (fix #101)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/105",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T10:07:43Z",
      "updatedAt": "2018-04-11T13:22:35Z",
      "closedAt": "2018-02-27T14:20:29Z",
      "mergedAt": "2018-02-27T14:20:29Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2MjYxNzM=",
          "commit": {
            "abbreviatedOid": "409998e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-27T10:18:56Z",
          "updatedAt": "2018-02-27T10:18:56Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "92fa126906bf44e1c0e66cc9eb892f4df6c06306",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "api-summary",
      "headRefOid": "409998eb65fd228462b4ccf91cdd9815f3c06187",
      "mergeCommit": {
        "oid": "e9d43b3de3ccaab1164c4062722d38c704223448"
      }
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNjIzNjcx",
      "title": "Clone preconnections too (fix #95)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/106",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T10:41:00Z",
      "updatedAt": "2018-04-11T13:22:32Z",
      "closedAt": "2018-02-27T14:20:41Z",
      "mergedAt": "2018-02-27T14:20:41Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NDczODI=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-27T11:27:24Z",
          "updatedAt": "2018-02-27T11:27:33Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "\"tend to yield to connections\" is IMO too weak - it doesn't say anything about how the available capacity is really divided; however, when we DO get a multi-streaming protocol, the capacity division can become quite precise. That's why I included the equation for an \"ideal transport system implementation\". Why not do the same? Let me try:\r\n\r\nAn ideal transport system implementation would assign the Connection the capacity share (M-N) x C / M, where N is the Connection's Niceness value, M is the maximum Niceness value used by all Connections in the group and C is the total available capacity (this assumes that positive integer or float values are used to represent Niceness).",
              "createdAt": "2018-02-27T11:27:24Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NjM5ODc=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T12:30:08Z",
          "updatedAt": "2018-02-27T12:30:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": ":= presumably?",
              "createdAt": "2018-02-27T12:30:09Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NjY2MDc=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T12:39:46Z",
          "updatedAt": "2018-02-27T12:39:46Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Should be explicit that calling `Initiate()`, `Listen()`, or `Rendezvous()` on a cloned `Preconnection` does not cause the other clones to be established, but if they are\u00a0established then they'll be entangled with the existing connection.\r\n\r\nAlso suggest adding: \"If `Clone()` is called on a `Preconnection` that is subsequently established into an active `Connection`, then attempts to change the parameters of the cloned `Preconnection` will fail.\"",
              "createdAt": "2018-02-27T12:39:46Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NzY3Njk=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:15:03Z",
          "updatedAt": "2018-02-27T13:15:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Niceness in send properties is (was originally) specified as a set of discrete classes, as opposed to an inverse numeric priority, but yeah, this is a better way to do it (as long as the \"as it sees fit\" language stays in). will change.",
              "createdAt": "2018-02-27T13:15:03Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NzY4MDk=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:15:09Z",
          "updatedAt": "2018-02-27T13:15:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "yep will change",
              "createdAt": "2018-02-27T13:15:09Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NzY4OTU=",
          "commit": {
            "abbreviatedOid": "97ec122"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:15:25Z",
          "updatedAt": "2018-02-27T13:15:25Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "agreed, will change.",
              "createdAt": "2018-02-27T13:15:25Z",
              "updatedAt": "2018-02-27T13:39:44Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "92fa126906bf44e1c0e66cc9eb892f4df6c06306",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "preclone",
      "headRefOid": "63bc41cf0fee4411ed813b01d87f4a21ca0e1cfd",
      "mergeCommit": {
        "oid": "ae81b9633703c619e4eee4cf9e18857fb00fc414"
      }
    },
    {
      "number": 107,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNjMxNzE0",
      "title": "Fixes to sending and receiving messages to support vanilla TCP",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/107",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The previous text didn't support sending multiple messages across vanilla TCP without framers/deframers or a top-level protocol in the stack that would de-frame. This change allows sending multiple messages across vanilla TCP and handing them over as bytes to an application that, by itself, detects message boundaries from the chunks of bytes that it gets.",
      "createdAt": "2018-02-27T11:14:01Z",
      "updatedAt": "2018-02-28T10:32:26Z",
      "closedAt": "2018-02-28T10:32:26Z",
      "mergedAt": "2018-02-28T10:32:26Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems we never came to consensus over the main issue here - we did have consensus that it's fine to have framers and deframers. It seems that the crux of the matter is the following:\r\n\r\nTommy and you want: a sender saying \"the frame ends here\" will terminate a TCP connection; so if you really really want to hand over multiple chunks of data from a stream, then you should use one huge message and only terminate when finished with everything.\r\n\r\nI don't want that, for the reason I explained so often under the heading \"Application-Framed Bytestream\": the sending application doesn't know whether it gets vanilla TCP or e.g. SCTP. If it gets SCTP, messages can be sent as messages, with all their properties: lifetime, unordered delivery ...   but this can only work if the sender knows that messages are messages. If the transport system gets TCP, however, it must be able to send the messages\u00a0directly on the bytestream. Either way this is fine as long as the receiving application is able to determine boundaries in the chunk of data that it gets: in case of SCTP, it really does get messages, in case of TCP, it gets a bytestream.\r\n\r\nBy requiring \"atomic\" message transmission from one end to the other, and not being able to send multiple messages on a single TCP connection, this functionality becomes unavailable.\r\n\r\nIf this seems confusing, please consider taking another look at the animations, e.g. here:\r\nhttp://heim.ifi.uio.no/michawe/research/publications/ietf98-taps-discussion.pptx\r\n\r\nIf you want a longer, more detailed explanation, please read:\r\nhttps://tools.ietf.org/html/draft-ietf-taps-minset-01#appendix-A.3.1\r\n\r\nIf you don't believe this can work, please download and test NEAT.\r\n\r\nI don't understand all this \"a TCP connection represents a large message business\". It's a strange limit that gets in the way of efficiently falling back to vanilla TCP.",
          "createdAt": "2018-02-27T13:28:58Z",
          "updatedAt": "2018-02-27T13:28:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "our lack of consensus seems to me to come from a giant pile of subtle misunderstandings:\r\n\r\n> Tommy and you want: a sender saying \"the frame ends here\" will terminate a TCP connection; \r\n\r\nnope. Well, at least I don't want this. This would be silly. \r\n\r\nThere's no guarantee that one side of a connection using this interface will be connected to another side of a connection also using the interface. Message sends are passed down to the underlying protocol stack atomically, so that stacks that do indeed support boundary preservation have boundaries. If you get TCP, it'll ignore the boundaries, and hope the other side provides deframing. (If a sender absolutely requires atomicity without relying on receiver-side deframing, it could prohibit the selection of protocol stacks that don't support it, of course.) \r\n\r\n> By requiring \"atomic\" message transmission from one end to the other, and not being able to send multiple messages on a single TCP connection, this functionality becomes unavailable.\r\n\r\nBut we don't require atomic message transmission. We require an API which presents atomic message transmission to the application when it is available, and allows (asks) for the application to help provide this when it is not.\r\n\r\nHere's what this looks like when a sender writes multiple messages on a stack not supporting boundary preservation to a receiver not running this interface:\r\n\r\n```\r\n  sender [msg 1] [msg 2] [msg 3] -> TCP [bytes 1] [bytes 2] [bytes 3] -> receiver [pile of bytes] -> application layer parser\r\n```\r\n\r\nThe receiver gets a pile or bytes in order and hands them to an app layer parser, just like in TCP.\r\n\r\nHere's what this looks like when a TCP only-sender writes three app-layer-delimited messages to a stream to a receiver running this interface with deframers:\r\n\r\n```\r\nTCP [bytes 1] [bytes 2] [bytes 3] -> interface deframer [msg 1] [msg 2] [msg 3] -> receiver\r\n```\r\n\r\nThe receiver pushed the deframe logic down into the interface, and got to simplify its own workflow -- every callback has an atomic message.\r\n\r\nHere's what this looks like in the case this PR seems to care about: TCP, no deframer:\r\n\r\n```\r\nTCP [bytes 1] [bytes 2] [bytes 3] -> receiver [pile of partial messages containing bytes 1-3 in order] -> application layer parser\r\n```\r\n\r\nJust like the TCP case above. Each `Received<>` event is just like a stream `read()` call in TCP. (I can, indeed, see why you'd want to provide length hints to `Receive()` to support this, and I think we should add that.)\r\n\r\n> If you don't believe this can work, please download and test NEAT.\r\n\r\nI believe it can work, that's not the question at all. I just don't think it's a very useful abstraction if a goal of building a new interface is moving application development away from stream-centric assumptions in order to allow it to take advantage of new transports that provide better-than-single-stream abstractions. \r\n\r\n> I don't understand all this \"a TCP connection represents a large message business\". It's a strange limit that gets in the way of efficiently falling back to vanilla TCP.\r\n\r\nThere's no limit here. To translate this interface into bytestream thinking: a partial message is simply a section of a bytestream with a running offset (which can itself be calculated trivially by the stack or the system). When a receiver doesn't have enough information to atomize messages, it presents bytestream(s) as partials.",
          "createdAt": "2018-02-27T14:19:05Z",
          "updatedAt": "2018-02-27T14:19:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So in this comment, I agree with absolutely everything. Just two comments:\r\n\r\n\r\n> > Tommy and you want: a sender saying \"the frame ends here\" will terminate a TCP connection;\r\n> nope. Well, at least I don't want this. This would be silly.\r\n\r\nGreat!!   But I was under the strong impression that this is what Tommy wants because of things that he wrote, both in the text and in issue #79. Fantastic if I misunderstood all that, but then my suggested text changes should be fine. All I want is to allow:\r\n1) sending many messages (multiple \"message over\" markers from the application) over a single TCP connection\r\n2) receiving blocks of data (similar to normal TCP data reception today) from which an application determines where messages begin and end.\r\n\r\n\r\n> (I can, indeed, see why you'd want to provide length hints to Receive() to support this, and I think we should add that.)\r\n\r\nJust for the record, that didn't come from me - I suspect it was from Tommy. Anyway, it makes sense to me as well.\r\n",
          "createdAt": "2018-02-27T14:48:34Z",
          "updatedAt": "2018-02-27T14:48:34Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n\r\n> > (I can, indeed, see why you'd want to provide length hints to Receive() to support this, and I think we should add that.)\r\n\r\n> Just for the record, that didn't come from me - I suspect it was from Tommy. Anyway, it makes sense to me as well.\r\n\r\nhm i think that might have been me. such is the nature of the pile of confusions...",
          "createdAt": "2018-02-27T15:18:58Z",
          "updatedAt": "2018-02-27T15:18:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> All I want is to allow:\r\n> 1. sending many messages (multiple \"message over\" markers from the application) over a single TCP connection\r\n\r\nwith the caveat that these might be completely lost on send, yep, absolutely we need to allow this.\r\n\r\n> 2. receiving blocks of data (similar to normal TCP data reception today) from which an application determines where messages begin and end.\r\n\r\nyep, with the caveat that we do not yet have a way to pass the max length the application wants to receive (but can easily add this).\r\n\r\n> but then my suggested text changes should be fine\r\n\r\nHm, I think you still need the \"this is a partial message\" indicator on the receive (which of course the application knows, but allowing the \"partial message\" marker to be omitted when the underlying transport / deframe stack doesn't have any boundary information seems like a contract violation to me.",
          "createdAt": "2018-02-27T15:21:44Z",
          "updatedAt": "2018-02-27T15:21:44Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 1. sending many messages (multiple \"message over\" markers from the application) over \r\n> a single TCP connection\r\n\r\nYes, of course. Same as happens today.\r\n\r\n> 2. receiving blocks of data (similar to normal TCP data reception today) from which an \r\n> application determines where messages begin and end.\r\n\r\nYes, although the way I was envisaging this working was that the application provides a de-framing function to the stack, and that de-framing function determines where the messages begin and end, so that what's returned are complete messages. That way, you get a message based abstraction even if running over a byte-stream transport like TCP.\r\n",
          "createdAt": "2018-02-27T15:30:28Z",
          "updatedAt": "2018-02-27T15:30:28Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the caveats you list above, that's all fine. About this:\r\n\r\n> Hm, I think you still need the \"this is a partial message\" indicator on the receive (which of course the application knows, but allowing the \"partial message\" marker to be omitted when the underlying transport / deframe stack doesn't have any boundary information seems like a contract violation to me.\r\n\r\nThe point is that the receiving application must be able to know if it did get a complete message. When it does, the transport system can say so, so there you get your contract. When it does not, the receiver-side transport system may not know about it because it doesn't know about sender-supported message boundaries in the first place (the first of your two mentioned caveats). If it got the data as a TCP stream, then at best, it can say \"perhaps this isn't a complete message, I'm not sure\", but it certainly can't provide the other things your text requires in this case (whether it's a partial message, a reference to the complete message, ..).\r\n\r\nIf we phrase it as I suggest, I think we break no contract and we promise as much as we can promise.",
          "createdAt": "2018-02-27T15:31:41Z",
          "updatedAt": "2018-02-27T15:31:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AHHHH okay.\r\n\r\nActually, I think this should be a three-state indicator:\r\n\r\n(1) This is a complete message (known because the deframer said so, or the transport stack did).\r\n(2) This is a partial message containing a section of a message with a known message boundary (made partial for local buffering reasons, either by the underlying protocol stack or the deframer)\r\n(3) This is a partial message containing a data with no definite message boundary (i.e. stream protocol and no deframer)...",
          "createdAt": "2018-02-27T15:37:09Z",
          "updatedAt": "2018-02-27T15:37:09Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CONVERGED!  I agree with the 3-state indicator proposal  :)",
          "createdAt": "2018-02-27T15:45:58Z",
          "updatedAt": "2018-02-27T15:45:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I like your last list of three, but I will still point out that over any stream protocol with no deframer, there will be a definite end to received data (the equivalent of a FIN).\r\n\r\nMy previous comments about FINs, etc, were just to point out that it is possible to map a stream this way. If we're doing HTTP/2 or QUIC streams, we may indeed want the end of the message to correspond to the end of the stream, since HTTP over HTTP/2 generally will do one request per stream identifier. However, I had also mentioned that it is possible to have the stream protocol ignore any claimed message boundaries, but this means that the message boundaries are understood to be lost when mapped into the bytes on the wire.",
          "createdAt": "2018-02-27T15:47:55Z",
          "updatedAt": "2018-02-27T15:47:55Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram yes..... I _think_ that makes sense",
          "createdAt": "2018-02-27T15:50:30Z",
          "updatedAt": "2018-02-27T15:50:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly - this sounds fine!  (phew!)    So we agree that a sender can send 50 small messages over a single connection (each marked with \"end of message\"), right? And when the transport system ends up using vanilla TCP, and the receiver-side application then wants to obtain the messages, it must provide a deframer (note that the \"must\" here is new to me, but I think it's fine and probably even a good idea in order to do cooler things later).",
          "createdAt": "2018-02-27T16:12:29Z",
          "updatedAt": "2018-02-27T16:12:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> but I will still point out that over any stream protocol with no deframer, there will be a definite end to received data (the equivalent of a FIN).\r\n\r\nWell, yes... but the application won't know what the end is *until* it sees the FIN. so s/no definite message boundary/no known message boundary/ in state 3?\r\n\r\n(git logistics question: @mwelzl, do you want to update this branch (which will automatically update the PR) with receive length and three-state partials, or shall we land this PR then do those in another?)",
          "createdAt": "2018-02-27T16:47:11Z",
          "updatedAt": "2018-02-27T16:47:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll update the PR next  (first time I'm doing this - sorry for being clumsy)",
          "createdAt": "2018-02-27T17:20:21Z",
          "updatedAt": "2018-02-27T17:20:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good to me now. I'll do a separate PR to add receive size to the API.",
          "createdAt": "2018-02-28T09:57:34Z",
          "updatedAt": "2018-02-28T09:57:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, sorry, I forgot this to do this (receive size); thanks!",
          "createdAt": "2018-02-28T10:08:54Z",
          "updatedAt": "2018-02-28T10:08:54Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...see #121 ",
          "createdAt": "2018-02-28T10:13:25Z",
          "updatedAt": "2018-02-28T10:13:25Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will land both of these; open subsequent issues if we need to tweak the text, but IMO this is certainly -00 quality...",
          "createdAt": "2018-02-28T10:32:17Z",
          "updatedAt": "2018-02-28T10:32:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2Njc4ODk=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-27T12:44:27Z",
          "updatedAt": "2018-02-27T12:50:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't get it: if you don't supply a deframer for a byte-stream protocol, how does the top-level protocol provide the abstraction of framed messages over the connection? Surely the point of the deframer is to provide this.",
              "createdAt": "2018-02-27T12:44:27Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NzMyNzg=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:03:15Z",
          "updatedAt": "2018-02-27T13:03:16Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Surely that's the point of a deframer, but if the top-level protocol (I assumed that this is the top-level *inside* the transport system) is e.g. HTTP or SCTP, it knows where messages begin and end.",
              "createdAt": "2018-02-27T13:03:16Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2NzE0NDY=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I really don't understand the problem this PR is meant to solve. \r\n\r\nAs discussed in Cambridge (and I thought we'd come to consensus on this), messages are atomic, and for applications that don't care about message atomicity, partial messages give you streams.\r\n\r\nI will note that it probably makes sense to add a message length limit to the Receive() call, so that an application can say how much of a message it's willing to  accept on a per message basis, which would also be used for the max read size parameter when using partials as streams. It might also make sense, for people who reallyreallyreallyreally want streams, to point out more explicitly that partials are the way to do that.",
          "createdAt": "2018-02-27T12:56:59Z",
          "updatedAt": "2018-02-27T13:03:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't get this. Handing a message to a receiver without telling it that it's partial risks incorrect functionality. If the API is going to break its contract that messages are meaningfully atomic (albeit because the application told it to), then it has a responsibility to indicate this (even if the application ignores it)",
              "createdAt": "2018-02-27T12:56:59Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            },
            {
              "originalPosition": 14,
              "body": "It seems important to leave this in (though on reading I can see that it might be useful to use less potentially-but-unintentionally-pejorative word than \"degenerate\" as an adjective for this case)",
              "createdAt": "2018-02-27T13:00:17Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2ODIxNDQ=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:31:54Z",
          "updatedAt": "2018-02-27T13:31:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, right. We can fix this by flipping the logic. I suggest to replace:\r\n\r\nIn this case, the Message object passed to Received may contain an indication\r\nthat the object received is partial, the byte offset of the data in the\r\npartial Message within the full Message, an indication whether this is the\r\nlast (highest-offset) partial Message in the full Message, and an optional\r\nreference to the full Message it belongs to.\r\n\r\nwith:\r\n\r\nComplete Messages passed to Received are marked as such.\r\nWhen a message is incomplete, it may contain an indication\r\nthat the object received is partial, the byte offset of the data in the\r\npartial Message within the full Message, an indication whether this is the\r\nlast (highest-offset) partial Message in the full Message, and an optional\r\nreference to the full Message it belongs to.\r\n\r\n\r\n... now, no more contract broken. You know what you get.",
              "createdAt": "2018-02-27T13:31:54Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk2ODI2ODA=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T13:33:34Z",
          "updatedAt": "2018-02-27T13:33:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's not about the word \"degenerate\": it hints at \"the FIN indicates the end of a message\", which is a bad idea.",
              "createdAt": "2018-02-27T13:33:34Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MTIwODc=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T14:50:14Z",
          "updatedAt": "2018-02-27T14:50:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "If you insist on keeping this, please give better arguments than \"it seems important\" - because to me this text is confusing and potentially misleading.",
              "createdAt": "2018-02-27T14:50:14Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MTIzMDI=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T14:50:44Z",
          "updatedAt": "2018-02-27T14:50:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Do we agree on this replacement?",
              "createdAt": "2018-02-27T14:50:44Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MjUyMjc=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:21:22Z",
          "updatedAt": "2018-02-27T15:21:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "If you have HTTP over TCP, then you have an HTTP deframer, surely? ",
              "createdAt": "2018-02-27T15:21:22Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MjYxNDM=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:23:33Z",
          "updatedAt": "2018-02-27T15:23:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "If you have a raw TCP connection with no framing protocol specified, how else do you know when the Message ends other than the end of the Connection? (i.e., the FIN indicates the end of message)\r\n\r\nNote, though, that this is an extremely rare case, since you almost always have a framing protocol.",
              "createdAt": "2018-02-27T15:23:33Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MjY2ODM=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:24:51Z",
          "updatedAt": "2018-02-27T15:24:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "So your point is that the receiving application MUST tell the transport system about its deframer?",
              "createdAt": "2018-02-27T15:24:51Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3Mjk3OTI=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:31:59Z",
          "updatedAt": "2018-02-27T15:31:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes. This doesn't change anything on the wire, or affect interoperability with existing endpoints or protocols, it just means the application gives the de-framing function to the stack to run, rather than doing it itself.",
              "createdAt": "2018-02-27T15:31:59Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MzIyNzE=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:37:41Z",
          "updatedAt": "2018-02-27T15:37:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I see. Sure, this way, it can work. It wasn't clear to me that, in order to obtain messages, a receiver MUST provide a de-framer. I'm not sure this is very explicit in the text?",
              "createdAt": "2018-02-27T15:37:41Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MzU1Mjc=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T15:45:00Z",
          "updatedAt": "2018-02-27T15:45:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This is connected to the discussion above: I now understand that you interpret this statement as \"if you want anything better than the entire connection to be one huge message, you MUST provide a deframer\".  So this is a way of saying \"you really MUST provide a deframer.\" Now I think I also understand why Brian thought this is important. So, I think that's okay... I understand that this is a good idea because the transport system could then even apply this on the TCP byte stream (provided it has access to it) in order to cut out messages that arrive out of order. But then (for -01 ?) we should add such a flag to the receiver side to optionally offer, to do these Minion / Hollywood - like things.\r\n\r\nAnyway. If my interpretation above is right, then I agree to keep this sentence.",
              "createdAt": "2018-02-27T15:45:00Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NjIxNTY=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T16:45:05Z",
          "updatedAt": "2018-02-27T16:45:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The point of this paragraph was to describe how you can send multiple message using a framer. I don't think we should add \"without a deframer\", since the point was to describe the framer.",
              "createdAt": "2018-02-27T16:45:05Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NjI1MDY=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T16:45:54Z",
          "updatedAt": "2018-02-27T16:45:54Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This part looks fine to me.",
              "createdAt": "2018-02-27T16:45:54Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NjMyNzU=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T16:47:38Z",
          "updatedAt": "2018-02-27T16:47:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "A deframer *is* a layer of framing above TCP. So this is saying \"if you don't have a deframer, use a deframer\". I think that if you choose not to use a deframer, you should at the very least get an indication that a FIN has been received by the received content being marked as complete. That was actually a big problem for stream clients we had when we didn't give them this bit.",
              "createdAt": "2018-02-27T16:47:38Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NjM3OTk=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Still needs a bit of work on the no-framing case, especially when receiving the end of the stream. This should be indicated, and the complete-message bit seems to be the cleanest thing.",
          "createdAt": "2018-02-27T16:48:56Z",
          "updatedAt": "2018-02-27T16:48:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NzU2MTU=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T17:18:32Z",
          "updatedAt": "2018-02-27T17:18:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I get it now, agreed",
              "createdAt": "2018-02-27T17:18:32Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3Nzk5ODc=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T17:30:13Z",
          "updatedAt": "2018-02-27T17:30:13Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Sorry about the language silliness, which I'll fix. But: a \"layer of framing\" could also be taken to mean a protocol - something that the sender and receiver both know about, e.g. HTTP/TCP inside the transport system.\r\n\r\nThe part I dislike about the original text is: \"That means that if the application can make several Send calls to enqueue subsequent data chunks for the same Message to continue writing, but marking the Message complete corresponds to closing the sending stream.\"   Besides the sentence being broken, this again sounds like prohibiting my wish of \"sending 50 short messages across a single connection\".\r\n\r\nI also generally find it strange to conflate \"end of message\" with \"FIN\" because the latter means \"connection closed\". You can always tell your applications that the remote endpoint has closed.",
              "createdAt": "2018-02-27T17:30:13Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3ODM1MjQ=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T17:39:42Z",
          "updatedAt": "2018-02-27T17:39:42Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "There's a very important difference between \"connection closed/finished\" and one side sending a FIN. I can send a write-close after my initial request, and still keep the TCP connection up for a long time. If an application needs to know when the other send send the end-of-message/file, then that should be communicated in the Receive path, not in an event that \"Connection Finished\", which generally implies no more traffic at all.",
              "createdAt": "2018-02-27T17:39:42Z",
              "updatedAt": "2018-02-27T17:48:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3OTQ2NDM=",
          "commit": {
            "abbreviatedOid": "59f0f57"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-27T18:10:37Z",
          "updatedAt": "2018-02-27T18:10:37Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "But we do not have a write-close so in the current API I guess the Close call is what will generate the FIN, correct? I am fine this being communicated in the receive path, but I think the \"Connection Finished\" will also follow from the FIN.",
              "createdAt": "2018-02-27T18:10:37Z",
              "updatedAt": "2018-02-27T18:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDAwMTQ3",
          "commit": {
            "abbreviatedOid": "f113fc9"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-28T09:56:54Z",
          "updatedAt": "2018-02-28T09:56:54Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "92fa126906bf44e1c0e66cc9eb892f4df6c06306",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "f113fc9b02fc4476d84c2ce2f40c0c4e06731b30",
      "mergeCommit": {
        "oid": "aaa7a096c8d6a4c1b1fb1fc08e82b577fd60e2a7"
      }
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNjU3NzE0",
      "title": "Complete my author block",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/115",
      "state": "MERGED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T13:11:09Z",
      "updatedAt": "2018-02-27T15:06:36Z",
      "closedAt": "2018-02-27T14:45:52Z",
      "mergedAt": "2018-02-27T14:45:52Z",
      "mergedBy": "abrunstrom",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d8e6910c243ec442df1eebcbc59729268be2ea10",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tj/author-block",
      "headRefOid": "b88bdfc6d5335d75d2025b22b0798048f8e35600",
      "mergeCommit": {
        "oid": "7adbaa1d7a4952c9995c05a38c3306e743b596ac"
      }
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNjg1NDAy",
      "title": "cut C (fix #104), replace B with ref to content (fix #114)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/116",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T14:53:22Z",
      "updatedAt": "2018-04-11T13:22:30Z",
      "closedAt": "2018-02-27T16:05:59Z",
      "mergedAt": "2018-02-27T16:05:59Z",
      "mergedBy": "theri",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3MzYwODM=",
          "commit": {
            "abbreviatedOid": "837c617"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me",
          "createdAt": "2018-02-27T15:46:25Z",
          "updatedAt": "2018-02-27T15:46:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NDQzNTg=",
          "commit": {
            "abbreviatedOid": "837c617"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2018-02-27T16:04:19Z",
          "updatedAt": "2018-02-27T16:04:19Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7adbaa1d7a4952c9995c05a38c3306e743b596ac",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "appendectomy",
      "headRefOid": "837c617be27d0f07d9aa9803a315f36e30e30bdf",
      "mergeCommit": {
        "oid": "e3dd72f9fa881ab89f3b2dc277b7e272b94c11c6"
      }
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNzI0NzQ5",
      "title": "move timeout suggestion to appendix A (see #109)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/117",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T17:02:06Z",
      "updatedAt": "2018-04-11T13:22:27Z",
      "closedAt": "2018-02-27T17:16:38Z",
      "mergedAt": "2018-02-27T17:16:38Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NzIxODM=",
          "commit": {
            "abbreviatedOid": "3b21a17"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Suggest adding a reference to the GitHub issue in the appendix, along with the text, to remind us that there's more to do here. Otherwise looks good.",
          "createdAt": "2018-02-27T17:09:22Z",
          "updatedAt": "2018-02-27T17:09:22Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3dd72f9fa881ab89f3b2dc277b7e272b94c11c6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "we-dont-believe-in-timeouts-yet",
      "headRefOid": "2b1e088e4da95f2211647a3c3690593d220c6480",
      "mergeCommit": {
        "oid": "ce706c85278dbd42459587336024f70fae2d7f76"
      }
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNzI3MTY2",
      "title": "efficient grouping is multiplexing (fix #108)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/118",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T17:10:47Z",
      "updatedAt": "2018-04-11T13:22:29Z",
      "closedAt": "2018-02-27T17:16:52Z",
      "mergedAt": "2018-02-27T17:16:52Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk3NzQ3ODc=",
          "commit": {
            "abbreviatedOid": "7fdf808"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-27T17:16:16Z",
          "updatedAt": "2018-02-27T17:16:16Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3dd72f9fa881ab89f3b2dc277b7e272b94c11c6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "call-multiplexing-muliplexing",
      "headRefOid": "7fdf8086e9a9eedc87e970374217cbf5bdbc07d8",
      "mergeCommit": {
        "oid": "63be8bdc6828b52ef73d4cea85b4309e7e098316"
      }
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNzMyNDU4",
      "title": "enumerate special notifications (fix #110)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/119",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T17:30:56Z",
      "updatedAt": "2018-04-11T13:22:25Z",
      "closedAt": "2018-02-28T09:54:19Z",
      "mergedAt": "2018-02-28T09:54:19Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk5MTg5MTU=",
          "commit": {
            "abbreviatedOid": "82ad1b4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-28T01:31:18Z",
          "updatedAt": "2018-02-28T01:31:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTk5ODYxMjA=",
          "commit": {
            "abbreviatedOid": "82ad1b4"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-02-28T09:10:52Z",
          "updatedAt": "2018-02-28T09:10:52Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "4386624382a67270c0d39e6b1923b26103fce18b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "unspecial-notifications",
      "headRefOid": "82ad1b44cc037cf283218fd0bf5a5bd5934ac2c1",
      "mergeCommit": {
        "oid": "a092f3f498a6f37c8d9ab9c4543c10f96cc60b85"
      }
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxOTA4MzI2",
      "title": "add maxLength to receive (fix #120)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/121",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-28T10:13:02Z",
      "updatedAt": "2018-04-11T13:22:24Z",
      "closedAt": "2018-02-28T10:32:37Z",
      "mergedAt": "2018-02-28T10:32:37Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDA5NDQx",
          "commit": {
            "abbreviatedOid": "9f083e0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-28T10:26:16Z",
          "updatedAt": "2018-02-28T10:26:16Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a092f3f498a6f37c8d9ab9c4543c10f96cc60b85",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "receive-size",
      "headRefOid": "9f083e0496c777ee4253f90d84d2ebf276752fcf",
      "mergeCommit": {
        "oid": "330ad41b0e4efbf2d28239ecb663cfef48457908"
      }
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxOTI0OTMz",
      "title": "Intents implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/122",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Implementation draft, we add text to explain how Application Intents can be implemented in a transport system.\r\nThe two main functions are Path Selection, which can be implemented by ranking branches in the tree of connection options that will be raced, and Protocol Configuration, which happens after the racing is complete and a protocol stack has been chosen.",
      "createdAt": "2018-02-28T11:21:06Z",
      "updatedAt": "2018-04-11T13:23:35Z",
      "closedAt": "2018-03-02T00:16:39Z",
      "mergedAt": "2018-03-02T00:16:39Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Commit #9d3bf58 should address all changes requested - please reconsider your reviews",
          "createdAt": "2018-03-01T09:57:32Z",
          "updatedAt": "2018-03-01T09:57:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDI3MzQ2",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-28T11:26:30Z",
          "updatedAt": "2018-02-28T11:33:23Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "For each of these path properties, I'd ask: \"how can you know?\". Please give an example.",
              "createdAt": "2018-02-28T11:26:30Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 48,
              "body": "But again I'd like to know how you know about the path property - in this case, the expected completion time per path. Is this from previous measurements?",
              "createdAt": "2018-02-28T11:27:39Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 51,
              "body": "And again, how do you know about this path property?",
              "createdAt": "2018-02-28T11:28:12Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 71,
              "body": "But this is now already written for the \"instantaneous capacity profile\". Maybe remove \"traffic category, capacity profile\" here, or write TBD in case the intention is to be broader than what the \"instantaneous capacity profile\" offers?",
              "createdAt": "2018-02-28T11:30:53Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 73,
              "body": "My immediate reaction to this is this max cwnd would limit the \"max. bitrate\", not the bitrate - which goes back to my prior comment that a bitrate is an average over a certain time interval, and so this is a pretty vague parameter. But I haven't had time to read the Trickle paper yet (btw thanks for the reference). So I think this can be left standing as it is, for now.",
              "createdAt": "2018-02-28T11:32:38Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDM3OTIz",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T12:07:30Z",
          "updatedAt": "2018-02-28T12:07:30Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We can observe the maximum throughput over time in a performance cache, which we use as an estimate of the available bandwidth. I added some clarification to the parts you marked as well as one sentence to Section 8.2 (Performance Caches).",
              "createdAt": "2018-02-28T12:07:30Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDM4MzIy",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T12:09:03Z",
          "updatedAt": "2018-02-28T12:09:03Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Yes, we use cached performance estimates of Round Trip Time and expected maximum bandwidth to compute an estimated completion time on the paths. I modified the text to clarify this.",
              "createdAt": "2018-02-28T12:09:03Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDQxMzMz",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T12:20:28Z",
          "updatedAt": "2018-02-28T12:20:28Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Indeed the Capacity Profile in the current API draft already reflects most of what we specify here, although we may get broader in the future as we figure out the relation between Capacity Profile, our Timeliness Intent, and our Category Intent, which I think is a post-London discussion.\r\nNevertheless, I think it makes sense to mention Protocol Configuration aspects from the API draft in the Implementation draft, too, also for including the Capacity Profile. Do you agree with this in general?",
              "createdAt": "2018-02-28T12:20:28Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDQyMDM0",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T12:23:06Z",
          "updatedAt": "2018-02-28T12:23:06Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "In general yes, but my point is that this text repeats pretty much what I've already written in the implementation draft - if you search for Nagle or DSCP you'll see it",
              "createdAt": "2018-02-28T12:23:06Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDUyMTMw",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T13:00:04Z",
          "updatedAt": "2018-02-28T13:00:04Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Oh, now I see, that was an oversight on our part, sorry.\r\nI removed the part for now, broadening the concept is TBD post-London.",
              "createdAt": "2018-02-28T13:00:04Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDUzMTMx",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T13:03:30Z",
          "updatedAt": "2018-02-28T13:03:30Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "If we call this Maximum Bitrate to be Sent instead, does it fix the problem?\r\n\r\nAlso, as the Send Bitrate was now the only \"Protocol Configuration\" and we think that it also fits as a Send Parameter (e.g., if the message is an entire video being streamed), we moved the Send Bitrate to the \"Send Parameters\" (Section 5.1.1.1).",
              "createdAt": "2018-02-28T13:03:30Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMTIxODgx",
          "commit": {
            "abbreviatedOid": "40a909a"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "As the Application Intents have been moved to the appendix of the API draft for London I would not insert them in the main text for the implementation draft for London. I think it would be better to exemplify the ranking of branches using some of the Protocol and Path Selection Properties. Just one or two examples perhaps? We could add the application intents to an appendix also for the implementation draft or save it for later. ",
          "createdAt": "2018-02-28T16:03:34Z",
          "updatedAt": "2018-02-28T16:03:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMTUzNzY2",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-28T17:25:42Z",
          "updatedAt": "2018-02-28T17:32:10Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Can we call this step \"sorting\" rather than \"ranking\"? This would be more in line with Happy Eyeballs (https://tools.ietf.org/html/rfc8305#section-4)",
              "createdAt": "2018-02-28T17:25:42Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 34,
              "body": "Let's leave off Application Intents here, since that's still just in the appendix of the API for now.",
              "createdAt": "2018-02-28T17:27:11Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 39,
              "body": "I disagree with the approach here: we shouldn't:\r\n\r\n1. Gather all possible paths into a tree\r\n2. During sorting, prune out the ones that aren't allowed\r\n\r\nInstead, it's simpler to:\r\n\r\n1. Gather all permissible paths\r\n2. Sort them for preference\r\n\r\nEssentially, the pruning is already covered by Candidate Gathering. We can add more text there to emphasize that (it already has \"This list is determined by the requirements, prohibitions, and preferences of the application as specified in the Path Selection Properties and Protocol Selection Properties.\"), but that's where that operation belongs.",
              "createdAt": "2018-02-28T17:29:45Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 50,
              "body": "Please remove items that are still just in the appendix and not agreed upon for now. (that's Size, Bitrate, and Cost)",
              "createdAt": "2018-02-28T17:31:11Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 67,
              "body": "Let's remove this until it gets out of the appendix",
              "createdAt": "2018-02-28T17:31:48Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            },
            {
              "originalPosition": 78,
              "body": "Great!",
              "createdAt": "2018-02-28T17:32:05Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMzU1NDk2",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T09:03:47Z",
          "updatedAt": "2018-03-01T09:03:47Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I am fine with renaming it \u2013 needs a little more explanation then, but we can do that",
              "createdAt": "2018-03-01T09:03:47Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMzU2Mjg0",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T09:06:47Z",
          "updatedAt": "2018-03-01T09:06:47Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I guess we can move them to an appendix for now - completely removing them makes this pull-request pointless.",
              "createdAt": "2018-03-01T09:06:47Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMzU2NDIx",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T09:07:22Z",
          "updatedAt": "2018-03-01T09:07:23Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Same as above \u2013 moving it to an appendix for now",
              "createdAt": "2018-03-01T09:07:22Z",
              "updatedAt": "2018-03-01T09:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMzY4MTM2",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T09:48:13Z",
          "updatedAt": "2018-03-01T09:48:13Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Should be addressed now by #8ecb7df",
              "createdAt": "2018-03-01T09:48:13Z",
              "updatedAt": "2018-03-01T09:48:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMzY5MzQz",
          "commit": {
            "abbreviatedOid": "be9c014"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T09:52:09Z",
          "updatedAt": "2018-03-01T09:52:10Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Fixed with commit #9d3bf58",
              "createdAt": "2018-03-01T09:52:10Z",
              "updatedAt": "2018-03-01T09:52:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDQ0MDMx",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I missed to press \"submit\" !  So these comments are perhaps outdated? Or maybe not even visible anymore? I can't see them, anyway...",
          "createdAt": "2018-02-28T12:30:39Z",
          "updatedAt": "2018-03-01T18:22:19Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I think it's okay to leave this standing for now.\r\n\r\nThe whole point of asking for such text was to be able to have a conversation about the specific behavior below. When we have this conversation (post-London, I'd suggest), I'll want to ask \"how do you determine 'observed maximum throughput' - over which time interval? For how long do you think it's still valid? On what basis?  All in all, I think this is about inventing new mechanisms that require some solid backing to show that they really make sense.",
              "createdAt": "2018-02-28T12:30:39Z",
              "updatedAt": "2018-03-01T18:22:19Z"
            },
            {
              "originalPosition": 73,
              "body": "\"Maximum Bitrate to be Sent\" would still need a measurement time interval...  but if it's a Send Parameter, maybe this gets solved: then the time interval is dictated by the length of the message. So this makes more sense to me.",
              "createdAt": "2018-02-28T13:20:18Z",
              "updatedAt": "2018-03-01T18:22:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTQzMTM1",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure I understand that web interface here, but I just replied to two of @mwelzl 's comments.",
          "createdAt": "2018-03-01T18:34:09Z",
          "updatedAt": "2018-03-01T18:45:15Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Yes, I think this relates to the cached performance parameters, how the exact calculation of such parameters is done, their cache lifetime, etc. \r\nI'm currently working on another paper that deals with how to get good performance estimates, and I'm looking forward to discussing this more and perhaps contributing some insights to the draft... perhaps post-London. :)",
              "createdAt": "2018-03-01T18:34:10Z",
              "updatedAt": "2018-03-01T18:38:52Z"
            },
            {
              "originalPosition": 73,
              "body": "This probably relates to the point above of how to get good metrics. Otherwise I think it would be bitrate in (M)Bits per Second, as given e.g. in an MPEG-DASH manifest file? ",
              "createdAt": "2018-03-01T18:37:09Z",
              "updatedAt": "2018-03-01T18:38:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTQ2Mzc0",
          "commit": {
            "abbreviatedOid": "6396f52"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T18:43:46Z",
          "updatedAt": "2018-03-01T18:43:46Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "As long as it's related to a time interval or a certain amount of data, I guess it's fine...",
              "createdAt": "2018-03-01T18:43:46Z",
              "updatedAt": "2018-03-01T18:43:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNjQwMjI3",
          "commit": {
            "abbreviatedOid": "8ecb7df"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-02T00:08:23Z",
          "updatedAt": "2018-03-02T00:08:23Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "330ad41b0e4efbf2d28239ecb663cfef48457908",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "intents-implementation",
      "headRefOid": "8ecb7df9d8cc916eb478a42d1b206ab5e3606b18",
      "mergeCommit": {
        "oid": "61be2d8aff9af8533bd9cc284a2e92fe016068e3"
      }
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMDM4ODAx",
      "title": "Note implications of constant rate capcity profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/123",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #111",
      "createdAt": "2018-02-28T18:46:14Z",
      "updatedAt": "2018-04-11T13:23:34Z",
      "closedAt": "2018-02-28T19:16:40Z",
      "mergedAt": "2018-02-28T19:16:40Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMTkyNjEx",
          "commit": {
            "abbreviatedOid": "7c97128"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-02-28T19:16:33Z",
          "updatedAt": "2018-02-28T19:16:33Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "330ad41b0e4efbf2d28239ecb663cfef48457908",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-capacity-profile",
      "headRefOid": "7c97128658ebdc65645ad77d95afd03a3b342c0e",
      "mergeCommit": {
        "oid": "aaa198506b5faf7a7e651daaffa6a1d15212e455"
      }
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMTAyMjkx",
      "title": "Handling of idempotent send on initiate",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/124",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "",
      "createdAt": "2018-02-28T23:20:08Z",
      "updatedAt": "2020-09-11T16:31:10Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "aaa198506b5faf7a7e651daaffa6a1d15212e455",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-idempotent",
      "headRefOid": "f439e0e9393f6957f77feed5912de963b59e7c00",
      "closedAt": "2018-09-20T17:26:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will fix #112 when it lands.",
          "createdAt": "2018-02-28T23:21:21Z",
          "updatedAt": "2018-02-28T23:21:21Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so this update is definitely better than the version before it, but it seems like there should be some way to make the `Start()` phase optional. Otherwise, \"I `Initiate()`d, but forgot to `Start()`\" seems like the most common programmer error that this interface will elicit.",
          "createdAt": "2018-02-28T23:26:11Z",
          "updatedAt": "2018-02-28T23:26:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the concepts outlined here work well; semantically, language implementations that work well for the model can certainly do a InitiateAndStart() equivalent. We *could* imagine changing some of the naming to make the programmer error less easy to fall into, like replacing Initiate() with Allocate/Create|Outbound/Initiator(), and replacing Listen() with Allocate/Create|Inbound/Listener().",
          "createdAt": "2018-03-01T00:08:03Z",
          "updatedAt": "2018-03-01T00:08:03Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, please don't land this yet; I wanted this in PR form to be able to discuss concrete text, not because I'm at all convinced it's not terrible.\r\n\r\nSecond follows.",
          "createdAt": "2018-03-01T09:20:41Z",
          "updatedAt": "2018-03-01T09:20:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Second:\r\n\r\n>  ...can certainly do a InitiateAndStart() equivalent...\r\n\r\nugh ugh ugh ick ack thpbbbt no.\r\n\r\nSplitting this into three steps (put together some parameters, which might already be doing some preracing stuff in the background; instantiate that set of parameters i.e. while telling it what kind of thing it's going to be, then actually telling that thing to go) is very easy to implement but IMO exposes too much of the internals of the process we envision to the application. To try and elaborate on my comment last night... we have a paradox here:\r\n\r\n1. We would like the system to be able to do things that are Good and Cheap and Fast for the application on its own, without the application specifically asking for them.\r\n\r\n2. This particular thing, Good and Cheap and Fast via 0RTT, requires that the application give the data it would like to initiate with earlier than it otherwise would; indeed, if latency is important, it has to hand over the data it would like to initiate with *before the system might conceivably make a decision to start racing*.  This is *only* useful for initiation (I still need to think about rendezvous) -- listeners only have to be willing to handle 0RTT initiation. \r\n\r\nI can't think of any other thing the application might want the system to do on its behalf that reverses the order of operations like this, so 0RTT really is special. The question is how much do we bend the API for this specialness, given that it's actually kind of important for performance.\r\n\r\nThere seem to me to be four (or two and two halves) approaches for moving forward:\r\n\r\n1. This PR or something like it: split all the steps out, make the application go through all of them in order, provide syntactic sugar for the \"I really don't care about 0RTT\" case. The downside of this is that applications will then use that syntactic sugar, and will have to be mildly tweaked to use 0RTT in case they decide they want to use it in the future. (IMO this will reduce the deployment of 0RTT to applications built to APIs like this one).\r\n\r\n2. (or really, 1.5): This PR, with the operation that the application will perform on a Preconnection embedded into that Preconnection at instantiation time; i.e. you have Preinitiations and Prelisteners and Prerendezvous; or, with less terrible naming, a single Preconnection type that can be bound to a later operation by `PreconnectionForInitiation()`, `NewPreconnectionForListening()`, and so on. I still don't like this much but it seems to reduce the three-step thing to a two-step thing (i.e., `NewPreconnectionForInitiation()` does basically what `Preconnect()` and `Initiate()` do in this PR, and `Initiate()` does what `Start()` does.)\r\n\r\n3. Handle this via a configuration directive. This would work something like a new semantic attached to the \"I want 0RTT\" protocol selection property, stating that when 0RTT is requested and available, an Initiate() call actually *delays* `Initiate()` until the first `Send()`. This complicates the semantics of the API a little (and can complicate implementation quite a bit; i.e. I can't really see how to race a 0RTT-capable transport against a non-0RTT capable transport in this case). It also has the problem that you can't override the delayed initiation without playing protocol selection games (which we'd like to discourage) and you can't express that you really, really want five messages in the first 0RTT flight.\r\n\r\n4. (3.5) as 3, but with two initiate calls: `InitiateNow()` which will override any delay (i.e., I might have 0RTT but know I'm connecting to a server which will send me a banner first, so please don't wait for my first `Send()`), and `Initiate()` with the potential delay-to-first-Send; and a new state on the Immediate send parameter which basically says \"please please please coalesce this Message with the next one\" and, in the case of 0RTT, extends the send delay until it sees the first Send without that state.\r\n\r\nI'm not actually sure what the tradeoffs are here yet. They're all a little hacky, but I'm leaning toward 4 for purely external-aesthetic reasons.\r\n\r\nIn any case, I think we should ship -00 before this discussion converges. If we're fast (and don't have A Lot Of Other Stuff To Do in the two weeks to London) then we can always drop a -01 on IETF Monday. If not, we get to continue this discussion over a beer or three, which seems like it might be productive.",
          "createdAt": "2018-03-01T10:11:29Z",
          "updatedAt": "2018-03-01T10:11:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins was bba9a56 meant for this branch, or should I cherry-pick it over to master?",
          "createdAt": "2018-03-01T13:12:48Z",
          "updatedAt": "2018-03-01T13:12:48Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram bba9a56 was intended for here, since it assumes a `Rendezvous` object that doesn't exist in the API in master. It might make sense to cherry-pick it for the general concept though.",
          "createdAt": "2018-03-01T13:23:50Z",
          "updatedAt": "2018-03-01T13:23:50Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now, that I have time to go through the issues, I want to drop an Idea on that one:\r\n\r\n 5. Allow send() on a Pre-Connection. If 0-RTT is requested and send is idem-potent, do the send as 0-RTT if possible, otherwise buffer the send and send directly after the connection is fully established. As we do not allow to clone pre-connections anymore, it is safe to enqueue sends here. \r\n",
          "createdAt": "2018-04-18T08:44:17Z",
          "updatedAt": "2018-04-18T08:44:17Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "wasn\u2019t that always the plan??   if we have moved away from it, we did it for a reason - but what was that reason?\n\nor is this *even* earlier than what we currently have?  good, then!\n\nSent from my iPhone\n\n> On 18 Apr 2018, at 10:44, Philipp S. Tiesel <notifications@github.com> wrote:\n> \n> Now, that I have time to go through the issues, I want to drop an Idea on that one:\n> \n> Allow send() on a Pre-Connection. If 0-RTT is requested and send is idem-potent, do the send as 0-RTT if possible, otherwise buffer the send and send directly after the connection is fully established. As we do not allow to clone pre-connections anymore, it is safe to enqueue sends here.\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
          "createdAt": "2018-04-18T08:48:54Z",
          "updatedAt": "2018-04-18T08:48:54Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl we only have the \"send\" operation only on a connection, not on a pre-connection. This made sense as we could clone a pre-connection which would not nessessarily end up being a multistreamed-connection.\r\n\r\nAs we dropped \"clone\" from the pre-connection, variant 5 pops up as a new alternative",
          "createdAt": "2018-04-18T09:23:55Z",
          "updatedAt": "2018-04-18T09:23:55Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For in-person discussion in Montreal; we should turn the suggestions in this PR and in #112 into a message to the list.",
          "createdAt": "2018-05-16T15:57:55Z",
          "updatedAt": "2018-05-16T15:57:55Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we consider this PR moot by #214?",
          "createdAt": "2018-09-06T13:39:10Z",
          "updatedAt": "2018-09-06T13:39:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closing because #214 landed",
          "createdAt": "2018-09-20T17:26:40Z",
          "updatedAt": "2018-09-20T17:26:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjc4NDc1",
          "commit": {
            "abbreviatedOid": "7074e53"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T00:08:37Z",
          "updatedAt": "2018-03-01T00:08:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjc4ODY1",
          "commit": {
            "abbreviatedOid": "7074e53"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm not entirely happy with this, but think it's good enough for -00.",
          "createdAt": "2018-03-01T00:10:32Z",
          "updatedAt": "2018-03-01T00:10:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMjEyMzc3",
      "title": "made notation more uniform (mostly capitalization)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/125",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #39",
      "createdAt": "2018-03-01T11:35:20Z",
      "updatedAt": "2018-03-01T12:57:50Z",
      "closedAt": "2018-03-01T12:57:50Z",
      "mergedAt": "2018-03-01T12:57:50Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDIwMzc5",
          "commit": {
            "abbreviatedOid": "0a8b40b"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T12:57:35Z",
          "updatedAt": "2018-03-01T12:57:35Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a7cb407947c4fbd34eec7dd709851c334952732b",
      "headRepository": "mwelzl/drafts",
      "headRefName": "master",
      "headRefOid": "0a8b40bb0039e3ce8bc764f0f73526265bbdd458",
      "mergeCommit": {
        "oid": "e5af772fc92eb6eafae86ad27c3fc64e1cca1bfc"
      }
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMjE2Nzg2",
      "title": "Clarify upper bound on message size",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/126",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #113 ",
      "createdAt": "2018-03-01T11:56:52Z",
      "updatedAt": "2018-04-11T13:23:36Z",
      "closedAt": "2018-03-01T12:56:10Z",
      "mergedAt": "2018-03-01T12:56:10Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDE4ODQ0",
          "commit": {
            "abbreviatedOid": "70e08f3"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-03-01T12:51:56Z",
          "updatedAt": "2018-03-01T12:51:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDE5ODY0",
          "commit": {
            "abbreviatedOid": "70e08f3"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Indeed, much nicer!",
          "createdAt": "2018-03-01T12:55:47Z",
          "updatedAt": "2018-03-01T12:55:47Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "68c955ab4276896beb5e8b6cabb7c1e834741819",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-max-msg-size",
      "headRefOid": "70e08f364cbfe70932aeb1a3a042094ad08cd090",
      "mergeCommit": {
        "oid": "a7cb407947c4fbd34eec7dd709851c334952732b"
      }
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMjY2OTk3",
      "title": "Add text about framing",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/128",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "discuss"
      ],
      "body": "This is a reworking of the text from Section 4.2 of draft-trammell-taps-post-sockets-03, intended to help motivate the choice of Message-based APIs with framing for the transport services architecture. The level of detail here seems appropriate for the architecture document, rather than the API.",
      "createdAt": "2018-03-01T15:22:47Z",
      "updatedAt": "2018-04-11T13:23:37Z",
      "closedAt": "2018-03-01T22:31:10Z",
      "mergedAt": "2018-03-01T22:31:09Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well written, @csperkins!",
          "createdAt": "2018-03-01T16:22:45Z",
          "updatedAt": "2018-03-01T16:22:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's convenient about the framer? If I have messages of 100 bytes and the length is what defines my message, what's the point of requiring me to define a framer function that I give to the system? I just send, send, send, off go 3 100-byte messages. Hard to get more convenient than that  :)\r\n\r\nI understand that the hook to a sender-side and receiver-side framer can allow you to offer a library that does framing when needed; I don't personally see this as a big win, but okay...    and I understand that forcing apps to use a receiver side de-framer can, in principle, let us do cool things on the receiver side (accessing messages out of the bytestream). But for sending this just seems to be an uncomfortable add-on.\r\n\r\nI guess I shouldn't be arguing it as somehow it's again just syntactical sugar, and I said before that I don't care too much about syntax here. I get it, for the 100-byte messages the framer just won't do anything, and for sending I have to use Connection.Send(Framer.Frame(Message)) instead of Connection.Send(Message)... these calls could basically be renamed into SendMessage vs. SendSomethingHuge. I said before that I don't care too much about these syntactical bits.\r\n\r\nI guess it's just that tying \"Connection.Send(Message)\" to \"we assume your Message is big and terminates a TCP connection\" is really counterintuitive to me.",
          "createdAt": "2018-03-01T20:11:35Z",
          "updatedAt": "2018-03-01T20:11:35Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "... and I think I answered to @britram in the wrong place  :(    sorry github",
          "createdAt": "2018-03-01T20:14:16Z",
          "updatedAt": "2018-03-01T20:14:16Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl what\u2019s convenient about the framer? In a C based implementation, very little. In a high level language implementation, however, it means I can `Connection.send(HttpRequestObject)` and have it convert the high-level structured data into the on the wire format automatically, using a reusable library. ",
          "createdAt": "2018-03-01T20:22:37Z",
          "updatedAt": "2018-03-01T20:22:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "no, no, that was right.\r\n\r\nFramers can take an object by reference or value of any type, and turn them into an appropriately framed octet array. Syntactic sugar, yes, and pointless in some languages. But have a look at https://godoc.org/github.com/mami-project/postsocket -- here, you're pushing down the thing that converts application structures into wire structures into the API, so the API speaks to you in terms of your own structures (in Go, this is generally called a `Marshaler`; IIRC from Java `Serializer` is the terminology there).\r\n\r\nIf your application-internal structures are already serialized byte arrays, you're right, there is zero win here.",
          "createdAt": "2018-03-01T20:23:38Z",
          "updatedAt": "2018-03-01T20:23:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins Framers are still very very useful in C. You can use callbacks, function pointers, etc, to help lay our your data, and doing that in the context of the networking thread improves efficiency (beyond the simpler API).",
          "createdAt": "2018-03-01T20:26:21Z",
          "updatedAt": "2018-03-01T20:26:21Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly even better, then! ",
          "createdAt": "2018-03-01T20:28:39Z",
          "updatedAt": "2018-03-01T20:28:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also:\r\n\r\n> I guess it's just that tying \"Connection.Send(Message)\" to \"we assume your Message is big and terminates a TCP connection\" is really counterintuitive to me.\r\n\r\nso this whole line of argument is extremely perplexing to me, and indicative of some sort of fundamental failure to communicate on this particular point. absolutely nobody is saying that this interface implies \"your Message... terminates a TCP connection\" *on the sender side*. I can't see where you're getting the impression otherwise in the text. \r\n\r\n(When receiving, yes, if the receiver has no way to deframe the stream, you get a message that never ends, as a series of partial reads that looks just like a bunch of `read(2)` calls on a stream; i.e. when it fails, it fails to something that basically works exactly like sockets with callbacks.)\r\n\r\n I *really* suggest we table this whole discussion until London, because we don't seem to be making much progress in here, and ask you to trust me until then when I say that there is never, ever, ever a situation in which an implementation of this interface that was actually working would ever look at a single message on the sender side \"oh, cool, that's done, guess I'll send a FIN then!\", ever, because that would be an incredibly silly thing to do.\r\n\r\n(where's the blink tag in github markdown? i really need the blink tag for this)",
          "createdAt": "2018-03-01T20:36:29Z",
          "updatedAt": "2018-03-01T20:36:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On this:\r\n\r\n> absolutely nobody is saying that this interface implies \"your Message... terminates a TCP connection\" on the sender side. I can't see where you're getting the impression otherwise in the text.\r\n\r\nSorry, there's a lack of context - I interpreted this out of private emails from Tommy, which seemed to  pretty clearly say that, if you just call \"send\" without providing a framer, you do send a FIN - and I just found that awkward. But heck! Clearly we all don't want silliness to happen and we want a nice clean interface, and clearly we can quickly agree on this in London. So no worries, and see y'all soon!",
          "createdAt": "2018-03-01T21:23:08Z",
          "updatedAt": "2018-03-01T21:23:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDgzMjY4",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-03-01T15:51:23Z",
          "updatedAt": "2018-03-01T15:53:42Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Just for the record, I don't have a problem with the \"TCP represents their data as a single long message\" statement per se (although I don't think it adds much value to say this) - my issue is when this translates into \"thus, sending 50 small messages may mean 50 small TCP connections\".  Obviously we don't want that.\r\n\r\nAnyway - for this PR, this is fine by me!",
              "createdAt": "2018-03-01T15:51:23Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            },
            {
              "originalPosition": 35,
              "body": "\"Once it is passed, it can not be cancelled or paused\" - @tfpauly , is this really true in your implementation too? Else we probably shouldn't say that...",
              "createdAt": "2018-03-01T15:52:26Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            },
            {
              "originalPosition": 46,
              "body": "\"must\" is pretty strong here. I can agree to having this as a \"must\" on the receiver side for the added value that it can give there, but I'm less sure about the sender side being a \"must\"",
              "createdAt": "2018-03-01T15:53:37Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDk0MDk3",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:17:16Z",
          "updatedAt": "2018-03-01T16:17:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "50 small messages *does not* mean 50 small TCP connections, and I am not advocating that anyone does that. =)",
              "createdAt": "2018-03-01T16:17:16Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDk0NDgw",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:18:11Z",
          "updatedAt": "2018-03-01T16:18:11Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Yeah, you can't cancel a message once you send it.",
              "createdAt": "2018-03-01T16:18:11Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDk1OTg4",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:22:02Z",
          "updatedAt": "2018-03-01T16:22:02Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I agree that this should be a \"should\", since a perfectly reasonable use case may not need messages on TCP. There *are* some long stream use cases, like a big file transfer.",
              "createdAt": "2018-03-01T16:22:02Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNDk2MDk2",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T16:22:18Z",
          "updatedAt": "2018-03-01T16:22:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTEwMTc3",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:57:08Z",
          "updatedAt": "2018-03-01T16:57:08Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Well this is getting into the conversation we wanted to have in London, not before, but my concern is \"must use a framer if I don't want 50 connections for 50 short messages over TCP\".   What's the point of a sender-side framer anyway?  Only that you can offer common functionality in a library - but when I don't care about that, why can't it be good enough to just use \"send\"?\r\n\r\nTHAT is my concern about the \"must\"",
              "createdAt": "2018-03-01T16:57:08Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTEwNTQx",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:58:03Z",
          "updatedAt": "2018-03-01T16:58:03Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I thought it does, in your system, if I don't care about using framers and just use \"send\" ?   Anyway sure we all agree that nobody wants 50 short TCP connections  :)",
              "createdAt": "2018-03-01T16:58:03Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTExMDE0",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:59:15Z",
          "updatedAt": "2018-03-01T16:59:15Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Then that text is fine I think  (and well written!)",
              "createdAt": "2018-03-01T16:59:15Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTExMjE3",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T16:59:47Z",
          "updatedAt": "2018-03-01T16:59:47Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Either way: this text is also fine to keep. So there's only one small item left below that is a change request - the \"must\" / \"should\"",
              "createdAt": "2018-03-01T16:59:47Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTcwMzcy",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T19:52:57Z",
          "updatedAt": "2018-03-01T19:53:16Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "+1 to should here, though I still think that the \"every message starts a new TCP connection\" thing is so silly on its face that if someone really, really wants to implement that, it's their own damn fault and we don't have any responsibility at all to save them from themselves.\r\n\r\nSender-side framers are really just a convenience to allow applications to pass down an application-layer object and have it turn into a bytestream with appropriate framing that a receiver-side deframer can deframe (except in the case that the application (1) requires message semantics and (2) provides no framing, which I'd argue means it absolutely can't run over TCP anyway, TAPS or not -- i.e. this is another one of those silly things we have no duty to mention.)",
              "createdAt": "2018-03-01T19:52:57Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTc4NjI4",
          "commit": {
            "abbreviatedOid": "b7575d5"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T20:18:36Z",
          "updatedAt": "2018-03-01T20:18:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Saying \u201cmust provide APIs\u201d is not \u201cmust use APIs\u201d...\r\n\r\nThat said, I\u2019m surprised by the resistance to this, since the overwhelming majority of applications have the equivalent of a framer/de-framer in them today as part of their protocol implementation. This isn\u2019t a new feature: it\u2019s breaking out an existing feature to make it reusable. ",
              "createdAt": "2018-03-01T20:18:36Z",
              "updatedAt": "2018-03-01T22:13:44Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "899b4c4ac16586e89fb8beb61f92af758892d47d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-framing",
      "headRefOid": "56c5a0b43cd71b08b7b289a6c759276a5e90aac4",
      "mergeCommit": {
        "oid": "2530d7166386af465dfd011aed22ff9cb6b63416"
      }
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1ODY1NDAz",
      "title": "Interface slides",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/143",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-19T11:01:11Z",
      "updatedAt": "2018-03-19T11:01:56Z",
      "closedAt": "2018-03-19T11:01:21Z",
      "mergedAt": "2018-03-19T11:01:21Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "150ad5aa921e3c1d4c68b36113ba8ece1fb5b50d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "interface-slides",
      "headRefOid": "e2f8ec4407fb2edce57332d325ba0e7e6463204c",
      "mergeCommit": {
        "oid": "5c6ab4ca4ac9281da5c260d77d873ceca6a070ae"
      }
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwODk3MzY3",
      "title": "Clones are for multistreaming only; fix #64",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/162",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-11T13:07:44Z",
      "updatedAt": "2018-04-11T20:22:14Z",
      "closedAt": "2018-04-11T20:22:10Z",
      "mergedAt": "2018-04-11T20:22:09Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzc5MzE1",
          "commit": {
            "abbreviatedOid": "90f66a1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T19:55:26Z",
          "updatedAt": "2018-04-11T19:55:26Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9e496a0a2f956c30e5ab7c92e521a55631dbc284",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "multistreaming-64",
      "headRefOid": "90f66a1fb466d3429c1f79edffaf08fa01efdc8f",
      "mergeCommit": {
        "oid": "6344d269b19295b3c6edfa5af0a7d05adf1e4f07"
      }
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwOTAxNjEy",
      "title": "clarify soft errors, fix #141",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/163",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-11T13:21:56Z",
      "updatedAt": "2018-04-12T09:18:34Z",
      "closedAt": "2018-04-12T09:18:31Z",
      "mergedAt": "2018-04-12T09:18:31Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzc5OTM3",
          "commit": {
            "abbreviatedOid": "6dbf002"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-04-11T19:57:18Z",
          "updatedAt": "2018-04-11T19:57:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\"properly routed\" seems strange to me; suggest to replace with \"delivered\"",
              "createdAt": "2018-04-11T19:57:18Z",
              "updatedAt": "2018-04-11T21:22:37Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9e496a0a2f956c30e5ab7c92e521a55631dbc284",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "icmperror-141-take-2",
      "headRefOid": "3d94a80e439eac4b02214aad4f9a990809516b6f",
      "mergeCommit": {
        "oid": "9c26fb3705295f1548dcba97c5255c3376799393"
      }
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxODA1NTI1",
      "title": "make transport selection properties subsections, too",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/164",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Send parameters were subsections, transport selection properties were not. This fixes that by promiting transport selection properties to subsections, and reorganizing the sections slightly to make that fit.\r\n\r\nThere are no changes to technical content in this PR.",
      "createdAt": "2018-04-16T09:45:41Z",
      "updatedAt": "2018-04-16T11:51:48Z",
      "closedAt": "2018-04-16T11:41:39Z",
      "mergedAt": "2018-04-16T11:41:39Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyMzYxMDcz",
          "commit": {
            "abbreviatedOid": "d3d0f3f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Makes sense - had that one also on my list of ugliness to be fixed.",
          "createdAt": "2018-04-16T10:37:29Z",
          "updatedAt": "2018-04-16T10:37:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyMzYzOTcw",
          "commit": {
            "abbreviatedOid": "d3d0f3f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-16T10:47:57Z",
          "updatedAt": "2018-04-16T10:47:57Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9c26fb3705295f1548dcba97c5255c3376799393",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "section-org-editorial",
      "headRefOid": "d3d0f3f6f06c0735c52bf56468c60bc4ac4d976f",
      "mergeCommit": {
        "oid": "a8701767e42b133b2dddc949276e4b254892a443"
      }
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMDgyNzk2",
      "title": "coalesce immediate acknowledgment into low latency profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/166",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Removes Immediate Acknowledgment and makes it an optional implicit feature of Low Latency profile, renames Instantaneous Capacity Profile to Transmission Profile. Addresses #90; we should open a new issue to discuss whether we want to split Capacity Profile back out.",
      "createdAt": "2018-04-17T08:05:58Z",
      "updatedAt": "2018-04-17T12:09:12Z",
      "closedAt": "2018-04-17T12:09:08Z",
      "mergedAt": "2018-04-17T12:09:08Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyNzMwMzgy",
          "commit": {
            "abbreviatedOid": "5f4ee0f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "About \"Transmission profile\", I like it; we had Capacity Profile (not \"Instantaneous\" though) in NEAT because it contains choices about how an application wants to make use of the available capacity. Because \"Transmission profile\" loses that hint, it conveys less meaning - but frankly, I still prefer it just for the way it sounds.",
          "createdAt": "2018-04-17T09:22:53Z",
          "updatedAt": "2018-04-17T09:22:53Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a8701767e42b133b2dddc949276e4b254892a443",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "low-latency-90",
      "headRefOid": "5f4ee0f436d17635e709b7ca0a1d3d34280fa502",
      "mergeCommit": {
        "oid": "cbc9920402df01f95e728767b67c8b414f68723e"
      }
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMDg3Nzcy",
      "title": "fix #138 fix #137 add refs",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/167",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-17T08:27:03Z",
      "updatedAt": "2018-04-23T03:15:01Z",
      "closedAt": "2018-04-20T06:49:23Z",
      "mergedAt": "2018-04-20T06:49:23Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "seeing no comment... :)",
          "createdAt": "2018-04-20T06:49:19Z",
          "updatedAt": "2018-04-20T06:49:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, looks good =) Busy week over here!",
          "createdAt": "2018-04-23T03:15:01Z",
          "updatedAt": "2018-04-23T03:15:01Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a8701767e42b133b2dddc949276e4b254892a443",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "arch-nits-0",
      "headRefOid": "ffee9a42171921062ce1d0ee47b78d606022fed7",
      "mergeCommit": {
        "oid": "7e3e9f5cde2f2417e0f59127d1773ff045c2c987"
      }
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMjU0ODU1",
      "title": "Transport Parameter Fixes for -00",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/168",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This commit fixes bug #165 by making transport parameter types explicit.\r\n\r\nIt also fixes  Path- and Protocol Selection Properties from \"binary + preference\" to preferences type.\r\nWith the old boolean properties, one could do things like \"prohibit Reliable Transport false\" - is that the same as \"prefer Reliable Transport true\"?",
      "createdAt": "2018-04-17T18:27:04Z",
      "updatedAt": "2018-04-23T09:48:40Z",
      "closedAt": "2018-04-23T09:48:36Z",
      "mergedAt": "2018-04-23T09:48:36Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To the questions in @britram's review summary:\r\n\r\n 1. For the general case: I believe there will be boolean properties (that are not preferences).\r\n   The way I understand \"Excessive Retransmit Notifications\" and \"ICMP soft error message\", I think booleans are the more appropriate type. \r\n 2. Not for -00, but for -01:\r\n      -  I want to define all types more rigorously in -01 --- we have Boolean, Enumeration, Boolean in the Transport Parameters right now, we also have some Integers in the Send Parameters. \r\n      - I am not sure that the frontmatter of this section is the right place to do so.",
          "createdAt": "2018-04-18T12:36:48Z",
          "updatedAt": "2018-04-18T12:36:48Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "General clarification:\r\n - This pull request changed \"preference\" to a data type a value can have rather than being something weakly defined that can be specified along with every Transport Parameter.\r\n   So we go from a Key / Preference / Value tripel where Preference or Value is pointless for (n-1) cases to a Key / Value pair with typed values. \r\n - The only Transport Parameter (including the Intents in the Appendix) that uses a parameter and a preference is the \"Interface Type\".\r\n - I would like to land this for -00 as this is good enough for discussion while the old state is confusing.\r\n - ToDos for -01:\r\n   - Explain types clearly\r\n   - make  \"Interface Type\" easier in -01\r\n   - discuss extendability",
          "createdAt": "2018-04-20T08:14:05Z",
          "updatedAt": "2018-04-20T08:14:05Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't see a functional difference between preference with two valid levels and boolean...\r\n\r\nIf we're doing booleans, the document needs to define a concise and generally applicable rule for how booleans interact with preferences. ISTM that boolean True == preference Prefer and boolean False == preference Avoid (in which case, why not just say Prefer and Avoid instead of True and False?)\r\n\r\nI might be wrong here though. Will defer to @tfpauly.\r\n",
          "createdAt": "2018-04-20T12:51:43Z",
          "updatedAt": "2018-04-20T12:54:13Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also @philsbln: Please file everything in the comments on this PR that should be addressed in -01 as an issue (if you haven't already)... thanks!",
          "createdAt": "2018-04-20T12:54:21Z",
          "updatedAt": "2018-04-20T12:54:21Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If we're doing booleans, the document needs to define a concise and generally applicable rule for how booleans interact with preferences\r\n\r\nOk - now I got your point. These properties (Notification of excessive retransmissions and Notification of ICMP soft error message arrival) are actually doing two things:\r\n - Enable sending these events\r\n - Indicate that we prefer protocols stacks that can send these events\r\n\r\nThe question is which one is more important. As I think the former is more important, I leave it boolean an add remarks to the individual properties that this implies preferring protocols that can provide these events for now. As this does not hide things, this should provide the better feedback for -00",
          "createdAt": "2018-04-20T13:18:28Z",
          "updatedAt": "2018-04-20T13:18:28Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be ready for landing. \u2013 @britram please merge if you agree\r\n\r\nOpen Issues for Milestone itef-01:\r\n - Restructure Transport Parameters Section #153 \r\n - Explain data types explicitly #173\r\n - Rewrite Interface Types to be useful and implementable #35\r\n ",
          "createdAt": "2018-04-20T13:57:32Z",
          "updatedAt": "2018-04-20T13:57:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTUzOTc5",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This leaves a couple of questions open:\r\n\r\n1. Do we really need booleans?\r\n2. Should we define enumerations more rigorously in the frontmatter?\r\n\r\nAlso, just logistically, this might also conflict with #168, so we'll need to deconflict after that lands.",
          "createdAt": "2018-04-18T10:01:58Z",
          "updatedAt": "2018-04-18T10:08:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "s/paremeter/parameter/",
              "createdAt": "2018-04-18T10:01:58Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            },
            {
              "originalPosition": 98,
              "body": "I'm not sure how this is supposed to work. Is true == Require or Prefer; is false == Avoid or Prohibit? How do I ignore?\r\n\r\nI think this might be a Preference, though not one that most apps will use.",
              "createdAt": "2018-04-18T10:06:05Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            },
            {
              "originalPosition": 109,
              "body": "As above.",
              "createdAt": "2018-04-18T10:06:07Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            },
            {
              "originalPosition": 131,
              "body": "An Enumeration is a set of (Type, Preference) tuples, correct? We might want to say that somewhere.",
              "createdAt": "2018-04-18T10:07:53Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            },
            {
              "originalPosition": 142,
              "body": "As above.",
              "createdAt": "2018-04-18T10:07:55Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTg3NjM4",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T12:03:35Z",
          "updatedAt": "2018-04-18T12:03:36Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Oh - that is not what I wanted to state here \u2013 my idea was just to use this as \"prefer interface type\", e.g., Wifi.\r\n\r\nHowever, I like your Idea of making that a tuple much better.",
              "createdAt": "2018-04-18T12:03:35Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTg5MDU5",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T12:08:45Z",
          "updatedAt": "2018-04-18T12:08:45Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Good question \u2013 I thought of it only as boolean whether to fire an event when these notifications are available.\r\nIf we assume there are applications that do not work without this kind of notification, we have to make this a Preference, otherwise, I think it is a Boolean.",
              "createdAt": "2018-04-18T12:08:45Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTg5MzI1",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T12:09:39Z",
          "updatedAt": "2018-04-18T12:09:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Same Comment as above ;-)",
              "createdAt": "2018-04-18T12:09:39Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTkzNTI3",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T12:23:55Z",
          "updatedAt": "2018-04-18T12:23:55Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I don't see this as a subject to preference, but as expressing the expectation. Tha application tells the Transport system the traffic is Constant Rate, not that it prefers / wants to avoid that the traffic is treated as constant rate. ",
              "createdAt": "2018-04-18T12:23:55Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzODcwMDAw",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-20T07:09:31Z",
          "updatedAt": "2018-04-20T07:09:31Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "IMO we should ask a slightly different question here, not \"can we think of an application that would really want to prohibit selection of a transport based on the inability to see RTX notifications or ICMP soft errors\", but \"do we have a good reason for creating a third class of selection parameter when two suffice\"? If True = \"prefer\" and False = \"ignore\", then we can just say that in the docs rather than specifying additional codepaths (every codepath, remember, is another way you can accidentally screw up :) )",
              "createdAt": "2018-04-20T07:09:31Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzODcwMTA4",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-20T07:10:14Z",
          "updatedAt": "2018-04-20T07:10:14Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "> The application tells the Transport system the traffic is Constant Rate, not that it prefers / wants to avoid that the traffic is treated as constant rate.\r\n\r\nHow is the TAPS system's action based on this information different, though?",
              "createdAt": "2018-04-20T07:10:14Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzODgwNTgw",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-20T07:55:33Z",
          "updatedAt": "2018-04-20T07:55:33Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "I don't see a functional difference between preference with two valid levels and boolean, just, from an application programmers perspective, I still think that \"Boolean\" is less confusing here.\r\n\r\nI would like to get at least a second opinion from @tfpauly on that -- after that, I change it to the one that makes this change land for -00.",
              "createdAt": "2018-04-20T07:55:33Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzODgyNjgx",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-20T08:03:21Z",
          "updatedAt": "2018-04-20T08:03:22Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "This case is different from the Interface Type case:\r\nThe Interface type case needs a parameter in addition to the preference.\r\nFor the Capacity Profile, the preference makes no difference here, adding it is redundant and mildly confusing. So I prefer it being just a Enum of the envisioned capaity profiles.\r\n",
              "createdAt": "2018-04-20T08:03:21Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzOTIzNTQ4",
          "commit": {
            "abbreviatedOid": "762b9d6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-20T10:18:01Z",
          "updatedAt": "2018-04-20T10:18:01Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "okay, that makes sense. There should be some language, either here or in Implementation, that a selection of a capacity profile may be used by the TAPS system as a \"preference\" for a transport that is \"good\" for the given capacity profile.",
              "createdAt": "2018-04-20T10:18:01Z",
              "updatedAt": "2018-04-20T13:41:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0MzExNTA0",
          "commit": {
            "abbreviatedOid": "e76dbfb"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "still not convinced by the boolean argument, but it's time to ship it.",
          "createdAt": "2018-04-23T09:48:28Z",
          "updatedAt": "2018-04-23T09:48:28Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7e3e9f5cde2f2417e0f59127d1773ff045c2c987",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "transport-parameters-fix-00",
      "headRefOid": "e76dbfbd50afa87097e9f71e1b2ce9cb946e0f03",
      "mergeCommit": {
        "oid": "e2c5191e9d9db35e73df6aecb163e7ec9401c0f1"
      }
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMzk1ODMx",
      "title": "Conflicting policies",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/169",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added text about what happens when an application specifies both protocol and path selection properties. Path selection properties have precedence. I added examples to both API and implementation draft to illustrate this. Relates to #149 ",
      "createdAt": "2018-04-18T07:57:27Z",
      "updatedAt": "2018-04-20T06:49:00Z",
      "closedAt": "2018-04-20T06:48:55Z",
      "mergedAt": "2018-04-20T06:48:55Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTE2Mjk3",
          "commit": {
            "abbreviatedOid": "3d179a2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is good, but I think it would benefit from adding a little text on a strict ordering of properties within property class by type of preference. ",
          "createdAt": "2018-04-18T08:11:44Z",
          "updatedAt": "2018-04-18T08:15:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Does this mean that Prohibit takes precedence over all others? (I think it does, and I think it's correct). I think what I'd like to see here (and maybe I'm just a languages geek) is a strict ordering, e.g. something like:\r\n\r\n`Prohibit` > `Require` > `Prefer` > `Avoid` ",
              "createdAt": "2018-04-18T08:11:44Z",
              "updatedAt": "2018-04-18T09:01:00Z"
            },
            {
              "originalPosition": 10,
              "body": "Precedence order (as above) should IMO appear here too...",
              "createdAt": "2018-04-18T08:14:54Z",
              "updatedAt": "2018-04-18T09:01:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTMyOTI4",
          "commit": {
            "abbreviatedOid": "3d179a2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T09:01:04Z",
          "updatedAt": "2018-04-18T09:01:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Makes sense. I added more text to the implementation that details how this should work.",
              "createdAt": "2018-04-18T09:01:04Z",
              "updatedAt": "2018-04-18T09:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTMzNTYw",
          "commit": {
            "abbreviatedOid": "3d179a2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-18T09:02:42Z",
          "updatedAt": "2018-04-18T09:02:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Agreed, I added some text here too, and moved it below the table. This section should perhaps be restructured in the future.",
              "createdAt": "2018-04-18T09:02:42Z",
              "updatedAt": "2018-04-18T09:02:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMTM0NDc1",
          "commit": {
            "abbreviatedOid": "0af9aef"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "this is good, thanks!",
          "createdAt": "2018-04-18T09:05:01Z",
          "updatedAt": "2018-04-18T09:05:01Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cbc9920402df01f95e728767b67c8b414f68723e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "conflicting-policies",
      "headRefOid": "0af9aefb371cc259688887a3fb7e7fb4977f7679",
      "mergeCommit": {
        "oid": "ab2b79321305ea550c8fd26e996f23c3048cbfcc"
      }
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNTM3ODMy",
      "title": "Add back batching sends",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/171",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "review"
      ],
      "body": "See issue #136 \r\n\r\nThe one question I have here is the semantics around batching. In our implementation, we use block semantics (from clang), to batch looks like:\r\n\r\nconnection_batch(^{\r\n    connection_send(...);\r\n    connection_send(...);\r\n});\r\n\r\nwhere the block is called inline, and the batch is over when the block returns. I'm not sure what the right style for the pseudo-code is for the draft.",
      "createdAt": "2018-04-18T16:38:08Z",
      "updatedAt": "2018-09-26T06:42:45Z",
      "closedAt": "2018-04-21T15:56:45Z",
      "mergedAt": "2018-04-21T15:56:45Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzODY2MTIz",
          "commit": {
            "abbreviatedOid": "f5ca7fc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, we can worry about the right way to pseudocode this later.",
          "createdAt": "2018-04-20T06:51:03Z",
          "updatedAt": "2018-04-20T06:56:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Yep, this is good.",
              "createdAt": "2018-04-20T06:51:03Z",
              "updatedAt": "2018-04-20T06:56:12Z"
            },
            {
              "originalPosition": 17,
              "body": "I'd almost leave out the pseudocode, but this is fine for now. Like events, the implementation platform is going to almost completely determine the syntax. In Go, I'd probably do something like:\r\n\r\n```go\r\nfunc (c Connection) Batch (sendfunc func());\r\n\r\nvar c Connection\r\nc.Batch(func() {\r\n    c.Send(...)\r\n    c.Send(...)\r\n})\r\n```\r\n\r\nwhich is almost the same thing but makes the closure explicit (I presume the Swift thing has a closure behind it anyway).\r\n\r\nAnother pattern I've seen (usually with RDBMS drivers and such) is to have a `Batch` object that has a `Send` method and a `Commit` method.\r\n\r\nIn C you'd probably end up with something like `sendv(Connection, messages...)`.",
              "createdAt": "2018-04-20T06:56:07Z",
              "updatedAt": "2018-04-20T06:56:12Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cbc9920402df01f95e728767b67c8b414f68723e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/batching",
      "headRefOid": "f5ca7fc06c5a2491f37093f1178b7dc5429f9752",
      "mergeCommit": {
        "oid": "90a9c142d4d95fc781d94a58975e76c7eca144e2"
      }
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg0OTMyNjk0",
      "title": "architecture and interface are now ietf-00",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/175",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-30T11:24:09Z",
      "updatedAt": "2018-09-26T06:42:49Z",
      "closedAt": "2018-04-30T11:31:32Z",
      "mergedAt": "2018-04-30T11:31:32Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e2c5191e9d9db35e73df6aecb163e7ec9401c0f1",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "ietf-00-arch-api",
      "headRefOid": "fdc7b711e777d6158b4f52aa30075f0e8ae028b7",
      "mergeCommit": {
        "oid": "57e7f5473eb29a8a7e446bae42bf6db2f5e91158"
      }
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwNzk2ODc4",
      "title": "Rework text for interface types",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/181",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "discuss"
      ],
      "body": "Implements #35 ",
      "createdAt": "2018-05-27T16:55:13Z",
      "updatedAt": "2018-09-26T06:43:36Z",
      "closedAt": "2018-06-09T12:11:16Z",
      "mergedAt": "2018-06-09T12:11:16Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "tagging discuss since @mwelzl and I, at least, apparently have a fairly fundamental disagreement on flexibility versus classification of layers 2.",
          "createdAt": "2018-05-28T08:25:34Z",
          "updatedAt": "2018-05-28T08:25:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram - I don't think I'll fight for this one, but to begin with, tell me: what do you think is wrong about my view?",
          "createdAt": "2018-05-28T10:01:11Z",
          "updatedAt": "2018-05-28T10:01:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the hearty discussion!\r\n\r\nOn this point, I do agree with @britram that we're not going to achieve full portability across systems for interfaces and PvDs, and it likely doesn't need to be a goal.\r\n\r\nIf I'm writing an implementation in ten years for some new system that only uses Wi-Fi and [INSERT FANCY NEW RADIO TYPE HERE], why would I need to add support for this wired ethernet thing that I don't have any devices for?\r\n\r\nSince moving between different implementations isn't likely going to be 100% portable anyhow due to language differences and symbol differences, applications will need to change. However, a specific implementation that is portable (like NEAT, or like Apple's if we make it cross-platform) should endeavor to offer the same types across systems.",
          "createdAt": "2018-05-28T18:18:49Z",
          "updatedAt": "2018-05-28T18:18:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fine by me, go ahead",
          "createdAt": "2018-05-28T19:44:51Z",
          "updatedAt": "2018-05-28T19:44:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri @philsbln please take a look at the update!\r\n\r\n@mwelzl, I assume based on your last comment that you're okay with the change going in now?",
          "createdAt": "2018-05-31T23:47:14Z",
          "updatedAt": "2018-05-31T23:47:14Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I agree with it!",
          "createdAt": "2018-06-01T08:46:45Z",
          "updatedAt": "2018-06-01T08:46:45Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "let's land this one then...",
          "createdAt": "2018-06-09T12:11:09Z",
          "updatedAt": "2018-06-09T12:11:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkzMTUy",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T19:21:30Z",
          "updatedAt": "2018-05-27T19:23:30Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Does this mean we need a registry?",
              "createdAt": "2018-05-27T19:21:30Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            },
            {
              "originalPosition": 41,
              "body": "\"Note that...\" is repeated from above.",
              "createdAt": "2018-05-27T19:21:49Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkzOTg0",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T19:57:29Z",
          "updatedAt": "2018-05-27T19:57:30Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "No, we decided on the call that a registry is definitely not the way to go\u2014I'm saying here that any given implementation likely has a list of types it supports, and it should make all types it knows about available across various platforms to make the code as reusable as possible.",
              "createdAt": "2018-05-27T19:57:29Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkzOTk5",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T19:58:15Z",
          "updatedAt": "2018-05-27T19:58:15Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Mmm, it's *almost* the same, but mentions specific interface \"type\", and notes that it's not quite as strict as a specific interface.",
              "createdAt": "2018-05-27T19:58:15Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTk1Mzg5",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T21:02:27Z",
          "updatedAt": "2018-05-27T21:04:15Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Sorry, right, my point was that maybe we could factor this out into a single paragraph that covers interfaces and types at the end of this section... or not. Either way works. ",
              "createdAt": "2018-05-27T21:02:27Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            },
            {
              "originalPosition": 38,
              "body": "Right, that's what I thought, but the text makes it seem like *different* implementations might share these same types. You do mention that these are implementation specific, yet there's no accompanying example like there is for the system-specific types. Maybe we could just add one such example?",
              "createdAt": "2018-05-27T21:04:11Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjM5MTY3",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-05-28T06:58:57Z",
          "updatedAt": "2018-05-28T07:00:02Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think we should be more concrete and more prescriptive for the sake of portability. I'd replace \"Implementations should provide all types that are supported on some system to all systems, in order to allow applications to write generic code.\" with 'For the sake of application portability, all implementations should provide at least the types \"Wi-Fi\", \"Cellular\", \"Wired Ethernet\".'   - these types are pretty generic anyway, what's the harm in always offering them?  I'm afraid that a relaxed statement like the one that's now here is not going to lead to a coherent set across systems (because the point of reference are only other implementations, not this draft!), and so the idea of application portability is lost.",
              "createdAt": "2018-05-28T06:58:57Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjU5Mzk4",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T08:24:05Z",
          "updatedAt": "2018-05-28T08:24:05Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> all implementations should provide at least the types \"Wi-Fi\", \"Cellular\", \"Wired Ethernet\"\r\n\r\nEh. This viewpoint is very biased toward a traditional notion of what an Internet node is: a server, workstation, desktop, or laptop. Simple example: if I'm writing apps on a mobile phone whose manufacturer doesn't ship Ethernet adapters, or on a miniserver platform without LTE radios as an option, why does my implementation need to care about these irrelevant layers 2?\r\n\r\n(Yes, I know, every wired networking technology will be called \"Ethernet\" and have a 14-byte header, forever, regardless of how the signaling and MAC actually work. But hardcoding this seems rather less than futureproof.)",
              "createdAt": "2018-05-28T08:24:05Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjYwMDYx",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, modulo the fact that we should clearly discuss this :)",
          "createdAt": "2018-05-28T08:26:32Z",
          "updatedAt": "2018-05-28T08:26:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjkwNTA2",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T10:14:48Z",
          "updatedAt": "2018-05-28T10:14:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I can see that. But what about my counter-argument that saying \"Implementations should provide all types that are supported on some system to all systems\" isn't ever going to give us enough coherence across implementations that application code is going to really be portable?  What's a better alternative?",
              "createdAt": "2018-05-28T10:14:48Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjk0MDU0",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T10:30:02Z",
          "updatedAt": "2018-05-28T10:30:02Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I'm not sure we need a common interface type system for portability here, because in most case the specific semantics of whether a given application should or should not use a given transport/interface are administrative- or user-level choices, not application developer choices.\r\n\r\nIn other words, a system would provide a way for an application to ask a user (or, as in Apple's case, provide a system UI to ask the user) which apps should work with which interfaces. This is probably an implementation-level thing though, as it might also tie into other specifics of the platform...",
              "createdAt": "2018-05-28T10:30:02Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjk1NTM4",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T10:36:50Z",
          "updatedAt": "2018-05-28T10:36:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't understand what this has to do with hard-coding L2-style names or not. Indeed, admin choices will tell us which interfaces can be used, but how can you write an application and port it between systems if you have no common name to use for the WiFi interface?  But as I said, of course I also understand your other argument, that hardcoding L2 names isn't going to be great for all time in the future. I just wanted to raise the concern, I think it would the better compromise to hard-code these names after all, but I'm not going to fight for a paricular choice here. My view is that Tommy should read our discussion and then decide, and let's go for what he picks.",
              "createdAt": "2018-05-28T10:36:50Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNzAyMDA0",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T11:07:49Z",
          "updatedAt": "2018-05-28T11:07:50Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> but how can you write an application and port it between systems if you have no common name to use for the WiFi interface?\r\n\r\nI guess I'm having a hard time understanding why a (non-network-admin-tool) would want, as part of its application logic, as opposed to in response to some user configuration demand, to define a constraint on interface types. I can think of one such constraint: having two connections, one \"essential\" and one \"higher-bandwidth\", and constraining the latter to cheaper connections, but that's really a higher-level policy which (1) requires user input and (2) probably should be expressed in higher-level goals than \"wifi or not\"...\r\n\r\nI think this is a larger discussion (and indeed is kind of the problem PvD is meant to solve)... for this particular issue, though, I think what's here is good. I'm not going to fight awfully hard either, so +1 to making this @tfpauly's problem :)",
              "createdAt": "2018-05-28T11:07:49Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNzAzODMy",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T11:16:41Z",
          "updatedAt": "2018-05-28T11:16:41Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, +1 on this being difficult to understand - I was also just beginning to think along the same lines, that we should abstract from \"WiFi\" into \"cheap\" or whatever. Anyway, we agree: this is in @tfpauly 's hands - case closed, problem solved   :-D",
              "createdAt": "2018-05-28T11:16:41Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzOTAzNDc1",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T09:00:42Z",
          "updatedAt": "2018-05-29T09:00:43Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I read this part similar to @chris-wood, that different implementations would have to provide the same types, or even provide *all* types that any other implementation out there provides. If it means \"an implementation that can run on multiple platforms should provide the same types on all these platforms\", that's fine with me, but it should be made a little more clear in the text.\r\n\r\nI think generally it's good to offer more types and live with the fact that not all types are going to be available on every system an implementation is running on. An implementation will still know what types are actually available on this particular system at run time. If the application asks to \"Require\" something that isn't there, the implementation will error out early according to Section 3.1 in the Implementation Draft. Maybe this is worth another sentence in the \"types\" paragraph - a \"Require\" on a particular interface type will also restrict the selection, maybe unnecessarily.\r\n\r\nImo this kind of interface selection is often about assumptions that an application developer has about a particular type of access network - like \"WiFi = cheap\" as @mwelzl was saying, and as @britram probably meant by \"higher-level goal\". I agree with them that for such use-cases we should abstract from specific interface choice and encourage applications to request what they actually want from the network (e.g., cheap), instead of relying on the developer's assumptions, which might be wrong. This is what we are trying to achieve with Intents, too.",
              "createdAt": "2018-05-29T09:00:42Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzOTA0Nzkz",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Generally on the right track, just needs a little more clarification imo, see my other comment.",
          "createdAt": "2018-05-29T09:04:28Z",
          "updatedAt": "2018-05-29T09:07:48Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Why not \"Avoid\"? I would add that one here.",
              "createdAt": "2018-05-29T09:04:28Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MDQzNDI4",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I definitely support adding PvDs and the direction of the Interface type changes.\r\n\r\nI definitely want a stricter separation between \"asking for a special interface/PvD\" or \"requesting a certain technology/feature/cost structure\" ",
          "createdAt": "2018-05-29T15:20:28Z",
          "updatedAt": "2018-05-29T15:29:42Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I agree with @theri \u2013 maybe one might want to avoid using the infrastructure of a competitor, but not prohibit it.",
              "createdAt": "2018-05-29T15:20:28Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            },
            {
              "originalPosition": 38,
              "body": "I can live with a spirit of the text @tfpauly wrote  \u2013 But I guess the Interface Type or Instance should only be a corner case anyway. It is implementation specific and I guess it will have surprising results.\r\nWhat should the system do, if one specifies \"prohibit cellular\" but it knows that the uplink for the Wifi interface is also cellular?\r\n\r\nWe should add a warning against using \"Wifi\" as a representant for \"cheap\" or \"Cellular\" as a representant for \"expensive\" \u2013 for this use case, we should use something like the cost preference Intent.",
              "createdAt": "2018-05-29T15:20:57Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            },
            {
              "originalPosition": 62,
              "body": "- We should have at least a portable way to specify PvD strings. \r\n- Maybe we should also have a portable way to map 3GPP APNs tp PvDs (but most probably out of scope for this document)\r\nOther stuff can indeed be implementation specific.",
              "createdAt": "2018-05-29T15:26:50Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            },
            {
              "originalPosition": 68,
              "body": "Is this the right place to request such a service? I have no idea how such a PvD Type specifier could look like\u2026",
              "createdAt": "2018-05-29T15:26:51Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MjAyOTMw",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T23:04:41Z",
          "updatedAt": "2018-05-29T23:04:41Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Sure, we can add avoid. Many use cases for that.",
              "createdAt": "2018-05-29T23:04:41Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MjE1MTU4",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T00:15:19Z",
          "updatedAt": "2018-05-30T00:15:19Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "There is no portable definition of a PvD string, and we certainly aren't going to go into the business of creating APN registries...",
              "createdAt": "2018-05-30T00:15:19Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MjE1MzU0",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T00:16:43Z",
          "updatedAt": "2018-05-30T00:16:43Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yup, we use this a lot.\r\n\r\nIn your APN example, the PvD type is like \"Cellular : VVM\" for visual voicemail. The Instance is a specific instance of a PvD, which there may be multiple of a type on a device.",
              "createdAt": "2018-05-30T00:16:43Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MzA4MzIy",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T08:58:28Z",
          "updatedAt": "2018-05-30T08:58:28Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Oh snap\u2026 RFC7558 really does not define any format\u2026 If we take the assumption that PvDs are FQDNs from draft-bruneau-pvd, it would be so much easier, as we could be sure the PvD does not contain a colon.\r\nThis would enable clearly sepatating explicit PvDs (without colon) from PvD classes (with colon)\r\n\r\nReverring to a specific APN could be realized with a APN class: `APN:[apn name]`",
              "createdAt": "2018-05-30T08:58:28Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0MzA4NzUx",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T08:59:38Z",
          "updatedAt": "2018-05-30T08:59:38Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Ok - not that makes sense to me.\r\n\r\nI guess we should still describe this in more detail and at least give a structure how these classes look like (see comment above)",
              "createdAt": "2018-05-30T08:59:38Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NTI0NTcx",
          "commit": {
            "abbreviatedOid": "4dc380c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-30T18:03:19Z",
          "updatedAt": "2018-05-30T18:03:19Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "This document is certainly not the place to go into the debate of how to identify PvDs. This is a very long and complicated discussion, and we already have two platforms (Android and iOS) that handle them with quite different identifiers. Thus, the text here represents the reality that these will indeed need to be system-specific.",
              "createdAt": "2018-05-30T18:03:19Z",
              "updatedAt": "2018-05-31T23:44:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDExOTI5",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-31T23:45:25Z",
          "updatedAt": "2018-05-31T23:45:25Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Added text to explain why the PvD identifier isn't strongly defined.",
              "createdAt": "2018-05-31T23:45:25Z",
              "updatedAt": "2018-05-31T23:45:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDExOTQy",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-31T23:45:31Z",
          "updatedAt": "2018-05-31T23:45:31Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Added text to explain why the PvD identifier isn't strongly defined.",
              "createdAt": "2018-05-31T23:45:31Z",
              "updatedAt": "2018-05-31T23:45:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDExOTY2",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-31T23:45:38Z",
          "updatedAt": "2018-05-31T23:45:39Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Added avoid",
              "createdAt": "2018-05-31T23:45:38Z",
              "updatedAt": "2018-05-31T23:45:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDEyMDI3",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-31T23:46:06Z",
          "updatedAt": "2018-05-31T23:46:06Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Added a comment warning against using interface types as a proxy for metered and unmetered networks.",
              "createdAt": "2018-05-31T23:46:06Z",
              "updatedAt": "2018-05-31T23:46:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDg5NTM5",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-01T08:45:41Z",
          "updatedAt": "2018-06-01T08:45:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MTY3ODEy",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "in my opinion, almost there\u2026 only minor comments to address left",
          "createdAt": "2018-06-01T13:31:19Z",
          "updatedAt": "2018-06-01T13:53:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "nit: according to the definition of a preference, everything after the OR is redundant",
              "createdAt": "2018-06-01T13:31:20Z",
              "updatedAt": "2018-06-01T13:53:52Z"
            },
            {
              "originalPosition": 38,
              "body": "I can not parse `on some system to all systems` in the last paragraph.\r\n\r\nI think the whole last paragraph still hard to understand as it introduces a new concept without saying so \u2013 how about:\r\n\r\n   The set of valid interface types is implementation- and system-specific and can include mnemonic types.\r\n   On a mobile device, for example, there may be the interface types`Wi-Fi` and `Cellular` available; on a desktop computer, there may be `Wi-Fi` and `Wired Ethernet` available.\r\n   Implementations should provide a way to enumerate interface mnemonic types order to allow applications to write generic code.",
              "createdAt": "2018-06-01T13:43:59Z",
              "updatedAt": "2018-06-01T13:53:52Z"
            },
            {
              "originalPosition": 52,
              "body": "I like that, but the text above still leads in another direction (how one can use interface types for that)\r\n\r\nMaybe move that paragraph up directly after the paragraph defining the interface types and shorten the explanation in between.",
              "createdAt": "2018-06-01T13:48:37Z",
              "updatedAt": "2018-06-01T13:53:52Z"
            },
            {
              "originalPosition": 68,
              "body": "I guess that works for now.\r\n\r\nnit: maybe double-check whether there is a need to talk about `Categories` and  `Types` of PvDs",
              "createdAt": "2018-06-01T13:51:47Z",
              "updatedAt": "2018-06-01T13:53:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MTY0ODAy",
          "commit": {
            "abbreviatedOid": "7744554"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me now. Sorry for the delay!",
          "createdAt": "2018-06-08T13:39:26Z",
          "updatedAt": "2018-06-08T13:39:26Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bd558dcebcdca335c876f7ed119e36efdcda2acb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/interface-types",
      "headRefOid": "7744554681ec778f197440702316eeabe945ef36",
      "mergeCommit": {
        "oid": "c61b581baead4f526f41f32d6099b2dfc17e9284"
      }
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwODA2NjU0",
      "title": "Add text for Final Messages to support half-close",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/183",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Satisfies #53 ",
      "createdAt": "2018-05-27T21:01:37Z",
      "updatedAt": "2018-09-26T06:43:33Z",
      "closedAt": "2018-06-01T12:01:27Z",
      "mergedAt": "2018-06-01T12:01:27Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, addressed capitalization and took Brian's suggested paragraph (with one tiny change).",
          "createdAt": "2018-05-28T18:13:17Z",
          "updatedAt": "2018-05-28T18:13:17Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fine with me - go ahead",
          "createdAt": "2018-05-29T15:31:55Z",
          "updatedAt": "2018-05-29T15:31:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl, @britram any further comments on this one?",
          "createdAt": "2018-05-31T23:35:28Z",
          "updatedAt": "2018-05-31T23:35:28Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ship it",
          "createdAt": "2018-06-01T05:27:59Z",
          "updatedAt": "2018-06-01T05:27:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, seems I should have clicked \"approve\" earlier. Still being clumsy in github  :(",
          "createdAt": "2018-06-01T08:44:28Z",
          "updatedAt": "2018-06-01T08:44:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjQyODQw",
          "commit": {
            "abbreviatedOid": "615f45e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T07:17:47Z",
          "updatedAt": "2018-05-28T07:17:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Capitalization of \"Final\" vs. \"final\" is inconsistent above - I suggest to write \"The Final property overrides...\" and \"...marked as Final ...\"  in the last two sentences above.",
              "createdAt": "2018-05-28T07:17:47Z",
              "updatedAt": "2018-05-28T18:12:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjQzMDUy",
          "commit": {
            "abbreviatedOid": "615f45e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-28T07:18:40Z",
          "updatedAt": "2018-05-28T07:18:40Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Suggest \"marked as Final\"",
              "createdAt": "2018-05-28T07:18:40Z",
              "updatedAt": "2018-05-28T18:12:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjQzNjk1",
          "commit": {
            "abbreviatedOid": "615f45e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is just a wording nit",
          "createdAt": "2018-05-28T07:21:25Z",
          "updatedAt": "2018-05-28T07:21:54Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I think \"Final Messages are delivered by protocols that support closing one side of a Connection\" and \"Protocols that do not support this functionality, such as UDP, may never deliver a Message marked as Final\"  (note capitalization) is wrong?!\r\n\r\nI mean, what may not be delivered is the Final property, but not the message itself, right?  I'd expect that, in case of UDP, you (unless it's dropped) get the message delivered anyhow, but the information that it's the last one may never arrive. Right?  This however reads as if marking a message as Final reduces the probability that the message will ever be transferred.",
              "createdAt": "2018-05-28T07:21:25Z",
              "updatedAt": "2018-05-28T18:12:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNjU4Mjgx",
          "commit": {
            "abbreviatedOid": "615f45e"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Almost there, one minor make-it-less-specific change to receiving Finals, +1 to @mwelzl on capitalization.",
          "createdAt": "2018-05-28T08:20:03Z",
          "updatedAt": "2018-05-28T08:20:52Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I also don't think we need to go into this level of detail *here*. You might get a Final message, but you, the application, should not rely on it. (Indeed, if the BSD API for TCP had this functionality, any peer that did the send-last-drop-state-start-RSTing-ACKS trick some CDNs use (used?) as a performance optimization would never send Final messages, even though the underlying transport supports them).\r\n\r\nFirst para is okay. Suggest replacing second para with something like \"Some transport protocols and peers may not support signaling of a Final message. Applications therefore must not rely on receiving a message marked Final to know that the other endpoint is done sending on a connection\"",
              "createdAt": "2018-05-28T08:20:03Z",
              "updatedAt": "2018-05-28T18:12:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDUwNTc2",
          "commit": {
            "abbreviatedOid": "b95d6df"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-01T05:27:48Z",
          "updatedAt": "2018-06-01T05:27:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDg5MDM3",
          "commit": {
            "abbreviatedOid": "b95d6df"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-01T08:43:58Z",
          "updatedAt": "2018-06-01T08:43:58Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bd558dcebcdca335c876f7ed119e36efdcda2acb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/final-message",
      "headRefOid": "b95d6df95656fbfae101cd9f6700f22f79f06b2b",
      "mergeCommit": {
        "oid": "9c51ffcebe664a4ba534b85adc5ae1137dfb94e8"
      }
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxOTA4ODQ4",
      "title": "Move authors out of list to Contributors at end of document",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/185",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "discuss"
      ],
      "body": "Satisfies #184 ",
      "createdAt": "2018-06-01T00:48:53Z",
      "updatedAt": "2020-09-11T16:31:11Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bd558dcebcdca335c876f7ed119e36efdcda2acb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/author-list",
      "headRefOid": "cd6be8193357de027e861488de36e950d0e05cac",
      "closedAt": "2018-06-06T07:09:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 @mwelzl I would also be okay with not doing this, and fighting the RPC about it. \r\n\r\n(One of the reasons the limit is being advertised more forcefully is that there have been instances where authorship doesn't necessarily reflect work done, in some cases because people are financially rewarded for getting their name on an RFC or even an Internet-Draft, and you have people who really have no clue what is in the document on the critical path in auth48. This is not the case here.)\r\n\r\n(Doubleparenthetical: someone should have a talk with the RSE about how to handle actual large collaborations such as this one where not everyone needs to be on the RPC last call, but where people actually should show up in the metadata that gets pulled into various academically-important indices.)",
          "createdAt": "2018-06-01T11:00:45Z",
          "updatedAt": "2018-06-01T11:00:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hope we all agree that this can be closed; it's probably better addressed with an email to the chairs.",
          "createdAt": "2018-06-06T07:09:10Z",
          "updatedAt": "2018-06-06T07:09:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I don't particularly care\u2014I don't see why it's a huge problem, considering that the QUIC documents, etc, are doing this style, but if you guys want to fight the man, that's fine too =)",
          "createdAt": "2018-06-08T14:20:27Z",
          "updatedAt": "2018-06-08T14:20:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDUzMTIy",
          "commit": {
            "abbreviatedOid": "cd6be81"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-01T05:48:58Z",
          "updatedAt": "2018-06-01T05:49:06Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I'd do this a bit differently (applies to all three docs)\r\n\r\n- I'd place contributors above acknowledgments\r\n- \"include\" sounds like there are other authors, which is not what we're saying.\r\n- I haven't included editors in contributors' lists in the past \"in addition to the editors, this document was written by:\"\r\n- I'd add back affiliations and (with author agreement, gdpr etc) email addresses\r\n- and stylistically, I'd do this in list form.\r\n\r\nWhere specific sections have specific authors, this should also be noted (see 8095), but this is not the case here...",
              "createdAt": "2018-06-01T05:48:58Z",
              "updatedAt": "2018-06-01T05:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDU1Mzk1",
          "commit": {
            "abbreviatedOid": "cd6be81"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T06:06:35Z",
          "updatedAt": "2018-06-01T06:06:35Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Just to be sure ...\r\n\r\nAre you suggesting keeping the current list of authors in the boilerplate; diving text between contributors and acknowledgment sections. - That I would agree with.\r\n\r\nIf you were to be suggesting pruning the authors list - I would not want that for the document s were I am currenty listed as an author: specifically I *would* wish to be in the RFC-Ed last call for these documents.",
              "createdAt": "2018-06-01T06:06:35Z",
              "updatedAt": "2018-06-01T06:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDkyNTUw",
          "commit": {
            "abbreviatedOid": "cd6be81"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T08:56:18Z",
          "updatedAt": "2018-06-01T08:56:18Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "See my answer to this in #184: I agree with Gorry here. Specifically, as long as we're not told that we MUST do such a thing, I think we should try to keep the author list as-is.",
              "createdAt": "2018-06-01T08:56:18Z",
              "updatedAt": "2018-06-01T08:56:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDkyOTU3",
          "commit": {
            "abbreviatedOid": "cd6be81"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "My proposal is to not do that unless we're 100% clear that we must. The wording in RFC 7322 doesn't seem to be strict about this.",
          "createdAt": "2018-06-01T08:57:35Z",
          "updatedAt": "2018-06-01T08:57:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkyMDM0NTQx",
      "title": "initial support for unidirectional connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/191",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [],
      "body": "This closed #170 \r\n\r\nAs we have no methods on a connection object that query properties, can_send/can_receive also became connection properties.\r\n\r\nAs with all the other connection properties, these are indeed a little underspecified. I want to keep it that way till we fix it for all connection properties with #153 and #190",
      "createdAt": "2018-06-01T13:28:03Z",
      "updatedAt": "2018-09-26T06:43:40Z",
      "closedAt": "2018-06-06T11:01:19Z",
      "mergedAt": "2018-06-06T11:01:18Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aehm\u2026 that comes surprising \u2013 @britram why didn't you bring this up in #170 ?\r\nDo you think this pull-request is the right place to discuss this issue?\r\n\r\nI would prefer we merge it now and make a new issue for the question whether the uni-directional connection should be more reflected in the connection. I am not particularly found on keeping it a selection property but would like to have the concept of unidirectional connections rather sooner than later.\r\n\r\nOur consensus in #170 was that unidirectional connection should use the same abstraction for QUIC unidirectional streams, multicast sources/sinks, and half-closed connections \u2013 despite they are constructed in completely different ways. The Selection property is just for the QUIC style ones\u2026",
          "createdAt": "2018-06-04T09:48:46Z",
          "updatedAt": "2018-06-04T10:37:58Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">Aehm\u2026 that comes surprising \u2013 @britram why didn't you bring this up in #170 ? Do you think this pull-request is the right place to discuss this issue?\r\n\r\nHappy to move the discussion back over to the issue if you like. Will continue the thread here for now though since you've got points to address below.\r\n\r\n> I would prefer we merge it now and make a new issue for the question whether the uni-directional connection should be more reflected in the connection. I am not particularly found on keeping it a selection property but would like to have the concept of unidirectional connections rather sooner than later.\r\n\r\nfine, but keep #170 open then, because adding the selection property is possibly-necessary but definitely-not-sufficient to fully address unidirectional connection semantics.\r\n\r\n> Our consensus in #170 was that unidirectional connection should use the same abstraction for QUIC unidirectional streams, multicast sources/sinks, and half-closed connections \u2013 despite they are constructed in completely different ways.\r\n\r\ngood, I agree with this.\r\n\r\n> The Selection property is just for the QUIC style ones\u2026\r\n\r\nthen I'm confused why this PR purports to close #170, since it only addresses part of the issue...?",
          "createdAt": "2018-06-04T12:31:42Z",
          "updatedAt": "2018-06-04T12:31:42Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram agreed.\r\n\r\n> then I'm confused why this PR purports to close #170, since it only addresses part of the issue...?\r\n\r\nThe question (and discussion) #170 was about support for including some support for unidirectional connections (with focus on QUIC and half-closed), but omitted details on multicast, as this has not laned yet. So indeed, this pull-requests does everything requested by #170, but does not fully capture the topic. \r\n\r\nI will move the open issues (Multicast support, is the Selection Property enough, find some place for more explanation of Uni/Bidi Streams) to #170 once this PR is merged.",
          "createdAt": "2018-06-04T13:31:08Z",
          "updatedAt": "2018-06-04T13:31:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MTk0ODg0",
          "commit": {
            "abbreviatedOid": "99dd4e9"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "We should decide whether unidirectional connections are simple enough to model with selection properties... not clear to me this isn\u2019t something fundamentally different.\r\n\r\nIt\u2019s also not clear that unidirectional streams a la QUIC and multicast sources/sinks are the same thing, though IMO it would be nice if so.",
          "createdAt": "2018-06-01T14:40:51Z",
          "updatedAt": "2018-06-01T14:43:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Though it probably is one for reasons of implementation expediency, I\u2019m not sure this belongs as a \r\n\r\nPost had these as separate connection calls, which seems more natural to me, and maps to multicast more nicely: receive-only has a lot in common with listen, for instance.",
              "createdAt": "2018-06-01T14:40:51Z",
              "updatedAt": "2018-06-04T13:49:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2MjU1Mzgx",
          "commit": {
            "abbreviatedOid": "5f6b979"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM\r\n\r\nAbout the multicast concern: I agree that it would be good if this could function for multicast reception too, and I couldn't tell if this is suitable for multicast. I suspect that multicast support is much harder anyway - see RFC 3678... so for now, this is a good step forward IMO, and let's discuss how this relates to multicast when we see a concrete text proposal that addresses it.",
          "createdAt": "2018-06-06T07:07:21Z",
          "updatedAt": "2018-06-06T07:07:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2MjYyOTMw",
          "commit": {
            "abbreviatedOid": "5f6b979"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "ok, with the caveat that we need to keep multicast as an open issue",
          "createdAt": "2018-06-06T07:37:36Z",
          "updatedAt": "2018-06-06T07:37:36Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9c51ffcebe664a4ba534b85adc5ae1137dfb94e8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "unidirectional",
      "headRefOid": "5f6b979c8222b6db674335a12532920c6ec3cdf8",
      "mergeCommit": {
        "oid": "520e1be4e4ab04e91382fc3c88773321f37a0c4d"
      }
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkyOTE0NTA2",
      "title": "Congestion control and Gorry's read-through comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/193",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "fixes #158, and addresses #186",
      "createdAt": "2018-06-06T06:44:48Z",
      "updatedAt": "2018-09-03T15:46:55Z",
      "closedAt": "2018-06-09T12:13:00Z",
      "mergedAt": "2018-06-09T12:13:00Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDg0Njcz",
          "commit": {
            "abbreviatedOid": "c75e411"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good",
          "createdAt": "2018-06-08T09:04:02Z",
          "updatedAt": "2018-06-08T09:04:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MzY0MjE3",
          "commit": {
            "abbreviatedOid": "c75e411"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-09T12:12:55Z",
          "updatedAt": "2018-06-09T12:12:55Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9c51ffcebe664a4ba534b85adc5ae1137dfb94e8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "taps-drafts-mw-several-updates",
      "headRefOid": "c75e411695cf9a3294e9294f76943ffaffb36eb2",
      "mergeCommit": {
        "oid": "7eb650b13e02fc0f7b82fc8ae3a0a9219c1cfbe5"
      }
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMTcxNDAw",
      "title": "Prescribe policies for gathering multiple security protocols (or actually, not)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/194",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Addresses #172.\r\n\r\nWe are limited to only recommending conditions for which multiple security protocols should be offered up. We cannot and should not attempt to define security protocol equivalence. Equivalent algorithms, for example, is not a sufficient condition for equivalence. I give an example of this for TLS 1.2 and 1.3. I think it might behoove us to consider a cross-area document that attempts to define security protocol equivalence to help guide implementations. It's definitely out of scope for these three documents. ",
      "createdAt": "2018-06-06T23:57:59Z",
      "updatedAt": "2018-06-22T04:03:36Z",
      "closedAt": "2018-06-22T04:03:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@tfpauly I am opposed to adding any text that tries to articulate what security protocol equivalence is, and try to more specifically suggest circumstances in which it is safe to race competing security protocols. Brian's suggestion regarding specifying protocols by name is probably the safest and best way to go. ",
          "createdAt": "2018-06-12T16:21:07Z",
          "updatedAt": "2018-06-12T16:21:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood That's not what I meant\u2014I need to write a section overall on transport protocol equivalence, which currently is not treated. The comments about security protocol equivalence, whether it exists or not, needs to be written in context and perhaps contrast to that general discussion.",
          "createdAt": "2018-06-12T16:23:39Z",
          "updatedAt": "2018-06-12T16:23:39Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure whether we want to call it \"protocol equivalence\" or just spin it as \"find protocol candidates that satisfy requirements\" \u2013 To be raced, protocols only need to fit (be equivalent with respect to the application's requirements).\r\n\r\nI  have done this categorization for most transport aspects and plan to add this to draft-tiesel-communitgrany, but this gets a little lengthy to make it a section here. Defining this for security protocols would be possible, but probably hard to get consensus on.",
          "createdAt": "2018-06-15T10:57:32Z",
          "updatedAt": "2018-06-15T10:57:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@philsbln defining security protocol equivalence is outside the scope of these documents and TAPS as a whole, IMO.",
          "createdAt": "2018-06-18T03:29:29Z",
          "updatedAt": "2018-06-18T03:29:42Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I am not advocating for solving the security protocol equivalence problem here.\r\n\r\nStill, I guess it would be good to have the TAPS API not preventing an implementation that has a definition of security protocol equivalence to make use of it.",
          "createdAt": "2018-06-19T13:35:52Z",
          "updatedAt": "2018-06-19T15:17:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i would go so far as to say that, at this point in the development of security protocols, any implementation of a system purporting to provide security protocol equivalence is almost certainly wrong. the set of  ways in which these things differ from each other is much more subtle than transport protocols in ways that may appear to work without actually guaranteeing given properties. here, safety dictates that we do need to be able to reach into the stack here for now.",
          "createdAt": "2018-06-20T14:36:39Z",
          "updatedAt": "2018-06-20T14:36:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "+1 to Brian's comment! \r\n\r\n@all, Tommy is going to write a more general section on protocol equivalence that focuses primarily on the transport bits. This proposed text will be reworked and pulled in there. When done, I'll close this PR.",
          "createdAt": "2018-06-20T14:53:48Z",
          "updatedAt": "2018-06-20T14:53:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Take a look at #199, and add what you'd like there; then we can close this PR once that's ready to go?",
          "createdAt": "2018-06-21T16:51:18Z",
          "updatedAt": "2018-06-21T16:51:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Good to go! Closing this beast.",
          "createdAt": "2018-06-22T04:03:36Z",
          "updatedAt": "2018-06-22T04:03:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDg0Njc5",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T09:02:48Z",
          "updatedAt": "2018-06-11T09:02:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't understand this should \u2013 does that mean we don't want racing between e.g. DTLS and QUIC because they use different security protocols? It is clear that stacking arbitrarily security protocols is a bad idea but this sentence does tell me no racing between security protocols with the next one realativising this.",
              "createdAt": "2018-06-11T09:02:48Z",
              "updatedAt": "2018-06-11T09:02:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NTA4OTM2",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "a few changes, but this points in the right direction.",
          "createdAt": "2018-06-11T10:16:11Z",
          "updatedAt": "2018-06-11T10:36:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "so there's apparent confusion here between \"select for attempted racing\" and \"use in the configured stack\". The latter is clearly nonsensical. The former is also potentially problematic, and I think that's what this SHOULD is trying to avoid...",
              "createdAt": "2018-06-11T10:16:11Z",
              "updatedAt": "2018-06-11T10:36:15Z"
            },
            {
              "originalPosition": 19,
              "body": "I think we can probably be simpler about this for now: application MUST specify crypto protocols by name and preference. I don't think we have enough understanding yet to do crypto stack equivalence the same way we can do transport stack equivalence.",
              "createdAt": "2018-06-11T10:35:39Z",
              "updatedAt": "2018-06-11T10:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQwNzQ2",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Overall, I think this section should not exist on its own, but be part of the broader section I'm going to be adding on protocol equivalence, racing, etc.\r\n\r\nWould you be fine with me lifting this text, but trying to contextualize it in a broader story?",
          "createdAt": "2018-06-12T16:11:47Z",
          "updatedAt": "2018-06-12T16:13:07Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "What do you mean by \"only one security protocol SHOULD be used\"? Also, we aren't using capital SHOULDs and MUSTs right now in the document.",
              "createdAt": "2018-06-12T16:11:47Z",
              "updatedAt": "2018-06-12T16:13:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQzNTQy",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:18:49Z",
          "updatedAt": "2018-06-12T16:18:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yes, it's pointed at the former. Basically, do NOT race DTLS and QUIC.",
              "createdAt": "2018-06-12T16:18:49Z",
              "updatedAt": "2018-06-12T16:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQzNzU2",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:19:26Z",
          "updatedAt": "2018-06-12T16:19:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Agreed. That's what I'm trying to spell out here. Do not race security protocols since we don't know what's equal and what's not.",
              "createdAt": "2018-06-12T16:19:26Z",
              "updatedAt": "2018-06-12T16:19:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQzODgz",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:19:43Z",
          "updatedAt": "2018-06-12T16:19:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Don't try to race DTLS and QUIC!",
              "createdAt": "2018-06-12T16:19:43Z",
              "updatedAt": "2018-06-12T16:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQ0ODc0",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:22:08Z",
          "updatedAt": "2018-06-12T16:22:08Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Okay, that's not very clear",
              "createdAt": "2018-06-12T16:22:08Z",
              "updatedAt": "2018-06-12T16:22:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDQ1OTMy",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:24:58Z",
          "updatedAt": "2018-06-12T16:24:59Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "What would make it more clear? The text seems fairly blunt: don't use more than one. ",
              "createdAt": "2018-06-12T16:24:58Z",
              "updatedAt": "2018-06-12T16:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MzQ0MDM4",
          "commit": {
            "abbreviatedOid": "7da6172"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T12:04:16Z",
          "updatedAt": "2018-06-13T12:04:16Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Do we need this much detail? This seems to be saying that once the set of candidates has been identified, those that don't provide appropriate security properties must be discarded before attempting to establish a connection. The implementation draft will need to provide guidance on what that means, but the architecture can be less specific. ",
              "createdAt": "2018-06-13T12:04:16Z",
              "updatedAt": "2018-06-13T12:04:16Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "520e1be4e4ab04e91382fc3c88773321f37a0c4d",
      "headRepository": "chris-wood/taps-apidrafts",
      "headRefName": "caw/equivalence",
      "headRefOid": "7da61723bdaf73277f4d0fb8ee34f200719aee63",
      "mergeCommit": null
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzOTc0Nzcy",
      "title": "API events",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/195",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Suggestion to address #155 and #157 in the API doc.",
      "createdAt": "2018-06-11T13:04:50Z",
      "updatedAt": "2018-06-20T14:52:54Z",
      "closedAt": "2018-06-20T14:52:49Z",
      "mergedAt": "2018-06-20T14:52:49Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NjY4MjA4",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A couple of things - quite possible that it's me misunderstanding things, dunno!",
          "createdAt": "2018-06-11T17:38:36Z",
          "updatedAt": "2018-06-11T17:44:34Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "\"The details ... is a detail\" isn't so great",
              "createdAt": "2018-06-11T17:38:36Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            },
            {
              "originalPosition": 104,
              "body": "How can you guarantee that?  An abort can happen at any time, and that would give you a ConnectionError. Maybe I don't understand what \"outstanding\" means... or maybe it needs to be defined?",
              "createdAt": "2018-06-11T17:43:42Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            },
            {
              "originalPosition": 38,
              "body": "What's the point of this - how is it different from Abort?",
              "createdAt": "2018-06-11T17:44:06Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODgyNjI5",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T09:21:06Z",
          "updatedAt": "2018-06-12T09:21:07Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "This really depends on the concurrency model of the implementation platform. If the platform does callbacks, it ensures this by enqueueing dispatch of close/connection error after the dispatch of all other events is completed. If the platform does CSP dispatch, this naturally happens because a channel creates a queue. If the platform dispatches every event to a new thread, then this is hard, but it's kind of the platform's fault then...",
              "createdAt": "2018-06-12T09:21:06Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODg0MTYy",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T09:25:41Z",
          "updatedAt": "2018-06-12T09:25:42Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "actually, this is `Preconnection.Stop()`, not `Connection.Abort()`. It's for no longer listening (indeed, I considered calling it `Unlisten()` but that would be weird)",
              "createdAt": "2018-06-12T09:25:41Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODg0MjQ3",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T09:25:52Z",
          "updatedAt": "2018-06-12T09:25:53Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "agreed.",
              "createdAt": "2018-06-12T09:25:52Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODkyMzQz",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T09:49:10Z",
          "updatedAt": "2018-06-12T09:49:11Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Ah, sorry, missed this, it's for cleaning up a Preconnection. That makes sense to me. But semantically this seems quite similar to abort to me - a way to say \"I don't want to use this anymore, from now on\" - so why not give it the same name?  (though I don't care much about the name)",
              "createdAt": "2018-06-12T09:49:10Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODkzNzQ1",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T09:53:23Z",
          "updatedAt": "2018-06-12T09:53:24Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Okay, you mean \"outstanding\" as in \"enqueued locally\". Then this should be phrased as \"locally outstanding\" or something like that, I think.  To be clear, I have no problem at all with the first sentence - it's the second one that makes me think of the protocol machinery when I read \"outstanding\" - as in outstanding packets, incoming messages, causing events...",
              "createdAt": "2018-06-12T09:53:24Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3OTMwMTAz",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T11:56:52Z",
          "updatedAt": "2018-06-12T11:56:52Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Does this mean `Closed<>` can't fire until you're sure there can be no errors from the peer (e.g., after the TIME_WAIT timeout for TCP)?",
              "createdAt": "2018-06-12T11:56:52Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3OTcwMzky",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T13:45:09Z",
          "updatedAt": "2018-06-12T13:45:10Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is there a reason not calling it ``Preconnection.Abort()``",
              "createdAt": "2018-06-12T13:45:10Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDAzNjkz",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T14:53:49Z",
          "updatedAt": "2018-06-12T14:53:50Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Exactly what I meant - sorry for not saying it clearer",
              "createdAt": "2018-06-12T14:53:50Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDU1MTI5",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:49:22Z",
          "updatedAt": "2018-06-12T16:49:22Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I agree with the approach of always having some final event (whether this is Closed or something else like Invalidated is another point).\r\n\r\nIf the connection has been dropped by the application, then I think the assumption is that if there are any errors that occurred later, the application would have no way of receiving them anyhow, so they must be silently discarded?",
              "createdAt": "2018-06-12T16:49:22Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDU2NzI5",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T16:53:48Z",
          "updatedAt": "2018-06-12T16:53:49Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "See my comments on the `Closing` issue\u2014I do think that this is of no benefit to the application, and doesn't provide a meaningful signal in the state machine. We can certainly prohibit send and receive after close, but that doesn't necessarily align with a closing state when things are asynchronous.",
              "createdAt": "2018-06-12T16:53:48Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDYwNDg0",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T17:03:45Z",
          "updatedAt": "2018-06-12T17:03:46Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "IMO `Abort()` should be used for exceptional or abnormal termination, and this is used for a normal termination of listening.",
              "createdAt": "2018-06-12T17:03:45Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDYxMjI5",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T17:05:43Z",
          "updatedAt": "2018-06-12T17:05:44Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "+1 to \"locally outstanding\", will fix. Will have to think about `Closed<>` versus `ConnectionError<>`. ",
              "createdAt": "2018-06-12T17:05:43Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjc3OTgz",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-20T08:01:11Z",
          "updatedAt": "2018-06-20T08:01:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDE1NDcy",
          "commit": {
            "abbreviatedOid": "982c552"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T14:14:33Z",
          "updatedAt": "2018-06-20T14:14:34Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "ISTM there's probably another PR for the closing state issue once discussion completed; I won't address this here.",
              "createdAt": "2018-06-20T14:14:33Z",
              "updatedAt": "2018-06-20T14:15:00Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7eb650b13e02fc0f7b82fc8ae3a0a9219c1cfbe5",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "api-events-155-157",
      "headRefOid": "81b9cefe54c9cb58ae9cf0b8f8ed2e258bfa8b59",
      "mergeCommit": {
        "oid": "5959d19538b8f9f961a9947982b633c8a8dd7aaf"
      }
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1NjU4ODgz",
      "title": "Address architecture nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/196",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Integrate Gorry's comments from #187 \r\n\r\nThis does not yet address Gorry's two other issues, which cover the background section, or potentially moving the transport implementation earlier in the document.",
      "createdAt": "2018-06-18T21:51:25Z",
      "updatedAt": "2018-06-20T14:39:48Z",
      "closedAt": "2018-06-20T14:39:42Z",
      "mergedAt": "2018-06-20T14:39:42Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDA4OTEy",
          "commit": {
            "abbreviatedOid": "f89e356"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-20T14:00:41Z",
          "updatedAt": "2018-06-20T14:00:41Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7eb650b13e02fc0f7b82fc8ae3a0a9219c1cfbe5",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-nits",
      "headRefOid": "f89e3565f18036bd9aa66fb4784d036779670873",
      "mergeCommit": {
        "oid": "bc4658066a98e7dc5003ff4930d00f3868e82dc9"
      }
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1ODgyNzA1",
      "title": "Abstract security parameter configuration, and unify the interface with the security survey draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/197",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-19T16:14:54Z",
      "updatedAt": "2018-06-20T20:14:32Z",
      "closedAt": "2018-06-20T20:14:32Z",
      "mergedAt": "2018-06-20T20:14:32Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjc2MzY2",
          "commit": {
            "abbreviatedOid": "8ae2631"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM in general, but please check my comment about references.",
          "createdAt": "2018-06-20T07:56:10Z",
          "updatedAt": "2018-06-20T07:56:54Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Do these things need references?  E.g. \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\" ?",
              "createdAt": "2018-06-20T07:56:11Z",
              "updatedAt": "2018-06-20T07:56:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDE3NDg0",
          "commit": {
            "abbreviatedOid": "8ae2631"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-20T14:18:43Z",
          "updatedAt": "2018-06-20T14:19:07Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "eh... in examples, it's probably okay ",
              "createdAt": "2018-06-20T14:18:43Z",
              "updatedAt": "2018-06-20T14:19:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDM1MzI0",
          "commit": {
            "abbreviatedOid": "8ae2631"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T14:50:14Z",
          "updatedAt": "2018-06-20T14:50:14Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "@mwelzl I agree with Brian here, especially since these are meant to be abstract constants that each implementation could, on its on, redefine using some other constant or enum.",
              "createdAt": "2018-06-20T14:50:14Z",
              "updatedAt": "2018-06-20T14:50:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNTY0Mjc3",
          "commit": {
            "abbreviatedOid": "8ae2631"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T19:57:06Z",
          "updatedAt": "2018-06-20T19:57:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "ok by me then. just wanted to check",
              "createdAt": "2018-06-20T19:57:06Z",
              "updatedAt": "2018-06-20T19:57:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNTY0MzU3",
          "commit": {
            "abbreviatedOid": "8ae2631"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-20T19:57:21Z",
          "updatedAt": "2018-06-20T19:57:21Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7eb650b13e02fc0f7b82fc8ae3a0a9219c1cfbe5",
      "headRepository": "chris-wood/taps-apidrafts",
      "headRefName": "caw/abstractify",
      "headRefOid": "8ae2631c9345f52a81c8fd390838ff1f47265be9",
      "mergeCommit": {
        "oid": "08933f37cc1a03e2511cd4cf3a88c7a06e551328"
      }
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1OTQ4NzY5",
      "title": "Split Message receive Metadata into a separate section",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/198",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "And add an early data metadata value.",
      "createdAt": "2018-06-19T20:30:10Z",
      "updatedAt": "2018-06-20T14:51:48Z",
      "closedAt": "2018-06-20T14:51:47Z",
      "mergedAt": "2018-06-20T14:51:47Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjc3NTQ4",
          "commit": {
            "abbreviatedOid": "ed1dc1a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Much better I think!",
          "createdAt": "2018-06-20T07:59:50Z",
          "updatedAt": "2018-06-20T07:59:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMzM3MTk4",
          "commit": {
            "abbreviatedOid": "ed1dc1a"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good - minor nits noted in comments.",
          "createdAt": "2018-06-20T10:49:04Z",
          "updatedAt": "2018-06-20T10:51:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Is this change intended?",
              "createdAt": "2018-06-20T10:49:04Z",
              "updatedAt": "2018-06-20T14:43:14Z"
            },
            {
              "originalPosition": 53,
              "body": "Better - although I wonder if it should be \"Idempotent Early Data\"?",
              "createdAt": "2018-06-20T10:50:52Z",
              "updatedAt": "2018-06-20T14:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDA3MTc0",
          "commit": {
            "abbreviatedOid": "ed1dc1a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "this looks good, requesting same edits as @csperkins ",
          "createdAt": "2018-06-20T13:56:51Z",
          "updatedAt": "2018-06-20T13:59:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "+1, this looks like an editor regression",
              "createdAt": "2018-06-20T13:56:51Z",
              "updatedAt": "2018-06-20T14:43:14Z"
            },
            {
              "originalPosition": 53,
              "body": "also +1 to \"idempotent early data\" (the former is implied by Early Data in a TLS context, but not necessarily in a transport context)",
              "createdAt": "2018-06-20T13:59:20Z",
              "updatedAt": "2018-06-20T14:43:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDI5Njg2",
          "commit": {
            "abbreviatedOid": "ed1dc1a"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T14:39:12Z",
          "updatedAt": "2018-06-20T14:43:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yeah, uh, or fat finger. Oops.",
              "createdAt": "2018-06-20T14:39:12Z",
              "updatedAt": "2018-06-20T14:43:15Z"
            },
            {
              "originalPosition": 53,
              "body": "@britram @csperkins That implies that this metadata signals whether or not data is idempotent, which is something only applications can determine. The TAPS system can only determine if something was received as part of early data or not. I added some text clarifying this.",
              "createdAt": "2018-06-20T14:40:41Z",
              "updatedAt": "2018-06-20T14:44:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDM1OTUw",
          "commit": {
            "abbreviatedOid": "ad5060a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "yay lgtm",
          "createdAt": "2018-06-20T14:51:30Z",
          "updatedAt": "2018-06-20T14:51:30Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7eb650b13e02fc0f7b82fc8ae3a0a9219c1cfbe5",
      "headRepository": "chris-wood/taps-apidrafts",
      "headRefName": "caw/message-metadata",
      "headRefOid": "ad5060ad6d3b7275afda8493b63c4d5f089b10b7",
      "mergeCommit": {
        "oid": "e203f9e3763f4dfacb42c0d14252b3066de69d7c"
      }
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NTExODU3",
      "title": "Add architecture text for protocol equivalence",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/199",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Satisfies #172, including text for both generic protocol equivalence and security protocols.\r\n\r\nWe may want to move the section around organizationally later, as per some of Gorry's comments on structure. However, I reference terms from our concept definitions, so it is easier to write in the latter portion of the document.",
      "createdAt": "2018-06-21T16:40:12Z",
      "updatedAt": "2018-09-26T06:43:42Z",
      "closedAt": "2018-06-24T18:42:28Z",
      "mergedAt": "2018-06-24T18:42:28Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU1MTcy",
          "commit": {
            "abbreviatedOid": "746fb06"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-22T03:09:55Z",
          "updatedAt": "2018-06-22T03:12:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "This is good text! Here's a slight variation that focuses less on encryption and more on general properties:\r\n\r\nThe inclusion of transport security protocols {{I-D.ietf-taps-transport-security}} in a Protocol Stack adds extra restrictions to Protocol Stack equivalence. Security features and properties, such as cryptographic algorithms, peer authentication guarantees, and identity hiding (or absence thereof) vary across security protocols, and across versions of security protocols. Protocol equivalence should not be assumed for different protocols or protocol versions, even if they offer similar application configuration options.\r\n",
              "createdAt": "2018-06-22T03:09:55Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            },
            {
              "originalPosition": 21,
              "body": "How about: \r\n\r\n... are identical. For safety and security reasons, implementations should consider protocols identical if they are of the same type and version. For example, the same version of TLS running over two different transport protocol stacks may be considered equivalent, whereas TLS 1.2 and TLS 1.3 should not be considered equivalent.",
              "createdAt": "2018-06-22T03:12:05Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU1OTk5",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T03:18:00Z",
          "updatedAt": "2018-06-22T03:18:00Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Thanks! Updated.",
              "createdAt": "2018-06-22T03:18:00Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU2MDE5",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T03:18:10Z",
          "updatedAt": "2018-06-22T03:18:10Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thanks! Updated, and added document reference.",
              "createdAt": "2018-06-22T03:18:10Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDU2OTQ1",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-06-22T03:27:01Z",
          "updatedAt": "2018-06-22T03:27:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMTUwNzEw",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "tiny editorial nits on section refs otherwise this is good to go",
          "createdAt": "2018-06-22T10:48:05Z",
          "updatedAt": "2018-06-22T10:48:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "this kind of linking generates weird text; suggest \"or raced in parallel (see {{racing}})\".",
              "createdAt": "2018-06-22T10:48:05Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            },
            {
              "originalPosition": 15,
              "body": "same comment",
              "createdAt": "2018-06-22T10:48:24Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMjQ3MDM2",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T15:45:08Z",
          "updatedAt": "2018-06-22T15:45:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Fixed!",
              "createdAt": "2018-06-22T15:45:08Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMjQ3MDcw",
          "commit": {
            "abbreviatedOid": "f43c825"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T15:45:12Z",
          "updatedAt": "2018-06-22T15:45:13Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Fixed!",
              "createdAt": "2018-06-22T15:45:13Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMjczMDk0",
          "commit": {
            "abbreviatedOid": "d286f6b"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "One comment inline, but otherwise looks good.",
          "createdAt": "2018-06-22T17:05:31Z",
          "updatedAt": "2018-06-22T17:07:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Possibly \"might be allowed as an equivalent Protocol Stack provided the addition of reliability does not conflict with other requested properties, such as timing\"? It's not always safe to add reliability.",
              "createdAt": "2018-06-22T17:05:31Z",
              "updatedAt": "2018-06-22T22:19:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMzYyNDA1",
          "commit": {
            "abbreviatedOid": "cb710a7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T22:19:36Z",
          "updatedAt": "2018-06-22T22:19:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Okay, clarified ",
              "createdAt": "2018-06-22T22:19:36Z",
              "updatedAt": "2018-06-22T22:19:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDI5ODI5",
          "commit": {
            "abbreviatedOid": "cb710a7"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-24T16:56:10Z",
          "updatedAt": "2018-06-24T16:56:10Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "08933f37cc1a03e2511cd4cf3a88c7a06e551328",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/equivalence",
      "headRefOid": "cb710a771d3015672730cbdce07d0fa8ac888870",
      "mergeCommit": {
        "oid": "f9acc9d5e450d9152e99abc2235033e0edf0bde0"
      }
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2OTc0Njgw",
      "title": "Rework partial sends and receives",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/200",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Satisfies #148 \r\n\r\n- Support partial sends more naturally by splitting out into Message, messageData, and endOfMessage flag.\r\n- Do the same for Receive\r\n- Receive should also take minIncompleteLength to specify how partial receives are treated (or not, by default)",
      "createdAt": "2018-06-24T23:02:09Z",
      "updatedAt": "2018-09-26T06:43:28Z",
      "closedAt": "2018-06-27T14:33:00Z",
      "mergedAt": "2018-06-27T14:33:00Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like a good approach.\r\nI have a general question about setting Message Properties:\r\nThis Pull Request gets rid of an explicit MessageProperties object and instead sets any Message Properties directly on the Message. For (Pre-)Connections, we do have an explicit TransportProperties object, which has the advantage that it can be reused across multiple Connections without being tied to any specific Connection. I think that the same would be useful for Messages, e.g., across multiple threads. \r\nWhat is the advantage of setting properties directly on a Message, versus having an explicit MessageProperties object, which is then assigned to the Message?",
          "createdAt": "2018-06-25T07:55:55Z",
          "updatedAt": "2018-06-25T07:55:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - your idea sounds interesting, but from your description I don't understand why this reduces complexity in the API.\r\n\r\nI think the complexity is related to ordering. If we assume that, on the receiver side, message fragments are only delivered in order, things become easier. Then we may only need an extra signal to tell the receiver that remaining fragments will never arrive.",
          "createdAt": "2018-06-25T13:20:20Z",
          "updatedAt": "2018-06-25T13:20:20Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the general idea and I agree having an explicit message object really is a way out, but I also think the API in this PR exposes too many details and makes the \"common\" case unnecessarily complicated.\r\n\r\nI like @csperkins Idea to move that partial send complexity into the message object.",
          "createdAt": "2018-06-25T15:00:29Z",
          "updatedAt": "2018-06-25T15:00:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on second thought, let me +1 @csperkins on \"move partial send complexity into the message object\":\r\n\r\n- to send a partial message, get a message and keep writing bytes to it.\r\n\r\n- to receive a partial message, get a message that indicates that the octets read from it are not the whole message.",
          "createdAt": "2018-06-25T16:28:10Z",
          "updatedAt": "2018-06-25T16:28:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins Right, having Message objects be the active objects for sending and receiving is the other option. That's the one that we had implemented back when we were working on Minion, years ago. It certainly can work, but adds a ton of complexity to the application workflow, and reduces the ability to have meaningful back pressure and flow control.\r\n\r\nI think that to a large degree, this PR is just writing out the underlying way that sending and receiving in the current draft works. Here's the long form of sending that works for partial and complete:\r\n\r\nSend(messageContext, messageData, endOfMessage)\r\n\r\nThe default for endOfMessage should be true, therefore most applications will just see:\r\n\r\nSend(messageContext, messageData)\r\n\r\nAnd the the default for messageContext should be the default parameters for a new message, so most\r\napplications (using UDP, for example) will just see:\r\n\r\nSend(messageData)\r\n\r\nThe same is true for receive. We can give the variants of Send to be partial or not different names, but they boil down to convenience/default sets of the same thing.\r\n\r\nThe key points here are these:\r\n1. The properties of a message need to be the same across multiple partial sends if there are multiple partial sends. If the application is streaming a long message, then the properties of that message apply to all of the data.\r\n2. The completion handlers for Send actions that provide notions of back pressure and errors *must* be per data chunk sent, not per message. If I am streaming a long message, then I will likely need to handle flow control, and the completion handler for send can't just be on the whole message, it needs to be on the partial chunks.\r\n\r\nIf you move to sending data on a new Message object rather than the Connection, you would need to have back pressure on those sends too. It becomes very complicated for the application:\r\n\r\nConnection.Send(Message) -> MessageSentHandler[May have error but can't be used for flow control]\r\nMessage.Send(bytes) -> DataSentHandler[Used for per-message flow control, which now becomes difficult to coordinate with other messages if you have a stream with HOL blocking]\r\n\r\nGoing down this road means that partial sends become front-and-center for applications dealing with the API, even when they don't want it, and adds an extra layer of indirection just to get basic bytes on the wire for a transport.\r\n\r\nThe approach in this PR ends up being a way to allow expressiveness for partial sends when they are needed, but allows applications to ignore it most of the time with defaults and write the simplest code.",
          "createdAt": "2018-06-25T16:53:30Z",
          "updatedAt": "2018-06-25T16:53:30Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  but allows applications to ignore it most of the time with defaults and write the simplest code.\r\n\r\nTo date we've avoided adding alternate action and event signatures to this API, leaving what gets defaulted and how up to the platform. Perhaps we should explicitly suggest/define which parts of the API should be defaulted out... I think that would go a long way to reducing the apparent complexity of this approach.",
          "createdAt": "2018-06-25T18:25:13Z",
          "updatedAt": "2018-06-25T18:25:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, having the default support makes things much easier. For languages that support defaults (Swift, for us), you can do the scheme like I had above. For languages like C, you can write out the common sets of calls, which all can be implemented using the most complex:\r\n\r\n`connection_partial_send(data_t data, message_context_t message, bool end_of_message)`\r\n`connection_send(data_t data, message_context_t message)`\r\n`connection_default_message_send(data_t data)`",
          "createdAt": "2018-06-25T19:35:05Z",
          "updatedAt": "2018-06-25T19:35:05Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on introducing defaults. The API is beginning to get quite complex. Maybe we should explicitly split up the send section in \"Basic Send Operations\" and \"Advanced Send Functionality\" or something like that. Splitting up other relevant sections in a similar way. ",
          "createdAt": "2018-06-25T22:53:52Z",
          "updatedAt": "2018-06-25T22:53:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom Sure, I can work tomorrow on splitting out the definition of the simple send operations, versus the more full story for partial sends. We can mention as an implementation detail that everything in the simpler approach for atomic messages can be expressed in terms of defaults in the variants that support partial sends, and leave the specific symbol bindings as a per-language choice.",
          "createdAt": "2018-06-26T04:33:39Z",
          "updatedAt": "2018-06-26T04:33:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "+1 to @abrunstrom's recommendation.",
          "createdAt": "2018-06-26T12:01:55Z",
          "updatedAt": "2018-06-26T12:01:55Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "addressing @abrunstrom's comment here would make this ready to land IMO. I'd like to get this and #201 in soon so we can submit -01 in time, and keep working on this in person in Montreal.",
          "createdAt": "2018-06-26T16:07:15Z",
          "updatedAt": "2018-06-26T16:07:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, just updated the Sending side to break out basic sends, sending with context, and partial sends. I'll do a bit more work on receiving too today, but take a look at the sending side and see if that addresses the comments there.",
          "createdAt": "2018-06-26T18:39:15Z",
          "updatedAt": "2018-06-26T18:39:15Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @tfpauly for the restructuring, I like the new structure! I find it much more clear and readable.\r\n\r\nOne question on the Events in the relation to the partial sends. If I understand it correctly Sent Events relate to specific send calls whereas Expired Events relate to an entire Message. Not sure about SendError Events? Seems there it may depend on what the error is. Not sure if this is something that needs to be clarified further. ",
          "createdAt": "2018-06-26T19:59:54Z",
          "updatedAt": "2018-06-26T19:59:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I personally think it's simplest if the events correspond to Send events, so if you did a 2 partial sends for a single message that expired, you should get two Expired events if neither could be sent, etc.",
          "createdAt": "2018-06-26T20:51:20Z",
          "updatedAt": "2018-06-26T20:51:20Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense, thanks.",
          "createdAt": "2018-06-26T21:13:39Z",
          "updatedAt": "2018-06-26T21:13:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've added the rest of my reworked text, to bring Receives into the same style as Send (with the basic approach up front, and partial phrased as an extension later on). Thanks for all of the good feedback, I think this text is certainly clearer!\r\n\r\n@abrunstrom I added some text about how Send events are delivered when there are multiple Sends per Message, please check.\r\n\r\n@mwelzl I added text to explain that receiving is only in-order contiguous chunks, and clarified that you can't span a message over multiple datagrams directly, etc.",
          "createdAt": "2018-06-26T21:38:57Z",
          "updatedAt": "2018-06-26T21:38:57Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @tfpauly , the added text looks good to me!",
          "createdAt": "2018-06-26T22:53:11Z",
          "updatedAt": "2018-06-26T22:53:11Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This LGTM now, thanks a lot for doing this!",
          "createdAt": "2018-06-27T07:24:03Z",
          "updatedAt": "2018-06-27T07:24:03Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly wrote:\r\n>The key points here are these:\r\n>\r\n>The properties of a message need to be the same across multiple partial sends if there are multiple partial sends. If the application is streaming a long message, then the properties of that message apply to all of the data.\r\n>The completion handlers for Send actions that provide notions of back pressure and errors must be per data chunk sent, not per message. If I am streaming a long message, then I will likely need to handle flow control, and the completion handler for send can't just be on the whole message, it needs to be on the partial chunks.\r\n\r\nAgree with these.\r\n\r\n>If you move to sending data on a new Message object rather than the Connection, \r\n\r\nI wasn't arguing to move the sending data onto the Message object. In my approach, the Connection would still handle sending the data, but rather than have the application provide chunks of data, I was suggesting to have the connection pull data from the message object as needed.\r\n\r\n>you would need to have back pressure on those sends too. It becomes very complicated for the application:\r\n\r\nDon't we need that back pressure anyway? If one sends a message object from which data is pulled as needed, then I agree the connection would need to generate `PartiallySent` events before the final `Sent` event. But, we don't avoid that need by splitting the data up at the application level and making partial send requests: with a transport like TCP the connection can always block, and will need to generate a `PartiallySent` event, no matter whether the application has split the data into chunks before calling send or not.\r\n\r\nIt's perhaps easier for the application to change what it sends, or cancel the send, if it send chunk-by-chunk \u2013\u00a0that I agree \u2013\u00a0but otherwise I don't see a complexity saving.",
          "createdAt": "2018-06-27T09:19:36Z",
          "updatedAt": "2018-06-27T09:19:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins Regarding backpressure, you're right that we do need backpressure on all chunks that are sent. However, by allowing partial sends to be expressed in the native send action of the Connection, they automatically get the same backpressure that complete sends get. Each Sent event is one-to-one with a Send action, whether partial or complete.",
          "createdAt": "2018-06-27T14:31:42Z",
          "updatedAt": "2018-06-27T14:31:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I think based on the reviews we're in a good state to land this, and I do want to unblock merging for #201. As such, I'm going to go ahead and merge.",
          "createdAt": "2018-06-27T14:32:52Z",
          "updatedAt": "2018-06-27T14:32:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ4MzQ5",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Overall, this looks good. I mostly have editorial questions.",
          "createdAt": "2018-06-25T01:49:28Z",
          "updatedAt": "2018-06-25T02:06:28Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "s/will/will be",
              "createdAt": "2018-06-25T01:49:28Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 199,
              "body": "s/that is/i.e.?",
              "createdAt": "2018-06-25T01:49:45Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 6,
              "body": "Should we use something other than association here? That may complicate references to association elsewhere.",
              "createdAt": "2018-06-25T01:50:52Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 31,
              "body": "Remove \"any\"?",
              "createdAt": "2018-06-25T01:51:49Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 84,
              "body": "Maybe comment that message parameters cannot change after Send is invoked? ",
              "createdAt": "2018-06-25T02:00:53Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 155,
              "body": "If it's optional, it should be the last parameter, or we should specify that a value of 0 is the default when one should use it.",
              "createdAt": "2018-06-25T02:01:43Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 160,
              "body": "Since the last case is exceptional, perhaps we should mention that applications must check the received length before use, as it may be less than minIncompleteLength?",
              "createdAt": "2018-06-25T02:03:33Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 193,
              "body": "Partial message data is sent in-order. Received data may be received out-of-order, right? Do we need to clarify that?",
              "createdAt": "2018-06-25T02:05:12Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDg0Mzky",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks @tfpauly for doing this... this seems to be the simplest way to handle message non-atomicity while still providing for atomic(-like) sends and receives in the general case. All of my problems with what's here are about the elegance of the interface the programmer will see (a \"Message\" that is separate from the content seems misnamed; this adds complexity that we should make sure everyone knows can be papered over with syntactic sugar in the common case).\r\n\r\nI'm happy with landing this as-is for Montreal and filing an issue to discuss in person, though.",
          "createdAt": "2018-06-25T06:50:48Z",
          "updatedAt": "2018-06-25T08:51:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\u201cbound to\u201d maybe? \u201cTogether with\u201d?",
              "createdAt": "2018-06-25T06:50:48Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 11,
              "body": "beating the elegance and simplicity drum again: this is correct, but it\u2019d be nice to note here, especially, that syntactic sugar and reasonable defaults are encouraged. ",
              "createdAt": "2018-06-25T06:53:51Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 75,
              "body": "I don\u2019t like \u201cdata portions\u201d here but I struggle to do better...",
              "createdAt": "2018-06-25T06:59:49Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 89,
              "body": "So this raises the question as to why you can\u2019t also bind an octet array to a message instance. Also platform specific sugar, but it seems to me that if you can\u2019t bind data to a thing on send that it should probably not be called a message...",
              "createdAt": "2018-06-25T07:02:29Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 155,
              "body": "in general the question of defaults should be better addressed in this draft. I think we can say that \u201csyntactic sugar is allowed, here are the default behaviors we recommend\u201d. Everything about partial send should be optional. This also implies we need connection-bound default send parameters...",
              "createdAt": "2018-06-25T07:17:44Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 177,
              "body": "as with send, having a thing called a Message as well as messageData also on receive is... confusing. Renaming this to `MessageContext` would fix this at the expense of verbosity and slight obtuseness...",
              "createdAt": "2018-06-25T08:37:51Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTI1Nzkz",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T09:13:17Z",
          "updatedAt": "2018-06-25T09:13:17Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I'm wondering how this works with, e.g., \"Final\" messages. If Message Properties cannot be changed after Send, the application cannot reuse a Message object with an additional \"Final\" parameter added, but needs to create a new Message object just for this purpose, adding all properties of the previous messages to it, and \"Final\". Is this intended?",
              "createdAt": "2018-06-25T09:13:17Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTkwOTQ0",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I see where this is coming from, but I don't like the proposed API \u2013 it exposes a lot of low-level details about partial messages that I was hoping we'd get away from with the new API.\r\n\r\nI wonder if we should regard messages as more active objects? That is, a `Message` is something that knows whether it's complete or not, and that can produce more data as appropriate. The API could then be to `send()` a `Message` object once, then internally the system will repeatedly call `getData()` on the Message object until it returns that it's complete. This makes the conceptual model easier: you just send a message. The complexity of dealing with partial messages, etc., is then pushed into the message object.",
          "createdAt": "2018-06-25T12:48:06Z",
          "updatedAt": "2018-06-25T12:48:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTkyMzc3",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T12:52:06Z",
          "updatedAt": "2018-06-25T12:52:06Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Data blocks?",
              "createdAt": "2018-06-25T12:52:06Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTk3MDIx",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "UPDATE: I'm much happier now after discussion with Tommy. Now it's clear that messages will only be delivered in-order, taking much of the complexity away, and we won't have messages spanning over multiple UDP packets or anything like that.",
          "createdAt": "2018-06-25T13:04:30Z",
          "updatedAt": "2018-06-26T06:21:41Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "This is THE problem I have with this whole thing - it's also the question that I raised at the end of #148 and don't see addressed. Partial messages may arrive out of order, or they may never arrive at all, if we map them on an unreliable transport. At least, applications must have a number to identify that they're now getting message fragment 3 out of 7, something like that.",
              "createdAt": "2018-06-25T13:04:30Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 11,
              "body": "I find the split between Message and messageData awkward. Also, parameters are logically separate from the message itself, so it makes sense to write this as we had it - but \"endOfMessage\" is just one out of many message parameters, so why have this as a \"special\" parameter in the send call?",
              "createdAt": "2018-06-25T13:07:48Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            },
            {
              "originalPosition": 193,
              "body": "And what about partial reliability?  E.g., fragments 1 and 2 out of a total of 3 arrive in time, but for the third, the time expires and the transport gives up. Shouldn't it then tell the receiving application that it will never get the third fragment, and should throw away the first two? ",
              "createdAt": "2018-06-25T13:12:03Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjgzNTM0",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:22:13Z",
          "updatedAt": "2018-06-25T16:22:13Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "i.e. literally means \"that is\", so I think this is about the same?",
              "createdAt": "2018-06-25T16:22:13Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjg0NDU1",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:24:40Z",
          "updatedAt": "2018-06-25T16:24:40Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "If you need to do a write close with Final, you should mark that on your Message in the first send. If you need to send a partial Message that isn't necessarily the Final one, then don't mark it Final. You can later send a complete message that is final with no data.",
              "createdAt": "2018-06-25T16:24:40Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjg0ODM3",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:25:40Z",
          "updatedAt": "2018-06-25T16:25:40Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Both min and max are optional, so they can't both be the last parameter?",
              "createdAt": "2018-06-25T16:25:40Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjg1ODIw",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:28:05Z",
          "updatedAt": "2018-06-25T16:28:05Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "My inclination here is to only receive chunks in order and not deliver gaps. Does that work for you?",
              "createdAt": "2018-06-25T16:28:05Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjg4Mzk2",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:35:17Z",
          "updatedAt": "2018-06-25T16:35:17Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "The data needs to be specific to the send action, not the Message, or else the send action becomes somewhat meaningless. You could call the Message object just MessageContext or MessageParameters or MessageMetadata, which would be a bit more accurate.",
              "createdAt": "2018-06-25T16:35:17Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjg4NTQz",
          "commit": {
            "abbreviatedOid": "22de20d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:35:44Z",
          "updatedAt": "2018-06-25T16:35:45Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "I like MessageContext",
              "createdAt": "2018-06-25T16:35:44Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjkwMTI1",
          "commit": {
            "abbreviatedOid": "6c76d56"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:40:04Z",
          "updatedAt": "2018-06-25T16:40:05Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "Fixed",
              "createdAt": "2018-06-25T16:40:05Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjkwMTgw",
          "commit": {
            "abbreviatedOid": "6c76d56"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:40:13Z",
          "updatedAt": "2018-06-25T16:40:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Fixed",
              "createdAt": "2018-06-25T16:40:13Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjkwNTE5",
          "commit": {
            "abbreviatedOid": "6c76d56"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:41:08Z",
          "updatedAt": "2018-06-25T16:41:08Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Fixed",
              "createdAt": "2018-06-25T16:41:08Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjkwNjAx",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:41:18Z",
          "updatedAt": "2018-06-25T16:41:18Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "@chris-wood Added text",
              "createdAt": "2018-06-25T16:41:18Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNjkwNjU4",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T16:41:27Z",
          "updatedAt": "2018-06-25T16:41:27Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Added text",
              "createdAt": "2018-06-25T16:41:27Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNzgyMDcy",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T21:00:14Z",
          "updatedAt": "2018-06-25T21:00:14Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "@tfpauly I think that's a good direction, as it makes things much easier. I think we\u00a0should then still add a way for the transport system to signal to the application: \"throw away your chunks, the rest is never going to arrive\" - e.g. to support partial reliability.\r\n\r\nBut I have a bigger concern, then: what about UDP? What if I send a large message, the chosen transport is UDP, and the message is split it into 3 packets - first, this is perhaps not a great idea; second, the receiver won't be able to know about the order, so can't even do what you suggest here. How are you going to handle this case?",
              "createdAt": "2018-06-25T21:00:14Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODYyNTA5",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T04:38:41Z",
          "updatedAt": "2018-06-26T04:38:41Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "So, in our implementation, we allow the protocol to require that data for a single message fits within a limit (for UDP, whatever it can fit in a datagram). Splitting up a message over multiple UDP datagrams without any other framing layer on top doesn't make any sense, since there isn't any way for the other side to understand the message. So, in our implementation, we throw an error if you try to do this.\r\n\r\nProtocols on top of UDP, like IKE, may support fragmenting large messages across datagrams, but then the message that you send is first interpreted by a protocol in the stack that supports unbounded message sizes.\r\n\r\nI also do agree that there should be a signal that the chunks won't ever arrive\u2014our implementation passes an optional error along with the ReceiveHandler to indicate this.",
              "createdAt": "2018-06-26T04:38:41Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODc2ODAy",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T06:17:37Z",
          "updatedAt": "2018-06-26T06:17:37Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "Ah ok!  Great, I think that solves it. I'll conclude by requesting the following text:\r\n1) in the API draft, some kind of a signal that the chuncks won't error arrive (as we agreed)\r\n2) in the API draft, for the receiver side, a hint that message chunks will only arrive in order\r\n3) in the implementation draft, a hint that message fragmentation of course requires support by the underlying protocol and thus the size of any message, even with fragmentation, will have to be limited to the message size that the underlying protocol supports. For example, messages can not be spread across multiple UDP packets because the receiver would not understand that the message parts belong together.\r\n\r\nI can take care of 2 and 3 (but I'm fine with you doing it too if you want!  Just offering to help instead of always only criticizing!) .... but for 1), I think it would be better for you to do it since your implementation already does it.  Ok?",
              "createdAt": "2018-06-26T06:17:37Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxOTg1NDIw",
          "commit": {
            "abbreviatedOid": "39692f2"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T12:00:42Z",
          "updatedAt": "2018-06-26T12:00:42Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Yep -- I made the comment before getting to the next paragraph. Maybe add: \"Both minIncompleteLength and maxLength are optional parameters.\" at the beginning of this paragraph, and then proceed to describe them both?",
              "createdAt": "2018-06-26T12:00:42Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMjM0NTMw",
          "commit": {
            "abbreviatedOid": "a4e56c1"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T22:58:42Z",
          "updatedAt": "2018-06-26T22:58:42Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "I understand that the applications should derive the length of the delivered data from the messageData. Perhaps this should be made more explicit? Before I got to the ReceivedPartial Event when reading, where the messageContext was reused for multiple events, I was thinking that the length of the data delivered may be provided to the application as part of the messageContext meta data.",
              "createdAt": "2018-06-26T22:58:42Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMjQzOTE4",
          "commit": {
            "abbreviatedOid": "a4e56c1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T23:51:25Z",
          "updatedAt": "2018-06-26T23:51:25Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "Good point, I'll add an explicit comment about this.",
              "createdAt": "2018-06-26T23:51:25Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMzA4MTk3",
          "commit": {
            "abbreviatedOid": "a19f828"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-27T07:11:56Z",
          "updatedAt": "2018-06-27T07:11:56Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "A nit: I suggest to remove the \"Used\" at the beginning of this sentence",
              "createdAt": "2018-06-27T07:11:56Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMzEwNDcw",
          "commit": {
            "abbreviatedOid": "a19f828"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-27T07:20:49Z",
          "updatedAt": "2018-06-27T07:20:49Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "typo \"recieve\"",
              "createdAt": "2018-06-27T07:20:49Z",
              "updatedAt": "2018-06-27T14:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMzExNDE0",
          "commit": {
            "abbreviatedOid": "a19f828"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-27T07:24:37Z",
          "updatedAt": "2018-06-27T07:24:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNDU5MjEy",
          "commit": {
            "abbreviatedOid": "29f0e6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-27T14:28:55Z",
          "updatedAt": "2018-06-27T14:28:56Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Fixed! Thanks for catching.",
              "createdAt": "2018-06-27T14:28:56Z",
              "updatedAt": "2018-06-27T14:28:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNDU5Mjk1",
          "commit": {
            "abbreviatedOid": "29f0e6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-27T14:29:04Z",
          "updatedAt": "2018-06-27T14:29:04Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Agreed, removed.",
              "createdAt": "2018-06-27T14:29:04Z",
              "updatedAt": "2018-06-27T14:29:04Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f9acc9d5e450d9152e99abc2235033e0edf0bde0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/partial-io",
      "headRefOid": "29f0e6b5e8791b8a866dd5de0ed0c03c12c5443f",
      "mergeCommit": {
        "oid": "1a7acfb773e8d48a1ee6da8fb57255f7a74217fd"
      }
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3MTI1MTg1",
      "title": "Restructure Transport Properties \u2013 closes #153 and #190",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/201",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "theri",
        "philsbln"
      ],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This PR should close Issue #153 and #190.\r\n\r\nChange summary:\r\n - Unify terminology: all (Selection/Protocol/Message)-(Preferences/Properties/Parameters) become Properties\r\n   - Adjusted Section 5.2 \r\n   - Adjusted Section 7.1\r\n   - Adjusted Section 9 \r\n - Add proper Property Types\r\n   - Describe how Preferences from Preconnections are reflected on Connections (selection results)\r\n - Text on Property Classification\r\n   - Added \"Control Properties\" to catch transport system state like \"Final\" or notifications\r\n   - Added description of Intents (to classify \"Capacity Profile\")\r\n - Move all Properties to a single section (Section 12)\r\n   - Unify Property Formatting\r\n   - Merge some message/connection properties\r\n   - Fix property types\r\n\r\nThere are some ToDos left in the text \u2013 mostly already existing inconsistencies that have become obvious due to the new structure/formatting. ",
      "createdAt": "2018-06-25T14:07:47Z",
      "updatedAt": "2018-09-26T06:42:58Z",
      "closedAt": "2018-07-02T07:20:16Z",
      "mergedAt": "2018-07-02T07:20:16Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is a monster PR and will take a while even to review. As it stands, I don't anticipate it landing before Montreal. Alternately, we could just land it as is in order to stop blocking, and file a flurry of issues on anything we find wrong with it (I have a few already, in a pending review...)",
          "createdAt": "2018-06-25T18:35:17Z",
          "updatedAt": "2018-06-25T18:35:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Other reviewers: I suggest just looking at the document in its entirety with this PR here: https://taps-api.github.io/drafts/properties/draft-ietf-taps-interface.html -- I'm finding it much easier to read it that way than trying to navigate the giant diff on the MD)",
          "createdAt": "2018-06-25T18:36:34Z",
          "updatedAt": "2018-06-25T18:36:34Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for the giant PR @britram \u2013 we already tried to split it up in more or less useful commits, but tracking text moves is always tedious. \r\n\r\nI would be in favour of landing it and ripping the Properties apart afterwards. No matter what the consensus of the WG will finally be, in this form it should be much easier to discuss the problems and inconsistencies regarding properties than in the previous structure.\r\n\r\nI also see the categories and data types rather as something to start discussing than something I will fight for in every detail.",
          "createdAt": "2018-06-25T19:16:23Z",
          "updatedAt": "2018-06-25T19:16:23Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> we already tried to split it up in more or less useful commits, but tracking text moves is always tedious.\r\n\r\nno problem, I don't think there was any other way to do this; just trying to figure out how to make best use of our time on this in Montreal.",
          "createdAt": "2018-06-25T19:37:05Z",
          "updatedAt": "2018-06-25T19:37:05Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I will say that seeing the properties expressed like this was much more useful to me than the Venn diagram in understanding the arrangement of things, and halfway through my review I think it needs a bit of tweaking, on which more later.)",
          "createdAt": "2018-06-25T19:38:17Z",
          "updatedAt": "2018-06-25T19:38:17Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this stab at cleaning up the terminology. Some high level comments from a quick read through.\r\n\r\n- There are still a number of places using \"parameter\" which I find confusing. Two examples: Sec. 4. \"A Preconnection represents a set of **parameters** and constraints on the selection and configuration of paths and protocols to establish a Connection with a remote endpoint.\"; Sec. 5 \"The pre-establishment phase allows applications to specify **parameters** for the Connections they\u2019re about to make\". Are those just mistakes or there is some intended distinction? I thought they should all be properties now?\r\n- I see the benefit of having all the properties together in Section 12, but this has also caused some other problems for the structure. The preceding sections use several of the concepts and properties from section 12, some of those parts are now hard to interpret without the information. Not sure how to best solve this problem.\r\n- I do not see any useful benefit from separating out control properties and intents. \"Final\" can for example equally well be a message property. I would just stick to Selection, Protocol and Message Properties to make things simpler and less confusing.",
          "createdAt": "2018-06-25T22:23:42Z",
          "updatedAt": "2018-06-25T22:23:42Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your high-level feedback @abrunstrom. \r\n\r\n - I just did another pass through the document to fix left-over parameters, so I hope your first issue is addressed now. Security Parameters still are Parameters to not divert from TLS terminology. \r\n - To your second issue, I agree that a little more cross-references and explanation int he might be needed for better readability, but in my opinion, moving the vast amount of properties to Section 12 really improved readability of most parts of the document and makes the general idea of the API clearer.\r\n - As many Protocol Properties apply to connections as well as messages, we find the term \"Message Properties\" misleading for classification of properties. The new terminology is really orthogonal:\r\n   Everything is a Transport Property\r\n     - Transport properties can be applied to different objects\r\n         - Preconnections (Connection Properties) \r\n         - Connections (also Connection Properties) \r\n         - Messages (Message Properties) \r\n      - Transport properties can be classified by what and how they Effect things\r\n         - Selection Properties (effect the selection process)\r\n         - Protocol Properties (effect protocols selected) \r\n         - Control Properties  (effect the transport system / protocol state machine)\r\n         - Intents (may effect anything after being interoreted by the transport system)\r\n",
          "createdAt": "2018-06-26T07:57:21Z",
          "updatedAt": "2018-06-26T07:57:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi,\r\n\r\nThank you very much for this PR! I have now also given this a close read; my first reaction is that this structural re-working was much needed and does indeed clean things up nicely. While I understand the concern of @abrunstrom about things being harder to read with all these forward references, I also agree with @philsbln 's answer that this move was worth it and made it all clearer.\r\n\r\nI don't understand this concern of @britram:\r\n\r\n> The arrangement of properties -- most importantly, that Message properties are simply protocol properties -- is IMO probably incorrect.\r\n\r\n... as I can't see this PR stating that Message properties are protocol properties.\r\n\r\nGenerally I'd also be in favor of landing this and then fine-tuning it, either way I think it's a better basis for the document structure, better get this in earlier than later.",
          "createdAt": "2018-06-26T12:34:07Z",
          "updatedAt": "2018-06-26T12:34:07Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "reading @mwelzl's comment, IMO we should converge very soon on \"land this for -01 and fix it later\" versus \"hold for post-Montreal\". \r\n\r\nMy 2c: I think the structural changes to the document are correct. I'm less sure of the organization of properties (sharing @abrunstrom's and @mwelzl's concern) but these are details. I have a few picky questions I would like to see addressed before merging though (in the review). IMO we can land, submit -01, discuss in the WG meeting, and fix for a -02 after Montreal.\r\n\r\nOn this:\r\n\r\n> ... as I can't see this PR stating that Message properties are protocol properties.\r\n\r\nI'm possibly misreading the classification, and possibly not expressing myself very well. I'll try to draw a picture to say what I mean soon.",
          "createdAt": "2018-06-26T12:53:11Z",
          "updatedAt": "2018-06-26T12:53:11Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "on making a fast decision: @tfpauly please come have a look and chime in on \"land and fix\" versus \"hold for fix\"",
          "createdAt": "2018-06-26T12:53:45Z",
          "updatedAt": "2018-06-26T12:53:45Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think landing this now is fine to allow other parts to progress after restructuring. I think we will find out if we in the end can push all information about the Transport Properties to one section, or if some parts need to be introduced earlier, but I agree it is good to have it all there for the discussion. \r\nIf we land it for Montreal I would like us to simplify the structure of the properties before Montreal though. As also pointed out by @mwelzl  it is better to start simple and then add additional classes if really needed. So I am very much in favor of having just two classes to start with: Selection and one more (Protocol or Configuration).",
          "createdAt": "2018-06-26T13:30:48Z",
          "updatedAt": "2018-06-26T13:30:48Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer to discuss the classification of Transport Properties in Montreal \u2013 the work has been done in one way and classes can be easily merged if we agree that we need fewer classes, but have to be split up again if we are able to convince you that we need more.",
          "createdAt": "2018-06-26T16:07:52Z",
          "updatedAt": "2018-06-26T16:07:52Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason I think it is better to simplify first is that it seems all that have read it so far have had difficulties in understanding the separation between the classes. As it is not a difficult fix, I think it is better to simplify things before pushing it to the wg as other readers will likely have similar difficulties. We should also try to align the terminology in the other drafts which will be simpler with less constructs.\r\n\r\nWe also have several outstanding pull requests that need to be merged. Having seen the new structure for the Send section in Tommy's branch I think the send parameters should probably stay in that section. That would remove the message properties.\r\n",
          "createdAt": "2018-06-26T21:06:05Z",
          "updatedAt": "2018-06-26T21:06:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I still need to do my thorough pass on the PR, but my thoughts regarding schedule:\r\n\r\n- I'm in favor of landing this as part of -01\r\n- I disagree with some of the changes made to the sending of parameters section. I'd like to land #200 first, and then see how it merges into this PR overall. Many of the properties around sending have to do with scheduling a particular message, which I don't necessarily believe belong in the generic list of properties, or at least need a separate section.",
          "createdAt": "2018-06-26T22:02:30Z",
          "updatedAt": "2018-06-26T22:02:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1) simplification vs. keeping the classification as-is: I'd also like to insist on simplifying because a) I don't see it as hugely complicated to re-insert the properties into more categories again if we must, and b) at least I, and it seems some more people, are going to disagree with the classification anyway. So what's the point of first keeping it, then having us re-iterate that we don't like it, and then having to change it later?   Starting simple is always good.\r\n\r\n2) regarding PR #200, I read it carefully once more now, and I also agree that some message properties don't need to be pulled out because they strictly only appear there. I see only 2 1/2 exceptions: the first two are \"capacity profile\" and \"niceness\", for which it may be better to keep it as in this PR and simply refer forward to it in the sending section  (or vice versa!! Maybe even better?). The 1/2 is the \"corruption protection length\", which naturally fits together with \"control checksum coverage on sending or receiving\" (*) but is split apart in #200. I don't think this is a big issue though, and maybe better to keep them separate.\r\n\r\n(*) Side note, I dislike the naming conflict between these two; wouldn't \"checksum coverage\" be clearer than \"corruption protection length\" ?",
          "createdAt": "2018-06-27T07:38:06Z",
          "updatedAt": "2018-06-27T07:38:06Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to think that this is PR an overall improvement, although there are details I'd question. I'd agree to land it, then iterate.",
          "createdAt": "2018-06-27T08:44:37Z",
          "updatedAt": "2018-06-27T08:44:37Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've just been discussing with @philsbln for a while - I think a good way forward is to first land #200, then land this but without deleting stuff in the sending section. This will give us duplicate text - and then we start to look at these duplicates one by one. @philsbln says that they found several inconsistencies, but on the other hand, it seems that @tfpauly has improved some text in #200. Sure we could just compare the branches but I think we should keep things from diverging more at this point, and first pull these two PR's in one by one.\r\n\r\n(I'm only suggesting but hoping for @britram to actually pull the trigger because I'm afraid to mess something up - I've never manually merged a PR...)",
          "createdAt": "2018-06-27T08:51:17Z",
          "updatedAt": "2018-06-27T08:51:17Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for all the comments so far. \r\nRegarding classification, I agree with making it simpler for now, and then discuss in Montreal. This would mean going back to Selection Properties, Protocol Properties, and Message Properties for now, which is also in line with the other drafts. \r\nI will move the classification for Control Properties and Intents to the Appendix for now, so we can still see these definitions, modify them, and move them back up if we decide we want them.\r\nAfter we decide on the classification we want, we can also discuss about in which category the individual Properties belong.\r\nAbout #200 I'd be okay with landing it and then adjusting this PR, but I'm still not entirely sure about getting rid of the explicit MessageProperties...",
          "createdAt": "2018-06-27T08:53:56Z",
          "updatedAt": "2018-06-27T08:53:56Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly I agree to land PR #200 ASAP and re-merge your changes to this one.\r\n\r\nI think we will need all \"Control Properties\" at least listed in Section 12. This makes keeping related properties much easier. I agree to move the ones important to control flow, e.g., final, back to Section 7 and only list/cross-reference them in Section 12. Will do so after merging PR #200.",
          "createdAt": "2018-06-27T09:07:18Z",
          "updatedAt": "2018-06-27T09:07:18Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at the document, it seems like it will be easier to discuss the classification when having it all in one place, so I did not move them to the Appendix, but instead labeled them as \"TODO: Discuss\".",
          "createdAt": "2018-06-27T09:47:46Z",
          "updatedAt": "2018-06-27T09:47:46Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl and @abrunstrom \u2013 I totally agree that we need to simplify things.\r\n\r\n@theri and I do not agree on the current classification --- but we agree that we a need for discussion about how to structure Properties.\r\n\r\nI see this classification rather as a basis for discussion in Montreal than as a final thingy I want to push. Therefore, I would like to have the proposed classification in -01 point will add the rationale behind it to this PR. After discussion for Montreal, I am pretty sure that we will have a totally different classification (different from -00 and this proposal for -01).",
          "createdAt": "2018-06-27T10:14:57Z",
          "updatedAt": "2018-06-27T10:14:57Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that #200 landed, I merged the changes, changing all \"parameters\" to \"properties\" in line with this PR. \r\nAfter this initial merge, we now duplicate the following Properties in Section 7.3 and Section 12.3:\r\n\r\n- Lifetime is exactly the same, just adds Classification, Type, and Applicability in 12.3\r\n- Niceness, in Section 12.3, can not only apply on a Message but also on a Connection relative to other Connections (in the same group).\r\n- Ordered has been slightly reworded in Section 12.3 in an attempt to make it more clear\r\n- Idempotent is basically similar, just the start of the sentence has been slightly modified\r\n- Final has been slightly reworded in Section 12.3 in an attempt to make it more clear\r\n- Corruption protection length is exactly the same, just adds Classification, Type, and Applicability\r\n- Transmission Profile from 7.3 basically became per-Message Capacity Profile in 12.3, and has more levels in 12.3\r\n\r\nNow we could move all Properties to 12.3 while forward-referencing them in 7.3, merging the ones that are the same, and splitting Niceness and Capacity Profile into per-Connection and per-Message again.\r\nAlternatively, we could keep the duplicates for now and discuss further after landing this, but I would prefer to have the Properties all in one place.",
          "createdAt": "2018-06-27T15:55:12Z",
          "updatedAt": "2018-06-27T15:55:12Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I like this shorter list of 2 categories - selection looks like it is special, and then the stack needs configured.\n\nGorry\n\n> On 26 Jun 2018, at 14:20, mwelzl <notifications@github.com> wrote:\n> \n> @mwelzl commented on this pull request.\n> \n> In draft-ietf-taps-interface.md:\n> \n> > @@ -1502,6 +1096,732 @@ does provide the following guarantees about the ordering of operations:\n>    were sent (i.e., delivered to the kernel or to the network interface,\n>    depending on implementation).\n>  \n> +\n> +# Transport Properties {#transport-props}\n> +\n> +Transport Properties allow an application to control most aspects of the\n> +transport system.\n> +\n> +Properties are structured in two ways: \n> +\n> + - By how they influence the transport system, which leads to a classification\n> I very much agree with this. @abrunstrom also suggested to remove \"intent\" but I agree that even \"protocol\" vs. \"control\" doesn't seem a very clear line. Can we just have these two types - \"selection properties\" and, e.g., \"configuration properties\", to start with, and think about dividing the latter further only if it makes sense?\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2018-06-27T16:39:17Z",
          "updatedAt": "2018-06-27T16:39:17Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I marked the Properties in 7.3 as \"TODO: De-duplicate\". \r\nWith this, @philsbln and I think that this PR is ready to land. We are planning to prepare slides for Montr\u00e9al summarizing the current status and the discussion points.",
          "createdAt": "2018-06-28T07:46:37Z",
          "updatedAt": "2018-06-28T07:46:37Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my opinion, this PR should now address all changes requested or clearly mark them as discussion points. Slides for the Properties classification discussions in Montreal are ready.\r\n\r\nCan we land it?",
          "createdAt": "2018-06-29T11:57:39Z",
          "updatedAt": "2018-06-29T11:57:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri @philsbln Thanks for the changes! I\u2019m fine with landing this now, and look forward to the discussion it will create. Having this concrete set of items is a great framing to hold the conversation around. ",
          "createdAt": "2018-06-30T00:37:50Z",
          "updatedAt": "2018-06-30T00:37:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNzMwNjcw",
          "commit": {
            "abbreviatedOid": "ea6ebab"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this PR. I have a lot of little detailed comments (on which I'm requesting changes, see review), and a one giant one (which I think needs to be worked out in person in Montreal):\r\n\r\nThe arrangement of properties -- most importantly, that Message properties are simply protocol properties -- is IMO probably incorrect. Certain properties bound to messages are *related to* but *separate from* protocol properties (as to whether the given message properties will be honored). The attempt to organize these into one overarching class was useful, but ultimately results in an overgeneralization that increases the non-essential complexity of the interface.\r\n\r\nI'm not sure I'll have time before the -01 deadline to draw a picture of what I mean here, but will try.",
          "createdAt": "2018-06-25T18:30:29Z",
          "updatedAt": "2018-06-26T09:42:22Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "This does not seem consistent with Section 12.1.4 Preference; here, the Preference type is used for the level of preference implied by the call itself... am I missing something here?",
              "createdAt": "2018-06-25T18:30:29Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 812,
              "body": "This definition is inconsistent with Section 5.2",
              "createdAt": "2018-06-25T18:31:54Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 588,
              "body": "this seems like a whole lot of work to end up back at `setsockopt()` again.\r\n\r\nMore seriously, this call should be symmetric with its `GetProperties()` counterpart, and take a set of k/v pairs. Alternately, we could also make it explicit that implementations of the protocol may choose to split these out into their own calls.",
              "createdAt": "2018-06-25T18:41:00Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 768,
              "body": "At this point in the document, I'm not sure I buy this classification -- the only bold line between sets of things I'm sure exists here is between selection properties and everything else.",
              "createdAt": "2018-06-25T18:42:47Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 763,
              "body": "Is control the only aim here? It seems like introspection is also important.",
              "createdAt": "2018-06-25T18:43:38Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 770,
              "body": "This classification makes more sense. However, the line between preconnections and connections may also blur depending on the properties (more specific comments on a per-property basis below)",
              "createdAt": "2018-06-25T18:44:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 893,
              "body": "How are these ordered?",
              "createdAt": "2018-06-25T18:47:34Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 897,
              "body": "I'm not sure this is a very good example of a transport property. It feels much more like an argument to `Send()` to me.",
              "createdAt": "2018-06-25T18:48:16Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 969,
              "body": "what if the transport is fully reliable?",
              "createdAt": "2018-06-25T18:49:08Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 895,
              "body": "This section really needs a better lead in than this; a diagram or table showing how specific message properties are scoped, how message-scoped properties are related to selection properties that enable them, etc.",
              "createdAt": "2018-06-25T18:58:13Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 1000,
              "body": "is this a Message property or a Connection property? If the latter, this should be 'each Message' instead of 'a Message'",
              "createdAt": "2018-06-25T18:59:12Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 1006,
              "body": "this seems non-MTI to me.",
              "createdAt": "2018-06-25T18:59:34Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 770,
              "body": "On second thought, there are not a lot of per-Message properties which apply to Connections as well. There are per-Message properties which are *related* to connection properties, and the rest of the per-Message \"control\" properties can also be bound to a Connection in order to set defaults.\r\n\r\nSo I'm wondering if the split shouldn't be simpler after all (probably the right way to express this is attempt to edit the included SVG for a counterproposal)...",
              "createdAt": "2018-06-25T19:35:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 1144,
              "body": "this might also be an argument on Send",
              "createdAt": "2018-06-26T08:37:44Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 1147,
              "body": "in any case why is this not a \"control property\"?",
              "createdAt": "2018-06-26T08:38:00Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 1410,
              "body": "This seems potentially dangerous.",
              "createdAt": "2018-06-26T09:36:41Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxOTkxNDU3",
          "commit": {
            "abbreviatedOid": "8781248"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T12:20:07Z",
          "updatedAt": "2018-06-26T12:20:08Z",
          "comments": [
            {
              "originalPosition": 768,
              "body": "I very much agree with this. @abrunstrom also suggested to remove \"intent\" but I agree that even \"protocol\" vs. \"control\" doesn't seem a very clear line. Can we just have these two types - \"selection properties\" and, e.g., \"configuration properties\", to start with, and think about dividing the latter further only if it makes sense?",
              "createdAt": "2018-06-26T12:20:07Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDAwODI4",
          "commit": {
            "abbreviatedOid": "8781248"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T12:46:47Z",
          "updatedAt": "2018-06-26T12:46:47Z",
          "comments": [
            {
              "originalPosition": 1410,
              "body": "What?",
              "createdAt": "2018-06-26T12:46:47Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDA3NTU1",
          "commit": {
            "abbreviatedOid": "8781248"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T13:04:30Z",
          "updatedAt": "2018-06-26T13:04:30Z",
          "comments": [
            {
              "originalPosition": 1147,
              "body": "Ack - Fixed",
              "createdAt": "2018-06-26T13:04:30Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDA3OTUw",
          "commit": {
            "abbreviatedOid": "8781248"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T13:05:28Z",
          "updatedAt": "2018-06-26T13:05:28Z",
          "comments": [
            {
              "originalPosition": 1144,
              "body": "It could be (as Final) \u2013 exactly that is what makes it a \"Control Property\"",
              "createdAt": "2018-06-26T13:05:28Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDE0NzUy",
          "commit": {
            "abbreviatedOid": "3f94af5"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T13:21:39Z",
          "updatedAt": "2018-06-26T13:21:39Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Basically, TransportProperties.Require(property) is syntactic sugar for TransportProperties.add(property, value=Require). \r\nI'm not sure if this syntactic sugar should be in there, but I just pushed a commit to hopefully make it clearer that of course the property is the argument to the call, and the call just sets a specific preference level for the property.",
              "createdAt": "2018-06-26T13:21:39Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDIwMjcw",
          "commit": {
            "abbreviatedOid": "3f94af5"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T13:33:56Z",
          "updatedAt": "2018-06-26T13:33:56Z",
          "comments": [
            {
              "originalPosition": 1147,
              "body": "Why is this a control property? Then most message properties should be control properties? ",
              "createdAt": "2018-06-26T13:33:56Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDczOTY4",
          "commit": {
            "abbreviatedOid": "3f94af5"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:22:07Z",
          "updatedAt": "2018-06-26T15:22:07Z",
          "comments": [
            {
              "originalPosition": 893,
              "body": "We basically took the old order from the Connection Properties and merged everything else in a way that related stuff is directly adjacent. Afterward, we moved some things up that may need special attention, e.g., final.\r\n\r\nThe resulting order is, in our opinion, somewhat useful for discussion but far from final.",
              "createdAt": "2018-06-26T15:22:07Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDc5MzUy",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:33:17Z",
          "updatedAt": "2018-06-26T15:33:18Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "This is just syntactic sugar now - got just clarified in the text",
              "createdAt": "2018-06-26T15:33:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDc5NDI1",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:33:28Z",
          "updatedAt": "2018-06-26T15:33:28Z",
          "comments": [
            {
              "originalPosition": 812,
              "body": "see above",
              "createdAt": "2018-06-26T15:33:28Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDgwMjI2",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:35:10Z",
          "updatedAt": "2018-06-26T15:35:10Z",
          "comments": [
            {
              "originalPosition": 763,
              "body": "ack; addressed",
              "createdAt": "2018-06-26T15:35:10Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDg2NjU1",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:49:17Z",
          "updatedAt": "2018-06-26T15:49:17Z",
          "comments": [
            {
              "originalPosition": 897,
              "body": "True for most control properties that apply to messages \u2013 putting it here is a trade-off between cluttering the `Send()` call and \"hiding\" it in the properties.",
              "createdAt": "2018-06-26T15:49:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDg5OTk5",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:56:57Z",
          "updatedAt": "2018-06-26T15:56:57Z",
          "comments": [
            {
              "originalPosition": 969,
              "body": "clarified",
              "createdAt": "2018-06-26T15:56:57Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDkwOTU4",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T15:59:03Z",
          "updatedAt": "2018-06-26T15:59:03Z",
          "comments": [
            {
              "originalPosition": 1000,
              "body": "Clarified",
              "createdAt": "2018-06-26T15:59:03Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDkxNjU1",
          "commit": {
            "abbreviatedOid": "c56baec"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T16:00:37Z",
          "updatedAt": "2018-06-26T16:00:37Z",
          "comments": [
            {
              "originalPosition": 1006,
              "body": "Agreed - but let's do this discussion for all properties in Montreal",
              "createdAt": "2018-06-26T16:00:37Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMDk3Njcz",
          "commit": {
            "abbreviatedOid": "8781248"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T16:15:20Z",
          "updatedAt": "2018-06-26T16:15:20Z",
          "comments": [
            {
              "originalPosition": 1410,
              "body": "This has been in the draft for since trammell-taps-iterface-00 - nothing we added",
              "createdAt": "2018-06-26T16:15:20Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyMzkwODc5",
          "commit": {
            "abbreviatedOid": "03264d9"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-27T11:27:04Z",
          "updatedAt": "2018-06-27T11:27:04Z",
          "comments": [
            {
              "originalPosition": 1410,
              "body": "Okay. Withdrawn...\r\n",
              "createdAt": "2018-06-27T11:27:04Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNDk4MTQ3",
          "commit": {
            "abbreviatedOid": "567b761"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'll give my \"ok\" so at least I'm not blocking this any further. As for the classification, I sincerely hope that we'll *not* have more than the three that @theri has mentioned, this seems just right... but let's see  :)\r\n\r\n@theri I'm in favor of duplicates because the wording is not exactly equivalent. @philsbln told me that you have found several inconsistencies; @tfpauly has improved the wording here and there a little. I think we should compare the descriptions of the message properties one by one - removing the duplicates can then be a separate PR. It might be easiest to just mark them as DUPLICATE - TO BE FIXED or something like that.",
          "createdAt": "2018-06-27T15:56:35Z",
          "updatedAt": "2018-06-27T15:59:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyODkwNjg1",
          "commit": {
            "abbreviatedOid": "709c567"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T15:13:35Z",
          "updatedAt": "2018-06-28T15:13:35Z",
          "comments": [
            {
              "originalPosition": 897,
              "body": "Right, the previous title of being a message \u201cparameter\u201d makes more sense for items like Final. Not everything is a property... one option as long as you\u2019re adding these todos is to change the section back to parameters, which justifies its own section, and mention that the duplication that should be resolved is between some of the message sending parameters which are property-like, and the list of properties below. ",
              "createdAt": "2018-06-28T15:13:35Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMDE0MTA5",
          "commit": {
            "abbreviatedOid": "709c567"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-28T20:47:12Z",
          "updatedAt": "2018-06-28T20:55:35Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "Typo: ITEF->IETF",
              "createdAt": "2018-06-28T20:47:12Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 912,
              "body": "Grammar: remove \"not matter\"",
              "createdAt": "2018-06-28T20:47:49Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 912,
              "body": "Grammar: effect->affect",
              "createdAt": "2018-06-28T20:48:04Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 914,
              "body": "effect->affect",
              "createdAt": "2018-06-28T20:48:28Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 913,
              "body": "Remove \"what and\"",
              "createdAt": "2018-06-28T20:48:54Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 915,
              "body": "In general, this sentence is quite confusing. Perhaps:\r\n\r\n\"Properties are classified based on how they take effect in the system based on application preferences. There are two factors that determine the classification of a property:\"",
              "createdAt": "2018-06-28T20:52:43Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 917,
              "body": "effect -> affect",
              "createdAt": "2018-06-28T20:53:42Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 976,
              "body": "\"Control properties control\" is a bit redundant",
              "createdAt": "2018-06-28T20:54:12Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 897,
              "body": "I'd leave this out, and just let it be a Message Context Parameter",
              "createdAt": "2018-06-28T20:54:43Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            },
            {
              "originalPosition": 514,
              "body": "I'd prefer to leave this category as Parameters, since they're not all \"properties\"",
              "createdAt": "2018-06-28T20:55:16Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIwODYw",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:17:13Z",
          "updatedAt": "2018-06-29T07:17:13Z",
          "comments": [
            {
              "originalPosition": 910,
              "body": "Fixed.",
              "createdAt": "2018-06-29T07:17:13Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIwODc3",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:17:18Z",
          "updatedAt": "2018-06-29T07:17:18Z",
          "comments": [
            {
              "originalPosition": 912,
              "body": "Fixed.",
              "createdAt": "2018-06-29T07:17:18Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIwOTEx",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:17:25Z",
          "updatedAt": "2018-06-29T07:17:25Z",
          "comments": [
            {
              "originalPosition": 914,
              "body": "Fixed.",
              "createdAt": "2018-06-29T07:17:25Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIwOTMy",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:17:30Z",
          "updatedAt": "2018-06-29T07:17:30Z",
          "comments": [
            {
              "originalPosition": 913,
              "body": "Fixed.",
              "createdAt": "2018-06-29T07:17:30Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIxMzk2",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:19:17Z",
          "updatedAt": "2018-06-29T07:19:17Z",
          "comments": [
            {
              "originalPosition": 915,
              "body": "I reworded the second sentence, trying to convey the meaning that there may be multiple aspects in which properties differ, and here we emphasize two of these aspects, so applications know what to expect. ",
              "createdAt": "2018-06-29T07:19:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIxNDQx",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:19:26Z",
          "updatedAt": "2018-06-29T07:19:26Z",
          "comments": [
            {
              "originalPosition": 917,
              "body": "Fixed.",
              "createdAt": "2018-06-29T07:19:26Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIxNjQz",
          "commit": {
            "abbreviatedOid": "40fa47d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:20:16Z",
          "updatedAt": "2018-06-29T07:20:17Z",
          "comments": [
            {
              "originalPosition": 976,
              "body": "True. Changed it to \"manage\", not perfect but hopefully still works for what is meant here.",
              "createdAt": "2018-06-29T07:20:17Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTQxOTQ4",
          "commit": {
            "abbreviatedOid": "c97961b"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T08:35:50Z",
          "updatedAt": "2018-06-29T08:35:50Z",
          "comments": [
            {
              "originalPosition": 514,
              "body": "Renamed this part back to what it was in #200, and left \"Final\" up as a Message Context Parameter.\r\nI think the distinction between \"parameters\" and \"properties\" goes along the same lines as the distinction between \"Control Properties\" and \"Protocol Properties\", and I'm looking forward to the discussion in Montreal.",
              "createdAt": "2018-06-29T08:35:50Z",
              "updatedAt": "2018-06-29T09:47:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDA4NDM1",
          "commit": {
            "abbreviatedOid": "4ea18fd"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-30T00:37:54Z",
          "updatedAt": "2018-06-30T00:37:54Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "1a7acfb773e8d48a1ee6da8fb57255f7a74217fd",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "properties",
      "headRefOid": "4ea18fd529477129e42df21058cee2f0279dcbce",
      "mergeCommit": {
        "oid": "8dfe2440fb0f0ca5ff1b1fefa29c9175b7d5c8df"
      }
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTk2Nzg1",
      "title": "fix #204",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/205",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "quickly adding this to fix @gorryfair's nits before -01 submission",
      "createdAt": "2018-07-02T07:44:34Z",
      "updatedAt": "2018-07-02T07:55:20Z",
      "closedAt": "2018-07-02T07:55:14Z",
      "mergedAt": "2018-07-02T07:55:14Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8dfe2440fb0f0ca5ff1b1fefa29c9175b7d5c8df",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "fix-204",
      "headRefOid": "60c846dc5e82aca014a6d75c9fb17851da0fe207",
      "mergeCommit": {
        "oid": "6ff98c3673fe51b07f5d8711f3df8c2e29b0ff1f"
      }
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyNzA5NjA4",
      "title": "fix #102, some changes to Resolve() language",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/213",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "as I started reviewing issues in advance of the interim, I saw that #102 was already mostly fixed, but I made a few editorial changes to the language there.",
      "createdAt": "2018-09-03T10:45:33Z",
      "updatedAt": "2018-09-26T06:42:56Z",
      "closedAt": "2018-09-03T15:03:54Z",
      "mergedAt": "2018-09-03T15:03:54Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxODI3NTA0",
          "commit": {
            "abbreviatedOid": "e328687"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-03T15:01:32Z",
          "updatedAt": "2018-09-03T15:01:32Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cfd5ac5a726a285f1645643939d1928c92b5f53c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "explicit-resolution-102",
      "headRefOid": "e328687f7ae32e7e10ca10180a566dc90519de0c",
      "mergeCommit": {
        "oid": "ad77fa919e9b74288d8d0ac7cd5d96dda18ad2c0"
      }
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyNzQ1MTc4",
      "title": "InitiateAndSend() / RendezvousAndSend()",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/214",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is my attempt to address #112 with something that's (IMO) less clunky in the common case than #124. \r\n\r\nI'm not a big fan of this way of doing things either -- specifically, I think the semantics of RendezvousAndSend(), while consistent, are probably wrong.",
      "createdAt": "2018-09-03T13:13:25Z",
      "updatedAt": "2018-09-06T10:52:53Z",
      "closedAt": "2018-09-05T14:41:30Z",
      "mergedAt": "2018-09-05T14:41:30Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After some discussion with Brian I agree that the only solution is to provide some initial date to the preconnection when calling initiate. However, why do we need to have two different function. If we only have initiate and provide idempotent data as an optional input parameter that should be fine, right?",
          "createdAt": "2018-09-06T08:36:26Z",
          "updatedAt": "2018-09-06T08:36:47Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak: your question is now #224",
          "createdAt": "2018-09-06T10:52:52Z",
          "updatedAt": "2018-09-06T10:52:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxODI3MjUx",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-03T15:00:39Z",
          "updatedAt": "2018-09-03T15:00:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2NjY4",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't mind `InitiaiteAndSend()`, although I'd bike-shed the name, but `RendezvousAndSend()` needs more thought...",
          "createdAt": "2018-09-04T22:25:00Z",
          "updatedAt": "2018-09-04T22:31:41Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I like the general approach of `InitiateAndSend`. It keeps the types right, and avoids issues with trying to call `Send()` on `Preconnection` objects and with enqueued data.\r\n\r\nMaybe suggest changing the name to `InitiateAndSendIdempotent()` though, to be explicit? There are security issues with idempotent data, so we need to (try to) make sure people don't use without thinking through the consequences.",
              "createdAt": "2018-09-04T22:25:00Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            },
            {
              "originalPosition": 89,
              "body": "I guess we need to think more about the rendezvous model. \r\n\r\nIf the goal is to support traditional TCP simultaneous open, then 0-RTT idempotent data could work. For something like an ICE-driven rendezvous, with NAT traversal, I wonder if it still makes sense? STUN doesn't support delivering data in the binding discovery messages, so it's no longer 0-RTT. And, if some future protocol did support data in binding discovery messages, there's no guarantee that all those messages hit the same server, so the semantics get weird. \r\n\r\nI wonder if we should not try to support idempotent, 0-RTT, rendezvous for the first version?",
              "createdAt": "2018-09-04T22:30:24Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjgxNDEy",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:46:54Z",
          "updatedAt": "2018-09-04T22:46:54Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I  agree, being explicit here would be important.",
              "createdAt": "2018-09-04T22:46:54Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjgxOTgw",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:49:30Z",
          "updatedAt": "2018-09-04T22:49:30Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Sounds reasonable to leave it out for now.",
              "createdAt": "2018-09-04T22:49:30Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzg0NzAx",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T08:27:32Z",
          "updatedAt": "2018-09-05T08:27:33Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "+1 to change to `InitiateAndSendIdempotent()`, since it forces that message property.",
              "createdAt": "2018-09-05T08:27:32Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzg2MjQz",
          "commit": {
            "abbreviatedOid": "f084160"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T08:31:42Z",
          "updatedAt": "2018-09-05T08:31:42Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Yeah, I tried this out primarily to see what would happen if `RendezvousAndSend()` were kept consistent with `InitiateAndSend()` and you get this weird buffered-banner behavior that (1) probably doesn't do anything anyone wants and (2) also probably doesn't work anyway.\r\n\r\nWill cut it for now, and we can leave rendezvous acceleration as an area for future research.",
              "createdAt": "2018-09-05T08:31:42Z",
              "updatedAt": "2018-09-05T08:45:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzk3Nzcw",
          "commit": {
            "abbreviatedOid": "c9250de"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T09:01:06Z",
          "updatedAt": "2018-09-05T09:01:07Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "&lt;bikeshed> How about `InitiateWithIdempotentSend()`? &lt;/bikeshed>",
              "createdAt": "2018-09-05T09:01:07Z",
              "updatedAt": "2018-09-05T09:01:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNDMwOTUw",
          "commit": {
            "abbreviatedOid": "c9250de"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T10:29:20Z",
          "updatedAt": "2018-09-05T10:29:20Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "wfm",
              "createdAt": "2018-09-05T10:29:20Z",
              "updatedAt": "2018-09-05T10:29:20Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cfd5ac5a726a285f1645643939d1928c92b5f53c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "initiate-and-send-112",
      "headRefOid": "c9250de398fe9d20002202588b58faa8d62176f4",
      "mergeCommit": {
        "oid": "79eccf6fe0ca4fab81d3613a2f4e4dfed1217f0f"
      }
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyNzkxNTYy",
      "title": "Small changes to \"receive\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/215",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "1 tiny fix suggested to make the text a little clearer (because the default \"complete message\" delivery may need a de-framer, or the whole Connection may function as a message), and pointed at a possible error when delivering partial data (it's already written elsewhere, but the suggestion makes a sentence more correct, I believe).",
      "createdAt": "2018-09-03T16:33:42Z",
      "updatedAt": "2018-09-06T03:28:50Z",
      "closedAt": "2018-09-05T14:41:49Z",
      "mergedAt": "2018-09-05T14:41:49Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, thanks!",
          "createdAt": "2018-09-06T03:28:50Z",
          "updatedAt": "2018-09-06T03:28:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxODYxNzIx",
          "commit": {
            "abbreviatedOid": "abbe653"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-03T18:41:29Z",
          "updatedAt": "2018-09-03T18:41:29Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "85da0df716cdf4de4a74d8cee9b9f457e2d2b251",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "Small-fixes-to-Receive-calls",
      "headRefOid": "abbe65312272090cc80083a9d307a47a4da88afe",
      "mergeCommit": {
        "oid": "81bc2a2b40d363a90a839b0b1ae130d86bc492bb"
      }
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyODA1NTg3",
      "title": "Set/query conn. properties (sec 9) structure change",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/216",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rather than saying \"this can only be queried\" everywhere, I split this into setting and querying now, and I also moved SoftErrors in there. It's not precisely \"querying\" for a Property, but it's the closest match - better than \"Connection Termination\", I think (this is where SoftErrors were before).",
      "createdAt": "2018-09-03T18:43:34Z",
      "updatedAt": "2018-09-05T14:42:15Z",
      "closedAt": "2018-09-05T14:42:11Z",
      "mergedAt": "2018-09-05T14:42:11Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri what about \"Connection Maintenance: Setting Properties and Obtaining Information\" ?",
          "createdAt": "2018-09-04T20:24:20Z",
          "updatedAt": "2018-09-04T20:24:20Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maintenance sounds a bit strange to me, \"Managing Connections: Setting Properties and Obtaining Information\" ? ",
          "createdAt": "2018-09-04T20:55:47Z",
          "updatedAt": "2018-09-04T20:55:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like it (and I agree about \"maintenance\" being slightly strange)",
          "createdAt": "2018-09-05T06:58:27Z",
          "updatedAt": "2018-09-05T06:58:27Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Managing sounds good to me too.",
          "createdAt": "2018-09-05T08:38:47Z",
          "updatedAt": "2018-09-05T08:38:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ack, done",
          "createdAt": "2018-09-05T09:00:55Z",
          "updatedAt": "2018-09-05T09:00:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMTA0OTc4",
          "commit": {
            "abbreviatedOid": "1790228"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Agreed - if Protocol Properties are the only properties here that can be set, we do not need to explicitly state that all others can only be queried. This way looks cleaner and still says the same thing. \r\n\r\nAbout Soft Errors: Fine with me to have them here, but then I suggest we think about renaming this section again.\r\nI think it used to be called \"Introspection\" at some point, but then got changed, see #54. Before that, it was \"Maintenance\", but got changed in #47. \r\nMaybe we can find something broader than just \"Setting and Querying Properties\", but clear enough?\r\nI still like \"Maintenance\", FWIW.",
          "createdAt": "2018-09-04T14:51:01Z",
          "updatedAt": "2018-09-04T14:51:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzk4Mzky",
          "commit": {
            "abbreviatedOid": "af77777"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2018-09-05T09:02:46Z",
          "updatedAt": "2018-09-05T09:02:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNDAwMzg3",
          "commit": {
            "abbreviatedOid": "af77777"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-05T09:08:00Z",
          "updatedAt": "2018-09-05T09:08:00Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "85da0df716cdf4de4a74d8cee9b9f457e2d2b251",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW---Setting-and-Querying-Connection-Properties",
      "headRefOid": "af77777b88bb3e68b7641a6147b20ffeb9180e5d",
      "mergeCommit": {
        "oid": "3c5d55fce09f0782d1df4009051a2d55d8beec15"
      }
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyODA5ODMw",
      "title": "Transport Property clean-up after the re-org. De-duplication etc.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/217",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I gave the document a very careful back-to-back read. My take-away was that removing the Message Context Parameters from where they are, and just pointing to a later section, would make for a bad reading experience. Basically, it would feel like an empty shell - at some point, the reader wants to see something tangible, and so, reading all these Message properties where they appear is satisfying, in a way. The document would get quite tough to digest if it would just provide the \"framework\" for sending, receiving etc., and we have to wait for the \"meat\" until the end, where it is then offered in a very organized fashion.\r\n\r\nHence, I decided to leave all the message properties described where they are (as Message Context Parameters). That was my approach to de-duplication in this PR.\r\n\r\nSide comment if someone's surprised by the removal of A.1.9 \"Immediate\": that's because this is already fully covered by the Transmission Profile in Section 7.3.7.",
      "createdAt": "2018-09-03T19:29:37Z",
      "updatedAt": "2018-09-06T08:28:50Z",
      "closedAt": "2018-09-05T14:42:34Z",
      "mergedAt": "2018-09-05T14:42:34Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed - thanks!",
          "createdAt": "2018-09-05T08:58:26Z",
          "updatedAt": "2018-09-05T08:58:26Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for being late with the review, but I dislike some details of this PR as is only one part of what we agreed on in Montreal an adds inconsistencies:\r\n\r\nInconsistencies:\r\n - The list-style labeling of all properties with their data-type has removed for those properties that have been moved up to section 7.3 and replaced by prose.\r\n\r\nMissing Steps\r\n - Those Transport Properties which we decided to call \"Connection Properties\" have not been renamed.\r\n - Those Transport Properties which we decided to call \"Selection Properties\" have not been renamed.\r\n - Moving the other Transport Properties up\r\n\r\nAfter the complete thing, Section 12 should contain the following things:\r\n - Overview what Properties are and when they can be specified\r\n - Definition of types\r\n - List/Table of all properties with references to the earlier chapters where there are defined\r\n\r\nI will start preparing PRs fixing these\u2026",
          "createdAt": "2018-09-06T08:28:50Z",
          "updatedAt": "2018-09-06T08:28:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMDkxNDI2",
          "commit": {
            "abbreviatedOid": "8ac74db"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this! \r\nI think in a previous discussion we got to the same conclusion as you: Message Properties (or Message Context Parameters, as they are called here now) should appear in the earlier section and should be de-duplicated. \r\n\r\nI went over the differences between the two versions of the properties again, which I previously mentioned in #201, and everything looks fine except the Niceness.\r\nAt some point in #201 we merged per-Message and per-Connection Niceness, but then later we found that we'd rather keep them separate. I would like this PR to include this separation as well, see my comments here.\r\nOtherwise LGTM.",
          "createdAt": "2018-09-04T14:23:56Z",
          "updatedAt": "2018-09-04T14:31:13Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Previously, we had merged per-Message and per-Connection Niceness, but then come to realize that we rather want them separate.\r\n\r\nI think this sentence is an artifact of this. \r\nThe latter part refers to per-Connection Niceness (within a Connection Group), as opposed to per-Message Niceness (within the same Connection). I think here we only want per-Message Niceness, so the per-Connection part should be taken out.",
              "createdAt": "2018-09-04T14:23:56Z",
              "updatedAt": "2018-09-05T08:58:11Z"
            },
            {
              "originalPosition": 221,
              "body": "I think here we still want the per-Connection Niceness as it was before it was merged with the per-Message Niceness.\r\n\r\nI dug the old text out of the repo, and it said:\r\n\"This Property is a non-negative integer representing the relative inverse\r\npriority of this Connection relative to other Connections in the same\r\nConnection Group. It has no effect on Connections not part of a Connection\r\nGroup. As noted in {{groups}}, this property is not entangled when Connections\r\nare cloned.\"",
              "createdAt": "2018-09-04T14:26:13Z",
              "updatedAt": "2018-09-05T08:58:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjQzOTA3",
          "commit": {
            "abbreviatedOid": "8ac74db"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T20:39:23Z",
          "updatedAt": "2018-09-04T20:39:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "ACK!  I'm changing it only to \"over the same Connection\", dropping the group because this can make it confusing: what if I give a message a lower Niceness than all others in the group, yet the Connection the Message is on has a higher Niceness than the others? Then what does this mean?  All of this gets clear if the context of per-Message Niceness is only a single Connection. I think this is what you probably identified and I didn't think of so far - great catch!",
              "createdAt": "2018-09-04T20:39:23Z",
              "updatedAt": "2018-09-05T08:58:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjQ0Mzc4",
          "commit": {
            "abbreviatedOid": "8ac74db"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T20:40:39Z",
          "updatedAt": "2018-09-04T20:40:39Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "ACK - and thanks for digging, this was very useful!",
              "createdAt": "2018-09-04T20:40:39Z",
              "updatedAt": "2018-09-05T08:58:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzg2ODY4",
          "commit": {
            "abbreviatedOid": "aa68a58"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yes, makes sense to me.\r\nJust one more minor thing, the per-Connection Niceness below still says \"Applicability: Connection, Message\".\r\nOtherwise I think this is good to go.",
          "createdAt": "2018-09-05T08:33:24Z",
          "updatedAt": "2018-09-05T08:36:43Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Very minor thing, but here we want to drop \"Message\" as well.",
              "createdAt": "2018-09-05T08:33:24Z",
              "updatedAt": "2018-09-05T08:58:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzk4OTA4",
          "commit": {
            "abbreviatedOid": "a122dc6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "also lgtm",
          "createdAt": "2018-09-05T09:04:09Z",
          "updatedAt": "2018-09-05T09:04:09Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3c9b07aa8d0d295b538800d8056f28ffa4314fb6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW---clean-up-Transport-Properties",
      "headRefOid": "a122dc61082bf6524d4d000cc2cf99e69af6b891",
      "mergeCommit": {
        "oid": "bad3e2da67acd62285972e617a06b22a963127e7"
      }
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNTQ3MzQ0",
      "title": "This fixes inconcistencies from PR #217 - Message Properties move to Section 7.3",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/223",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- de-duplicates some properties in 7.3. and 12\r\n- moves up some message properties missing in 7.3.\r\n- make type definition consistent across all properties\r\n\r\nThis ignores Classification and Applicability labels which are subject\r\nto removal in another PR moving Selection and Connections properties up.\r\nSection 12.3 will most likely be replaces with a table then.",
      "createdAt": "2018-09-06T09:13:04Z",
      "updatedAt": "2018-09-06T15:41:48Z",
      "closedAt": "2018-09-06T13:38:28Z",
      "mergedAt": "2018-09-06T13:38:28Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri I want to convert 12.3 to a table once all properties have been moved up.\r\n\r\nI guess it is useful to include types in the table and put relations as footnotes into the table. ",
          "createdAt": "2018-09-06T12:01:17Z",
          "updatedAt": "2018-09-06T12:01:17Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think I understand \"connection niceness\", I do know how that would be used.\r\nAs I look through things today, I'm less sure about how expressing message niceness is actually needed, and if so - what sort of machinery you'd need to properly handle a message niceness property. My own mental model is that a sender that cares about \"niceness\" will keep its output queue low, and that it can itself maintain some notions about which threads/messages/whatever are most important to send next. What does the stack need to do in addition?\r\n- Maybe I am really missing something here (please tell me).",
          "createdAt": "2018-09-06T13:08:15Z",
          "updatedAt": "2018-09-06T13:08:15Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think per-message niceness is an artefact of not being sure how this will map onto multi-streaming. E.g., if this is NOT implemented as \"one (TAPS) Connection = one stream of a transport\", then maybe multiple streams could be used underneath the API, and per-message niceness could be used to assign a message to a stream based on a Niceness value. Then, however, per-connection Niceness becomes irrelevant.\r\n\r\nMy conclusion is that we should keep it in there for now, but mark it with a \"DISCUSS\" so we remember to decide for *either* per-message or per-connection Niceness depending on how we intend to implement multi-streaming.\r\n\r\n(my personal preference is to have per-connection Niceness only, and hence map \"one (TAPS) connection is one stream\")",
          "createdAt": "2018-09-06T13:17:10Z",
          "updatedAt": "2018-09-06T13:17:10Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "let's land this now, though, and have the niceness discussion in another issue / at the interim...",
          "createdAt": "2018-09-06T13:38:24Z",
          "updatedAt": "2018-09-06T13:38:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see I'm late for the party... but just for the record, now that I managed to give it a close read, I also agree with this  :)",
          "createdAt": "2018-09-06T15:41:48Z",
          "updatedAt": "2018-09-06T15:41:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyODQ2NTA4",
          "commit": {
            "abbreviatedOid": "b91b582"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, I think this helps to further clean up our property chaos.\r\nFixing these references is definitely the right move, and having the Type stand out explicitly for Message Properties as well. \r\nI'm not sure we need to explicitly state the type again down in Section 12.3, but I'm fine either way, as this Section is going to change further anyway.\r\n\r\nThe only thing that I disagree with here is that per-Message Niceness can override per-Connection Niceness. \r\nWe agreed that implementations can have a per-Connection default for a per-Message property as syntactic sugar for helping the application. However, this is a different thing than setting a Connection property on the Connection, and we need to be careful to not mix up the two.",
          "createdAt": "2018-09-06T09:32:29Z",
          "updatedAt": "2018-09-06T09:46:38Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Mhh, I don't think this is true.\r\nI think per-Connection Niceness and per-Message Niceness are different Properties and refer to different things (the priority of Connections within a Connection group, and the priority of Messages within a Connection), so they cannot override each other.\r\nI'd be in favor of removing this sentence.",
              "createdAt": "2018-09-06T09:32:29Z",
              "updatedAt": "2018-09-06T11:56:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyODk1MTE2",
          "commit": {
            "abbreviatedOid": "bfc59ea"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T11:58:46Z",
          "updatedAt": "2018-09-06T11:58:46Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Sorry, forgot about that - hope the new sentence captures the discussion.\r\nJust removing it does will bring us to new discussions about this sooner or later.",
              "createdAt": "2018-09-06T11:58:46Z",
              "updatedAt": "2018-09-06T11:58:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyOTE0MTUx",
          "commit": {
            "abbreviatedOid": "bfc59ea"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "this is fine",
          "createdAt": "2018-09-06T12:53:49Z",
          "updatedAt": "2018-09-06T12:53:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyOTE2NTI2",
          "commit": {
            "abbreviatedOid": "bfc59ea"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T12:59:36Z",
          "updatedAt": "2018-09-06T12:59:36Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Good point. I think like this it's fine.",
              "createdAt": "2018-09-06T12:59:36Z",
              "updatedAt": "2018-09-06T12:59:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyOTE3MDkw",
          "commit": {
            "abbreviatedOid": "bfc59ea"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Alright, then I think this is ready to land.",
          "createdAt": "2018-09-06T13:00:59Z",
          "updatedAt": "2018-09-06T13:00:59Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bad3e2da67acd62285972e617a06b22a963127e7",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "message-propery-inconsistency-fixes",
      "headRefOid": "bfc59ea480bd951cb549242975117146da6d6eb3",
      "mergeCommit": {
        "oid": "ef6cac72234b2793c4a16ff2f941c385629ed10c"
      }
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNjc0OTE3",
      "title": "Some clarifications in property text",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/225",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I didn't like something about reliability (let's not throw an error when we can't be UNreliable, only when we can't be reliable). I updated the text on ordering a bit, to say that the Property is ignored for the first Message on a Connection, and rephrased it slightly to talk about the receiver-side transport system and the receiving application - before, the text might have talked about a sender-side behavior.  I added a TODO DISCUSS comment about per-message Niceness.",
      "createdAt": "2018-09-06T16:16:26Z",
      "updatedAt": "2018-09-12T08:13:24Z",
      "closedAt": "2018-09-11T08:58:48Z",
      "mergedAt": "2018-09-11T08:58:48Z",
      "mergedBy": "philsbln",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTE3MTAw",
          "commit": {
            "abbreviatedOid": "0490599"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-06T20:53:15Z",
          "updatedAt": "2018-09-06T21:02:01Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "This fix is not correct. There is nothing special about the first message. The update needs to clarify the description of what \"ordered\" means:\r\n\r\n\"If true, it specifies that the receiver-side transport system should only deliver the Message to the receiving application after the previous **ordered** Message that was passed to the same Connection via the Send\r\nAction, **when such a message exists**.\"",
              "createdAt": "2018-09-06T20:53:15Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            },
            {
              "originalPosition": 21,
              "body": "This should not refer to the protocol I think. It is the connection that must be reliable (then as a consequence the protocol will also be reliable). But if you have an unreliable connection that happens to be mapped to TCP, it should not be allowed to send a reliable message on this unreliable connection.",
              "createdAt": "2018-09-06T20:59:41Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            },
            {
              "originalPosition": 37,
              "body": "Spelling is still incorrect :-)",
              "createdAt": "2018-09-06T21:01:42Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTI1MzIy",
          "commit": {
            "abbreviatedOid": "0490599"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T21:16:09Z",
          "updatedAt": "2018-09-06T21:16:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Agreed! will fix",
              "createdAt": "2018-09-06T21:16:09Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTI1Mzk4",
          "commit": {
            "abbreviatedOid": "0490599"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T21:16:23Z",
          "updatedAt": "2018-09-06T21:16:23Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Sigh  :)  thanks, will fix!",
              "createdAt": "2018-09-06T21:16:23Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTI3NzUz",
          "commit": {
            "abbreviatedOid": "0490599"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T21:23:32Z",
          "updatedAt": "2018-09-06T21:23:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Got it, thanks!",
              "createdAt": "2018-09-06T21:23:32Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTM4NzA2",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, all good now I think.",
          "createdAt": "2018-09-06T21:59:29Z",
          "updatedAt": "2018-09-06T21:59:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTcyNjYx",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-07T00:57:55Z",
          "updatedAt": "2018-09-07T00:57:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjMzMDc2",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I appreciate the clarification, but it's not entirely clear to me yet, see below.",
          "createdAt": "2018-09-07T07:40:33Z",
          "updatedAt": "2018-09-07T08:07:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "To me this sounds like it will only work if there is a transport system on the other side, but TAPS can also be implemented one-sided.\r\nShouldn't the message be sent in such a way that the receiver-side transport stack, which may or may not be a TAPS-like transport system, will deliver it to the application in order? (Of course this implies that our sender-side transport system has chosen a stack that can do this.)\r\nIf this is about the receiver-side transport protocol stack, not a transport system that we can't guarantee is actually running there, I'd favor \"receiver-side transport protocol stack\" or something similar. Or am I missing something here?",
              "createdAt": "2018-09-07T07:40:33Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            },
            {
              "originalPosition": 19,
              "body": "Agree that if the Connection does not support reliability and the application requests reliable, we must throw an error so that sending fails, but we don't need to fail the other way round. Maybe a warning makes sense, but we don't need to standardize that.\r\nHowever, I think this property makes most sense with partially reliable transport protocols, and I'd like to keep a reference to {{prop-partially-reliable}} here. Maybe something like \"if the Connection supports reliability, see {{prop-reliable}}, or partial reliability, see {{prop-partially-reliable}}\"?",
              "createdAt": "2018-09-07T08:02:44Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjQzMzQ0",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine with me, maybe fix minor knit",
          "createdAt": "2018-09-07T08:15:47Z",
          "updatedAt": "2018-09-07T08:17:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "From my perspective, this is a minor knit. Perhaps try the following instead:\r\n\r\n> If true, it specifies that the receiver-side transport system is expected to only deliver the Message to\r\n> the receiving application after the previous ordered Message which was passed to the same Connection.\r\n> The actual signaling of this is protocol specific.\r\n",
              "createdAt": "2018-09-07T08:15:47Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            },
            {
              "originalPosition": 19,
              "body": "For me, this is clear.",
              "createdAt": "2018-09-07T08:17:17Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjQ0MDI4",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T08:18:09Z",
          "updatedAt": "2018-09-07T08:18:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "What you say is true, but then TAPS uses transports that also have receiver sematics: \r\n\r\nTrue - seems like receiver TCP semantics? (so if there is a TCP receiver at the remote, TAPS can use that). SCTP can also support this.\r\n\r\nFalse - seems like UDP. If the stack supports this, the SCTP can alternatively do this.\r\n\r\n... My choice would be I'd prefer to standardise \"does not need to be ordered\", if I had a choice of semantics.\r\n",
              "createdAt": "2018-09-07T08:18:09Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjQ0MTI0",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T08:18:27Z",
          "updatedAt": "2018-09-07T08:18:27Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "... My choice would be I'd prefer to standardise \"needs reliable\", if I had a choice of semantics.\r\nRelaxing \"needs reliable\" can be done on a per-message basis for SCTP stacks that allow this.",
              "createdAt": "2018-09-07T08:18:27Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjQ1ODc1",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T08:24:13Z",
          "updatedAt": "2018-09-07T08:24:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes, \"TAPS uses transports that also have receiver sematics\" is exactly what I mean by \"this implies that our sender-side transport system has chosen a stack that can do this.\"\r\nMy point is just to make clear that there doesn't need to be a TAPS system running on the receiver side for this to work. But yes, I guess that's a nit.",
              "createdAt": "2018-09-07T08:24:13Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjY3MTU4",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T09:26:48Z",
          "updatedAt": "2018-09-07T09:26:48Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Indeed, the sender side alone can never guarantee ordering - at best, it can know that there is a receiver that takes care of it, or (e.g. in case of SCTP) signal the wish to the receiver. I updated the text to talk about the receiver behavior to avoid indicating sender-side logic that shouldn't be there. I thought the receiver-oriented text is clearer.",
              "createdAt": "2018-09-07T09:26:48Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjcwMDc4",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T09:34:34Z",
          "updatedAt": "2018-09-07T09:34:58Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I see -- I misunderstood the intention behind \"Reliable Data Transfer (Connection)\". I suggest to include the reference to partially reliability as @theri suggests, but also update the text after \"Reliable Data Transfer (Connection)\" from: \"This property specifies whether the application wishes to use a transport protocol that ensures that all data is received on the other side without corruption.\"  to \"This property specifies whether the application requires that all data it sends on the Connection will be received on the other side without corruption.\"\r\n\r\nThe main point here is the use of \"requires\" as opposed to \"wishes\".",
              "createdAt": "2018-09-07T09:34:34Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjg3MjUy",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T10:27:29Z",
          "updatedAt": "2018-09-07T10:27:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Well, \"Reliable Data Transfer (Connection)\" has the data type \"Preference\" anyway, so an application can Require, Prefer, Avoid, or Prohibit it. Out of these, I guess \"Require\" makes the most sense, and I think it can replace \"wishes\", which sounds like \"Prefers\".\r\nHowever, we have lots and lots of formulations like this in the other properties as well, so maybe we want to agree on a more general non-awkward way to phrase this (in another PR?).",
              "createdAt": "2018-09-07T10:27:29Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjg4ODI1",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T10:33:11Z",
          "updatedAt": "2018-09-07T10:33:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I agree with what you're saying, it's clearer.\r\nMy only comment (perhaps a nit) is to change \"receiver-side transport system\" to \"receiver-side transport protocol stack\", so we do not imply that there is a transport system (which, I think, we define as a TAPS implementation) running there, it could also just be a vanilla stack.",
              "createdAt": "2018-09-07T10:33:11Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMzA0NDQy",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T11:31:03Z",
          "updatedAt": "2018-09-07T11:31:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Ah. Understood.  But let me just call it \"needs\" for now.",
              "createdAt": "2018-09-07T11:31:03Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMzA0ODMz",
          "commit": {
            "abbreviatedOid": "466f53a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T11:32:30Z",
          "updatedAt": "2018-09-07T11:32:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I agree, that's better",
              "createdAt": "2018-09-07T11:32:30Z",
              "updatedAt": "2018-09-07T13:56:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMzUzNDg0",
          "commit": {
            "abbreviatedOid": "27a15d4"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-07T14:00:16Z",
          "updatedAt": "2018-09-07T14:00:16Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ef6cac72234b2793c4a16ff2f941c385629ed10c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "Some-clarifications-in-property-text",
      "headRefOid": "27a15d4c7999e135d1cffa6238bc6b2ac5382a78",
      "mergeCommit": {
        "oid": "3a697b52d753f5c4a85117e3f22308f5241e2202"
      }
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0OTEzOTkx",
      "title": "Moved Connection Properties up to #introspection",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/227",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is the second step towards applying our new Properties\r\nClassification. It moves up the Connection Properties and annotates most\r\nplaces with stuff to do.",
      "createdAt": "2018-09-12T10:38:12Z",
      "updatedAt": "2018-09-26T06:42:52Z",
      "closedAt": "2018-09-21T09:55:37Z",
      "mergedAt": "2018-09-21T09:55:37Z",
      "mergedBy": "philsbln",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NjYzMTQy",
          "commit": {
            "abbreviatedOid": "97a7b2d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I carefully checked it, but I find it very hard to be sure that this is 100% ok (as is usually the case IMO with diff's about text blocks being moved around). My suggestion is to land it and see.",
          "createdAt": "2018-09-12T14:01:16Z",
          "updatedAt": "2018-09-12T14:01:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NTI2NTcz",
          "commit": {
            "abbreviatedOid": "97a7b2d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for moving this forward!\r\n\r\nI only found a few nits.\r\nAlso, I have a question about whether two of these Properties should maybe be changed to be Selection Properties, but that's more of a discussion and not something that needs to be done in this PR.",
          "createdAt": "2018-09-14T14:42:14Z",
          "updatedAt": "2018-09-14T14:57:30Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "This basically says that this property is two things at the same time:\r\n1. A Connection Property saying that the application wants these notifications in case the transport stack can provide them,\r\n2. A Selection Property to \"Prefer\" transport stacks that can provide these notifications.\r\n\r\nI'm wondering if this property really should be both in one.\r\nI think this text got written before we had an actual concept of Preferences in Selection Properties. Maybe we want to make this an actual Selection Property instead, with data type \"Preference\"? And then once the Connection is instantiated, it becomes a Connection property like all other Selection Properties, providing a Boolean of whether the feature is there or not?\r\nI'd also be okay with it staying like this for this PR though.",
              "createdAt": "2018-09-14T14:42:14Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            },
            {
              "originalPosition": 75,
              "body": "Same question as for \"Notification of excessive retransmissions\" above.",
              "createdAt": "2018-09-14T14:42:55Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            },
            {
              "originalPosition": 169,
              "body": "Two nits here: \r\n1. The first link should point to {{selection-props}}.\r\n2. The comma should be before \"and\", not after.",
              "createdAt": "2018-09-14T14:44:51Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            },
            {
              "originalPosition": 178,
              "body": "Why change \"the object they apply on\" to \"context they apply on\"? I think \"object\" was clearer.",
              "createdAt": "2018-09-14T14:45:43Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            },
            {
              "originalPosition": 207,
              "body": "This sentence is incomplete.",
              "createdAt": "2018-09-14T14:47:05Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            },
            {
              "originalPosition": 259,
              "body": "Nit: s/Interger/Integer/",
              "createdAt": "2018-09-14T14:47:58Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MzgyMzQw",
          "commit": {
            "abbreviatedOid": "97a7b2d"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "ok modulo @theri's comments",
          "createdAt": "2018-09-20T17:25:30Z",
          "updatedAt": "2018-09-20T17:26:07Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yes, this should eventually be split.",
              "createdAt": "2018-09-20T17:25:30Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3NjExNTE2",
          "commit": {
            "abbreviatedOid": "97a7b2d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-21T09:25:08Z",
          "updatedAt": "2018-09-21T09:25:09Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I agree, but I'll leave it as ist is for this PR and make a new ticket for it",
              "createdAt": "2018-09-21T09:25:08Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3NjEzMTk1",
          "commit": {
            "abbreviatedOid": "97a7b2d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-21T09:30:02Z",
          "updatedAt": "2018-09-21T09:30:02Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Thanks for this findings - fixed",
              "createdAt": "2018-09-21T09:30:02Z",
              "updatedAt": "2018-09-21T09:37:55Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a697b52d753f5c4a85117e3f22308f5241e2202",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "connection-properties",
      "headRefOid": "a7b9aefa99ca32c89e0e17c4610c5511c2ad5e47",
      "mergeCommit": {
        "oid": "33387a4b7882be61754ac58b5c2133a3f3226a3b"
      }
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3MDQ4ODYw",
      "title": "fix #219, Bindings is now an array",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/229",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-20T17:24:21Z",
      "updatedAt": "2018-09-27T22:19:16Z",
      "closedAt": "2018-09-20T18:30:59Z",
      "mergedAt": "2018-09-20T18:30:59Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3Mzg0ODcw",
          "commit": {
            "abbreviatedOid": "c323b8a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-20T17:31:39Z",
          "updatedAt": "2018-09-20T17:31:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3NTg2Njg5",
          "commit": {
            "abbreviatedOid": "c323b8a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-21T08:14:58Z",
          "updatedAt": "2018-09-21T08:15:16Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Just a nit: above, it's said that an action creates an array of objects, but here it's called a list. For consistency, it would be better to call it either a list or an array everywhere, I guess.",
              "createdAt": "2018-09-21T08:14:58Z",
              "updatedAt": "2018-09-21T08:15:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5NjYzMjU3",
          "commit": {
            "abbreviatedOid": "c323b8a"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-09-27T22:19:16Z",
          "updatedAt": "2018-09-27T22:19:16Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b3a4093245187682dbdd0949d20b912948975835",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "219-bindings-wtf",
      "headRefOid": "c323b8a50cd9ae279a310653d8944759189c66de",
      "mergeCommit": {
        "oid": "6709611c62dee2b11685ef3558f97b95ba6767b2"
      }
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIwOTQ1Nzg2",
      "title": "segmentation and fragmentation prohibited: fix #226",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/232",
      "state": "CLOSED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add segmentation and fragmentation prohibited message properties",
      "createdAt": "2018-10-07T12:41:57Z",
      "updatedAt": "2018-10-17T15:00:18Z",
      "closedAt": "2018-10-10T14:28:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "all right let's do the other one for now.",
          "createdAt": "2018-10-10T14:28:51Z",
          "updatedAt": "2018-10-10T14:28:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDQ0NjEy",
          "commit": {
            "abbreviatedOid": "f66d7b6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I have more comments and I'm moving them to #226, I think the discussion isn't over yet...",
          "createdAt": "2018-10-08T12:22:28Z",
          "updatedAt": "2018-10-08T12:37:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Suggest: \"When used with transports supporting this functionality, running over IP version 4, the Don't Fragment bit will be set.\"",
              "createdAt": "2018-10-08T12:22:29Z",
              "updatedAt": "2018-10-09T12:32:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNTcwODc2",
          "commit": {
            "abbreviatedOid": "f66d7b6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-08T17:31:52Z",
          "updatedAt": "2018-10-08T17:31:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyODA0OTgy",
          "commit": {
            "abbreviatedOid": "f66d7b6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-09T09:57:56Z",
          "updatedAt": "2018-10-09T09:57:57Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "ack fill wix.",
              "createdAt": "2018-10-09T09:57:56Z",
              "updatedAt": "2018-10-09T12:32:26Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "33387a4b7882be61754ac58b5c2133a3f3226a3b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "dont-fragment-226",
      "headRefOid": "d2df6055aa81936e7619d3df0440f288a23b1430",
      "mergeCommit": null
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIwOTQ1OTY0",
      "title": "clean up capacity profile per #142",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/233",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a (work in progress) attempt to clean up Capacity Profile as a selection property along the lines of the state of the discussion in #142.\r\n\r\n@gorryfair: you had a suggestion to add \"High Throughput Data\" as a separate profile mapping to AF2n, but I don't know anything else about what this would actually imply for transport selection; can you help me out here?",
      "createdAt": "2018-10-07T12:45:15Z",
      "updatedAt": "2018-10-17T15:00:05Z",
      "closedAt": "2018-10-09T15:39:43Z",
      "mergedAt": "2018-10-09T15:39:43Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign .... to the transmitted traffic. For multiplexed connections, the guidelines in RFC 75657, Section 6 apply.\r\n\r\n+1 to this",
          "createdAt": "2018-10-08T12:38:54Z",
          "updatedAt": "2018-10-08T12:38:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri - \"Please give me the maximum available bandwidth, possibly at the cost of latency\" is not how this is defined. See RFC 4594, section 4.8: \"The High-Throughput Data service class is RECOMMENDED for elastic applications that require timely packet forwarding of variable rate traffic sources and, more specifically, is configured to provide good throughput for TCP longer-lived flows.\"\r\n\r\nI don't interpret \"require timely packet forwarding\" as \"possibly at the cost of latency\".\r\n\r\nI'm also in favor of keeping it - because it has a defined meaning and implementation method as described in at least one RFC, and is hence perhaps even already used by some ISPs to treat traffic in a certain way.",
          "createdAt": "2018-10-09T07:12:31Z",
          "updatedAt": "2018-10-09T07:12:31Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl Yes, but for a high-throughput flow, \"timely packet forwarding\" will more likely be achieved on a high-bandwidth path with higher latency than on a low-latency path with lower bandwidth, that's what I mean. In RFC 4594, Figure 2, it says that High-Throughput data has a \"Medium-High tolerance to Delay\", I think that means the same - for this traffic, you don't optimize for low latency on the path, but for high bandwidth.",
          "createdAt": "2018-10-09T08:43:29Z",
          "updatedAt": "2018-10-09T08:43:54Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just committed text for High Throughput, making it clear that the *only* thing the transport system can do with this is stick a DSCP mark on it. Is this ready to go?",
          "createdAt": "2018-10-09T09:57:16Z",
          "updatedAt": "2018-10-09T09:57:16Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly is this good to merge?",
          "createdAt": "2018-10-09T12:35:07Z",
          "updatedAt": "2018-10-09T12:35:07Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Seemed you reached the correct conclusion scavenger =/= bulk.",
          "createdAt": "2018-10-09T17:01:27Z",
          "updatedAt": "2018-10-09T17:01:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDIzODQw",
          "commit": {
            "abbreviatedOid": "4ce8ecc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start!  I particularly like the idea of using a SHOULD to associate these things with DSCP values. However, the wording used everywhere: \"When the underlying transport protocol stack(s) support per-connection DSCP signaling, transmitted traffic SHOULD carry...\" is a bit too restrictive IMO. E.g., when TAPS connections are streams of a single underlying transport, one may want to implement this as a pure sender-side scheduling decision. Also, in case of multiplexing, these SHOULDs should be checked against RFC 7657, which provides rules to avoid multiplexing DSCP values that don't work well together on the same 5-tuple.\r\n\r\nAs a way out of this, I'd suggest to change every instance of the phrase above to:\r\n\r\n\"Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign .... to the transmitted traffic. For multiplexed connections, the guidelines in RFC 75657, Section 6 apply.\"",
          "createdAt": "2018-10-08T11:15:05Z",
          "updatedAt": "2018-10-08T11:49:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I think Gorry took issue with \"pattern expected by the application\" in #142 (i.e., I don't think this re-wording fixes his problem with the old version). Specifically, he wrote that he'd prefer: \"application\u2019s expectation of the treatment the network should provide for...\"",
              "createdAt": "2018-10-08T11:15:05Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            },
            {
              "originalPosition": 62,
              "body": "This was also in the old text and I only notice it now: why do we say \"a large amount of data\"?  It could also be tiny?  That seems quite unnecessary here.",
              "createdAt": "2018-10-08T11:17:47Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            },
            {
              "originalPosition": 99,
              "body": "What a strange beast. Oh well. It exists and there's probably a point. As for implementation, see:  https://trac.tools.ietf.org/html/rfc4594#section-4.8   AF1n, it seems, not AF2n.",
              "createdAt": "2018-10-08T11:40:31Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDQ5NzQy",
          "commit": {
            "abbreviatedOid": "4ce8ecc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-08T12:37:33Z",
          "updatedAt": "2018-10-08T12:37:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "ah, yep, will fix.",
              "createdAt": "2018-10-08T12:37:33Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDQ5ODMx",
          "commit": {
            "abbreviatedOid": "4ce8ecc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-08T12:37:51Z",
          "updatedAt": "2018-10-08T12:37:51Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "agreed, will fix.",
              "createdAt": "2018-10-08T12:37:51Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDQ5OTY5",
          "commit": {
            "abbreviatedOid": "4ce8ecc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-08T12:38:14Z",
          "updatedAt": "2018-10-08T12:38:14Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "will change to AF1n, then wait for @gorryfair to tell me what it means.",
              "createdAt": "2018-10-08T12:38:14Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDczNDI0",
          "commit": {
            "abbreviatedOid": "21662a4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the commit that addresses my comments!\r\n\r\nBut this goes only half-way along my proposal, and I suspect that wasn't by intention.\r\n\r\nMy proposed text was:\r\n\r\nTransport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign .... to the transmitted traffic. For multiplexed connections, the guidelines in RFC 75657, Section 6 apply.\r\n\r\nYou incorporated the following for all DSCP bits:\r\n\"For multiplexed connections, the guidelines in RFC 75657, Section 6 apply.\"\r\n... but the text still says \"When the underlying transport protocol stack(s) support per-connection DSCP signaling, transmitted traffic SHOULD ...\", which I find too restrictive (not suitable if I don't want to use the DSCP at all and instead implement it all only with a sender-side scheduler, for example).\r\nHence, please also use the first half of my proposed text, or something like it.",
          "createdAt": "2018-10-08T13:37:19Z",
          "updatedAt": "2018-10-08T13:37:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNTM4MjUx",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-08T15:58:52Z",
          "updatedAt": "2018-10-08T15:58:52Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Actually, I find Scavenger/Bulk very confusing. Bulk is a large amount of data, and could still be urgent. Scavenger could be tiny or large and is not urgent. So if this is what we are talking about the name should be only Scavenger?",
              "createdAt": "2018-10-08T15:58:52Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNTQ4NDY3",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-08T16:25:46Z",
          "updatedAt": "2018-10-08T16:25:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNTQ4OTAw",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-08T16:26:56Z",
          "updatedAt": "2018-10-08T16:26:57Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I somehow overlooked the \"bulk\" bit in the headline, but I totally agree!",
              "createdAt": "2018-10-08T16:26:57Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNTc2NjU4",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's remove the High Throughput for now?",
          "createdAt": "2018-10-08T17:49:12Z",
          "updatedAt": "2018-10-08T17:50:29Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Sp: specity => specify",
              "createdAt": "2018-10-08T17:49:12Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            },
            {
              "originalPosition": 102,
              "body": "Yeah, not really sure what to do with \"High Throughput\". Perhaps we can just specify that this enum list of profiles is allowed to grow in the future when we have better ideas?",
              "createdAt": "2018-10-08T17:50:13Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNzM3NTc5",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the way this is phrased now.\r\n\r\nI'm in favor of keeping High Throughput:\r\nThe Transport System could use this for Path Selection imo, if it has an idea of the available bandwidth over the paths. I think it makes sense that the application is able to say \"Please give me the maximum available bandwith, possibly at the cost of latency\" here.",
          "createdAt": "2018-10-09T06:54:01Z",
          "updatedAt": "2018-10-09T06:54:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNzQxMjUx",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-09T07:08:24Z",
          "updatedAt": "2018-10-09T07:08:24Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I'm concerned with us simply shrugging off stuff that has been previously defined in the IETF; the \"High Throughput\" service class is described in RFC 4594, Section 4.8. While I personally also find the service as described there a little awkward, I find it hard to believe that RFC 4594 was simply published with no prior discussion. If you want something newer, it's also discussed in RFC 8325. By mapping it to AF1n as described in RFC 4594, it seems simple enough to implement.\r\n\r\nSo, I'd rather keep it with a reference to this RFC and this simple mapping. But I'm not going to fight for it!",
              "createdAt": "2018-10-09T07:08:24Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNzkyODgw",
          "commit": {
            "abbreviatedOid": "e8e75f1"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-09T09:28:30Z",
          "updatedAt": "2018-10-09T09:28:30Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "If we want to keep it, we need text as to why an application would want this.",
              "createdAt": "2018-10-09T09:28:30Z",
              "updatedAt": "2018-10-09T12:33:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyODU4OTM5",
          "commit": {
            "abbreviatedOid": "79dcc17"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Please also change Scavenger/Bulk to Scavenger as per Anna's request. I'd do it myself but I don't want to create a conflict",
          "createdAt": "2018-10-09T12:23:29Z",
          "updatedAt": "2018-10-09T12:23:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyOTU5OTgx",
          "commit": {
            "abbreviatedOid": "1e3dbd4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-09T15:39:11Z",
          "updatedAt": "2018-10-09T15:39:11Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "33387a4b7882be61754ac58b5c2133a3f3226a3b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "capacity-profile-142",
      "headRefOid": "1e3dbd4fc8ca20d84894b67af11f1bc7ec11c8bf",
      "mergeCommit": {
        "oid": "9037bcdc5ca83258322a593f940580eb8002f08e"
      }
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIwOTQ3MjQ0",
      "title": "add discussion of states to event ordering, fix #231",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/234",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-07T13:09:59Z",
      "updatedAt": "2018-10-17T15:00:15Z",
      "closedAt": "2018-10-08T12:36:53Z",
      "mergedAt": "2018-10-08T12:36:53Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyNDAzNjg0",
          "commit": {
            "abbreviatedOid": "4c40586"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This LGTM",
          "createdAt": "2018-10-08T10:08:20Z",
          "updatedAt": "2018-10-08T10:08:20Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "33387a4b7882be61754ac58b5c2133a3f3226a3b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "states-for-real-231",
      "headRefOid": "4c40586c58c08d10645f9bc80369136c1da7c7de",
      "mergeCommit": {
        "oid": "f2a6e56095aa3ed42cab8bc522e7e15696ef5fde"
      }
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIxNzE5NTI3",
      "title": "singular transmission fix for #226",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/235",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Alternate fix for fragmentation/segmentation prohibited in a single message property, per discussion.\r\n\r\nMerge only one of these. :)",
      "createdAt": "2018-10-10T09:33:12Z",
      "updatedAt": "2018-10-17T14:59:52Z",
      "closedAt": "2018-10-10T14:29:09Z",
      "mergedAt": "2018-10-10T14:29:09Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYzMjY1NDY2",
          "commit": {
            "abbreviatedOid": "260da56"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Very nice! Thanks a lot for doing this!",
          "createdAt": "2018-10-10T09:35:21Z",
          "updatedAt": "2018-10-10T09:35:21Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9037bcdc5ca83258322a593f940580eb8002f08e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "single-nofrag-226",
      "headRefOid": "260da56b56bd28c00886821255d3ad54707faac0",
      "mergeCommit": {
        "oid": "0a4c8aeb46c56b2fb941f24cbb2aa34d5444c38d"
      }
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIyMjg2NzQw",
      "title": "Add more details to architecture introduction",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/236",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Address issue #189 \r\n- Add more intro section, with friendly diagrams\r\n- Highlight why we use events, messages, and racing",
      "createdAt": "2018-10-11T21:34:47Z",
      "updatedAt": "2018-10-17T14:59:50Z",
      "closedAt": "2018-10-16T08:35:46Z",
      "mergedAt": "2018-10-16T08:35:46Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0MTIwMzc3",
          "commit": {
            "abbreviatedOid": "c75ec21"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM; just 2 suggestions",
          "createdAt": "2018-10-12T07:10:10Z",
          "updatedAt": "2018-10-12T07:16:16Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I like this, but would propose to update it as follows:\r\n\r\n```\r\n +-----------------------------------------------------+\r\n |                    Application                      |\r\n +-----------------------------------------------------+\r\n        |                  |                    |\r\n +-----------------------------------------------------+\r\n |      |             Socket API                |      |\r\n +-----------------------------------------------------+\r\n        |                                       |\r\n +-----------------------------------------------------+\r\n |      |     Kernel Protocol Implementation    |      |\r\n |     TCP                                     UDP     |\r\n +-----------------------------------------------------+\r\n                           |\r\n +-----------------------------------------------------+\r\n |               Network Layer Interface               |\r\n +-----------------------------------------------------+\r\n```",
              "createdAt": "2018-10-12T07:10:10Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 64,
              "body": "A nit - should this be: \"Events in time more closely *reflect* \"  ?",
              "createdAt": "2018-10-12T07:14:30Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NDAyMzA2",
          "commit": {
            "abbreviatedOid": "c75ec21"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-12T20:43:12Z",
          "updatedAt": "2018-10-12T20:43:12Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "What are the lines from the application down to TCP and UDP? Just showing the different use cases?",
              "createdAt": "2018-10-12T20:43:12Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NDAyODY4",
          "commit": {
            "abbreviatedOid": "6742ec6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-12T20:45:05Z",
          "updatedAt": "2018-10-12T20:45:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "No, the point was to show that applications are statically bound to either TCP or UDP.",
              "createdAt": "2018-10-12T20:45:05Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NDA1MzY3",
          "commit": {
            "abbreviatedOid": "6742ec6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-12T20:53:22Z",
          "updatedAt": "2018-10-12T20:53:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Ah, I see now. That makes more sense now. I'll try to redraw to illustrate that.",
              "createdAt": "2018-10-12T20:53:22Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NDA2NTU0",
          "commit": {
            "abbreviatedOid": "47b2179"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-12T20:57:08Z",
          "updatedAt": "2018-10-12T20:57:08Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Okay, take a look at the updated diagram",
              "createdAt": "2018-10-12T20:57:08Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NDc0MzA2",
          "commit": {
            "abbreviatedOid": "47b2179"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-13T19:41:10Z",
          "updatedAt": "2018-10-13T19:41:10Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Much nicer! Thanks for this!",
              "createdAt": "2018-10-13T19:41:10Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NTA2Njc0",
          "commit": {
            "abbreviatedOid": "47b2179"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "This is great! Thanks for writing this down. I only have comments about the scope of the text, especially in relation to the connect-by-name feature.",
          "createdAt": "2018-10-14T17:14:34Z",
          "updatedAt": "2018-10-14T17:25:33Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "We should include TLS in this list!",
              "createdAt": "2018-10-14T17:14:34Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 15,
              "body": "This doesn't cover the fact that DNS resolution is done elsewhere. Should that be included?",
              "createdAt": "2018-10-14T17:15:54Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 54,
              "body": "What about connect-by-name, since we may represent endpoints as DNS+port tuples?",
              "createdAt": "2018-10-14T17:17:20Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 68,
              "body": "\"TLS encodes records using a header with a length\" -> \"TLS record headers carry a version, content type, and length\"",
              "createdAt": "2018-10-14T17:20:21Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 76,
              "body": "I think I follow this, though \"deal with higher-level endpoints\" may imply that applications must do resolution themselves to obtain IP addresses, which doesn't seem to be what we want to say. How about:\r\n\r\n\"This requires applications to work with higher-level endpoints than IP addresses, such as hostnames and URLs, which are used by a Transport Services implementation for path selection.\"",
              "createdAt": "2018-10-14T17:23:32Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            },
            {
              "originalPosition": 74,
              "body": "It might also be worth noting that this socket limitation permeates to higher levels of the protocol stack, e.g., through TLS. ",
              "createdAt": "2018-10-14T17:24:23Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0NzY2MDIw",
          "commit": {
            "abbreviatedOid": "47b2179"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm modulo @chris-wood's comments",
          "createdAt": "2018-10-15T15:35:24Z",
          "updatedAt": "2018-10-15T15:35:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0ODAzMTc1",
          "commit": {
            "abbreviatedOid": "47b2179"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-15T17:01:53Z",
          "updatedAt": "2018-10-15T17:01:53Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yes we should!",
              "createdAt": "2018-10-15T17:01:53Z",
              "updatedAt": "2018-10-15T17:12:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0ODA3Nzgx",
          "commit": {
            "abbreviatedOid": "bcb4628"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-15T17:13:14Z",
          "updatedAt": "2018-10-15T17:13:14Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think it's a bit messy for the diagram. I've updated more of the text below to mention multiple IPs and higher level endpoints below.",
              "createdAt": "2018-10-15T17:13:14Z",
              "updatedAt": "2018-10-15T17:13:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0ODIyMzM0",
          "commit": {
            "abbreviatedOid": "bcb4628"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-15T17:50:02Z",
          "updatedAt": "2018-10-15T17:50:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-10-15T17:50:02Z",
              "updatedAt": "2018-10-15T17:50:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0ODIyNTgx",
          "commit": {
            "abbreviatedOid": "bcb4628"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-10-15T17:50:38Z",
          "updatedAt": "2018-10-15T17:50:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY0OTAwNzY3",
          "commit": {
            "abbreviatedOid": "bcb4628"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-15T21:19:52Z",
          "updatedAt": "2018-10-15T21:19:52Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0a4c8aeb46c56b2fb941f24cbb2aa34d5444c38d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-intro",
      "headRefOid": "bcb4628bcb26c4a654d460078bc81394d6700807",
      "mergeCommit": {
        "oid": "31f8b5efcc082bb56d0ad72d2ad92893be4340b9"
      }
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzMjAyMTM1",
      "title": "First pass at property reorganization (see #208)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/238",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is my suggestion for cleaning up properties. It makes the following changes:\r\n\r\n1. Section 12 Transport Properties goes away. Its introduction to what transport properties are moves into a new section 4.1 (since Properties are key to how the API works, they need to come first). Selection Properties move into Section 5.2. Some of the explanation of each class has moved to the section of the document where the class is defined (5.2 Selection Properties, 7.3 Message Context Properties, 9.1 Connection Properties).\r\n\r\n2. Capacity Profile is a Connection Property, not a Selection Property, so it moves to Connection Properties. \r\n\r\n3. Directionality moves back into the appendix, because we're not done discussing it yet.\r\n\r\nThings that (might) still need to happen, not part of this PR:\r\n\r\n1. Reconcile Transmission Profile and Capacity Profile\r\n\r\n2. Figure out the best way to cross reference Selection Properties with Connection and Message Context Properties they enable. Maybe this happens in a new Section 12 (as the registry work @philsbln wants to do / an 8095-style table), and/or with direct references back to Selection Properties in each Connection and Message Context Property.\r\n\r\n3. Rename Message Context Properties\r\n\r\n",
      "createdAt": "2018-10-16T10:49:26Z",
      "updatedAt": "2018-10-18T08:17:00Z",
      "closedAt": "2018-10-16T21:24:20Z",
      "mergedAt": "2018-10-16T21:24:20Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'm also inclined to land this and fix the problems with it later. will wait for one more green check before doing so. \r\n\r\n(For those trying to review this, the important bits to look at are the new [section 4.1](https://taps-api.github.io/drafts/property-structure-208-218/draft-ietf-taps-interface.html#rfc.section.4.1) and [section 5.2](https://taps-api.github.io/drafts/property-structure-208-218/draft-ietf-taps-interface.html#rfc.section.5.2).)",
          "createdAt": "2018-10-16T14:59:45Z",
          "updatedAt": "2018-10-16T14:59:45Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whooop\u2026 that was fast. \r\n\r\nI like the overall result, except deleting the overview from Section 12.\r\nRe-introducing it for the registry proposal will be another 2-3h of unnecessary work.",
          "createdAt": "2018-10-17T09:06:41Z",
          "updatedAt": "2018-10-17T09:06:41Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO the useful subset of the overview content (for this document) lives in 4.1 now, and information on each class to the respective section for the class. The reorganization into Selection, Connection, and Message properties makes a lot of the boilerplate in each entry unnecessary. What, in your opinion, is still missing here?\r\n\r\nISTM the next step toward the registry is assigning names-in-code for each of the properties (for which I'll file a separate issue to be done post-BKK); after that's done, summary information for each property should be collected into the IANA Considerations section, with normative references to the subsections within the document for each registry entry (assuming, of course, we come to consensus that a registry is the right way to go).",
          "createdAt": "2018-10-18T08:16:59Z",
          "updatedAt": "2018-10-18T08:16:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MTE0NDM3",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is so hard to follow... and it's probably fine by me anyway. My choice would be to shoot first and ask second.  (land it, then let's read this)",
          "createdAt": "2018-10-16T11:42:07Z",
          "updatedAt": "2018-10-16T11:42:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MjI5ODEy",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for moving this further!\r\nI really like introducing Properties early.\r\nI have two issues and two nits, see below.\r\n\r\nBest,\r\nTheresa",
          "createdAt": "2018-10-16T15:37:42Z",
          "updatedAt": "2018-10-16T15:43:42Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Can this conflict between Protocol and Path Selection really just be removed? We don't distinguish between these anymore in the API, but we added this because of the observation that path and protocol selection may be at odds and this might be a relevant part of the API contract, see #149. \r\nI'd suggest to add this again.",
              "createdAt": "2018-10-16T15:37:43Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            },
            {
              "originalPosition": 156,
              "body": "nit: Redundant \". \"",
              "createdAt": "2018-10-16T15:39:54Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            },
            {
              "originalPosition": 95,
              "body": "Nit: Fix \"configufed\"",
              "createdAt": "2018-10-16T15:40:20Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            },
            {
              "originalPosition": 396,
              "body": "Wait, this got renamed again? \r\nWe changed it because this section also talks about Errors, which are not properties.\r\nMaybe the title isn't ideal, but I suggest we keep the title starting with \"Managing Connections\".",
              "createdAt": "2018-10-16T15:42:14Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYwMTY4",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T20:46:21Z",
          "updatedAt": "2018-10-16T20:46:21Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "```suggestion\r\nProperties are listed in the subsections below. Note that many properties are\r\n```",
              "createdAt": "2018-10-16T20:46:21Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYwNzg3",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T20:47:51Z",
          "updatedAt": "2018-10-16T20:47:52Z",
          "comments": [
            {
              "originalPosition": 396,
              "body": "```suggestion\r\n# Managing Connections {#introspection}\r\n```",
              "createdAt": "2018-10-16T20:47:51Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYwODgx",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T20:48:06Z",
          "updatedAt": "2018-10-16T20:48:06Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "```suggestion\r\ndetermined and configured using these properties. Since there could be paths\r\n```",
              "createdAt": "2018-10-16T20:48:06Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYxNzAz",
          "commit": {
            "abbreviatedOid": "345efc2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T20:50:03Z",
          "updatedAt": "2018-10-16T20:50:04Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Okay, will rephrase to capture the fact that we don't have two kinds of selection properties.",
              "createdAt": "2018-10-16T20:50:04Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYyNjcx",
          "commit": {
            "abbreviatedOid": "f580d47"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T20:52:27Z",
          "updatedAt": "2018-10-16T20:52:28Z",
          "comments": [
            {
              "originalPosition": 396,
              "body": "Properties and errors are discussed in the subheads, so maybe just Managing Connections?",
              "createdAt": "2018-10-16T20:52:27Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MzYyOTE4",
          "commit": {
            "abbreviatedOid": "f580d47"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, with a couple nits",
          "createdAt": "2018-10-16T20:53:04Z",
          "updatedAt": "2018-10-16T20:57:35Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Connections Properties, or Connection Properties?",
              "createdAt": "2018-10-16T20:53:04Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            },
            {
              "originalPosition": 32,
              "body": "Nit: let's be consistent about periods at the end of bullet lists",
              "createdAt": "2018-10-16T20:53:30Z",
              "updatedAt": "2018-10-16T21:07:12Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "31f8b5efcc082bb56d0ad72d2ad92893be4340b9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "property-structure-208-218",
      "headRefOid": "3f127b2cfaa9c9a38242729776e26e68be3aa0fa",
      "mergeCommit": {
        "oid": "0b5fc3a74f7383ac49a30413d680108964c775be"
      }
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzMjA3Njcy",
      "title": "fix #237",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/239",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-16T11:08:34Z",
      "updatedAt": "2018-10-17T14:59:48Z",
      "closedAt": "2018-10-16T13:05:11Z",
      "mergedAt": "2018-10-16T13:05:11Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MTI1MTAx",
          "commit": {
            "abbreviatedOid": "d1046a2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-16T12:13:15Z",
          "updatedAt": "2018-10-16T12:13:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "you copy+pasted a typo  :) the \"s\" in  \"needsto\"",
              "createdAt": "2018-10-16T12:13:15Z",
              "updatedAt": "2018-10-16T12:56:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1MTI1NzU0",
          "commit": {
            "abbreviatedOid": "d1046a2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm with one nit",
          "createdAt": "2018-10-16T12:15:01Z",
          "updatedAt": "2018-10-16T12:15:01Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "31f8b5efcc082bb56d0ad72d2ad92893be4340b9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "archnits-237",
      "headRefOid": "56b2f5626861efc92b6cf688435adb7ae14068b9",
      "mergeCommit": {
        "oid": "9d4b540cb4bcfbd7643f0aeac49f1c851a18febd"
      }
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzMjI0MjQ0",
      "title": "A minset appendix",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/240",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The point of this is to draw a line to minset, to make sure we're not missing something. Names of properties in the current document may be wrong, and I can fix them after the current round of updates by @britram - but this is more about what's missing than what's there.\r\n\r\nI'm happy to report that very, very little is missing!",
      "createdAt": "2018-10-16T12:07:42Z",
      "updatedAt": "2018-10-17T07:00:38Z",
      "closedAt": "2018-10-17T06:56:19Z",
      "mergedAt": "2018-10-17T06:56:19Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "JFYI, updates after your approval were only me playing around with the list format to make it look a little nicer. no content changes.",
          "createdAt": "2018-10-17T06:56:09Z",
          "updatedAt": "2018-10-17T06:56:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1Mzc0NDA5",
          "commit": {
            "abbreviatedOid": "817ebbf"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-10-16T21:24:42Z",
          "updatedAt": "2018-10-16T21:24:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1NDQ0OTk1",
          "commit": {
            "abbreviatedOid": "817ebbf"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-17T03:32:44Z",
          "updatedAt": "2018-10-17T03:32:44Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "31f8b5efcc082bb56d0ad72d2ad92893be4340b9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "michael-minset_appendix",
      "headRefOid": "8ae764f8683d440acab1fd793836ed2f8b842e6b",
      "mergeCommit": {
        "oid": "9c7baef10c3a43b750decd9148459be7f8af68fa"
      }
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNjQyOTc0",
      "title": "add section 4.2, fix #211",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/241",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T15:08:54Z",
      "updatedAt": "2018-10-18T07:48:12Z",
      "closedAt": "2018-10-18T07:48:05Z",
      "mergedAt": "2018-10-18T07:48:05Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1NjkzMDcx",
          "commit": {
            "abbreviatedOid": "443cb8f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! Just one comment in re-reading a section more carefully, not blocking.",
          "createdAt": "2018-10-17T15:25:11Z",
          "updatedAt": "2018-10-17T15:26:23Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Looking at this again, it seems a bit odd that we call out the Receive() event as a \"caveat\". The caveat seems to be that the asynchronous subsystem must follow the specifications for how many times an event can be fired. The fact that Receive() and Send() lead to a single event for each invocation is an example of where to be careful.",
              "createdAt": "2018-10-17T15:25:11Z",
              "updatedAt": "2018-10-17T15:26:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1ODM2NDc2",
          "commit": {
            "abbreviatedOid": "443cb8f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I especially like the \"Scope of the Interface Definition\" text!  Really nice and useful to have IMO",
          "createdAt": "2018-10-17T21:05:35Z",
          "updatedAt": "2018-10-17T21:05:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1OTYyMjY1",
          "commit": {
            "abbreviatedOid": "443cb8f"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-18T07:48:00Z",
          "updatedAt": "2018-10-18T07:48:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yep. I also noticed this but couldn't come up with a better way to frame it. Will try again today if I have time but will land this in the meantime.",
              "createdAt": "2018-10-18T07:48:01Z",
              "updatedAt": "2018-10-18T07:48:01Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9c7baef10c3a43b750decd9148459be7f8af68fa",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "apiscope-211",
      "headRefOid": "443cb8f5ca03e01116e21442c64de659eb12301f",
      "mergeCommit": {
        "oid": "2575d9c7522a788096f3d7e0a14d965c28e574fc"
      }
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNjQ2MzMz",
      "title": "Message Properties terminology cleanup",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/242",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Message Context Parameters/Properties are now Message Properties, and associated terminology cleanup. Addresses part of the resolution to #218.",
      "createdAt": "2018-10-17T15:17:59Z",
      "updatedAt": "2018-10-18T07:48:28Z",
      "closedAt": "2018-10-18T07:36:46Z",
      "mergedAt": "2018-10-18T07:36:46Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1NjkxMTA3",
          "commit": {
            "abbreviatedOid": "f7a2264"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks for the cleanup!",
          "createdAt": "2018-10-17T15:21:31Z",
          "updatedAt": "2018-10-17T15:21:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1ODMzOTMx",
          "commit": {
            "abbreviatedOid": "f7a2264"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-10-17T21:00:01Z",
          "updatedAt": "2018-10-17T21:00:01Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9c7baef10c3a43b750decd9148459be7f8af68fa",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "msgprop-208",
      "headRefOid": "f7a22646c9d77242f993c21562915b9808f6700d",
      "mergeCommit": {
        "oid": "0ef18e1fbdad5b9f336c76677517309c88f62d25"
      }
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzUzNzEy",
      "title": "Add CacheContext to architecture and API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/244",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "Address #45 by adding explicit caching context for defining state sharing boundaries. Doesn't expose knobs for accessing the cached state externally, but we can discuss and add that later if needed.",
      "createdAt": "2018-10-19T17:10:43Z",
      "updatedAt": "2020-09-11T16:31:12Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2575d9c7522a788096f3d7e0a14d965c28e574fc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/cachecontext",
      "headRefOid": "04a8ac2359d4f907b2a091c6e5ffd17c5bfda451",
      "closedAt": "2019-01-15T16:50:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will create new PR",
          "createdAt": "2019-01-15T16:50:02Z",
          "updatedAt": "2019-01-15T16:50:02Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "many thanks, please try again. :)\r\n\r\nPer discussion at the interim meeting, we need to have a slot in the architecture that allows applications control over which connections/preconnections might share cached state, and which connections/preconnections must not share state. \r\n\r\nProposal is for @tfpauly to write a new PR for -arch only, which we'll discuss on the list",
          "createdAt": "2019-01-15T16:51:26Z",
          "updatedAt": "2019-01-15T16:51:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAwNTA5",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-21T20:57:59Z",
          "updatedAt": "2018-10-21T21:05:58Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "s/to influence connection establishment, tuning protocol heuristics, and resuming state/for connection establishment and protocol heuristic tuning.",
              "createdAt": "2018-10-21T20:57:59Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            },
            {
              "originalPosition": 38,
              "body": "Maybe drop a reference to RFC 5077?",
              "createdAt": "2018-10-21T21:00:11Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            },
            {
              "originalPosition": 40,
              "body": "s/to be/to maintain?",
              "createdAt": "2018-10-21T21:00:28Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            },
            {
              "originalPosition": 43,
              "body": "Possibly add here, or in the implementation draft: Moreover, certain cache state may not be appropriate for re-use for all applications. For example, to improve privacy and limit client tracking, TLS 1.3 {{!RFC8446}} connection state should not be re-used absent early data to write, as this introduces an unnecessary tracking vector without saving any round trips. (It may however cost more CPU.)",
              "createdAt": "2018-10-21T21:03:06Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            },
            {
              "originalPosition": 44,
              "body": "I'd piggyback this with a blurb similar to the above, wherein we only want use that shared state if necessary.",
              "createdAt": "2018-10-21T21:03:49Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            },
            {
              "originalPosition": 72,
              "body": "I'm not sure if it's cleaner to give Preconnections a caching context that disables caching, or simply not give them a caching context. ",
              "createdAt": "2018-10-21T21:05:50Z",
              "updatedAt": "2018-10-21T21:05:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODMzMTAy",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I have trouble understanding this. My immediate reaction is: caching can (and should?) be implemented in the transport system, no doubt - but why bother the application with it?\r\n\r\nNow I can understand that there are certain properties of re-use (e.g., a need to use the same level of security again later, or the expected time until a connection to the same peer will be needed again) that an application could offer to the system as a hint - but that seems to me to be a different level than abstraction than what's written here.\r\n\r\nSo to begin with, I'll ask: what's the point of the caching context (as something seen and controlled by the application)? Wh do we need this, what will it be used for?",
          "createdAt": "2018-10-22T06:28:09Z",
          "updatedAt": "2018-10-22T06:28:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODMzMjE0",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I have trouble understanding this. My immediate reaction is: caching can (and should?) be implemented in the transport system, no doubt - but why bother the application with it?\r\n\r\nNow I can understand that there are certain properties of re-use (e.g., a need to use the same level of security again later, or the expected time until a connection to the same peer will be needed again) that an application could offer to the system as a hint - but that seems to me to be a different level than abstraction than what's written here.\r\n\r\nSo to begin with, I'll ask: what's the point of the caching context (as something seen and controlled by the application)? Wh do we need this, what will it be used for?",
          "createdAt": "2018-10-22T06:28:49Z",
          "updatedAt": "2018-10-22T06:28:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODMzNDA1",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I have trouble understanding this. My immediate reaction is: caching can (and should?) be implemented in the transport system, no doubt - but why bother the application with it?\r\n\r\nNow I can understand that there are certain properties of re-use (e.g., a need to use the same level of security again later, or the expected time until a connection to the same peer will be needed again) that an application could offer to the system as a hint - but that seems to me to be a different level than abstraction than what's written here.\r\n\r\nSo to begin with, I'll ask: what's the point of the caching context (as something seen and controlled by the application)? Wh do we need this, what will it be used for?",
          "createdAt": "2018-10-22T06:30:13Z",
          "updatedAt": "2018-10-22T06:30:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODQyMzY3",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for writing this up so we have something concrete to discuss; I tend to agree with @mwelzl here -- it's not clear that the CacheContext is something that needs to be exposed up to the application at this granularity. Specifically, why isn't this all just \"application context object\" level stuff?\r\n\r\nWe do need to say something in the architecture about this, we probably need to have a split of per-Remote and per-\"application context\" caches. As for application control, there definitely needs to be a way to dimension and purge the cache, and maybe (maybe?) a way to query it.\r\n\r\nMetacomment: I'd take this discussion back to #45, and stick it on the Bangkok agenda.",
          "createdAt": "2018-10-22T07:23:08Z",
          "updatedAt": "2018-10-22T08:03:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "+1, could quibble about the exact wording.\r\n\r\nI think there are two separate entities here that we need to deal with at the architectural level:\r\n\r\n- a \"cached remote view\" (I hate this term, but something that means the same thing), which is everything that an endpoint can remember about a remote endpoint it has associated with in the past. (This is largely equivalent to Post Sockets' Association, though there is a discussion to have about the extent to which Paths are bound to a cached remote view as opposed to the caching context as a whole.\r\n\r\n- a \"caching context\" as we have here, though there is a missing argument about why the caching context is not simply 1:1 contained within a transport services application context. (Indeed, I can't think of a good reason why it shouldn't be -- if the system can make inferences about paths from what it knows, why give the application special control over when it shouldn't)",
              "createdAt": "2018-10-22T07:23:10Z",
              "updatedAt": "2018-10-22T08:03:21Z"
            },
            {
              "originalPosition": 7,
              "body": "+1, could quibble about the exact wording.\r\n\r\nI think there are two separate entities here that we need to deal with at the architectural level:\r\n\r\n- a \"cached remote view\" (I hate this term, but something that means the same thing), which is everything that an endpoint can remember about a remote endpoint it has associated with in the past. (This is largely equivalent to Post Sockets' Association, though there is a discussion to have about the extent to which Paths are bound to a cached remote view as opposed to the caching context as a whole.\r\n\r\n- a \"caching context\" as we have here, though there is a missing argument about why the caching context is not simply 1:1 contained within a transport services application context. (Indeed, I can't think of a good reason why it shouldn't be -- if the system can make inferences about paths from what it knows, why give the application special control over when it shouldn't)",
              "createdAt": "2018-10-22T07:23:58Z",
              "updatedAt": "2018-10-22T08:03:21Z"
            },
            {
              "originalPosition": 7,
              "body": "+1, could quibble about the exact wording.\r\n\r\nI think there are two separate entities here that we need to deal with at the architectural level:\r\n\r\n- a \"cached remote view\" (I hate this term, but something that means the same thing), which is everything that an endpoint can remember about a remote endpoint it has associated with in the past. (This is largely equivalent to Post Sockets' Association, though there is a discussion to have about the extent to which Paths are bound to a cached remote view as opposed to the caching context as a whole.\r\n\r\n- a \"caching context\" as we have here, though there is a missing argument about why the caching context is not simply 1:1 contained within a transport services application context. (Indeed, I can't think of a good reason why it shouldn't be -- if the system can make inferences about paths from what it knows, why give the application special control over when it shouldn't)",
              "createdAt": "2018-10-22T07:25:08Z",
              "updatedAt": "2018-10-22T08:03:22Z"
            },
            {
              "originalPosition": 15,
              "body": "See above -- not clear why we need to expose this up as something special beyond a feature of the transport services application context (does this have a name in this doc?)",
              "createdAt": "2018-10-22T07:52:59Z",
              "updatedAt": "2018-10-22T08:03:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyODk4NjQy",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-08T10:48:01Z",
          "updatedAt": "2018-11-08T10:48:01Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "After discussion with Tommy in Bangkok: CacheContext should be an optional parameter.",
              "createdAt": "2018-11-08T10:48:01Z",
              "updatedAt": "2018-11-08T10:48:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTczOTAwMTc1",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-12T13:33:55Z",
          "updatedAt": "2018-11-12T13:33:55Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "In Bangkok we said that the default is that all sharing is allowed: \r\nIf the application does not provide any explicit caching context, all Connections are associated with the same implicit caching context, so they can share state.\r\n\r\nIf we do it like this, let's make it very explicit in the text:\r\nI suggest to move the sentence \"By default, a Preconnection is associated with an implicit CacheContext.\" up here, clarify that it's always the same implicit CacheContext, and say that this means that by default, all Connections within the same application context are allowed to share state. \r\nAfter this, the warning about sharing TLS 1.3 connection state fits quite nicely imo.\r\n\r\nAlternatively, we could set the default that all state can be shared _except_ TLS 1.3 connection state ...?",
              "createdAt": "2018-11-12T13:33:55Z",
              "updatedAt": "2018-11-12T13:33:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMTcyMzM2",
          "commit": {
            "abbreviatedOid": "04a8ac2"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-06T10:30:07Z",
          "updatedAt": "2018-12-06T10:30:08Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I tend to have a global, singleton ``DoNotCacheContext`` as a shortcut for that.",
              "createdAt": "2018-12-06T10:30:07Z",
              "updatedAt": "2018-12-06T10:30:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMwOTc3MTM3",
      "title": "Add 2119 language",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/250",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "This PR contains the architecture revisions Gorry and I went through at IETF 103. The main change is adding official 2119 language and cleaning up all other uses of should/may/must.\r\n\r\nThis does *not* contain the necessary rework of the framing section, which will come in a future PR.",
      "createdAt": "2018-11-14T20:50:59Z",
      "updatedAt": "2019-11-20T06:26:03Z",
      "closedAt": "2018-11-30T20:32:01Z",
      "mergedAt": "2018-11-30T20:32:01Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NDY4MzAw",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2018-11-15T17:26:56Z",
          "updatedAt": "2018-11-15T17:26:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NjkyNDM1",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T08:12:24Z",
          "updatedAt": "2018-11-16T08:12:24Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "\"if there are equivalent options\" sounds a bit more limiting / stricter than I think it should. Just as a suggestion, why not say it like this: \"... that only that protocol could be used. For example, allowing an application to specify constrained checksum usage will not make communication fail when using a protocol such as TCP, which always uses a checksum covering the entire payload.\"",
              "createdAt": "2018-11-16T08:12:24Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1Njk1MzI3",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T08:23:15Z",
          "updatedAt": "2018-11-16T08:23:15Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "Please apply a low \"ignore this\" bar, as I'm not a native speaker... but: isn't it a bit awkward not to have a \"the\" in front of \"Maximum Transmission Unit\" and \"Path MTU\" ?",
              "createdAt": "2018-11-16T08:23:15Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1Njk4NDI0",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T08:33:27Z",
          "updatedAt": "2018-11-16T08:33:28Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Why an \"error\"? If it can also be due to a graceful shutdown, then \"notification\" may be a better word.",
              "createdAt": "2018-11-16T08:33:28Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1Njk5Mjkz",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T08:36:28Z",
          "updatedAt": "2018-11-16T08:36:28Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "double \"provide\" here... maybe replace the second with \"implement\" ?",
              "createdAt": "2018-11-16T08:36:28Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1Njk5NjY3",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T08:37:39Z",
          "updatedAt": "2018-11-16T08:37:39Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "I find \"send or receive .... with\" a weird communication. Maybe replace with \"to / from\" ?",
              "createdAt": "2018-11-16T08:37:39Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NzAyNzcy",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. I added a few non-blocking comments.",
          "createdAt": "2018-11-16T08:46:36Z",
          "updatedAt": "2018-11-16T08:46:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NzMxMjM5",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T10:03:26Z",
          "updatedAt": "2018-11-16T10:03:26Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "... adding /the/ sounds fine to me.\r\n\r\n",
              "createdAt": "2018-11-16T10:03:26Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NzMzMjI0",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T10:08:47Z",
          "updatedAt": "2018-11-16T10:08:47Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The approach is OK, is this better:\r\n\"For example, if an application were to specify constrained checksum usage, communication would not fail when a protocol such as TCP is selected, which always uses a checksum covering the entire payload.\"\"",
              "createdAt": "2018-11-16T10:08:47Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NzMzOTgy",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T10:10:43Z",
          "updatedAt": "2018-11-16T10:10:43Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Do you mean \"send packets to or receive packets from\"?",
              "createdAt": "2018-11-16T10:10:43Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1NzY2MDM3",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T11:43:14Z",
          "updatedAt": "2018-11-16T11:43:15Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "I meant to replace it with the term \"to / from\", but I can see that this doesn't read well. I suggest: \"... to send packets to a Remote Endpoint or receive packets from it.\" in the first case (s/Remote Endpoint/remote system in the latter).",
              "createdAt": "2018-11-16T11:43:14Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1Nzk0OTE2",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T13:15:12Z",
          "updatedAt": "2018-11-16T13:15:12Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Woks for me:-)",
              "createdAt": "2018-11-16T13:15:12Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDE5ODMw",
          "commit": {
            "abbreviatedOid": "de18865"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T19:41:37Z",
          "updatedAt": "2018-11-30T19:41:37Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Swapping the first \"provide\" for \"implement\", actually.",
              "createdAt": "2018-11-30T19:41:37Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDIxNDM1",
          "commit": {
            "abbreviatedOid": "d8aa477"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T19:45:57Z",
          "updatedAt": "2018-11-30T19:45:57Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Great, fixed!",
              "createdAt": "2018-11-30T19:45:57Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDIxNDgx",
          "commit": {
            "abbreviatedOid": "d8aa477"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T19:46:04Z",
          "updatedAt": "2018-11-30T19:46:04Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "Added `the`",
              "createdAt": "2018-11-30T19:46:04Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDIxNTY1",
          "commit": {
            "abbreviatedOid": "d8aa477"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T19:46:15Z",
          "updatedAt": "2018-11-30T19:46:15Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Made this \"reason or error\"",
              "createdAt": "2018-11-30T19:46:15Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDIxNzg2",
          "commit": {
            "abbreviatedOid": "d8aa477"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T19:46:45Z",
          "updatedAt": "2018-11-30T19:46:46Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Changed to \"communicate with\"",
              "createdAt": "2018-11-30T19:46:45Z",
              "updatedAt": "2018-11-30T20:25:28Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6b0ba3a838e92e5379f5d4b054a054e8749dba95",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-2119",
      "headRefOid": "8ef58a59db13fee9b5802fa6c5a83d72aac7e8ba",
      "mergeCommit": {
        "oid": "b166683eccaef8a6ee8e56fdd63561dd8d94823a"
      }
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM0OTQ2ODY3",
      "title": "Additions to the abstract and intro text",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/252",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-30T10:50:57Z",
      "updatedAt": "2019-11-20T06:26:02Z",
      "closedAt": "2018-11-30T21:09:17Z",
      "mergedAt": "2018-11-30T21:09:17Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for these fixes! I did a bit of reworking of the abstract, but it keeps the main part of the changes you made.",
          "createdAt": "2018-11-30T21:08:12Z",
          "updatedAt": "2018-11-30T21:08:12Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the sentence you removed, that was an adaption of an existing sentence, which I believe aimed to mention the words implementation and API to implicitly refere to the other docs (which was probably too subtle for anybody to notice anyway). However, the other change I made to that sentence was to mention one of the benefits / deployment incentives for taps (dynamic protocol and path selection). I wasn't sure about the wording here, but I think it would be good to (re-)add a sentence to the abstract saying why taps is so great and that everybody should deploy it.",
          "createdAt": "2018-12-01T08:10:40Z",
          "updatedAt": "2018-12-01T08:10:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the original second sentence was aimed at mentioning that there were two other documents, API and Implementation, that would be based on this one.\r\n\r\nI liked how in your revision, it did try to make things clearer than just saying \"flexible transport networking services\", but I felt that the specific example of dynamic path and protocol selection was a bit too specific for that one line. (I was chatting with @chris-wood about this as I was editing, btw). My thought was that the list of features that you added in right after that, which go through the top-level bullet points of the advantages, do a more comprehensive job of summarizing the benefit.",
          "createdAt": "2018-12-01T22:26:07Z",
          "updatedAt": "2018-12-01T22:26:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDQ5Nzcz",
          "commit": {
            "abbreviatedOid": "2567d83"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-30T21:08:26Z",
          "updatedAt": "2018-11-30T21:08:26Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "34fc410d7f3b3dcbacd93ddbf1327378169b7eb7",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-intro",
      "headRefOid": "2567d8369a1e5815a681521713e3e57cfd4fcdcb",
      "mergeCommit": {
        "oid": "7dc5dcc131766eec044257ee3c251dc9c8b914fe"
      }
    },
    {
      "number": 253,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM0OTQ4OTMz",
      "title": "small wording edit on event driven API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/253",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I guess here is not nessecarily a notification required in sychronuous communication",
      "createdAt": "2018-11-30T10:57:59Z",
      "updatedAt": "2019-11-20T06:25:59Z",
      "closedAt": "2018-12-01T22:30:53Z",
      "mergedAt": "2018-12-01T22:30:53Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged in master to avoid conflict, and tweaked working to remove \"some times\", which felt a bit too colloquial in tone.",
          "createdAt": "2018-12-01T22:30:47Z",
          "updatedAt": "2018-12-01T22:30:47Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "35aa335c857a63e59a855288b20f8e96003d3d66",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-no-notification",
      "headRefOid": "8931dad52c4ec5856478699e81da6bb3e5677527",
      "mergeCommit": {
        "oid": "faeb54b4f9c37d19e5dde7caabb0fd251661c854"
      }
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM0OTY3MTk2",
      "title": "Change \"Basic Objects\" to \"Connection(s)\" in diagram",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/259",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After reading the whole doc, this seems more logical for me.",
      "createdAt": "2018-11-30T12:08:52Z",
      "updatedAt": "2019-11-20T06:26:08Z",
      "closedAt": "2018-12-01T22:22:10Z",
      "mergedAt": "2018-12-01T22:22:10Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason this had been marked as \"Basic Objects\" is to match with the section below on Basic Objects, which includes Preconnection, Connection, and Listener: https://taps-api.github.io/drafts/draft-ietf-taps-arch.html#rfc.section.4.1.1\r\n\r\nHowever, the arrows into the diagram don't quite line up\u2014you're right that these arrows describe the connection parts, and that pre-establishment would be going into Preconnection...",
          "createdAt": "2018-11-30T19:34:37Z",
          "updatedAt": "2018-11-30T19:34:37Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understood where \"Basic Objects\" came from, but a) as you said that's not what's shown the diagram, and b) I find it strange to have this abstract term in the diagram. I think it'd be okay to only show connection though because it's a central concept, or alternatively you can add another box for pre-connection. ",
          "createdAt": "2018-12-01T08:01:05Z",
          "updatedAt": "2018-12-01T08:01:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine changing this to Connection(s) for now; we can always edit later",
          "createdAt": "2018-12-01T22:22:06Z",
          "updatedAt": "2018-12-01T22:22:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6b0ba3a838e92e5379f5d4b054a054e8749dba95",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-conn-diagram",
      "headRefOid": "b416eb039a9c9682271d2022b974422ef5ab42ff",
      "mergeCommit": {
        "oid": "35aa335c857a63e59a855288b20f8e96003d3d66"
      }
    },
    {
      "number": 264,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1MTA0MzE4",
      "title": "Re-base 2119 language diff",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/264",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Re-based #250 to avoid build issue/conflict",
      "createdAt": "2018-11-30T20:18:58Z",
      "updatedAt": "2020-09-11T16:31:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6b0ba3a838e92e5379f5d4b054a054e8749dba95",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-2119-2",
      "headRefOid": "9af47045dc2cef9ac7d386ea476cc9a0b4bf7d84",
      "closedAt": "2018-11-30T20:32:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Didn't actually need this",
          "createdAt": "2018-11-30T20:32:20Z",
          "updatedAt": "2018-11-30T20:32:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1Mzk2Mjg5",
      "title": "IETF 103 discussion results. Closes #37",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/265",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This does the following things with the properties from the appendix, based on https://datatracker.ietf.org/meeting/103/materials/minutes-103-taps-00.html\r\n\r\n- direction of communication: moved to the main text\r\n- \"Suggest a timeout to the Remote Endpoint\": moved to the main text but explicitly described as a TCP-specific property; also changed it to contain all the parameters that UTO really has\r\n- traffic category: removed. Mirja said \"Let's see if there's anything in the implementation document that actually needs this information\" but I figured that chances are low, and if this really happens we can still re-introduce this later.\r\n- size to be sent or received: removed\r\n- duration: removed\r\n- send or receive bit-rate: changed this to specify an upper and/or lower bound\r\n- cost preferences: kept in the appendix, but inserted mirja's comment \"Not convinced cost preferences are on the right level.\"  (@mirjak: what did you mean with \"on the right level\"?)",
      "createdAt": "2018-12-03T10:31:02Z",
      "updatedAt": "2018-12-04T12:23:26Z",
      "closedAt": "2018-12-04T12:22:09Z",
      "mergedAt": "2018-12-04T12:22:09Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cost doesn't seem to mean too much for the transport layer. I guess it could e.g. make more sense to specified which link technology you prefer (e.g. wifi over cellular) (which would be on a less abstract level). However, still not sure what the right level is...",
          "createdAt": "2018-12-03T11:20:40Z",
          "updatedAt": "2018-12-03T11:20:40Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I'm not so keen on specifying link technology - a transport only knows the local link - and that can be very different to the technology of the path bottleneck.\r\n\r\nMaybe cost isn't that bad - sometimes the presence of cost *IS* known, or at least a decision could try to be made to minimise cost. It's hard to do more than hint at this.",
          "createdAt": "2018-12-03T11:29:20Z",
          "updatedAt": "2018-12-03T11:29:20Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about cost prefernce a bit further and with respect to @theri's comment that this could part of an layer on top of taps, I would prefer to not include it expect we have some concrete implementation example guidance in the implementation draft.",
          "createdAt": "2018-12-03T12:19:33Z",
          "updatedAt": "2018-12-03T12:19:33Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak that all sounds very reasonable to me, thanks for clarifying!  So it seems fit where the cost preferences are now in this PR - I left them in the appendix for now, with a mark saying that we'll see if there will suitable text in the implementation draft.",
          "createdAt": "2018-12-03T13:12:01Z",
          "updatedAt": "2018-12-03T13:12:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzI4MjI2",
          "commit": {
            "abbreviatedOid": "729f88c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm!",
          "createdAt": "2018-12-03T11:50:12Z",
          "updatedAt": "2018-12-03T11:50:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzMxMTAy",
          "commit": {
            "abbreviatedOid": "729f88c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for doing this!\r\n\r\nI have just two suggestions about what section to place the properties in.\r\n\r\nAbout the Cost Preferences discussion, I think having both this and the less abstract interface preference in there makes sense, and then the implementation can map those properties to each other.\r\nThe alternative would be to make this part of the \"layer on top of the TAPS API\", which some of the other Intents would end up on as well.\r\nIf we do this, I think it might make sense to keep the other Intents in the appendix for now (instead of deleting them like this PR does).",
          "createdAt": "2018-12-03T11:58:48Z",
          "updatedAt": "2018-12-03T12:17:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Implementing this property is also optional, right?\r\n\r\nAlso, I'm not sure this is in the right section here with the Selection properties... unless we plan to do path or protocol selection based on it...?\r\nI think it might be more of a (Generic) Connection Property, so it should be in Section 9.1.",
              "createdAt": "2018-12-03T11:58:49Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            },
            {
              "originalPosition": 49,
              "body": "Same question as above: Should this be in Section 9.1? That's where we have all the other timeouts etc.",
              "createdAt": "2018-12-03T12:08:22Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzU2NjU2",
          "commit": {
            "abbreviatedOid": "729f88c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-03T13:10:30Z",
          "updatedAt": "2018-12-03T13:10:30Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I agree! will do",
              "createdAt": "2018-12-03T13:10:30Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzU2Njky",
          "commit": {
            "abbreviatedOid": "729f88c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-03T13:10:34Z",
          "updatedAt": "2018-12-03T13:10:34Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I agree! will do",
              "createdAt": "2018-12-03T13:10:34Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzYwMzg2",
          "commit": {
            "abbreviatedOid": "729f88c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-03T13:20:30Z",
          "updatedAt": "2018-12-03T13:20:30Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Regarding optional implementation, I think everything in the API draft is mandatory to offer. What's optional is to do something useful with the information, and it's also optional for the application to use it. But I think all APIs should offer all the primitives - e.g. to make applications more portable or be able to retro-fit functionality below them.",
              "createdAt": "2018-12-03T13:20:30Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwODkyMzQ4",
          "commit": {
            "abbreviatedOid": "bc7308f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-03T17:40:52Z",
          "updatedAt": "2018-12-03T17:42:05Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Having `flow-` and `congestion control` seems unbalanced. Either:\r\n- `flow- and congestion-control`\r\n- `flow control and congestion control`",
              "createdAt": "2018-12-03T17:40:53Z",
              "updatedAt": "2018-12-04T09:01:19Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "523e9d250aaf8b198e19ba1b6509c7a300fda2b9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "ietf-103-updates-+-missing-minset-bits",
      "headRefOid": "15d5792f4fa78fdf8708e833312b041f3af3fa4f",
      "mergeCommit": {
        "oid": "c748fa6297e269955df2733177c78ef7d8f69a68"
      }
    },
    {
      "number": 267,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM2NDc5ODI2",
      "title": "Last missing bits from minset. Closes #109. Closes #246.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/267",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Notable changes:\r\n- added control over using multipath (which was a late addition to minset)\r\n- added a timeout for conn. establishment, separate from the other conn. abort timeout (see #109)\r\n- renamed InitiateWithIdempotentSend into InitiateWithSend, and adjusted the text to recommend declaring idempotence. This addresses the minset function that goes back to TCP's send-with-SYN.",
      "createdAt": "2018-12-06T10:32:17Z",
      "updatedAt": "2018-12-12T10:40:32Z",
      "closedAt": "2018-12-12T10:40:31Z",
      "mergedAt": "2018-12-12T10:40:31Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Status:\r\n- @britram said \"LGTM modulo tiny nits\" and I think these nits are now addressed.\r\n- @tfpauly requests something more than just a boolean to enable/disable usage of multiple paths. It seems to me that this needs more discussion, but it also doesn't seem like a show-stopper for the boolean to begin with; I think we can discuss this more after landing this PR.\r\n- @theri hasn't reacted (or am I missing this), but this has an ok from @philsbln and @csperkins \r\n\r\nIn conclusion: I think this is good to go. I'll wait until tomorrow; unless someone speaks up by then, I'll merge this PR.",
          "createdAt": "2018-12-11T10:27:01Z",
          "updatedAt": "2018-12-11T10:27:01Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you make it a boolean it cannot be used as a selection property, so I do not think that is a good choice. Or how should it be interpreted for the selection? ",
          "createdAt": "2018-12-11T10:45:09Z",
          "updatedAt": "2018-12-11T10:45:09Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you make it a boolean it cannot be used as a selection property, so I do not think that is a good choice. Or how should it be interpreted for the selection?\r\n\r\n@abrunstrom what do you mean, that it should be a (binary - yes/no) Preference instead?  I thought this would be more limiting but I'm fine with this as well.",
          "createdAt": "2018-12-11T10:58:47Z",
          "updatedAt": "2018-12-11T10:58:47Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I meant that it should be a Preference as pointed out in the original comment by @philsbln. I do not understand what a boolean means during selection (is it a requirement or a preference?) I also do not understand what it means in the middle of a connection. You mean you should try and use a single or several subflows for scheduling data, assuming you already have a multipath connection? I guess this is possible, but then the description needs to be more clear that this is what it means.\r\nIn the appendix about minset your have \"Disable MPTCP: \"Parallel Use of Multiple Paths\" Property.\" I assume this refers to the Protocol Selection phase? It does not make sense to disable or enable MPTCP in the middle of a connection I think.\r\n \r\nI guess part of how to specify the property depends on how to interpret this part from the intro to the Managing Connections section:\r\n\"The application can set and query Connection Properties on a per-Connection basis. Connection Properties that are not read-only can be set during pre-establishment (see {{selection-props}}), as well as on connections directly using the SetProperty action\"\r\nI interpreted this as properties set during pre-establishment are selection properties, but maybe this is not the intention as they may need to be expressed differently? If they are not intended as selection properties, we are missing a selection property for multipath I guess.",
          "createdAt": "2018-12-11T13:05:53Z",
          "updatedAt": "2018-12-11T13:05:53Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom \r\n\r\n> @mwelzl I meant that it should be a Preference as pointed out in the original comment by @philsbln. \r\n\r\nOk.\r\n\r\n\r\n> I do not understand what a boolean means during selection (is it a requirement or a preference?) I also do not understand what it means in the middle of a connection. You mean you should try and use a single or several subflows for scheduling data, assuming you already have a multipath connection? I guess this is possible, but then the description needs to be more clear that this is what it means.\r\n\r\nThat's what I meant, yes - but I agree that's not covered by the description, it really is a selection preference only as it's written now.\r\n\r\n\r\n> In the appendix about minset your have \"Disable MPTCP: \"Parallel Use of Multiple Paths\" Property.\" I assume this refers to the Protocol Selection phase? It does not make sense to disable or enable MPTCP in the middle of a connection I think.\r\n\r\nOK  (though you CAN do it with the \"real\" API, by closing subflows, but this goes beyond the spec'd protocol, and I'm also not sure it's a good idea, especially when limited to only enabling / disabling it altogether).\r\n\r\n\r\n> I guess part of how to specify the property depends on how to interpret this part from the intro to the Managing Connections section:\r\n> \"The application can set and query Connection Properties on a per-Connection basis. Connection Properties that are not read-only can be set during pre-establishment (see {{selection-props}}), as well as on connections directly using the SetProperty action\"\r\n> I interpreted this as properties set during pre-establishment are selection properties, but maybe this is not the intention as they may need to be expressed differently? If they are not intended as selection properties, we are missing a selection property for multipath I guess.\r\n\r\nI would have understood this as in your first interpretation: \"properties set during pre-establishment are selection properties\".",
          "createdAt": "2018-12-11T13:17:09Z",
          "updatedAt": "2018-12-11T13:17:09Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl \r\n> OK (though you CAN do it with the \"real\" API, by closing subflows, but this goes beyond the spec'd protocol, and I'm also not sure it's a good idea, especially when limited to only enabling / disabling it altogether).\r\n\r\nClosing a subflow is not the same as disabling MPTCP to me. You will still be using MPTCP, only with a single subflow. And you can certainly not open a subflow unless MPTCP is already enabled.\r\n\r\nBut seems we now have a common understanding.",
          "createdAt": "2018-12-11T13:23:35Z",
          "updatedAt": "2018-12-11T13:23:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom ack, we've converged. I just pushed a commit that turns the \"Parallel Use of Multiple Paths\" property into a Selection property.",
          "createdAt": "2018-12-11T13:28:57Z",
          "updatedAt": "2018-12-11T13:28:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMTg2MDkx",
          "commit": {
            "abbreviatedOid": "18a4be5"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the small cleanups and simplifications. Timeout is also fine with me.\r\nI only have two knits annotated",
          "createdAt": "2018-12-06T11:04:57Z",
          "updatedAt": "2018-12-06T11:09:06Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Why Boolean? This is a selection property and should be a Preference as most others",
              "createdAt": "2018-12-06T11:04:57Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            },
            {
              "originalPosition": 10,
              "body": "Really seconds here? I can imagine time-critical applications that want to use timeouts on the range of 200-500ms",
              "createdAt": "2018-12-06T11:07:03Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMTkzNTI2",
          "commit": {
            "abbreviatedOid": "18a4be5"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM modulo tiny nits",
          "createdAt": "2018-12-06T11:25:49Z",
          "updatedAt": "2018-12-06T11:28:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This actually makes me wonder whether \"Integer\" is the right type, since it requires us to make statements about timing resolution that might not be properly abstract.",
              "createdAt": "2018-12-06T11:25:49Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            },
            {
              "originalPosition": 20,
              "body": "yay! this is way less clunky.",
              "createdAt": "2018-12-06T11:26:23Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            },
            {
              "originalPosition": 82,
              "body": "+1",
              "createdAt": "2018-12-06T11:26:45Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nA ConnectionError informs the application that data to could not be delivered after a timeout, \r\n```",
              "createdAt": "2018-12-06T11:27:48Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMjIwNzI1",
          "commit": {
            "abbreviatedOid": "18a4be5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-06T12:44:58Z",
          "updatedAt": "2018-12-06T12:44:59Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Good one!  We specify it in seconds, yet don't allow floats  :-D    For now, I'll just remove the statement about seconds and the Integer type here, and from \"Timeout for aborting Connection\", which has the same mistake.",
              "createdAt": "2018-12-06T12:44:58Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMjI0MjQ5",
          "commit": {
            "abbreviatedOid": "9f8e71d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-06T12:54:54Z",
          "updatedAt": "2018-12-06T12:54:54Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Why limit this to a selection property? FWIW, an application could turn this on or off later. Not in minset, but in the real MPTCP API:  https://datatracker.ietf.org/meeting/96/materials/slides-96-mptcp-4",
              "createdAt": "2018-12-06T12:54:54Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyMzg5MjI3",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-06T18:44:31Z",
          "updatedAt": "2018-12-06T18:44:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyNDg0NTA1",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-06T22:45:38Z",
          "updatedAt": "2018-12-06T22:45:39Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "There can be different levels of \"aggressiveness\" in using multiple paths; anything actually using MPTCP or QUIC (migration or multipath) will likely need more than just a bool to set this meaningfully.",
              "createdAt": "2018-12-06T22:45:39Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyNDkwMTUz",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-06T23:04:24Z",
          "updatedAt": "2018-12-06T23:04:24Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "TL;DR: can't we just keep the boolean for now, to have minset addressed, and discuss the rest later?  Because that may not be an easy one.\r\n\r\nThe longer version:\r\nOhhhhh.... I feel like I opened a gate that I shouldn't have opened, by pointing at the beyond-the-standards API slides. I mean, the thing that I'm guessing you have in mind (duplicating data across multiple paths to minimize latency vs. not doing that) really needs full control of subflows, which this API offers, but the (proposed) standard doesn't. Hence, we ended up with only the \"disable\" boolean in RFC 8303, and then minset - the absolute minimum that an application really needs, I guess.\r\n\r\nAs a way to keep the API simple, rather than adding more \"aggression levels\" or something like that, wouldn't it be better to let the application be in control, by using multiple TAPS connections as these subflows? We could maybe let it express a wish to couple the congestion control of connections if possible (because I'm guessing that, for the data duplication use case, that's the only thing that MPTCP buys you here? And... is that even a win?).",
              "createdAt": "2018-12-06T23:04:24Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyNjUzNjkx",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-07T11:29:34Z",
          "updatedAt": "2018-12-07T11:29:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyNjgxMjg5",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-07T12:58:31Z",
          "updatedAt": "2018-12-07T12:58:32Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "@tfpauly I tend to rather have a \"Do I want Multipath\" preference in the first place (like the one @mwelzl proposed) and have the distribution strategy/aggressiveness either controlled by an additional enum or by an Intents layer on top",
              "createdAt": "2018-12-07T12:58:31Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNjMzOTkz",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Sorry, missed this until just now.\r\nLooks fine with me, I just have a small question and my 2 cents to the multipath discussion (which we can have at a later point).",
          "createdAt": "2018-12-11T11:43:31Z",
          "updatedAt": "2018-12-11T11:46:56Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Perhaps just a question to understand this:\r\nWhat if the InitiateWithSend() message is not marked as idempotent, but the protocol stack supports 0-RTT?\r\nIn this case, no 0-RTT happens, right?",
              "createdAt": "2018-12-11T11:43:31Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            },
            {
              "originalPosition": 82,
              "body": "FWIW I agree that there should be different levels, like \"no multipath\", \"only as backup path\", and \"balance load\" or something. But I'm fine with keeping this a Boolean to start with and discuss later.",
              "createdAt": "2018-12-11T11:45:59Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNjQxNTQz",
          "commit": {
            "abbreviatedOid": "874c491"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-11T12:04:06Z",
          "updatedAt": "2018-12-11T12:04:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Exactly",
              "createdAt": "2018-12-11T12:04:06Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNjY0NDkw",
          "commit": {
            "abbreviatedOid": "18a4be5"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-11T13:05:11Z",
          "updatedAt": "2018-12-11T13:05:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "@theri really boolean (as in the original version) or preference (which would match the other selection properties)?",
              "createdAt": "2018-12-11T13:05:11Z",
              "updatedAt": "2018-12-11T13:22:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNzg5MTE0",
          "commit": {
            "abbreviatedOid": "71b0593"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-11T16:55:05Z",
          "updatedAt": "2018-12-11T16:55:05Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c748fa6297e269955df2733177c78ef7d8f69a68",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "addressing-minset-stuff",
      "headRefOid": "71b0593f6030f1963627064494322755da28fcb9",
      "mergeCommit": {
        "oid": "f5e980aca020510c1d47f3c9feb397782c5d0c68"
      }
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMTI5Mjk4",
      "title": "Re-align Properties in Architecture - closes Issue #256",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/272",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- fixes Properties Terminology and aligns them to the API \r\n- adds Properties as \"Basic Object\"\r\n- updates Figure 2",
      "createdAt": "2018-12-20T10:57:08Z",
      "updatedAt": "2019-05-17T08:12:11Z",
      "closedAt": "2019-01-10T09:38:58Z",
      "mergedAt": "2019-01-10T09:38:58Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram's comments should be addressed now.\r\n\r\nThanks for the reviews ",
          "createdAt": "2019-01-08T14:23:50Z",
          "updatedAt": "2019-01-08T14:23:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MDI1Njk3",
          "commit": {
            "abbreviatedOid": "8712b02"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks basically good, thanks for doing this. A few nitpicky questions in the review to consider.",
          "createdAt": "2018-12-20T14:41:43Z",
          "updatedAt": "2018-12-20T14:45:27Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "does this render correctly as a sublist when compiled to txt/html?",
              "createdAt": "2018-12-20T14:41:44Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            },
            {
              "originalPosition": 36,
              "body": "why are Message Properties bound to Preconnections? The availability of some Message Properties may depend on Selection Properties, and one can set default Message Properties, but this rendering makes it look like setting defualt Message Properties on a Preconnection is non-optional...",
              "createdAt": "2018-12-20T14:44:16Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            },
            {
              "originalPosition": 54,
              "body": "I'm (still) not really convinced of the value of a terminological container for all properties -- does this grouping exist because there really is something useful to be said about all properties together, or as an artifact of how we edited the API doc?",
              "createdAt": "2018-12-20T14:44:54Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3Mjg5MzAw",
          "commit": {
            "abbreviatedOid": "8712b02"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for doing this - and thanks @britram for the close look you're taking",
          "createdAt": "2018-12-21T07:01:35Z",
          "updatedAt": "2018-12-21T07:01:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3NDUxOTAw",
          "commit": {
            "abbreviatedOid": "8712b02"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T16:13:26Z",
          "updatedAt": "2018-12-21T16:13:26Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "At the moment, it is just a wall of text \u2013 but if turned into a sublist, it renders fine. Will update it to become a sublist for the sake of readability.",
              "createdAt": "2018-12-21T16:13:26Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3NDUzMTI2",
          "commit": {
            "abbreviatedOid": "8712b02"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T16:16:39Z",
          "updatedAt": "2018-12-21T16:16:39Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "We do not distinguish between optional and mandatory in the drawing at all, e.g., we have listen and imitate paths in there.\r\n\r\nThe only problem I see is that we might have to clarify in API that \"default message properties specified on a pre-connection that do not apply do not cause errors \u2013 if you need the property, set the corresponding selection property to require \"",
              "createdAt": "2018-12-21T16:16:39Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3NDU2Nzgw",
          "commit": {
            "abbreviatedOid": "8712b02"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T16:26:23Z",
          "updatedAt": "2018-12-21T16:26:23Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I definitely see a value: The whole property discussion showed us that any partition will have some exception or corner cases, e.g., the capacity profile, which now is a connection property, is a useful input to the selection. Having them unter one umbrella make these thins less strange. In addition, they all should share one namespace in the registry. This is necessary as the \"use as default\" requires no name clashes. \r\n\r\nAfter having said this, the reason why they appear here is not any of the above, but that they the concept would come out of the blue otherwise and that I found no better place to put this necessary text. I am fine with moving it if someone has a better idea.",
              "createdAt": "2018-12-21T16:26:23Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NzM3NTYw",
          "commit": {
            "abbreviatedOid": "b709e09"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T09:50:36Z",
          "updatedAt": "2019-01-07T09:50:37Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "ok, will drop this objection.",
              "createdAt": "2019-01-07T09:50:36Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NzM3ODIw",
          "commit": {
            "abbreviatedOid": "b709e09"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T09:51:22Z",
          "updatedAt": "2019-01-07T09:51:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "+1, it makes sense to note this at the level of the archietcture; can you add this sentence when doing the sublist change above, then I'll merge...",
              "createdAt": "2019-01-07T09:51:22Z",
              "updatedAt": "2019-01-08T14:21:05Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f5e980aca020510c1d47f3c9feb397782c5d0c68",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "phils-propertiesarch",
      "headRefOid": "1cf1dc9642b1cd3d2e63898f98e49c10063b217a",
      "mergeCommit": {
        "oid": "5b173e2e31708a3183430c43576051b1202264e1"
      }
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMjkyMzQ0",
      "title": "Updating implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/274",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Several small updates, mostly to clean things up a bit, and align property names and such.",
      "createdAt": "2019-01-04T15:25:57Z",
      "updatedAt": "2019-11-20T06:25:49Z",
      "closedAt": "2019-03-11T19:18:49Z",
      "mergedAt": "2019-03-11T19:18:49Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom - I think you're wrong: my understanding (and also the way the text is written - otherwise we'd have to change it in the API draft) was that Connection Properties can (and should) also be set on Preconnections, to give as much input as possible for Connection establishment. In the API draft, the Selection Properties in Section 5.2 can *only* be used on Preconnections: you can't ask for congestion control after establishment. You can't say that you'd rather have multistreaming support after establishment. But that doesn't exclude Connection properties from being usable earlier.\r\n\r\nRequired minimum checksum coverage could influence choosing UDP-Lite vs. UDP. Bounds on Send or Receive Rate could influence the interface choice. The capacity profile could influence various things (and no, there isn't a matching Selection Property now - there is a per-Message override).\r\n\r\nSo... I think that either you're wrong, or I'm missing something and the API draft heavily lags behind a decision that was made. I hope not!",
          "createdAt": "2019-01-04T20:22:14Z",
          "updatedAt": "2019-01-04T20:22:14Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl The API drafts says: \r\n\r\n> Each application using the Transport Services Interface declares its preferences for how the transport service should operate using properties at each stage of the lifetime of a connection. During pre-establishment, Selection Properties (see {{selection-props}}) are used to specify which paths and protocol stacks can be used and are preferred by the application, and Connection Properties (see {{connection-props}}) can be used to fine-tune the eventually established connection. These Connection Properties can also be used later, to monitor and fine-tune established connections -- but configuring Connection Properties on Preconnections is preferred because they can then can influence decisions made during establishment.\r\n\r\nI interpret this as only the Selection Properties influence selection and the Connection properties are used to further configure the connections according to user preferences. Otherwise what is the difference between them?\r\n\r\n",
          "createdAt": "2019-01-04T23:42:30Z",
          "updatedAt": "2019-01-04T23:42:30Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you interpret it as you do, I think the text isn't clear enough (indeed it isn't super clear - in particular, \"eventually established\" is misleading IMO). Though, note that it says that Connection properties can *also* be used later.\r\n\r\nRegarding the difference between them: Selection Properties *only* make sense for Preconnections.",
          "createdAt": "2019-01-05T00:09:58Z",
          "updatedAt": "2019-01-05T00:09:58Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl - sorry lost this thread. But I saw that you have started cleaning up some Connection properties that had mixed Connection and Selection properties up in the API draft. Does it mean that we are now in synch and agree that only Selection properties are used in the selection and Connection properties are used for configuration (both during establisment and also after the connection setup).",
          "createdAt": "2019-01-08T16:26:25Z",
          "updatedAt": "2019-01-08T16:26:25Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom the other PR means nothing about what I said here: it only tried to address issue #230 which is about a wording inconsistency in a specific property.\r\n\r\nYou say that Connection properties can also be used during establishment - if you agree with allowing this, then why not allow to configure them as early as possible and allow them to influence selection? What's bad about having more information available that can guide the selection process?",
          "createdAt": "2019-01-09T08:47:13Z",
          "updatedAt": "2019-01-09T08:47:13Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl the problem is that the Connection properties are not expressed in a way suitable for selection. If they should also be used for Selection they would have to be reworked to be of type Preference. Otherwise I do not know what they mean for selection. What does it mean if I pick say a particular connection group transmission scheduler? Is it required or preferred? Most connection properties also do not look very useful to me for selection so in case there are some we need I think it would be simpler to just define a matching selection property.",
          "createdAt": "2019-01-09T16:44:28Z",
          "updatedAt": "2019-01-09T16:44:28Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom we're only discussing whether it's allowed to use them as additional input or not. I agree, some (like the scheduler choice) don't seem useful, but some do... generally we may not have good guidance on how they should be used by an implementation, but giving the system freedom to use as many inputs as possible is probably a good thing.\r\n\r\nRegarding the type, require/prefer//ignore/avoid/prohibit obviously works fine for a \"wishlist\" of boolean character: having something, or not having it. The selection properties are generally like that - except \"Interface Instance or Type\" and \"Provisioning Domain Instance or Type\" which are, well... wishlist-collections.\r\n\r\nConsider the capacity profile. Surely configuring this early can be useful input - e.g. if someone picks low latency / interactive, you may even want to put this traffic on a specific network interface!  But if you'd want to make a copy of the capacity profile as a \"proper\" selection property, how would you do it?  Apply require/prefer/ignore/avoid/prohibit for each of its values? Then I could say \"prefer\" low latency/non-interactive but \"avoid\" low latency/non-interactive, which would surely be odd. Apply the qualifier to the whole thing? Then it's about, e.g. \"avoiding\" to use a capacity profile at all. That's odd as well.\r\n\r\nI think it's in the nature of the current selection properties that they merely say \"I want to be able to do this, and this is how important it is to me\", which is different from configuring something. That's also why, as written, they simply wouldn't work for later connection configuration.\r\n\r\nConnection properties really are about configuring something, but I still say that being able to use them as early input is good. I agree that the implementation isn't super clear as they don't come with a require/prefer/... etc. qualifier, but then we just offer some freedom to implementers.",
          "createdAt": "2019-01-09T22:50:56Z",
          "updatedAt": "2019-01-09T22:50:56Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I just pushed a commit that updates the selection and connection properties text, removing \"connection\" almost everywhere, but adding a disclaimer in the beginning that says that connection properties should be configured as early as possible because they can influence decisions made by the implementation, and \"In the remainder of this document, we only refer to Selection Properties because they are the more typical case.\"  Frankly I'm not sure this is better... but it does remove most of the \"selection and connection\" double mentions that you pointed out.",
          "createdAt": "2019-01-16T10:52:32Z",
          "updatedAt": "2019-01-16T10:52:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed up branch building and resolved merge conflicts. I'll merge this in later today before the posting deadline.",
          "createdAt": "2019-03-11T15:34:18Z",
          "updatedAt": "2019-03-11T15:34:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cool thanks!  Sorry if I messed something up",
          "createdAt": "2019-03-11T15:39:38Z",
          "updatedAt": "2019-03-11T15:39:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NDQ1MjEy",
          "commit": {
            "abbreviatedOid": "6996068"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "There is some confusion with the Connection Properties that affected multiple parts of the text. I think they should not be used for selection.",
          "createdAt": "2019-01-04T16:56:07Z",
          "updatedAt": "2019-01-04T17:40:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I do not think Connection Properties should be included here. Only Selection properties define the candidates.",
              "createdAt": "2019-01-04T16:56:07Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 36,
              "body": "Again should probably only mention Selection Properties here.",
              "createdAt": "2019-01-04T16:57:47Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 40,
              "body": "Connection properties should not be used for this.",
              "createdAt": "2019-01-04T17:05:02Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 43,
              "body": "Selection Property should not be needed here.",
              "createdAt": "2019-01-04T17:06:14Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 48,
              "body": "I think there is a matching Selection Property missing in the API description, if it should be used for selection.",
              "createdAt": "2019-01-04T17:08:34Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 65,
              "body": "Again only selection properties. ",
              "createdAt": "2019-01-04T17:15:24Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 70,
              "body": "This example should actually be moved to the previous paragraph where the  branchingorder is discussed or deleted.",
              "createdAt": "2019-01-04T17:31:06Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 94,
              "body": "Selection Properties only.",
              "createdAt": "2019-01-04T17:32:32Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 97,
              "body": "Same here.",
              "createdAt": "2019-01-04T17:32:57Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 165,
              "body": "Again only Selection Properties.",
              "createdAt": "2019-01-04T17:38:29Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5Njk3NDMy",
          "commit": {
            "abbreviatedOid": "6996068"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T07:25:11Z",
          "updatedAt": "2019-01-07T07:25:12Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I don't get that: these two paragraphs talk about the same thing. The first sentence should actually be a part of the previous paragraph IMO because then this para explains all about the branching order. Then there's a paragraph giving an example. How does that not fit?\r\n\r\nAnyway, I'll move the first sentence one paragraph up for now.",
              "createdAt": "2019-01-07T07:25:11Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzI5Mzg1",
          "commit": {
            "abbreviatedOid": "62e7ad8"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-08T16:31:30Z",
          "updatedAt": "2019-01-08T16:31:31Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Sorry, my comment was messed up. I meant to say that the example should move to the previous section (not paragraph), where the branching order is defined. It is not connected to Require and Avoid so that sentence can be removed.",
              "createdAt": "2019-01-08T16:31:31Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjIzODcw",
          "commit": {
            "abbreviatedOid": "e883285"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T08:59:03Z",
          "updatedAt": "2019-01-09T08:59:03Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "understood, done",
              "createdAt": "2019-01-09T08:59:03Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzMDc1MDI3",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-16T10:49:53Z",
          "updatedAt": "2019-01-16T10:49:53Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I just made a commit that updates all other occurrences of \"Selection and Connection\", but I left this one standing on purpose: I think, because Connection Properties CAN be used to guide the decisions later, it is useful to have them in the example here as a way to remind the reader of this possibility.",
              "createdAt": "2019-01-16T10:49:53Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTkzMDc4",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good to me with a few minor nits.\r\n\r\nBased on the discussion, we really need to make clear that we don't forbid the policy form using early-provided properties as a selection input and add this as a hint/warning to the API.\r\nWith this, we should also add a note that Protocol Specific Properties (see PR #291 ) must not be used as a selection criteria.",
          "createdAt": "2019-03-10T08:57:04Z",
          "updatedAt": "2019-03-10T09:21:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "+1 Very clear to me.",
              "createdAt": "2019-03-10T08:57:04Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 8,
              "body": "nit: is this really a \"must\" or a should this rathe be a \"should\" \u2013  constrained platforms may have good reasons to alter defaults",
              "createdAt": "2019-03-10T08:57:44Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 19,
              "body": "nit: Again mention other properties: \"or derived from early specification of Connection or Message Properties\"",
              "createdAt": "2019-03-10T09:01:35Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 48,
              "body": "I think this would duplicate this property a second time and leads to confusion. I really prefer using the early-provided connection property here.",
              "createdAt": "2019-03-10T09:06:44Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 135,
              "body": "This has been renamed to \"Priority\" in the API (after writing this PR) ",
              "createdAt": "2019-03-10T09:12:29Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 215,
              "body": "The Cost Preference is still in the API as experimental, so I would like to also keep it in the Implementation",
              "createdAt": "2019-03-10T09:16:25Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 212,
              "body": "This has been included in the API as \"Bounds on Send or Receive Rate\" and should stay",
              "createdAt": "2019-03-10T09:18:05Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjI5MDcz",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T23:38:42Z",
          "updatedAt": "2019-03-10T23:38:43Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "@philsbln The earlier text covers the fact that you may also use connection properties if available. Let us not put them back into the text everywhere again. And there is also a distinction as you must take selection properties into account, but the connection properties are additional input that you can use if you like. ",
              "createdAt": "2019-03-10T23:38:42Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMwMDQx",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T23:59:49Z",
          "updatedAt": "2019-03-10T23:59:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Perhaps we should add to the last sentence \"we only refer to Selection Properties because they are the more typical case and have to be handled by all implementations\" or similar.  \r\n\r\nAn implementation could ignore the Connection properties, but not the Selection properties (it then depend on their setting if they can be ignored in the second step or not, but they have to be considered and if set to require or prohibit also satisfied).",
              "createdAt": "2019-03-10T23:59:49Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMwNTE4",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T00:10:22Z",
          "updatedAt": "2019-03-11T00:10:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@philsbln This may depend on the property. I do not think that it can be changed to a general \"should\". You can for instance not change from reliable to unreliable, even if your platform is constrained. Properties that can break the application if changed must follow the default if not provided by the application. I think a must in combination with good defaults should work. For properties that are set to prefer or avoid the implementation can always choose to ignore them in favor of other constraints. ",
              "createdAt": "2019-03-11T00:10:22Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyMzE2",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good! Only changes I'd like to see are removing the section on immediate (or actually filling it out, but I think it's not needed) and updating Niceness to Priority",
          "createdAt": "2019-03-11T00:40:55Z",
          "updatedAt": "2019-03-11T00:42:31Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "The reason for leaving out immediate is that we recommend not using it, `implementations should not use immediate racing`.",
              "createdAt": "2019-03-11T00:40:55Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            },
            {
              "originalPosition": 135,
              "body": "Good point, let's update that.",
              "createdAt": "2019-03-11T00:41:23Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODA4OTM2",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:37:49Z",
          "updatedAt": "2019-03-11T12:37:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done with the wording you propose",
              "createdAt": "2019-03-11T12:37:49Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODA5NzIz",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:39:48Z",
          "updatedAt": "2019-03-11T12:39:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't see the problem but removed \"Selection Property\" here and \"Connection Property\" in the next item, that should be a safe way out either way.",
              "createdAt": "2019-03-11T12:39:48Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODEyNDAy",
          "commit": {
            "abbreviatedOid": "ec1702b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:46:09Z",
          "updatedAt": "2019-03-11T12:46:19Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@philsbln this isn't really a discussion for this PR (which is just trying to reflect the API in the implementation draft).\r\nAnyway, to answer your concern: the capacity profile now exists in the interface draft as a Connection Property and as a per-Message override; the latter contains a statement about being inconsistent, and being fixed in the future.\r\n\r\nLet's not get hung up on this now in this PR and fix the capacity profile later.",
              "createdAt": "2019-03-11T12:46:09Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODEzNzAy",
          "commit": {
            "abbreviatedOid": "2850747"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:49:12Z",
          "updatedAt": "2019-03-11T12:49:13Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Understood. I removed it.",
              "createdAt": "2019-03-11T12:49:12Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODE0MTAx",
          "commit": {
            "abbreviatedOid": "2850747"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:50:05Z",
          "updatedAt": "2019-03-11T12:50:05Z",
          "comments": [
            {
              "originalPosition": 212,
              "body": "Kept it with a text update (matching bounds from the interface)",
              "createdAt": "2019-03-11T12:50:05Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODE2ODU2",
          "commit": {
            "abbreviatedOid": "2850747"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T12:56:22Z",
          "updatedAt": "2019-03-11T12:56:22Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "(Un)done, sorry",
              "createdAt": "2019-03-11T12:56:22Z",
              "updatedAt": "2019-03-11T15:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyODUyMzUy",
          "commit": {
            "abbreviatedOid": "b43e62f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for updating this \u2013 looks good!\r\n\r\njust needs s/send-params/msg-properties/ and merging",
          "createdAt": "2019-03-11T14:03:34Z",
          "updatedAt": "2019-03-11T14:09:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyOTAzNjY3",
          "commit": {
            "abbreviatedOid": "b43e62f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T15:24:36Z",
          "updatedAt": "2019-03-11T15:24:36Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "48059c641f8b5f4aa349fcff9a20ae264f963a0e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "updating-implementation",
      "headRefOid": "47a70a7a1fc513d6b6a9ac02afb21b820a8354e6",
      "mergeCommit": {
        "oid": "63f93c91f4c750fc45f6766c5e15be6d55a477ef"
      }
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyOTc3ODE1",
      "title": "Split Notification of Excessive Retransmission, and make the preference to receive Soft Errors a Selection Property",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/275",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This closes #230 and addresses a comment about soft errors by @theri in #227:\r\n\r\n- \"Notification of Excessive Retransmission\" is made a Selection Property\r\n- There's now an \"Excessive Retransmission\" Event (just like the one for Soft Errors)\r\n- The preference to receive Soft Errors is also made a Selection Property\r\n",
      "createdAt": "2019-01-08T13:36:59Z",
      "updatedAt": "2019-11-20T06:25:56Z",
      "closedAt": "2019-01-18T22:11:42Z",
      "mergedAt": "2019-01-18T22:11:42Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops sorry, will fix",
          "createdAt": "2019-01-08T15:02:54Z",
          "updatedAt": "2019-01-08T15:02:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri - the latter was exactly my thinking. if someone doesn\u2019t want these notifications they can just ignore them.\n\nSent from my iPhone\n\n> On 8 Jan 2019, at 17:15, Brian Trammell <notifications@github.com> wrote:\n> \n> @britram approved this pull request.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n",
          "createdAt": "2019-01-08T16:23:40Z",
          "updatedAt": "2019-01-08T16:23:40Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I think we should not standardise this. I also don't think that IETF transports typically provide this control, nor do I think this is really useful to have. So I'd argue the API should be silent about these three things!",
          "createdAt": "2019-01-08T16:29:54Z",
          "updatedAt": "2019-01-08T16:29:54Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Gorry that you can probably remove them. If anything I would see it as a Connection properties, not as Selection properties. How likely is it that you will have two transport stacks to select from where one supports soft errors the other not and this is what you will want to use to make a decision? Does not seem like a strong use case.",
          "createdAt": "2019-01-08T16:39:08Z",
          "updatedAt": "2019-01-08T16:39:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To Gorry's point, how widely do we expect these to be supported for various protocols? And is the meaning of excessive retransmits consistent across protocols that do retransmission (TCP, SCTP, QUIC)?",
          "createdAt": "2019-01-08T19:02:06Z",
          "updatedAt": "2019-01-08T19:02:06Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I certainly agree that it seems unlikely that someone will want to insist on a transport that offers \"Notification of Excessive Retransmission\". Removing this selection property is fine by me.\r\n\r\nRegarding soft errors, I could agree but I'm less sure - so just to double check, are we *really* all sure we don't want to offer this kind of control? What if applications really want to be able to receive ICMP messages, e.g. to insist on doing their own PMTUD?\r\n\r\n@abrunstrom mentions that, if anything, they should be Connection Properties: I agree with that; they were both Connection Properties before, but with unfitting wording (fixing this was a part of this split). I think they should both be described as events, like we already have it for soft errors only:\r\nhttps://taps-api.github.io/drafts/draft-ietf-taps-interface.html#rfc.section.9.2\r\n\r\nWe shouldn't remove them altogether: if we did, this would AFAIK be our only divergence from minset.  To answer @tfpauly's question, I dont know what most implementations do about these two things - but here's a spec backtrace that talks about TCP and UDP (for other protocols, \"do nothing\" is a safe choice here I guess):\r\n\r\nAbout \"Notification of Excessive Retransmission\", minset's Appendix A.1 says:\r\n\r\n   o  Notification of Excessive Retransmissions (early warning below\r\n      abortion threshold)\r\n      Protocols: TCP\r\n      Optimizing because it is an early warning to the application,\r\n      informing it of an impending functional event.\r\n      Implementation: via ERROR.TCP.\r\n      Implementation over UDP: do nothing (there is no abortion\r\n      threshold).\r\n\r\nRFC 8303, section 4.1 (\"pass 2\"), says about ERROR.TCP: \"The reported conditions include at least: ICMP error message arrived and excessive retransmissions.\" For the soft errors bit, minset also points at ERROR.UDP(-Lite), which, in RFC 8303, is described to just return soft errors, nothing else. For both protocols, the text points back at \"error_report\" from pass 1, which in TCP's case points back at section 4.2.4.1 in RFC 1122:\r\nhttps://tools.ietf.org/html/rfc1122#page-106\r\nThe text also refers to RFC 5461 which may provide more information regarding @tfpauly's question.\r\n\r\nFor soft errors from UDP, we need to look at \"error_report\" in RFC 8304, which quotes section 4.1.4 or RFC1122 to say: \"UDP MUST pass to the application layer all ICMP error messages that it receives from the IP layer.\" and goes on to explain that this is necessary to implement ICMP-based PMTUD.",
          "createdAt": "2019-01-09T08:23:32Z",
          "updatedAt": "2019-01-09T08:23:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMjcyNjU3",
          "commit": {
            "abbreviatedOid": "30cbe68"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "good, but in moving these properties to become selection properties, the type changes (and should be implicit, as with all other selection properties)",
          "createdAt": "2019-01-08T14:43:28Z",
          "updatedAt": "2019-01-08T14:44:26Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This is a selection property, so Type is implied (preference)",
              "createdAt": "2019-01-08T14:43:29Z",
              "updatedAt": "2019-01-08T15:31:56Z"
            },
            {
              "originalPosition": 33,
              "body": "same as above",
              "createdAt": "2019-01-08T14:43:35Z",
              "updatedAt": "2019-01-08T15:31:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzIwOTQx",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.\r\nI think there was the idea to have an additional Connection Property, which allows to turn the soft errors on or off on an existing Connection. \r\nDo we want to standardize this additional Connection Property as well, or is this too much and we leave it up to the implementation whether such a thing exists? I tend towards the latter, as I consider this just a convenience function.",
          "createdAt": "2019-01-08T16:14:54Z",
          "updatedAt": "2019-01-08T16:14:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMzIxNDY1",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-08T16:15:51Z",
          "updatedAt": "2019-01-08T16:15:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTE3OTc1",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I am fine to make these properties Selection Properties, and thus somehow \"promote\" them (use them as input to protocol selection instead of just providing a switch to mute the notifications).\r\nI think we should standardise them, but won't fight for them.\r\n\r\nWe defiantly should standardise the Events for ICMP soft-errors and excessive retransmissions, because they are a selling point for TAPS. Today, they are not really used, and I suspect this is primarily because getting these information to the application is incredibly painful with BSD sockets, and we should take the change to change that.",
          "createdAt": "2019-01-10T09:43:38Z",
          "updatedAt": "2019-01-10T09:55:28Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "As ICMP is unreliable anyway, the remark is somewhat redundant.",
              "createdAt": "2019-01-10T09:43:38Z",
              "updatedAt": "2019-01-10T09:55:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTQyMjgz",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T10:41:21Z",
          "updatedAt": "2019-01-10T10:41:21Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "There could be a perception issue here, because we see this differently.\r\n\r\n* First, transports ignore soft errors (as specified by the IETF), primarily because after years of experience this was found to be the correct thing to do. Sure this extra information *could* help in some cases, it can also be very unhelpful in many cases (one obvious case is where there is some parallelism and packets are forwarded across more than one set of nodes - e.g. after a failover,  ... when the path changes, this is made worse when there are delayed messages due to intermittent forwarding ). I'd suggest the end to argument identifies these messages are for diagnostics, not to influence the forwarding/transport.\r\n\r\n(2) I think you suggest the logic does not exist to forward this presently through the API. That is as I expected, and adding this as a requirement to TAPS is adding another requirement to the stack developer, TCP implementor, etc - all of which seems like a hurdle to deploying TAPS rather than a selling point. Many UDP API's don't even signal hard errors.\r\n\r\nBased on this, I argue soft errors from the network (ICMP) must not be passed to an application. Soft errors from the transport (such as retry failures, timeouts) could be passed if there is a need.\r\n\r\nGorry",
              "createdAt": "2019-01-10T10:41:21Z",
              "updatedAt": "2019-01-10T10:41:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTQ3NjE5",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T10:54:44Z",
          "updatedAt": "2019-01-10T10:54:44Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@gorry - I'm not sure you answered in the right place - I think you're answering my comment, not Phil's?  Or maybe it is Phil's, because of your point (2), where I don't understand why you say \"I think you suggest the logic does not exist to forward this presently through the API. \"\r\n\r\nEither way: your argument of not passing ICMP messages to the application at all makes sense to me, yet it's a divergence from minset and as such not offering everything that TCP and UDP offer. In a way it's quite a serious divergence, as we're stepping away from RFC 1122 here.\r\n\r\nAn option I see is to take this discussion to the mailing list, and if there's agreement to do this, do it and capture the reasoning in one of our documents.",
              "createdAt": "2019-01-10T10:54:44Z",
              "updatedAt": "2019-01-10T10:54:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTUyNzM5",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T11:08:21Z",
          "updatedAt": "2019-01-10T11:08:22Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "P.S. I just re-read RFC 5461, and I like the phrase:\r\n\r\n \"When the connection timer expires and an ICMP soft error message has\r\n   been received before the timeout, TCP can use this information to\r\n   provide the user with a more specific error message (see [Stevens],\r\n   pp. 317-319).\"\r\n\r\nP.P.S It wouldn't be a deployment hurdle, if it were optional to implement;-).\r\n",
              "createdAt": "2019-01-10T11:08:22Z",
              "updatedAt": "2019-01-10T11:08:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMjM4NjM4",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T14:44:04Z",
          "updatedAt": "2019-01-10T14:44:04Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I like that phrase too but I'm not sure this changes anything about the API... it's a TCP-internal thing. I like the idea of going optional !",
              "createdAt": "2019-01-10T14:44:04Z",
              "updatedAt": "2019-01-10T14:44:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMzI3MjQ2",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T17:32:30Z",
          "updatedAt": "2019-01-10T17:32:30Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I agree that _requiring_ an TAPS implementation to forward soft errors is a deployment hurdle, but I also think it is a useful feature. \r\nWhat I would like to see is _requiring the support of the property_ but making the functionality optional (so the property can be a NO-OP). I am fine with adding a warning against relying on ICMP generating soft errors.",
              "createdAt": "2019-01-10T17:32:30Z",
              "updatedAt": "2019-01-10T17:32:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzMDc4MDMw",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-16T10:57:09Z",
          "updatedAt": "2019-01-16T10:57:09Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@philsbln @gorryfair I wanted to update the text to address your comment now, but then I saw that the text about \"Soft Errors\" already says:\r\n\r\n\"This will only happen if the underlying protocol stack supports\r\naccess to soft errors; however, even if the underlying stack supports it, there\r\nis no guarantee that a soft error will be signaled.\"\r\n\r\nThe part after the semicolon is what you want, right?\r\n\r\nSo ... all is optional. Which text changes are you then asking for?",
              "createdAt": "2019-01-16T10:57:09Z",
              "updatedAt": "2019-01-16T10:57:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0MTUwMjU4",
          "commit": {
            "abbreviatedOid": "79a5933"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-18T15:32:57Z",
          "updatedAt": "2019-01-18T15:32:58Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@mwelzl I am fine with the text for soft errors. \r\n\r\nWe should just add a general remark about optional / NO-OP selection properties in a separate PR.",
              "createdAt": "2019-01-18T15:32:57Z",
              "updatedAt": "2019-01-18T15:32:58Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3e11c09e862ec7b0a53cd63e30426fae397aa2dc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW---Notification-of-excessive-retransmissions-and-Soft-Errors",
      "headRefOid": "79a5933cd56977836201aafa1a7a46371c8d5232",
      "mergeCommit": {
        "oid": "0fcc2d2c920bd24bdbd8b2df623ad217abb68326"
      }
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MDc5Mzky",
      "title": "Define a IANA registry for Transport Property Names",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/276",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "This PR contains a rough skeleton for an IANA registry fro property names.\r\n\r\nIt is mainly a proposal and starting point and will be discussed on the Jan'19 Interim.",
      "createdAt": "2019-01-11T16:29:52Z",
      "updatedAt": "2019-03-01T14:31:59Z",
      "closedAt": "2019-03-01T14:31:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Superseded by PR #291",
          "createdAt": "2019-03-01T14:31:41Z",
          "updatedAt": "2019-03-01T14:31:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5b173e2e31708a3183430c43576051b1202264e1",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "phils-registry",
      "headRefOid": "e48d49530ba11928aea707d1f5ad0f83ed1a5cf1",
      "mergeCommit": null
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2NDM5Njkz",
      "title": "Describe mutability of connection properties in architecture",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/278",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "As discussed at the January interim last week",
      "createdAt": "2019-01-21T23:51:23Z",
      "updatedAt": "2019-11-20T06:25:54Z",
      "closedAt": "2019-01-22T20:16:29Z",
      "mergedAt": "2019-01-22T20:16:29Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0ODc2MTg4",
          "commit": {
            "abbreviatedOid": "c75a83e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This definition is exactly right, IMO.",
          "createdAt": "2019-01-22T08:12:36Z",
          "updatedAt": "2019-01-22T08:12:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MTQ2NTA4",
          "commit": {
            "abbreviatedOid": "c75a83e"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Exactly right.",
          "createdAt": "2019-01-22T17:52:21Z",
          "updatedAt": "2019-01-22T17:52:21Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0fcc2d2c920bd24bdbd8b2df623ad217abb68326",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/connectionprops",
      "headRefOid": "c75a83eb70af6e329918a130f50524d07aa367e2",
      "mergeCommit": {
        "oid": "1b12bfdaf246a5094ef6e81f4f3df101dd4c61ac"
      }
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2ODk2MDEz",
      "title": "Minor adjustment to the semantics of Reliable Data Transfer (Message)\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/279",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 and Lifetime. Closes #273.",
      "createdAt": "2019-01-23T09:34:58Z",
      "updatedAt": "2019-01-25T13:57:52Z",
      "closedAt": "2019-01-25T13:16:41Z",
      "mergedAt": "2019-01-25T13:16:41Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @britram, all done",
          "createdAt": "2019-01-23T11:46:20Z",
          "updatedAt": "2019-01-23T11:46:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NDM2NDEy",
          "commit": {
            "abbreviatedOid": "ad2f40d"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "good modulo tiny nits",
          "createdAt": "2019-01-23T10:10:37Z",
          "updatedAt": "2019-01-23T10:12:21Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "do this to unbreak the build:\r\n\r\n```suggestion\r\nproperty (see {{msg-reliable-message}}). The type and units of Lifetime are implementation-specific.\r\n```",
              "createdAt": "2019-01-23T10:10:38Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            },
            {
              "originalPosition": 9,
              "body": "new paragraph?",
              "createdAt": "2019-01-23T10:11:14Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            },
            {
              "originalPosition": 21,
              "body": "tiny style nit:\r\n\r\n```suggestion\r\nWhen true, this property specifies that a message should be sent in such a way\r\n```",
              "createdAt": "2019-01-23T10:11:50Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NDc2MjQ3",
          "commit": {
            "abbreviatedOid": "ad2f40d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T11:44:16Z",
          "updatedAt": "2019-01-23T11:44:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Very sorry for this one!",
              "createdAt": "2019-01-23T11:44:17Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NDc2NjA5",
          "commit": {
            "abbreviatedOid": "ad2f40d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T11:45:14Z",
          "updatedAt": "2019-01-23T11:45:15Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "ok",
              "createdAt": "2019-01-23T11:45:15Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NDc2Nzgy",
          "commit": {
            "abbreviatedOid": "ad2f40d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T11:45:42Z",
          "updatedAt": "2019-01-23T11:45:42Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "ack",
              "createdAt": "2019-01-23T11:45:42Z",
              "updatedAt": "2019-01-23T11:46:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NDkzMzIy",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-25T12:54:45Z",
          "updatedAt": "2019-01-25T12:54:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NTA0NzAy",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T13:27:41Z",
          "updatedAt": "2019-01-25T13:36:41Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I find \"a time constraint on it\" confusing. Perhaps this should be \"does not wish to apply a time constraint on the transmission of the message\". An infinite lifetime does mean it should be transmitted at least once.",
              "createdAt": "2019-01-25T13:27:42Z",
              "updatedAt": "2019-01-25T13:36:41Z"
            },
            {
              "originalPosition": 25,
              "body": "What does the \r\n\r\n> Connection supports reliability\r\n\r\n mean? The connection is using a protocol that support reliability or the application has asked for a reliable connection? If I ask for an unreliable connection and it happens to get implemented with TCP, can I ask for a reliable message?  I would say no, as this would fail most of the time. So maybe this should be \"Connection is relable\"?",
              "createdAt": "2019-01-25T13:35:33Z",
              "updatedAt": "2019-01-25T13:36:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NTA5NTA0",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T13:40:21Z",
          "updatedAt": "2019-01-25T13:40:21Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm sorry, I merged this PR too quickly. I agree with your comment and will address it with a direct commit to the master.",
              "createdAt": "2019-01-25T13:40:21Z",
              "updatedAt": "2019-01-25T13:40:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NTEyMjk1",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T13:47:39Z",
          "updatedAt": "2019-01-25T13:47:39Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I agree with the idea of what you say, but not with the wording \"Connection is reliable\" because that sounds contradictory - we'd have a sentence saying that changing reliable data transfer per message is only possible if the Connection is reliable.  (but if it's reliable, why can you then change it?)\r\n\r\nI think you mean that this should only be possible for Connections that were established with the Selection Property \"Reliable Data Transfer (Connection)\" enabled. So I propose to phrase it as: \"Changing the \u00b4Reliable Data Transfer\u00b4 property on Messages\r\nis only possible for Connections that were established with the Selection Property 'Reliable Data Transfer (Connection)' enabled.\"\r\n\r\nPlease ACK or NACK - then I'll also apply this as a direct commit to the master. Sorry again for merging too fast.",
              "createdAt": "2019-01-25T13:47:39Z",
              "updatedAt": "2019-01-25T13:47:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NTE1NjU1",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T13:55:36Z",
          "updatedAt": "2019-01-25T13:55:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@mwelzl -Yes that is what I  I meant, thanks.",
              "createdAt": "2019-01-25T13:55:36Z",
              "updatedAt": "2019-01-25T13:55:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2NTE2NjEz",
          "commit": {
            "abbreviatedOid": "7f60827"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T13:57:52Z",
          "updatedAt": "2019-01-25T13:57:52Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@abrunstrom: great, thanks - I now committed both these changes to the master.",
              "createdAt": "2019-01-25T13:57:52Z",
              "updatedAt": "2019-01-25T13:57:52Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "1b12bfdaf246a5094ef6e81f4f3df101dd4c61ac",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-minor_text_update_reliable_messaging",
      "headRefOid": "7f60827bd461a2e717bdce7ba3b9af56cca94792",
      "mergeCommit": {
        "oid": "30daf2032e2efe57914f3cf296e8cdd4e9787502"
      }
    },
    {
      "number": 280,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ4NTU2NTYz",
      "title": "Change Niceness to Priority, as agreed with @britram. Closes #228",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/280",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not many text fixes needed - quite a bit of text reflected the old choice of Priority anyway and wasn't correctly updated for Niceness   :-)",
      "createdAt": "2019-01-29T15:47:25Z",
      "updatedAt": "2019-11-20T06:25:53Z",
      "closedAt": "2019-02-07T09:46:26Z",
      "mergedAt": "2019-02-07T09:46:26Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3NjUyMTE2",
          "commit": {
            "abbreviatedOid": "3b6a41f"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM, one open question",
          "createdAt": "2019-01-29T16:30:08Z",
          "updatedAt": "2019-01-29T16:30:19Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "should we say something here about what the max prio is?",
              "createdAt": "2019-01-29T16:30:08Z",
              "updatedAt": "2019-01-29T16:30:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3NjU4NzUw",
          "commit": {
            "abbreviatedOid": "3b6a41f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T16:41:10Z",
          "updatedAt": "2019-01-29T16:41:11Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think not - this should be application dependent. Giving a max of 10 or 100 or whatever they want. I only removed the statement to say that it's unbounded - with Niceness or Priority, this could be done, but is that better or worse than limiting it? I don't know. Let them decide.",
              "createdAt": "2019-01-29T16:41:10Z",
              "updatedAt": "2019-01-29T16:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Nzk4NzIw",
          "commit": {
            "abbreviatedOid": "3b6a41f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-29T21:41:10Z",
          "updatedAt": "2019-01-29T21:41:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5NTY5MDA3",
          "commit": {
            "abbreviatedOid": "3b6a41f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine with me. The max_prio problem can be addressed separately.",
          "createdAt": "2019-02-04T12:49:32Z",
          "updatedAt": "2019-02-04T12:51:11Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I see no reason to specify a concrete \"max prio\" \u2013 but perhaps we should define a read-only property to query it",
              "createdAt": "2019-02-04T12:49:32Z",
              "updatedAt": "2019-02-04T12:51:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwOTkzMzA2",
          "commit": {
            "abbreviatedOid": "3b6a41f"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T09:45:52Z",
          "updatedAt": "2019-02-07T09:45:53Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "okay, we'll just leave this as undefined (and a nonportable value in the abstract API, which is also fine)",
              "createdAt": "2019-02-07T09:45:52Z",
              "updatedAt": "2019-02-07T09:45:53Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2861f14444daf59f6969852685eb0f7773062ba8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-replace_niceness_with_priority",
      "headRefOid": "3b6a41f3ceaaaed77276aec415f44dfde4300ac8",
      "mergeCommit": {
        "oid": "b02fb7eb5d099d75c6b339860c9f4e04881e45cd"
      }
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ4NTg0ODI1",
      "title": "Closes #207. Added \"preservation of message boundaries\" selection property; turned\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/281",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 establishment timeout into a parameter of init calls (it stood out strangely in the list of selection properties because it really isn't one); updated defaults for selection properties.",
      "createdAt": "2019-01-29T17:02:09Z",
      "updatedAt": "2019-11-20T06:25:51Z",
      "closedAt": "2019-02-20T08:17:28Z",
      "mergedAt": "2019-02-20T08:17:28Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me now. Fixed the merge conflict with #284.",
          "createdAt": "2019-02-18T08:21:00Z",
          "updatedAt": "2019-02-18T08:21:00Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the updated definitions I think the defaults for \"Notification of excessive retransmissions\" and \"Notification of ICMP soft error message arrival\" should probably be Ignore?\r\nIf you are not interested in these properties they should not affect the selection.",
          "createdAt": "2019-02-18T09:41:07Z",
          "updatedAt": "2019-02-18T09:41:07Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I completely agree; done. @britram thanks a lot for fixing the conflict! I was worried about this :)  Now waiting for an ok from @philsbn and @abrunstrom before this lands.",
          "createdAt": "2019-02-18T20:43:41Z",
          "updatedAt": "2019-02-18T20:43:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwMjU4MTQ2",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "First, thanks for the editorial fixes and the preservation of message boundaries.\r\n\r\nI have some issues with turning the direction into a preference, as this makes little sense as discussed in #191. \r\n\r\nI like the addition of timeout, but can we make it optional?",
          "createdAt": "2019-02-05T19:22:25Z",
          "updatedAt": "2019-02-05T19:38:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good point - I take this as editorial change",
              "createdAt": "2019-02-05T19:22:25Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 11,
              "body": "s/needs/needs or prefers/",
              "createdAt": "2019-02-05T19:25:00Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 97,
              "body": "Despite this being a selection property, this is rather an Enum then a Preference. This was most probably lost on the pass that moved this property up in the document and removed the types.\r\nAs unidirectional applications can just ignore the other direction, using this as an Enum is safe.",
              "createdAt": "2019-02-05T19:30:11Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 134,
              "body": "Why do we need a timeout as a mandatory parameter here? I am fine with adding an option one, as we have no other means for this yet, but mandatory?",
              "createdAt": "2019-02-05T19:32:36Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwMjg1NjA4",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this!\r\nI really like that we finally have actual defaults for the Selection Properties.\r\nDoes this mean that we want to specify defaults for Connection Properties and Message Properties as well, or is that too much?\r\n\r\nOne comment about the \"timeout\" parameter - I think for connection establishment, it should stay a Connection property (9.1.4, in fact). Maybe it just got in the Selection Properties by accident.\r\nAs I say in the comment, I don't think this should be a (required) parameter on each Initiate.",
          "createdAt": "2019-02-05T20:25:11Z",
          "updatedAt": "2019-02-05T20:36:18Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I'd say this is a Connection Property rather than a Selection Property, so it should go in Section 9.1 -- in fact it already is there: 9.1.4 is \"Timeout for aborting Connection\" (which is missing a Type, but we can easily add that).\r\n\r\nSo let's not add it as a mandatory parameter here, but have it as a Connection Property with some default.",
              "createdAt": "2019-02-05T20:25:11Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 97,
              "body": "I'm fine with this staying a simple selection property. Having more granular control would be nice, but I'm not sure if we need to standardize that.\r\n\r\n@philsbln \r\nBy Enum you mean something like \"Use second path as fallback\", \"aggregate bandwidth\", or \"do not use multiple paths\"? Or are there more possible values?\r\nI'm not sure what \"the other direction\" would mean here?",
              "createdAt": "2019-02-05T20:32:28Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNTg0MDU5",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T13:51:54Z",
          "updatedAt": "2019-02-06T13:52:05Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I didn't mean to make it mandatory, sorry - happy to make it optional. Having it here seems better: all the other properties express a wish (or requirement, or wish to avoid, ... etc.) about the Connection that we're about to get - but this one doesn't. It really stands out in the list, as being nothing but a detail of how init works - so I thought it seems much cleaner to have it here as a parameter.",
              "createdAt": "2019-02-06T13:51:54Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNTg1MTI4",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T13:54:08Z",
          "updatedAt": "2019-02-06T13:54:09Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I'm lost - this is about \"Direction of communication\", right? But it already has multiple values (bidirectional vs. unidirectional)?",
              "createdAt": "2019-02-06T13:54:08Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNjIxMDY1",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T15:01:53Z",
          "updatedAt": "2019-02-06T15:01:54Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I thought this was about \"Parallel Use of Multiple Paths\".",
              "createdAt": "2019-02-06T15:01:53Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNjIzMzk3",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T15:06:18Z",
          "updatedAt": "2019-02-06T15:06:18Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Wait, Wishes (or requirements etc) are Selection Properties, not Connection properties. \r\nConnection properties do not express a wish (or requirement etc), but they set a specific variable, such as a timeout, to a specific value, such as a number of seconds.\r\n\r\nI see your point that it's not really the property of a Connection, but of a connection attempt or something like this.\r\nBut then, does the Connection property in 9.1.4 make sense? Or is this yet something else?",
              "createdAt": "2019-02-06T15:06:18Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNjQxOTEx",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T15:37:48Z",
          "updatedAt": "2019-02-06T15:37:48Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "It's something else - but now I notice that the wording there (\"before deciding that a Connection has failed after establishment.\") is a bit misleading. This (9.1.4) is the timeout that decides to abort a connection when data could not be delivered too long. It can be changed at any time, whereas the init. timeout just decides how long to try establishing before giving up.",
              "createdAt": "2019-02-06T15:37:48Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNjQzMTE3",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T15:39:45Z",
          "updatedAt": "2019-02-06T15:39:46Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": ".... and now I noticed how my answer to you was confusing. Sorry - indeed, you talked about the Connection Property which is already there. This update (of making the timeout a (with the next commit, optional) parameter of init) is about removing the init timeout only, 5.2.14.",
              "createdAt": "2019-02-06T15:39:46Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNjQ3MTYx",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T15:46:07Z",
          "updatedAt": "2019-02-06T15:46:08Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Okay, makes sense :)\r\nThen I'm fine with this timeout being an optional parameter to Initiate() (Maybe it's better to say explicitly that it's optional?), but I'd like it if 9.1.4 was made a bit more clear.",
              "createdAt": "2019-02-06T15:46:08Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwOTk0NDYy",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Have some questions about preference levels (and timeout as optional parameter raises separate issues). Otherwise good, thanks!",
          "createdAt": "2019-02-07T09:48:10Z",
          "updatedAt": "2019-02-07T09:55:54Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Really? I mean I'm all for a set of defaults that drives SCTP (or future PR-QUIC) usage, but I don't think most applications care about this.",
              "createdAt": "2019-02-07T09:48:11Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 44,
              "body": "Same comment as above.\r\n\r\n(It actually seems to me that smarter TAPS implementations could even extract the preferences/requirements of an application from static code analysis. An app that never clones connections doesn't need multistreaming, as an app that never sets deadlines/reliability doesn't need partial reliability)",
              "createdAt": "2019-02-07T09:50:44Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 55,
              "body": "This language was IMO not correct in the initial version; the fix to change preference is also not right... I think this is two separate properties: require checksum on receive, control checksum coverage on send.\r\n\r\nPrefer checksum coverage control on sending will tend to always select UDP-Lite when e.g. TAPS-enable Linux machines are talking to each other. Is this what we want?",
              "createdAt": "2019-02-07T09:53:13Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 110,
              "body": "not Require?",
              "createdAt": "2019-02-07T09:54:21Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            },
            {
              "originalPosition": 134,
              "body": "In general, I think we need to handle optional parameters better in the API doc. Will file an issue.",
              "createdAt": "2019-02-07T09:55:11Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTQ3NTgw",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:26:55Z",
          "updatedAt": "2019-02-07T15:26:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Prefer only means that you'd rather get a protocol that can do this if possible. It's harmless to request. A part of \"not caring\" is perhaps also the fact that this is so often not available?",
              "createdAt": "2019-02-07T15:26:55Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTUwNzcy",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:31:50Z",
          "updatedAt": "2019-02-07T15:31:50Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "The above (supporting per-message reliability) is a matter of \"does the application care\", as in \"will it use this functionality\"?  However this is a very different case!  This is about being allowed to group them without the application caring about it - I think we definitely want to do this, to benefit from multistreaming whenever possible. The benefits can be large even without app involvement, as both Connections get a single congestion control context.\r\n\r\nFor our API design, let's not presume that the underlying system can see into the future by analyzing the app code. Sequentially, this is before an application could do \"clone\".",
              "createdAt": "2019-02-07T15:31:50Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTUyNTUx",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:34:55Z",
          "updatedAt": "2019-02-07T15:34:55Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I agree that these should be two properties. Will fix.\r\n\r\nAbout always selecting UDP-Lite: why not? The problem is reachability, and that's for the TAPS transport system to figure out. It's certainly correct to use UDP - not much bad will happen.",
              "createdAt": "2019-02-07T15:34:55Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTU1Mjcw",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:39:27Z",
          "updatedAt": "2019-02-07T15:39:28Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "No, because it's only available in TCP (I traced it back in the minset => RFC 8303 path). E.g., SCTP can't do that. So this is then up to the transport system to weigh against other preferences... I thought \"Prefer\" because it seems to make sense to have.",
              "createdAt": "2019-02-07T15:39:27Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTU4OTcx",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:45:28Z",
          "updatedAt": "2019-02-07T15:45:28Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "So I think that @philsbn was talking about \"Direction of communication\" but got confused. Then @theri thought it's about \"Parallel Use of Multiple Paths\". So altogether we're all confused, I think. Here's a suggestion: let me continue with this as-is on this PR, and fix it afterwards.",
              "createdAt": "2019-02-07T15:45:28Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTYwNzMx",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:48:17Z",
          "updatedAt": "2019-02-07T15:48:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "done",
              "createdAt": "2019-02-07T15:48:17Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTYxNDg5",
          "commit": {
            "abbreviatedOid": "1dd1417"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T15:49:32Z",
          "updatedAt": "2019-02-07T15:49:33Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "done - I added \"optional: \" in front of the parameter. I suggest to accept this as-is for now and fix afterwards because it's a general style thing - if you don't like this specific style proposal, no problem to change it.",
              "createdAt": "2019-02-07T15:49:33Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTcxNDE4",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:05:26Z",
          "updatedAt": "2019-02-07T16:05:26Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "It will be difficult to do multi-streaming without explicit action by the application (calling clone).\r\n\r\nThe \"automagic multi-streaming mode\" works for my connection pool proposal (I should just write an PR for that), but not for regular connections. We tried searching for \"matching connections\" on ```socketconnect()```in our Socket Intents Prototype, but this was really tedious and error prone.\r\nSo requiring/preferring it really means \"the application may want to call ```clone()```\"",
              "createdAt": "2019-02-07T16:05:26Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTc1NjEx",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:12:29Z",
          "updatedAt": "2019-02-07T16:12:29Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Sorry \u2013 I was talking about \"Direction of communication\" \u2026 made the comment above the section.\r\n\r\nDirection of communication is not a preference \u2013 It has three distinct values whereby one of these values can be used as an obvious fallback.",
              "createdAt": "2019-02-07T16:12:29Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTgwMDc5",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:19:09Z",
          "updatedAt": "2019-02-07T16:19:09Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "It is not clear to me why an SCTP implementation should not be able to gather this kind of information, but I think Prefer is just right. Many stacks will not implement this feature and applications need to be careful in using this signal anyway.",
              "createdAt": "2019-02-07T16:19:09Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMjA0NzU2",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:53:39Z",
          "updatedAt": "2019-02-07T16:53:39Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "\"Automagic\" streaming mode is possible and has always been part of the model - see minset. Also, NEAT is able to do this. For details, see:\r\nF. Weinrank and M. T\u00fcxen. \u201cTransparent Flow Mapping for NEAT\u201c. In Workshop on Future of Internet Transport (FIT 2017), Stockholm, June 2017.\r\nhttp://dl.ifip.org/db/conf/networking/networking2017/1570349380.pdf",
              "createdAt": "2019-02-07T16:53:39Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMjA1MzM1",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:54:35Z",
          "updatedAt": "2019-02-07T16:54:35Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "SCTP: it's simply not part of the spec. See RFC 8303.",
              "createdAt": "2019-02-07T16:54:35Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzM1NTY3",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T21:34:04Z",
          "updatedAt": "2019-02-07T21:34:05Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think this discussion around defaults, here and at other places in the document, indicates that we need to have a \"not defined\" option as a default for several of them. \r\nThe indicated preferences should be used to make the selection of the transport. This should not be influenced by various parameters that are not relevant to the application. I would not like to get or not get a transport becuase of a default setting of a parameter that is not relevant for my application. On the other hand, if I prefer a protocol that provides for instance partial relaiability I would like that to have some impact on what is selected. So it should not be \"harmless\" to request something.",
              "createdAt": "2019-02-07T21:34:04Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzM4MjU2",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T21:40:35Z",
          "updatedAt": "2019-02-07T21:40:36Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I totally agree!  Actually I think the issue is - I tried to make a choice between the defined preference levels, and couldn't find a reasonable \"neutral\" one: the middle one is defined as:\r\n\r\n> Ignore  - Cancel any system default preference for this property\r\n\r\n... but \"Cancel any system default\" hardly makes sense for a recommended default. I think we want the middle preference level to mean \"don't care\".  (which I'd prefer over \"not defined\" because, well, there must be a default value, so what does \"not defined\" mean?)\r\n\r\nSo I suggest:\r\n\r\n> Neutral - No preference for or against this property",
              "createdAt": "2019-02-07T21:40:35Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzM5NDQ0",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T21:43:41Z",
          "updatedAt": "2019-02-07T21:43:41Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "As above, I would prefer not to make the default choice between UDP or UDP-Lite based on the default setting of this property. I think it should not be defined unless the application makes a choice. The defualt choice between UDP and UDP-Lite should better be set by a policy.",
              "createdAt": "2019-02-07T21:43:41Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzQ1MDQ2",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T21:58:39Z",
          "updatedAt": "2019-02-07T21:58:39Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I agree - let's introduce a reasonable \"Neutral\" preference level, and then that should be the default for this.",
              "createdAt": "2019-02-07T21:58:39Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTEzNDYy",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T10:28:16Z",
          "updatedAt": "2019-02-08T10:28:17Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "@mwelzl in case of NEAT, this is explicitly negotiated with the peer, which is a contradiction to the TAPS requirement to work with a non-TAPS peer.\r\nIf we accept that Transparent Flow Mapping is a protocol feature that might be present, I am unsure how does this will interact with an application that explicitly uses ```clone()``` to initiate another stream? \r\n - Do we need a parameter to turn off Transparent Flow Mapping to allow manual flow mapping with clone?\r\n - What about protocols like HTTP/3 that have a fixed stream-id to protocol semantic mapping?",
              "createdAt": "2019-02-08T10:28:16Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTE3MjQy",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T10:38:16Z",
          "updatedAt": "2019-02-08T10:38:16Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "hm, i was confused here. question withdrawn.",
              "createdAt": "2019-02-08T10:38:16Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTE3NzE1",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T10:39:27Z",
          "updatedAt": "2019-02-08T10:39:28Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "yep, let's rename Ignore to Neutral.",
              "createdAt": "2019-02-08T10:39:27Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTU4Njg3",
          "commit": {
            "abbreviatedOid": "57a9e50"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T12:36:39Z",
          "updatedAt": "2019-02-08T12:36:39Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "The negotiation happens in SCTP - NEAT itself doesn't know or care about the negotiation, it just locally tries to use SCTP with all necessary features. So saying this contradicts TAPS is like saying \"using MPTCP contradicts TAPS because it requires negotiation\"; it's just a local thing to try. But the idea is to definitely allow (even encourage!) people implementing TAPS systems to support this, as it can yield a lot of benefits (reduced FCTs, less overall delay from less congestion control interactions, ..) without the application having to worry about anything.\r\n\r\nAbout your questions:\r\n1) No, you can still do this. (Why do you think you couldn't?)\r\n\r\n2) Does it, *still*? Sigh... well I guess it's just a matter of giving a stream number to a Preconnection. That should be a protocol-specific property, I guess. Moreover, the requirement level for \"Multistream Connections in Groups\" will have to be \"Require\" if you want that level of control. But I don't see what this has to do with automatically mapping streams - this doesn't become easier or harder with or without it as far as I can tell.",
              "createdAt": "2019-02-08T12:36:39Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTYzNzc0",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T12:52:04Z",
          "updatedAt": "2019-02-08T12:52:05Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Got it - fixed it by changing the text back (just removing the \"Prefer\").",
              "createdAt": "2019-02-08T12:52:04Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTYzOTA1",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T12:52:29Z",
          "updatedAt": "2019-02-08T12:52:30Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Changed to @britram style optional in the last commit.",
              "createdAt": "2019-02-08T12:52:29Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTY0MDk4",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T12:53:03Z",
          "updatedAt": "2019-02-08T12:53:04Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done, and applied to the (now two separate) checksum-related Selection properties.",
              "createdAt": "2019-02-08T12:53:03Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTY0MjYw",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T12:53:29Z",
          "updatedAt": "2019-02-08T12:53:30Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done",
              "createdAt": "2019-02-08T12:53:29Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNjI0MjIz",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T15:09:01Z",
          "updatedAt": "2019-02-08T15:09:01Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "HTTP/3 still does, but the mapping has become less ugly. I think we should not worry too much here as HTTP ugliness can be easily hid with connection pools and pseudo transports. An average application programmer has no change of implementing HTTP/1.1 + 2 + 3 including negotiation and fallback anyway.",
              "createdAt": "2019-02-08T15:09:01Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNjQ3NTIx",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T15:51:20Z",
          "updatedAt": "2019-02-08T15:51:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Sorry, but I actually think Ignore is a better name. Perhaps better defined as  \r\n\r\n> Ignore - Not used during protocol/path selection\r\n\r\n> \r\n\r\nAnd we should use it :-) ",
              "createdAt": "2019-02-08T15:51:20Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNjUxNDcx",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T15:58:52Z",
          "updatedAt": "2019-02-08T15:58:52Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Sigh  :)   but I agree, the problem that I had was the \"cancel any system default preference\" description, not the name. I'm fine with going back to Ignore. Will do in the next commit.",
              "createdAt": "2019-02-08T15:58:52Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNzAyNjM1",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Agree with changing the definition of Ignore, but keeping the name \"Ignore\". Then, all preference levels are verbs, that makes sense. :)",
          "createdAt": "2019-02-08T17:43:42Z",
          "updatedAt": "2019-02-08T17:48:12Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Nit: s/is/will/",
              "createdAt": "2019-02-08T17:43:42Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNzk3Mjc3",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T21:40:58Z",
          "updatedAt": "2019-02-08T21:41:26Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I agree that `neutral` is better (and less overloaded) than `ignore`, but I'm not 100% sold on it.\r\n\r\nI'm also wondering if it is useful to have an explicit way in the API to request to get the `default` system behavior for a property. I know that defaults are specified for individual properties below, but it may be useful for an application being ported between different implementation to say \"just do what the system/implementation wants for this one\", which is effectively neutral and passes the decision down to the lower layer.\r\n\r\nIf we replaced `neutral` with `default`, of course, it would be silly to say that the default disposition is `default`... but it's something to think about.\r\n\r\nFor various APIs we've exposed in the past, we've later had to add an explicit way to set the default value in this way.",
              "createdAt": "2019-02-08T21:40:58Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxOTc1NjI1",
          "commit": {
            "abbreviatedOid": "292f6dc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T07:52:54Z",
          "updatedAt": "2019-02-11T07:52:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "But now we have two voices in favor of \"Ignore\" again - the latest agreement was that it should be \"Ignore\", but without the pesky text \"Cancel any system default preference for this property\".  Combining this idea with what you say here, I suggest to call this:\r\n\r\n> Ignore   -   No preference; use system defaults for this property\r\n\r\n(just the opposite of \"Cancel system defaults\", actually  :)  )",
              "createdAt": "2019-02-11T07:52:55Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNTM0NTAw",
          "commit": {
            "abbreviatedOid": "11af471"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-12T08:29:51Z",
          "updatedAt": "2019-02-12T08:29:51Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done, I changed it back to \"Ignore\" but kept the newer description.",
              "createdAt": "2019-02-12T08:29:51Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNTM1NDAx",
          "commit": {
            "abbreviatedOid": "02cba31"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-12T08:32:16Z",
          "updatedAt": "2019-02-12T08:32:16Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "done",
              "createdAt": "2019-02-12T08:32:16Z",
              "updatedAt": "2019-02-18T20:41:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NjYwOTg0",
          "commit": {
            "abbreviatedOid": "02cba31"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-18T08:18:10Z",
          "updatedAt": "2019-02-18T08:18:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1NjIxMTQy",
          "commit": {
            "abbreviatedOid": "c6b63c3"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Well done.\r\n\r\nI'd like to have a preference \"Default\" that restores the System default and another round of going through properties and discuss whether we need to fix the default at all or make it implementation specific, but that is a separate PR",
          "createdAt": "2019-02-20T08:14:09Z",
          "updatedAt": "2019-02-20T08:14:09Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6c4faa56c0103f0fda2f431d84af720d0d0fa545",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-two_selection_property_fixes",
      "headRefOid": "c6b63c3484e8b47ed8981579dcf3b55bc7aee769",
      "mergeCommit": {
        "oid": "f910e569930972a670b05cd4e076c00fff4b21b8"
      }
    },
    {
      "number": 284,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxMTc0Nzk4",
      "title": "add optional parameter notation, fix #283 ",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/284",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-07T16:13:06Z",
      "updatedAt": "2019-11-20T06:25:52Z",
      "closedAt": "2019-02-08T10:36:59Z",
      "mergedAt": "2019-02-08T10:36:59Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTgxMDgw",
          "commit": {
            "abbreviatedOid": "4053fd6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! This approach certainly clarifies things.",
          "createdAt": "2019-02-07T16:20:23Z",
          "updatedAt": "2019-02-07T16:20:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMTg1Mjk0",
          "commit": {
            "abbreviatedOid": "4053fd6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine withe mit (with some minor knit)",
          "createdAt": "2019-02-07T16:26:10Z",
          "updatedAt": "2019-02-07T16:27:57Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I am a little bit unsure whether this is the best resolution \u2013 in some languages, e.g., C, it would be much more common to use a constant for \"don't care\" \u2013 I would mention both as examples.",
              "createdAt": "2019-02-07T16:26:10Z",
              "updatedAt": "2019-02-08T10:35:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMjA3ODc1",
          "commit": {
            "abbreviatedOid": "4053fd6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T16:58:56Z",
          "updatedAt": "2019-02-07T16:58:56Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "+1, I don't like this much for sounding too language-specific. It sure sounds like method overloading as in Java...   I think developers will have their own ways to handle these kinds of things, it's enough to tell them that a parameter is optional.",
              "createdAt": "2019-02-07T16:58:56Z",
              "updatedAt": "2019-02-08T10:35:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNDU3MDI3",
          "commit": {
            "abbreviatedOid": "4053fd6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM except for the paragraph that I commented on; I'd just delete that.",
          "createdAt": "2019-02-08T07:37:23Z",
          "updatedAt": "2019-02-08T07:37:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTE1NDk0",
          "commit": {
            "abbreviatedOid": "4053fd6"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-08T10:33:38Z",
          "updatedAt": "2019-02-08T10:33:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "okay, can cut this and let implementors figure it out.",
              "createdAt": "2019-02-08T10:33:38Z",
              "updatedAt": "2019-02-08T10:35:33Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "de2f2694348d2c2a90380705dd423ab0ebfc16d2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "283-optional-params",
      "headRefOid": "38c25cf751853fb7344d01fb6dc1a6a809b54786",
      "mergeCommit": {
        "oid": "6c4faa56c0103f0fda2f431d84af720d0d0fa545"
      }
    },
    {
      "number": 290,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1MjE5MjQ4",
      "title": "reference format nits (fixed some {#xxx} spots that appeared in the compiled text)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/290",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-21T23:21:12Z",
      "updatedAt": "2019-02-22T09:36:24Z",
      "closedAt": "2019-02-22T09:36:24Z",
      "mergedAt": "2019-02-22T09:36:24Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2NzI3OTQ0",
          "commit": {
            "abbreviatedOid": "5448d1a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks!",
          "createdAt": "2019-02-22T09:36:12Z",
          "updatedAt": "2019-02-22T09:36:12Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f910e569930972a670b05cd4e076c00fff4b21b8",
      "headRepository": "GrumpyOldTroll/taps-api-drafts",
      "headRefName": "master",
      "headRefOid": "5448d1a20cbe2ff00a0bccc7ca71bb86f2dca219",
      "mergeCommit": {
        "oid": "81b305aaada8e41a845b8c9ce932931f361d5924"
      }
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3NDYzNjUy",
      "title": "Add Transport Property Names to the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/291",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This implements the consensus on Transport Property Names from the Januar '19 Interim and the mailing list discussion about an IANA Registry for Property names.\r\n\r\nThis also closes #243. ",
      "createdAt": "2019-03-01T14:30:50Z",
      "updatedAt": "2019-05-17T08:11:44Z",
      "closedAt": "2019-03-11T11:12:29Z",
      "mergedAt": "2019-03-11T11:12:28Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Most nits addressed - ready to merge",
          "createdAt": "2019-03-11T09:06:57Z",
          "updatedAt": "2019-03-11T09:06:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTkwNTY2",
          "commit": {
            "abbreviatedOid": "c1d0e3a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks for doing this! I have lots of little nits, most of which are pretty firmly in bikeshed territory and should probably be discussed in a larger group in person. Approving so we can get the next rev out tomorrow.",
          "createdAt": "2019-03-10T07:34:50Z",
          "updatedAt": "2019-03-10T12:37:54Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "bikeshed alert: so I think I'm one of the people who argued for these, but seeing them in the examples is a little jarring. OTOH, underscores violate the \"don't use any one language's conventions (underscores would be very pythonic).\r\n\r\nMaybe the right approach here is to keep hyphens, and identify properties by strings in the examples?",
              "createdAt": "2019-03-10T07:34:50Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 16,
              "body": "(Or maybe just give up and switch to underscores... with namespaces, these look a lot like Linux sysctls, which are in the form `namespace.word_word`. I don't know.)",
              "createdAt": "2019-03-10T07:36:18Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 33,
              "body": "suggest \"a string identifying the vendor or implementation\" -- this is a little restrictive as it is.",
              "createdAt": "2019-03-10T07:37:15Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nMost Selection Properties are represented as preferences, which can\r\n```",
              "createdAt": "2019-03-10T07:38:08Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n: multistreaming\r\n```",
              "createdAt": "2019-03-10T07:38:39Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n: multipath\r\n```",
              "createdAt": "2019-03-10T07:39:05Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 169,
              "body": "if this can be an actual interface identifier, then `interface-type` is not accurate...",
              "createdAt": "2019-03-10T07:39:38Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 182,
              "body": "as above",
              "createdAt": "2019-03-10T07:39:47Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 238,
              "body": "Do we need to prefix these names with msg?",
              "createdAt": "2019-03-10T07:40:11Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            },
            {
              "originalPosition": 398,
              "body": "seems like we can try to make this shorter :)",
              "createdAt": "2019-03-10T07:40:40Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyMTQy",
          "commit": {
            "abbreviatedOid": "d82610c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T00:38:03Z",
          "updatedAt": "2019-03-11T00:38:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzExNTAw",
          "commit": {
            "abbreviatedOid": "d82610c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T08:48:30Z",
          "updatedAt": "2019-03-11T08:48:31Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The hyphens were actually inspired by @GrumpyOldTroll's proposal to add a YANG model for the TAPS API which were the hyphens would be the logical choice.\r\n\r\nI have no strong opinions \u2026 hyphens work and would be nice for YANG, but if we have strong opinions for underscores I won't object.",
              "createdAt": "2019-03-11T08:48:31Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzEzOTkw",
          "commit": {
            "abbreviatedOid": "d82610c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T08:54:56Z",
          "updatedAt": "2019-03-11T08:54:56Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "For lifetime I consider this important to not be confused with a connection lifetime.\r\n\r\nFor final and idempotent, I'll drop it",
              "createdAt": "2019-03-11T08:54:56Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE1NzAz",
          "commit": {
            "abbreviatedOid": "d82610c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T08:59:08Z",
          "updatedAt": "2019-03-11T08:59:09Z",
          "comments": [
            {
              "originalPosition": 398,
              "body": "I have no Idea hot to mak it shorter without loosing consistency with the message property",
              "createdAt": "2019-03-11T08:59:08Z",
              "updatedAt": "2019-03-11T09:03:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4MDUx",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:04:56Z",
          "updatedAt": "2019-03-11T09:04:56Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "dropped the type",
              "createdAt": "2019-03-11T09:04:56Z",
              "updatedAt": "2019-03-11T09:04:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4MTE1",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:05:06Z",
          "updatedAt": "2019-03-11T09:05:06Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "dropped the type",
              "createdAt": "2019-03-11T09:05:06Z",
              "updatedAt": "2019-03-11T09:05:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4MTYy",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:05:17Z",
          "updatedAt": "2019-03-11T09:05:17Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "doen",
              "createdAt": "2019-03-11T09:05:17Z",
              "updatedAt": "2019-03-11T09:05:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4Mjcw",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:05:31Z",
          "updatedAt": "2019-03-11T09:05:32Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "done",
              "createdAt": "2019-03-11T09:05:31Z",
              "updatedAt": "2019-03-11T09:05:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4MzQ5",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:05:42Z",
          "updatedAt": "2019-03-11T09:05:42Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "done",
              "createdAt": "2019-03-11T09:05:42Z",
              "updatedAt": "2019-03-11T09:05:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzE4NDA0",
          "commit": {
            "abbreviatedOid": "3135e13"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T09:05:51Z",
          "updatedAt": "2019-03-11T09:05:52Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "done",
              "createdAt": "2019-03-11T09:05:51Z",
              "updatedAt": "2019-03-11T09:05:52Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0f1b4ed55b97c6924190a49a115fda0b02e79ad9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "property-names",
      "headRefOid": "3135e1341b02fe4c73ad8e269275431c877bf8ea",
      "mergeCommit": {
        "oid": "56ace99a984408555db784dc9d38b44b75ca697d"
      }
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3NDc2MjQx",
      "title": "Added a \"Default\" preferece level for Selection Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/292",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This closes issue #289 ",
      "createdAt": "2019-03-01T15:07:25Z",
      "updatedAt": "2019-03-08T17:20:14Z",
      "closedAt": "2019-03-08T17:20:00Z",
      "mergedAt": "2019-03-08T17:20:00Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Weren't we supposed to stop making PRs and issues until March 5? See Zahed's email to the TAPS list",
          "createdAt": "2019-03-01T15:22:05Z",
          "updatedAt": "2019-03-01T15:22:05Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl sorry \u2013 I did not read list mails since yesterday morning.",
          "createdAt": "2019-03-01T15:33:03Z",
          "updatedAt": "2019-03-01T15:33:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, let's hold off on these until we move repos!",
          "createdAt": "2019-03-01T16:34:16Z",
          "updatedAt": "2019-03-01T16:34:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMTYxOTYz",
          "commit": {
            "abbreviatedOid": "e3e1749"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2019-03-06T10:49:54Z",
          "updatedAt": "2019-03-06T10:49:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzc1Mjk2",
          "commit": {
            "abbreviatedOid": "e3e1749"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-08T16:53:47Z",
          "updatedAt": "2019-03-08T16:53:47Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b444daf2f9bac30e60cacef1c8a4acb5df1fc35b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln-preference-default",
      "headRefOid": "e3e174902cc3ed7948d453536639c4da9b6f7241",
      "mergeCommit": {
        "oid": "dab1e84119ccfb4c8e7b2463f604511c8a19c63b"
      }
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MDM1Mjc2",
      "title": "API usage examples",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/293",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR provides usage examples of our abstract interface, to address #247.\r\n\r\nThe examples show how an application might use Listen(), Initiate(), and Rendezvous(), send a Message, and receive a Message.\r\nThere is some redundancy between these examples, and I introduces some subtle differences to make them plausible, e.g., the \"server\" provides its identity, and the \"client\" verifies the other endpoint's identity using a trust callback.\r\n\r\nOverall the section became rather long. Should we instead just stick to one example, e.g., Initiate()? (Or Rendezvous() because it covers the most aspects? Or Initiate() but with all the aspects from Rendezvous()?)\r\n\r\nOtherwise I'm particularly interested in feedback on the Rendezvous() example -- I think it's correct wrt the draft, but is there a \"more plausible\" port number, and should anything else be set there that is not in the Initiate() and Listen() examples?",
      "createdAt": "2019-03-07T09:33:33Z",
      "updatedAt": "2019-11-20T06:25:50Z",
      "closedAt": "2019-03-10T07:21:38Z",
      "mergedAt": "2019-03-10T07:21:38Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the review, I addressed the comments.\r\nMaybe the default for Preserve Message Boundaries should be Require as well, if we receive only complete Messages by default...",
          "createdAt": "2019-03-08T13:28:43Z",
          "updatedAt": "2019-03-08T13:28:43Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm good with these changes. Regarding how we show the pseudo-code, I'm not totally sure about the notation (how rigorous are we on that?), so someone else should validate it makes sense.",
          "createdAt": "2019-03-08T14:48:49Z",
          "updatedAt": "2019-03-08T14:48:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTY4NjY1",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for doing this! Some nits, esp about defaults, but I like having this here.",
          "createdAt": "2019-03-07T19:13:25Z",
          "updatedAt": "2019-03-07T19:36:14Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Random extra line? =)",
              "createdAt": "2019-03-07T19:13:25Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            },
            {
              "originalPosition": 7,
              "body": "Editorial nit, feels like this should be structured like:\r\n\r\n```\r\nhow an application might use a Transport Services Interface to:\r\n\r\n- Act as a server, by listening for incoming connections, receiving requests, and sending responses. See {{server-example}}.\r\n```\r\netc. The main point being we should have a `:` on the dangling sentence, which is filled out by the bullets.",
              "createdAt": "2019-03-07T19:15:22Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            },
            {
              "originalPosition": 42,
              "body": "I'd actually argue that we should not show setting these values. If we do believe that these are the defaults:\r\n\r\n```\r\nThe recommended default is to Require Reliable Data Transfer.\r\n```\r\n\r\nThen why would the application need to set these explicitly? That just adds to boiler-plate code bulk.",
              "createdAt": "2019-03-07T19:17:29Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            },
            {
              "originalPosition": 36,
              "body": "I don't like ever recommending using an interface by name; people often make incorrect assumptions about which interface is named which.",
              "createdAt": "2019-03-07T19:18:02Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            },
            {
              "originalPosition": 60,
              "body": "Again, aren't these the defaults?",
              "createdAt": "2019-03-07T19:33:23Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjczMTQy",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:06:25Z",
          "updatedAt": "2019-03-08T13:06:26Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Oops, yea, that happened when I moved this part around on my branch...",
              "createdAt": "2019-03-08T13:06:25Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjc0MTAw",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:09:37Z",
          "updatedAt": "2019-03-08T13:09:37Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agree, will change.",
              "createdAt": "2019-03-08T13:09:37Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjc0OTk2",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:12:40Z",
          "updatedAt": "2019-03-08T13:12:40Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "True for reliability and preserve order -- I wanted to show them explicitly, but I can also do that in a comment, and that's probably better.\r\nFor preserve-msg-boundaries, the default is Prefer, so I do think I need to set it here, otherwise I think the example will be somewhat ambiguous.",
              "createdAt": "2019-03-08T13:12:40Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjc2Nzk2",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:18:14Z",
          "updatedAt": "2019-03-08T13:18:14Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Agreed, hardcoding these in an application might be a bad idea.\r\nI took this example from the Transport Properties Section, so if we decide it's bad, maybe we should change it there as well.\r\n\r\nWhat about: LocalSpecifier.WithInterface(\"any\")? Or is there a better way to specify an interface to listen on than with interface names?",
              "createdAt": "2019-03-08T13:18:14Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjc3MTAz",
          "commit": {
            "abbreviatedOid": "65be1e6"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:19:12Z",
          "updatedAt": "2019-03-08T13:19:12Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Yes, they are.\r\nI wanted to show them explicitly, so readers are not confused when they read the parameters of the Receive call. But again, I can do that in a comment and that's probably better.",
              "createdAt": "2019-03-08T13:19:12Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzEzMTIz",
          "commit": {
            "abbreviatedOid": "331e822"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T14:46:52Z",
          "updatedAt": "2019-03-08T14:46:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Hm, okay. I think keeping one example of a changed property is good, so this one is fine. May want to change it in the future, but we can see.",
              "createdAt": "2019-03-08T14:46:52Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzEzNDM1",
          "commit": {
            "abbreviatedOid": "331e822"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T14:47:27Z",
          "updatedAt": "2019-03-08T14:47:27Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Would the defaults not make this collapse down to Connection.Receive()?",
              "createdAt": "2019-03-08T14:47:27Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzEzNzA5",
          "commit": {
            "abbreviatedOid": "331e822"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-08T14:48:02Z",
          "updatedAt": "2019-03-08T14:48:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzM1MjAz",
          "commit": {
            "abbreviatedOid": "331e822"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:31:20Z",
          "updatedAt": "2019-03-08T15:31:21Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "You're right, I overlooked the \"?\".",
              "createdAt": "2019-03-08T15:31:20Z",
              "updatedAt": "2019-03-08T15:31:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTkwMDkw",
          "commit": {
            "abbreviatedOid": "f68c9a3"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This looks good, modulo a couple of comments in the review (introduce API example notation, decide on formatting for property names). In the interests of getting this into the draft rev for Prague, though, I don't think we should block merging on these, and can clean them up in/after Prague.",
          "createdAt": "2019-03-10T07:16:52Z",
          "updatedAt": "2019-03-10T07:21:27Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I _think_ we're leaning toward underscore-, as opposed to dash-separation for property names? in any case I don't think this has been decided yet so can leave it for now...",
              "createdAt": "2019-03-10T07:16:52Z",
              "updatedAt": "2019-03-10T07:21:27Z"
            },
            {
              "originalPosition": 56,
              "body": "this means that \"the following lines will happen after this event triggers\"? \r\n\r\nWe should probably add a paragraph or two to the notation section for notations we want to use in examples. As above, see no reason to block merging on this though.,",
              "createdAt": "2019-03-10T07:19:32Z",
              "updatedAt": "2019-03-10T07:21:27Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b444daf2f9bac30e60cacef1c8a4acb5df1fc35b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "theri-api-usage-example",
      "headRefOid": "f68c9a35918e8d2a09c099d11e0c6443841a39d9",
      "mergeCommit": {
        "oid": "0f1b4ed55b97c6924190a49a115fda0b02e79ad9"
      }
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NTQ2ODU5",
      "title": "Caching Boundaries using Connection Groups",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/294",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Alternate proposal to address #45 (old PR was \"Add CacheContext to architecture and API\", #244)\r\n\r\n- Define explicit Connection Groups as a way to define caching boundaries\r\n- Update TLS 1.3 references to RFC 8446",
      "createdAt": "2019-03-08T17:19:52Z",
      "updatedAt": "2019-11-20T06:25:47Z",
      "closedAt": "2019-03-11T19:19:20Z",
      "mergedAt": "2019-03-11T19:19:20Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a light-weight approach, but seems a little heavy-handed.\r\n\r\nI thought connection groups were a tool to model multi-streaming. With this PR, they become a fuzzy thing between cache context and multi-streaming abstraction. This may be the better choice, but ist definitely an Architecture decision. \r\n\r\nI liked the cache original context more.",
          "createdAt": "2019-03-08T22:05:20Z",
          "updatedAt": "2019-03-08T22:05:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The result of the interim discussion was that we didn't like a separate cache context object as much.\r\n\r\nBased on the discussion, we need some abstraction to say \"these connections don't share state with the rest of the connections in my process, and can share between one another\". The Group is a convenient way to do this. Note that you can just have one connection in its own group even.\r\n\r\nIn some ways, it solves a lot of problems\u2014it isn't sensical to say that connections in a Group can not share cache state. It I multiplex, I'm by default sharing TLS state. So if we have a separate cache context, we'll need some prohibition that you can't have multiple connections in a group have different cache contexts. Using the group as the way to define the boundary solves this.",
          "createdAt": "2019-03-08T23:23:38Z",
          "updatedAt": "2019-03-08T23:23:38Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it solves a lot of Problems and is an easy-to-use solution. The more I think about it, the more I like it. If we agree that we want to go down this road, definitely a +1 from my side modulo  @chris-wood's comments.\r\n\r\nStill, if we land this one, we need to add some means of manually managing connection groups to the API in the next round.",
          "createdAt": "2019-03-09T08:56:47Z",
          "updatedAt": "2019-03-09T08:56:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood please re-review!",
          "createdAt": "2019-03-11T00:36:29Z",
          "updatedAt": "2019-03-11T00:36:29Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I updated the text to avoid the implication about cloning. I didn't intend to change the behavior for Clone() being required to get multiplexing. I was more thinking that the use of the cache could be managed implicitly, while still requiring calling Clone() to actually multiplex. But, for now, I removed the text about implicit groups.\r\n\r\nPlease check that this resolves your concerns!",
          "createdAt": "2019-03-11T16:09:54Z",
          "updatedAt": "2019-03-11T16:09:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the reviews and input!",
          "createdAt": "2019-03-11T19:19:15Z",
          "updatedAt": "2019-03-11T19:19:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNDY0NDEy",
          "commit": {
            "abbreviatedOid": "3a28feb"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good! Only a couple comments inline.",
          "createdAt": "2019-03-08T20:25:26Z",
          "updatedAt": "2019-03-08T20:31:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "nit: s/will be able to/can",
              "createdAt": "2019-03-08T20:25:26Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 44,
              "body": "I'd drop \"resumption\" here.",
              "createdAt": "2019-03-08T20:26:03Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 45,
              "body": "This is a bit of a double edged sword since multiplexing hides information from the on-path observer. I might drop this one, since coalescing to the same origin is (IMO) fine.",
              "createdAt": "2019-03-08T20:27:06Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 48,
              "body": "Maybe add an example which says that connections for a single browser tab would be grouped?",
              "createdAt": "2019-03-08T20:30:34Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjAwODE4",
          "commit": {
            "abbreviatedOid": "3a28feb"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "share @chris-wood's concerns, approving so we can submit a draft to discuss in prague...",
          "createdAt": "2019-03-10T12:42:36Z",
          "updatedAt": "2019-03-10T12:48:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nBy default, all stored properties of the Implementation are shared within a process, such as cached protocol state, cached path state, and heuristics. This provides efficiency and convenience for the application, since the Transport System Implementation can automatically optimize behavior.\r\n```\r\n\r\n...implementing @chris-wood's suggestion as a Suggestion",
              "createdAt": "2019-03-10T12:42:36Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 45,
              "body": "does the transport system implementation know enough when autocoalescing to ensure that it's the same origin, though? Thinking about cdn/cloud load balancers here...",
              "createdAt": "2019-03-10T12:45:02Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMxNTE5",
          "commit": {
            "abbreviatedOid": "3a28feb"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T00:27:52Z",
          "updatedAt": "2019-03-11T00:27:53Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah, I'd like to leave this. It's given as a concern an application may have; and when one is being paranoid (like for a private browsing case) it's nice to have a guarantee in usage like this.",
              "createdAt": "2019-03-11T00:27:52Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyMDA1",
          "commit": {
            "abbreviatedOid": "dc8a243"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T00:36:07Z",
          "updatedAt": "2019-03-11T00:36:07Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Added example!",
              "createdAt": "2019-03-11T00:36:07Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyMDEw",
          "commit": {
            "abbreviatedOid": "dc8a243"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T00:36:11Z",
          "updatedAt": "2019-03-11T00:36:11Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Dropped",
              "createdAt": "2019-03-11T00:36:11Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyMDE2",
          "commit": {
            "abbreviatedOid": "dc8a243"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T00:36:14Z",
          "updatedAt": "2019-03-11T00:36:15Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Fixed",
              "createdAt": "2019-03-11T00:36:14Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjM0MDE3",
          "commit": {
            "abbreviatedOid": "3a28feb"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T01:04:31Z",
          "updatedAt": "2019-03-11T01:04:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Defining the Connection Groups implicitly is a bit different from what we have in the API draft at the moment where I would read it as Connection Groups are formed explicitly by calling Clone, So the API text should probbaly be aligned a bit if we change it here. \r\n\r\nRelated to this, how do I know as an application what connections I affect when changing a protocol property if connections are grouped implicitly? We have in the API draft: \r\n\r\n> Connections in a Connection Group share all Protocol Properties that are not applicable to a Message. Changing one of these Protocol Properties on one Connection in the group changes it for all others. For example, changing \"Timeout for aborting Connection\" (see {{conn-timeout}}) on one Connection in a group will automatically change this Protocol Property for all Connections in the group in the same way. \r\n\r\nI think we would need some comment about the effect of the implicit grouping in the text above. With implicit grouping changing a protocol property may affect multiple connectione even if they were not explicitly grouped with Clone. This may not be a problem, but the semantics should be clear. ",
              "createdAt": "2019-03-11T01:04:31Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzM4Mjk0",
          "commit": {
            "abbreviatedOid": "dc8a243"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Summary: let's not implicitly group. Let people call clone.",
          "createdAt": "2019-03-11T09:49:30Z",
          "updatedAt": "2019-03-11T09:59:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I also wanted such implicit grouping some time ago, but @abrunstrom convinced me that this doesn't add value (and indeed creates problems like she describes here). That's because \"clone\" only expresses a wish for Connections to be grouped in some form, but there is no promise that much is really happening under the hood. I.e., after calling \"clone\", an application doesn't really know if its Connections WILL be multiplexed, and if priorities between them WILL play out correctly. However, there's a consistent behavior now regarding the things that ARE promised - e.g. the Connection Properties that she describes here: if one is changed, it affects all the Connections within a Group.\r\n\r\nAs a conclusion, rather than changing the text she quotes, I think this implicit grouping should be removed. The default behavior for an application should just be to use Clone whenever possible ... whenever there's no good reason NOT to use it.",
              "createdAt": "2019-03-11T09:49:31Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 48,
              "body": "This would automatically be solved if you agree with my comment regarding clone above: if this is never implicitly happening but always only a result of clone, you don't even need this SHOULD here.",
              "createdAt": "2019-03-11T09:53:31Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            },
            {
              "originalPosition": 50,
              "body": "I suppose anyone can optionally add whatever bells and whistles they want to their transport system... else, I wonder, is this important?  If it is, we could e.g. add a statement to the grouping text of the interface draft to say that, for every Connection Property, a \"sharing allowed\" boolean could also be offered by the API... or something like that.",
              "createdAt": "2019-03-11T09:56:22Z",
              "updatedAt": "2019-03-11T15:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyOTIzOTUw",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T15:55:28Z",
          "updatedAt": "2019-03-11T15:55:29Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Clarified what the SHOULD is here. The SHOULD is now that the interface should allow apps to mark their Groups as having an isolated cache. So, it says you need to be able to specify a knob to have an isolated group.",
              "createdAt": "2019-03-11T15:55:29Z",
              "updatedAt": "2019-03-11T15:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyOTI5MTc0",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks \u2013 Looks good to me!",
          "createdAt": "2019-03-11T16:03:34Z",
          "updatedAt": "2019-03-11T16:03:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyOTMxOTQy",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T16:08:08Z",
          "updatedAt": "2019-03-11T16:08:08Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Changed the language slightly to just say the interface MAY expose fine-grained tuning. I want to keep this in here to mitigate concerns that readers of the document may have about the architecture lumping layers together.",
              "createdAt": "2019-03-11T16:08:08Z",
              "updatedAt": "2019-03-11T16:08:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDIwODE5",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T18:48:35Z",
          "updatedAt": "2019-03-11T18:48:36Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-03-11T18:48:35Z",
              "updatedAt": "2019-03-11T18:48:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDIwODcz",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T18:48:40Z",
          "updatedAt": "2019-03-11T18:48:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": ":+1:",
              "createdAt": "2019-03-11T18:48:40Z",
              "updatedAt": "2019-03-11T18:48:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDIxMTU4",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2019-03-11T18:49:16Z",
          "updatedAt": "2019-03-11T18:49:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzMDI3MDAy",
          "commit": {
            "abbreviatedOid": "00dbbcd"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!  Thanks for the fix",
          "createdAt": "2019-03-11T19:01:05Z",
          "updatedAt": "2019-03-11T19:01:05Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b444daf2f9bac30e60cacef1c8a4acb5df1fc35b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/caching-groups",
      "headRefOid": "00dbbcd64f3bdb675461d299192463b15581ab8c",
      "mergeCommit": {
        "oid": "72fe36139c01cc1922976821ea729e479c320993"
      }
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NzE1MDY4",
      "title": "Add Connection Pool Object",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/295",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "This PR adds a first proposal for Connection Pools to TAPS as discussed in Issue #266.\r\n\r\n**This is an alternative to PR #298.**\r\n\r\nPooled Connections are only useful for request/response protocols like HTTP and serve the following purposes:\r\n - Provide a clean abstraction for HTTP/3 that is backward compatible to HTTP/0.9\r\n - Remove the motivation to map QUIC streams to Messages (by removing the drawback of complication HTTP/3 mapping when they are mapped to TAPS connections)\r\n - Allow Per-Request Path- and Endpoint Selection\r\n\r\nSee [my post on the mailing list](https://mailarchive.ietf.org/arch/msg/taps/u4imn1IKFBeSxwJRJK_HNwEoT98) for a more detailed description of this topic.",
      "createdAt": "2019-03-09T20:42:23Z",
      "updatedAt": "2019-07-08T13:29:13Z",
      "closedAt": "2019-04-01T12:09:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just updated the Connection Pool objects to be more Connection like and added the ```reqRef``` as parameter to the normal send and receive. So a connection pool really works like a connection and only differs in creation by calling ```RequestorPool()``` instead of ```Initiate()``` and ```ResponderPool()``` instead of ```Listen()```. ",
          "createdAt": "2019-03-11T13:34:39Z",
          "updatedAt": "2019-03-11T13:34:39Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this based on the result of the IETF-104 discussion",
          "createdAt": "2019-04-01T12:09:44Z",
          "updatedAt": "2019-04-01T12:09:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjAxMTcz",
          "commit": {
            "abbreviatedOid": "8994192"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you very much for writing this up, it allows me to understand better what was concretely being proposed in #266. That said, please don't merge this in its current form: IMO it adds complexity to the interface without benefit. The functionality of connection pooling could/should be provided by a Connection object, perhaps enabled by a selection property.\r\n\r\nThe message reference facility may be useful as an optional parameter on Received<> and Connection.Send(), separate from the connection pooling question.",
          "createdAt": "2019-03-10T12:51:31Z",
          "updatedAt": "2019-03-10T13:58:36Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\"initiator pool\" and \"responder pool\" would need to be more tightly defined, and I would suggest s/initiator/requestor/, since Initiator appears to mean something not in the context of request/response protocols)",
              "createdAt": "2019-03-10T12:51:31Z",
              "updatedAt": "2019-03-20T13:22:28Z"
            },
            {
              "originalPosition": 72,
              "body": "Exposing the distinction between a Connection and a ConnectionPool in this way seems to add complexity to the API for no benefit. Why does the application need to know a connection pool might be in use? Isn't one of the points of TAPS to allow multiplexing and pooling when possible but to provide nominal functionality when not?\r\n\r\nThe request reference is indeed useful here (if we accept that TAPS should be useful to build interfaces atop request/response semantics, which I do think is the case) to tell the TAPS system that one message should use the same low-level transport (Transport Stack Instance in Post terminology, IIRC) as another, but ISTM this could be added to every Received event and Send call as an optional parameter.",
              "createdAt": "2019-03-10T13:30:30Z",
              "updatedAt": "2019-03-20T13:22:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMxMTg0",
          "commit": {
            "abbreviatedOid": "8994192"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for writing this up!\r\n\r\nI agree very much with @britram that the notion of a separate object for a ConnectionPool does not seem to add direct value, but makes the interface more complex.\r\n\r\nOne of the key notions of the architecture is that the \"Connection\" is not necessarily analogous to a TCP connection, and I think that really makes the Connection abstraction able to do the same thing you're trying to add with a \"Pool\". For example, in HTTP/2, a Connection will be just one stream, that's multiplexed. And since each stream is effectively a single HTTP request/response, that means that we're really just treating a Connection as an HTTP request/response pair. So, over HTTP/1.1, or the like, a Connection for a request/response pair ends up \"pooling\" onto existing TLS/TCP connections. This can and should be automatic, perhaps with the ability to define boundaries of when not to automatically group.",
          "createdAt": "2019-03-11T00:22:32Z",
          "updatedAt": "2019-03-11T00:22:32Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "72fe36139c01cc1922976821ea729e479c320993",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln-connection-pools",
      "headRefOid": "3b18586afb91e5e700901578ac465c12c5477f05",
      "mergeCommit": null
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NzQ4NTk5",
      "title": "Nits: Clarify the scope in which Transport Properties may be used",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/296",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2019-03-10T10:07:07Z",
      "updatedAt": "2019-03-11T11:23:48Z",
      "closedAt": "2019-03-11T11:23:39Z",
      "mergedAt": "2019-03-11T11:23:39Z",
      "mergedBy": "philsbln",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjIzMDI1",
          "commit": {
            "abbreviatedOid": "a9e2f86"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-10T21:31:16Z",
          "updatedAt": "2019-03-10T21:31:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjMyNDk5",
          "commit": {
            "abbreviatedOid": "a9e2f86"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T00:43:49Z",
          "updatedAt": "2019-03-11T00:43:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzEzNjkx",
          "commit": {
            "abbreviatedOid": "a9e2f86"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T08:54:10Z",
          "updatedAt": "2019-03-11T08:54:10Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "56ace99a984408555db784dc9d38b44b75ca697d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "phils-property-effect-nits",
      "headRefOid": "3274993dc06ed6bd07b3ef0cdbd5099f0de8f5ed",
      "mergeCommit": {
        "oid": "f9ec8ff689f26f31b874fc7260d1a619a5d7eb7d"
      }
    },
    {
      "number": 297,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NzYxNTAz",
      "title": "move brian",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/297",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-10T14:00:39Z",
      "updatedAt": "2019-03-10T14:00:55Z",
      "closedAt": "2019-03-10T14:00:52Z",
      "mergedAt": "2019-03-10T14:00:52Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0f1b4ed55b97c6924190a49a115fda0b02e79ad9",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "bht-affiliation",
      "headRefOid": "e769307387cae82f4e3dc09c7e1b6034c7559b22",
      "mergeCommit": {
        "oid": "4d1519e3f59936527b811b98b744864d37207e2f"
      }
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYyOTY0MjEw",
      "title": "Add Pooled Connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/298",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API",
        "Architecture",
        "discuss"
      ],
      "body": "This PR adds a first proposal for adding Pooled Connection support to TAPS as discussed in Issue #266. \r\n\r\n**This is an alternative to PR #295.**\r\n\r\nPooled Connections are only useful for request/response protocols like HTTP and serve the following purposes:\r\n - Provide a clean abstraction for HTTP/3 that is backward compatible to HTTP/0.9\r\n - Remove the motivation to map QUIC streams to Messages (by removing the drawback of complication HTTP/3 mapping when they are mapped to TAPS connections)\r\n - Allow Per-Request Path- and Endpoint Selection\r\n\r\nSee [my post on the mailing list](https://mailarchive.ietf.org/arch/msg/taps/u4imn1IKFBeSxwJRJK_HNwEoT98) for a more detailed description of this topic.",
      "createdAt": "2019-03-20T17:25:32Z",
      "updatedAt": "2020-09-11T16:31:22Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "72fe36139c01cc1922976821ea729e479c320993",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln-connection-poolingpref",
      "headRefOid": "38fedcd07d507b966659ada1fe4ee8ddf3adb7d6",
      "closedAt": "2019-05-15T12:17:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at this, I fail to understand why these choices need to be up to the application. I agree with the idea of a Connection being composed of several underlying connections when the transport system deems this useful, but I don't see why the application would have to bother with this; request-response mapping happens per (TAPS-)Connection anyway. I must be missing something. Is this about giving a hint to the TAPS system to use multiple transport connections?\r\n\r\nI'm looking forward to discussing this at lunchtime today.",
          "createdAt": "2019-03-25T07:57:25Z",
          "updatedAt": "2019-03-25T07:57:25Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The application must be aware of the interaction mode it uses \u2013 this is done using the Selection Property added. See it as a switch between \"I care about connections\" or \"I only care about messages, I don't care over which connection they are send or received\".\r\n\r\nIn the latter case, you need still to send responses on the same connection you received the requests, at least for backward-compatibility. Therefore, I added the new send parameter.\r\n\r\nThe other changes fall into three categories:\r\n - Remove assumption that a connection maps to exactly one underlying transport connection (not sure whether I found all spots in the document)\r\n - Clarify behaviour of the pooling mode (not sure if sufficient)\r\n - Allow Selection Properties on Messages to influence the selection of the underlaying transport connections in case you are in pooling mode (cool, but optional).",
          "createdAt": "2019-03-25T10:54:59Z",
          "updatedAt": "2019-03-25T10:54:59Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The PR is superseded by #320, #321 and a PR that will follow once #321 is clear. Discussion should be continued in the other PRs and Issue #266. Closing this PR now.",
          "createdAt": "2019-05-15T12:17:48Z",
          "updatedAt": "2019-05-15T12:17:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3Njg1MjQy",
          "commit": {
            "abbreviatedOid": "bc71d9a"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Gave this a first look, added some questions and suggestions.\r\n\r\nHaving seen the complexity here, I'm not sure anymore whether Connection Pools, if we add them, should be an architecture, API, and/or implementation concept -- if processing and managing all these message references is mandatory for the application, it becomes indeed a quite different API usage...\r\n\r\nIn any case, I think this needs some clearer definitions, i.e., what does \"equivalent endpoints\" mean.\r\nDo underlying protocol stacks have to be equivalent? Does it have to be the same transport protocol, just different instances? etc.\r\nAlso, what happens to Connection properties? Are they shared across the underlying connections, similar to Connection Groups?\r\nI'm a little confused about the interaction with Connection Groups in general - e.g., can multiple connection pools be in the same Connection Group?",
          "createdAt": "2019-03-22T10:34:48Z",
          "updatedAt": "2019-03-22T11:15:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Are Connection Pools still a distinct concept in the Architecture in this PR? Or are they being abstracted within the Connection? Maybe it's a Transport System Implementation Concept like in the Architecture draft Section 4.2? But then I'm not sure it needs to be specified here upper case?\r\n\r\nAlso I don't see why this is a \"messages-only API\" and the non-pooled API is not.\r\n\r\nMaybe the text could say something like like \"The API can abstract the connection management of multiple underlying transport connections to equivalent endpoints as a single connection to the application, which is called connection pooling.\r\nIn this case, the application can send and receive messages, which the transport system distributes across the underlying transport connections.\"\r\n\r\nI think it would be important to define (not sure if here or elsewhere in the draft) what \"equivalent endpoints\" are: Same domain name and port, same security parameters, ...? And the give examples what can vary, e.g., endpoint's IP addresses and paths/local interfaces. Otherwise it's hard to understand \"per-message endpoint and path selection\".\r\n\r\nDoes equivalence here have anything to do with Protocol Stack Equivalence as specified in the Architecture draft Section 4.2.3?",
              "createdAt": "2019-03-22T10:34:48Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 17,
              "body": "Do I understand correctly that a single TAPS Connection can abstract both TCP and QUIC connections -- i.e., instances of different transport protocols within **the same** TAPS Connection? That might take it too far, IMHO.\r\nAnd what does \"saved the same way\" mean?",
              "createdAt": "2019-03-22T10:37:18Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 13,
              "body": "The last part reads a bit confusing to me - is it necessary to set this and otherwise the messages (requests) are not going to be multiplexed on a multi-streaming connection? Or is this because there can be multiple multi-streaming connections abstracted by the same TAPS connections? ",
              "createdAt": "2019-03-22T10:39:43Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 4,
              "body": "The application-layer protocol also needs to be stateless, right?\r\nI think HTTP is probably not the only use case, and that here the text should be explicit about the assumptions of when this can be used. And maybe it should explain somewhere (different section, maybe the \"implementation flexibility\" right below?) why this is useful.",
              "createdAt": "2019-03-22T10:42:12Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 20,
              "body": "What is the \"same backing connection\"? The underlying transport connection, right?\r\nI'm not sure this needs to be defined in terms of connection though - shouldn't it just indicate that a Message is a response to an earlier Message?",
              "createdAt": "2019-03-22T10:45:50Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 19,
              "body": "I think this point should come below the \"msgRef/reqRef\" stuff etc -- it's essentially about performance optimization, while the other things are fundamental for the Connection object and its usage.",
              "createdAt": "2019-03-22T10:47:50Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            },
            {
              "originalPosition": 59,
              "body": "... or if I call close on the Connection, in this case?",
              "createdAt": "2019-03-22T11:03:52Z",
              "updatedAt": "2019-03-22T14:23:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3NzYzODk2",
          "commit": {
            "abbreviatedOid": "bc71d9a"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for these early comments. I hope my last update clarifies most of them.\r\n\r\nThe msg refs add complexity to the Transport System, but should relieve the application of managing a lot of state. Especially, in cases where they need to have a connection per request otherwise. Just imagine how to implement the HTTP/3 mapping or a DNS server on top of TAPS without Connection Pools or Pooled Conections.",
          "createdAt": "2019-03-22T13:49:07Z",
          "updatedAt": "2019-03-22T14:30:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Protocols don't need to be stateless to use pooled connections, but must be reordering resistent. I already have this on the slides for next week and and will update the PR accordingly",
              "createdAt": "2019-03-22T13:49:07Z",
              "updatedAt": "2019-03-22T14:30:42Z"
            },
            {
              "originalPosition": 6,
              "body": "These are a lot knits\u2026 \r\n - The name \"Connection Pools\" here are an artefact of the writing process - will update them to \"pooled connections\"\r\n - In principle, equivalent endpoints should be part of Protocol Stack Equivalence, bit they are not.\r\n - In addition, connections in one pool also need to satisfy what is in Protocol Stack Equivalence now.\r\n\r\nI'll clarify this and update the PR.",
              "createdAt": "2019-03-22T13:55:18Z",
              "updatedAt": "2019-03-22T14:30:42Z"
            },
            {
              "originalPosition": 17,
              "body": "Yes, a pooled connection should be able to abstract a QUIC connection over Wifi and three TCP connections \r\nover LTE into one TAPS connection. Application sends HTTP requests, some of them go over HTTP/1.1 over TLS1.3 over TCP, others go over HTTP3 over QUIC. I don't think implementations have to go this far, but should be allowed to do so.\r\n \r\ns/saved the same way/served the same way/",
              "createdAt": "2019-03-22T13:59:31Z",
              "updatedAt": "2019-03-22T14:30:42Z"
            },
            {
              "originalPosition": 13,
              "body": "In the current API, you need to explicitly call ```initiate()``` or ```clone()``` to create a new stream.\r\nSo opening a new Stream for each request in HTTP/3 requires to call ```clone()``` for each request and manage the resulting connection object. ",
              "createdAt": "2019-03-22T14:07:36Z",
              "updatedAt": "2019-03-22T14:30:42Z"
            },
            {
              "originalPosition": 19,
              "body": "right",
              "createdAt": "2019-03-22T14:15:50Z",
              "updatedAt": "2019-03-22T14:30:42Z"
            },
            {
              "originalPosition": 20,
              "body": "To be backward compatible, responses usually will need to take the same underlying transport connection over which the request was received.",
              "createdAt": "2019-03-22T14:17:47Z",
              "updatedAt": "2019-03-22T14:30:43Z"
            },
            {
              "originalPosition": 59,
              "body": "Yepp - added this",
              "createdAt": "2019-03-22T14:20:53Z",
              "updatedAt": "2019-03-22T14:30:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY4Njc5ODI4",
      "title": "Restructure to include nat traversal in connection establishment",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/311",
      "state": "MERGED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Restructure to address #154 \r\nRearrange to include Rendezvous and Environment Discovery text in connection establishment. Remove that previous section. \r\n\r\n#154 was intended to check the ordering of sections against the other drafts and to merge #127. \r\n\r\nI have merged the Rendezvous text into Connection Establishment, but I haven't changed any of the text yet. I am a little concerned about creating an interdependancy in the text between derriving endpoints (name lookup) and the ICE/TURN stuff.\r\n\r\nMore generally, I am not sure what to say about name resolution and proxies (ala #282). TOR opens a can of privacy worms for name lookup and racing paths that I am not sure how to address. \r\n\r\n\r\n",
      "createdAt": "2019-04-09T10:35:31Z",
      "updatedAt": "2020-09-11T16:31:23Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cb59954786e6eb2b74ada6df0418dc56d800509c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tj/impl-restructure",
      "headRefOid": "a1565ef8567631cf34ab4d718a1e8aaaa996d28d",
      "closedAt": "2019-04-23T15:27:55Z",
      "mergedAt": "2019-04-23T15:27:55Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "d9773a45df353d47666c8dc32e9612e71863261c"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good apart from typo!",
          "createdAt": "2019-04-23T14:30:41Z",
          "updatedAt": "2019-04-23T14:30:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0OTExNTMw",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the change, as it makes the process much clearer and reduces the awkwardness of ICE/STUN.\r\n\r\nTo model TOR, SOCKS, or other tunnelling protocols, I would refrain from seeing them as protocol stacks, but treat them as derived paths that only support these stacks. This removes the need for cupeling name resolution to the protocol stack, and looks quite natural to me as these derived paths may be available in the connection cache or need to be established for name resolution anyway before starting the real candidate racing.\r\nIf we want to do so, it might be easier to talk about paths (that have one or more corresponding local endpoints), derived paths, derived remote endpoints (as result of name resolution on each path) and protocol stacks.",
          "createdAt": "2019-04-10T11:31:41Z",
          "updatedAt": "2019-04-10T11:41:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This addition is useful, however, what kind of tree? \r\n```suggestion\r\nwith the given endpoint as root, the available paths on the level below, the derived endpoints, and the available stacks at the lower levels.\r\n```",
              "createdAt": "2019-04-10T11:31:41Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1MjA4ODAz",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-10T20:45:18Z",
          "updatedAt": "2019-04-10T20:45:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Typo: `canidates` -> `candidates`",
              "createdAt": "2019-04-10T20:45:18Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzYwMDg1",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T19:59:22Z",
          "updatedAt": "2019-04-11T19:59:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think the tree is described enough elsewhere, and this should have a reference rather than trying to re-state the content",
              "createdAt": "2019-04-11T19:59:22Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzYwNzY2",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T20:00:46Z",
          "updatedAt": "2019-04-11T20:00:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Nit: `... exchange to exchange candidates` repeats the word `exchange` probably more than we ought to",
              "createdAt": "2019-04-11T20:00:46Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzYxMTEz",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T20:01:35Z",
          "updatedAt": "2019-04-11T20:01:35Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I don't think emphasis will come through in RFC markdown?",
              "createdAt": "2019-04-11T20:01:35Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzYxMjM2",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T20:01:54Z",
          "updatedAt": "2019-04-11T20:01:55Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Do `####` nested four deep actually work in the HTML/txt output for the RFC?",
              "createdAt": "2019-04-11T20:01:54Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2OTYyNTQ4",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T02:42:07Z",
          "updatedAt": "2019-04-16T02:42:08Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I believe they do, yes.  I get proper section numbers this way (though at 4 down they stop appearing in the table of contents, for me.)",
              "createdAt": "2019-04-16T02:42:07Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3MDUyMDAx",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T08:29:47Z",
          "updatedAt": "2019-04-16T08:29:47Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "In the xml format there is a parameter to set that for the ToC (default is 3)",
              "createdAt": "2019-04-16T08:29:47Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5NTA1MTk1",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-23T11:59:22Z",
          "updatedAt": "2019-04-23T11:59:22Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "The appear in my render, as @GrumpyOldTroll says not in the TOC",
              "createdAt": "2019-04-23T11:59:22Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5NTA1ODc0",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-23T12:01:03Z",
          "updatedAt": "2019-04-23T12:01:03Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "removed",
              "createdAt": "2019-04-23T12:01:03Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5NTg5OTY0",
          "commit": {
            "abbreviatedOid": "e0cc1c1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-23T14:30:19Z",
          "updatedAt": "2019-04-23T14:30:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Still looks like there's the \"canidates\" typo on the new text here?",
              "createdAt": "2019-04-23T14:30:19Z",
              "updatedAt": "2019-04-23T14:36:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5NTk0MzA1",
          "commit": {
            "abbreviatedOid": "a1565ef"
          },
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-23T14:36:58Z",
          "updatedAt": "2019-04-23T14:36:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "got it this time",
              "createdAt": "2019-04-23T14:36:58Z",
              "updatedAt": "2019-04-23T14:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5NjI3MjA0",
          "commit": {
            "abbreviatedOid": "a1565ef"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-23T15:27:39Z",
          "updatedAt": "2019-04-23T15:27:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1ODQ2MTE5",
          "commit": {
            "abbreviatedOid": "1a27d3b"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-09T22:02:10Z",
          "updatedAt": "2019-05-09T22:02:10Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "There's discussion of the implications of this non-local behaviour in draft-ietf-rtcweb-ip-handling-11 that might be worth referencing?",
              "createdAt": "2019-05-09T22:02:10Z",
              "updatedAt": "2019-05-09T22:02:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0Mzg5NzA1",
      "title": "Clarify that a TAPS connection has no 1:1 relation to an underlying transport connection",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/320",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": "This updates the definition of a TAPS connection to allow a TAPS implementation to do connection pooling and multi-streaming. It removes the limitation from a TAPS connection to relate to exactly one underlying transport connection and hints that underlying transport connections my be created automatically.\r\n\r\nThis is one result of the discussion around PR #298.",
      "createdAt": "2019-04-29T14:12:31Z",
      "updatedAt": "2019-05-08T08:11:50Z",
      "closedAt": "2019-05-06T18:14:27Z",
      "mergedAt": "2019-05-06T18:14:27Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All comments should be addressed \u2013 ready for merge",
          "createdAt": "2019-05-06T14:04:10Z",
          "updatedAt": "2019-05-06T14:04:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the changes! LGTM.",
          "createdAt": "2019-05-06T18:14:22Z",
          "updatedAt": "2019-05-06T18:14:22Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "That seems OK, can we fix: / It can also represent a pool of transport protocol instance/ to\r\nbe /instances/ or whatever the plural is of a transport protocol instance?\r\n\r\nGorry",
          "createdAt": "2019-05-08T08:11:50Z",
          "updatedAt": "2019-05-08T08:11:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODAwODM4",
          "commit": {
            "abbreviatedOid": "9319ef7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like this change a lot in general! My comments are mainly about phrasing details.",
          "createdAt": "2019-05-05T22:38:05Z",
          "updatedAt": "2019-05-05T22:45:02Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't love using the word `exploit` here; it's a bit of a negative connotation. How about using `utilize`?",
              "createdAt": "2019-05-05T22:38:06Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            },
            {
              "originalPosition": 13,
              "body": "If you switch to `one or more`, you also need to make it `transport protocol instances` in the first sentence. I'd also just remove the `(s)` and use `s` instead.",
              "createdAt": "2019-05-05T22:39:22Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            },
            {
              "originalPosition": 15,
              "body": "Let's make this all one paragraph again, and I'd drop the `However,`. Just say `A connection can also...`\r\n\r\nRather than `a bunch of`, please use `multiple` or `a set of`.\r\n\r\nI'd also drop the reference to a CDN.",
              "createdAt": "2019-05-05T22:40:47Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            },
            {
              "originalPosition": 7,
              "body": "This is a little too open/scary\u2014 don't say that they may automatically be created at any time, that sounds like there's no way to opt out, etc. Do we need a comment here in the API? This section isn't about transport layer stuff, just about initiate.",
              "createdAt": "2019-05-05T22:44:38Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODUxOTQx",
          "commit": {
            "abbreviatedOid": "9319ef7"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T07:24:27Z",
          "updatedAt": "2019-05-06T07:24:27Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't think this is a wise place to dig: saying transport connections can be opened later is not something I would like to see in TAPS (Maybe I share the view this COULD happen, but I'd really like to avoid saying anyting in this topic at all in the API. ",
              "createdAt": "2019-05-06T07:24:27Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODU3OTM0",
          "commit": {
            "abbreviatedOid": "9319ef7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T07:44:25Z",
          "updatedAt": "2019-05-06T07:44:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "+1",
              "createdAt": "2019-05-06T07:44:25Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODU4MDg2",
          "commit": {
            "abbreviatedOid": "9319ef7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo the small fixes pointed out by @tfpauly ",
          "createdAt": "2019-05-06T07:44:53Z",
          "updatedAt": "2019-05-06T07:44:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODk4NDEx",
          "commit": {
            "abbreviatedOid": "9319ef7"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T09:42:42Z",
          "updatedAt": "2019-05-06T09:42:42Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I would like to give implementations this kind of freedom, e.g., to automatically re-initiate a  transport connection after the server closed an old, idle one. But maybe this hint fits better into implementation.",
              "createdAt": "2019-05-06T09:42:42Z",
              "updatedAt": "2019-05-06T09:56:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzOTAzMzAz",
          "commit": {
            "abbreviatedOid": "d0db0e7"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T09:56:42Z",
          "updatedAt": "2019-05-06T09:56:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Yes, I think implementations can have the freedom to do many things without the need to put it in the base spec.",
              "createdAt": "2019-05-06T09:56:43Z",
              "updatedAt": "2019-05-06T09:56:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzOTAzMzA3",
          "commit": {
            "abbreviatedOid": "d0db0e7"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T09:56:43Z",
          "updatedAt": "2019-05-06T09:56:43Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "addressed",
              "createdAt": "2019-05-06T09:56:43Z",
              "updatedAt": "2019-05-06T09:56:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzOTAzNTQz",
          "commit": {
            "abbreviatedOid": "d0db0e7"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T09:57:22Z",
          "updatedAt": "2019-05-06T09:57:22Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "ack; fixed",
              "createdAt": "2019-05-06T09:57:22Z",
              "updatedAt": "2019-05-06T09:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzOTAzNjkx",
          "commit": {
            "abbreviatedOid": "d0db0e7"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T09:57:43Z",
          "updatedAt": "2019-05-06T09:57:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "yep, sounds better. applied",
              "createdAt": "2019-05-06T09:57:43Z",
              "updatedAt": "2019-05-06T09:57:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0MTIyMDE4",
          "commit": {
            "abbreviatedOid": "d0db0e7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-06T18:14:11Z",
          "updatedAt": "2019-05-06T18:14:11Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d9773a45df353d47666c8dc32e9612e71863261c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln-clarify-connection-definition",
      "headRefOid": "d0db0e7ccc325ced1f5e395a37a8c852598d8bf4",
      "mergeCommit": {
        "oid": "7bb305f5bf8a3b4904ac381b56f85cc7fef45d83"
      }
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0NDE4NjEx",
      "title": "Merge Message References and Message Contexts and enable their use for Requests/Response protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/321",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "philsbln"
      ],
      "labels": [
        "API"
      ],
      "body": "This merges Message References with the Message Context (closes #310) and adds a reply call to the Message Context to enable the transport system to assign a response to the same underlying transport the request was received on.\r\n\r\nThis is another result of the discussion around PR #298 and implements most o the API part for #266",
      "createdAt": "2019-04-29T15:26:04Z",
      "updatedAt": "2019-07-08T13:28:10Z",
      "closedAt": "2019-07-03T07:17:31Z",
      "mergedAt": "2019-07-03T07:17:31Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The technical idea behind this PR is fine IMO; though I agree with @tfpauly that the messageContext parameter could be used instead of adding an extra parameter.",
          "createdAt": "2019-05-06T08:43:12Z",
          "updatedAt": "2019-05-06T08:43:12Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @tfpauly that linking replies with requests should be better done using the message context. However, this requires answering some design questions:\r\n 1. Should one be able to pass the message context from a message we received to the send of the reply? This would be really elegant, but may limit implementations.\r\n 2. Should the ```msgref``` returned by send really be an opaque identifier (as specified in this request) or should it me a message context object?\r\n\r\nIf we answer both with yes, I am happy to write more text in message contexts, otherwise, I am happy to move setting the request-reference to the message context.",
          "createdAt": "2019-05-06T10:16:49Z",
          "updatedAt": "2019-05-06T10:16:49Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I updated the PR to address @tfpauly's comments.  \r\n- merged the functionality of msgRef (which was not described anyway) into the Message Context.\r\n- merged send and receive Message Context.\r\n- realised the reply functionality using the Message Context.\r\n- clarified what the the Message Context is / does\r\n\r\nSorry for the force pushes, I accidentally fixed too many whitespace errors. ",
          "createdAt": "2019-05-15T10:15:58Z",
          "updatedAt": "2019-05-15T10:15:58Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did a merge and update pass to address @mwelzl's comments and also added a way to get the original request's Message Context from the reply's MessageContext",
          "createdAt": "2019-06-27T14:06:27Z",
          "updatedAt": "2019-06-27T14:06:27Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It would be good have some cleanup on the usage of contexts, and if we want to change the functions like send to return a context, explain in more detail what the returned value means.\r\n\r\nAgreed, but this is not a problem introduced by the PR, but that existed before for the ```msgRef``` and the MessageContext object.\r\nMaking the returned value a MessageContext object and clarifying that the MessageContexts used in ```send``` and ```recv``` are the same kind of object improves this in my opinion, but may in fact not be sufficient.\r\nThe question is whether we need to fix this in this PR or (if there are no other things blocking this) should merge the PR and do the cleanup in a separate PR.",
          "createdAt": "2019-06-27T15:36:48Z",
          "updatedAt": "2019-06-27T15:36:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tfpauly, @britram - should we press the Merge button on this one?",
          "createdAt": "2019-07-01T13:35:06Z",
          "updatedAt": "2019-07-01T13:35:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to hear the response for returning a message from Send... I'm OK to merge, but would want an issue to revisit that point.",
          "createdAt": "2019-07-01T14:53:25Z",
          "updatedAt": "2019-07-01T14:53:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzODAxMzEz",
          "commit": {
            "abbreviatedOid": "9ec1f3a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-05-05T22:51:13Z",
          "updatedAt": "2019-05-05T22:51:18Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "The messageContext parameter is exactly what this proposed message reference does. How about just adding more text to better explain the message context?",
              "createdAt": "2019-05-05T22:51:13Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzOTA2Mzc1",
          "commit": {
            "abbreviatedOid": "9ec1f3a"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-06T10:05:55Z",
          "updatedAt": "2019-05-06T10:05:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I agree that the functionality of linking requests to responses may be a better done using the message context than using this parameter. Doing so would require to answer a few additional questions (see below).",
              "createdAt": "2019-05-06T10:05:55Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NDQ3Mjg0",
          "commit": {
            "abbreviatedOid": "08b283a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM modulo a few comments. Only one technical thing really (double params in ReceivedPartial), but this may just be a glitch. All else are just nits.",
          "createdAt": "2019-06-26T08:14:17Z",
          "updatedAt": "2019-06-26T08:32:37Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "tiny fix: s/responses/response",
              "createdAt": "2019-06-26T08:14:17Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 40,
              "body": "just a nit: here, and in the \"code\" line above, s/replyMessgeContext/replyMessageContext",
              "createdAt": "2019-06-26T08:20:12Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 98,
              "body": "nit: remove \"and\" after \"contains\"",
              "createdAt": "2019-06-26T08:22:38Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 127,
              "body": "nit: I think this would read better as \"to enable mapping\" (to reduce the number of \"to\" occurrences in the sentence). But anyway, I'd rather not repeat the lower-level details here and instead say: \"The messageContext is provided to retrieve metadata about the message, see {{msg-ctx}}, and to refer to the message later on, e.g., to map responses to prior requests.\"   That's just a suggestion, it's ok for me either way.",
              "createdAt": "2019-06-26T08:25:58Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 140,
              "body": "huh? two messageContexts, with the same name even?",
              "createdAt": "2019-06-26T08:27:10Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 149,
              "body": "why two? and why is one written with a capital M?",
              "createdAt": "2019-06-26T08:27:42Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 165,
              "body": "I think this is grammatically challenged. PERHAPS it's correct if you add a comma after {{message-props}}, dunno; I'm quite sure it's correct if you use parantheses instead, i.e.: \"The application can set (see {{message-props}}) and query...\"",
              "createdAt": "2019-06-26T08:29:43Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            },
            {
              "originalPosition": 178,
              "body": "I think (not 100% sure) that there must be an \"a\" before \"reply\" here. Anyway, if you add the \"a\", I'm quite sure it's correct.",
              "createdAt": "2019-06-26T08:30:50Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MjAxNjU4",
          "commit": {
            "abbreviatedOid": "79454e4"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T12:48:44Z",
          "updatedAt": "2019-06-27T12:48:45Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "rewriting artefact - fixed",
              "createdAt": "2019-06-27T12:48:44Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MjAxOTUw",
          "commit": {
            "abbreviatedOid": "79454e4"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T12:49:19Z",
          "updatedAt": "2019-06-27T12:49:20Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "rewriting artefact - fixed",
              "createdAt": "2019-06-27T12:49:19Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MjQ5NTA1",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T14:03:58Z",
          "updatedAt": "2019-06-27T14:03:58Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Rewrote the paragraph to make it more readable",
              "createdAt": "2019-06-27T14:03:58Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mjk0MDk2",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T15:09:44Z",
          "updatedAt": "2019-06-27T15:09:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "What is this messageContext returned by Send()? If you pass in a messageContext, is it the same one?",
              "createdAt": "2019-06-27T15:09:44Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mjk0Mjcx",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T15:10:00Z",
          "updatedAt": "2019-06-27T15:10:00Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Typo: `replyMessgeContext` -> `replyMessageContext`",
              "createdAt": "2019-06-27T15:10:00Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mjk0NjY4",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T15:10:37Z",
          "updatedAt": "2019-06-27T15:10:37Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Also, it feels odd to have replyMessageContext come from the reply of itself. Should these be two separate variables?",
              "createdAt": "2019-06-27T15:10:37Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mjk1MzE0",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "It would be good have some cleanup on the usage of contexts, and if we want to change the functions like send to return a context, explain in more detail what the returned value means.",
          "createdAt": "2019-06-27T15:11:34Z",
          "updatedAt": "2019-06-27T15:11:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mjk2Njk0",
          "commit": {
            "abbreviatedOid": "a0a793b"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T15:13:44Z",
          "updatedAt": "2019-06-27T15:13:45Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yes \u2013 you only need it if you don't provide one. \r\nThis is necessary to get rid of the msgRef",
              "createdAt": "2019-06-27T15:13:45Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1MzA1NjI0",
          "commit": {
            "abbreviatedOid": "f81a9ff"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-27T15:27:00Z",
          "updatedAt": "2019-06-27T15:27:01Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Sorry - It seems it was way too hot (40\u00b0C+) in my office\u2026 \r\n```replyMessageContext := requestMessageContext.reply()```\r\nfixed",
              "createdAt": "2019-06-27T15:27:00Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1Mzk2MTQy",
          "commit": {
            "abbreviatedOid": "f81a9ff"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm fine with this - I tend to think that the right thing to do is to merge in this PR now, and then fix afterwards if there's something left that needs fixing.",
          "createdAt": "2019-06-27T18:13:10Z",
          "updatedAt": "2019-06-27T18:13:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2Mzg3NzQ4",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T14:52:00Z",
          "updatedAt": "2019-07-01T14:52:01Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This is to allow replying, correct? I'd say that if the application needed to get a reply, it should use an explicit messageContext instead.\r\n\r\nMy concern with returning a value that most often is not needed is that you then are often ignoring a return value, which is a warning often.",
              "createdAt": "2019-07-01T14:52:00Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2Mzg3ODg2",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T14:52:13Z",
          "updatedAt": "2019-07-01T14:52:13Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Looks like there's some extra whitespace here",
              "createdAt": "2019-07-01T14:52:13Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2Mzg4Mjgx",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T14:52:47Z",
          "updatedAt": "2019-07-01T14:52:48Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Are these only queryable on received messages?",
              "createdAt": "2019-07-01T14:52:48Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NzQ1MTQw",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T08:40:44Z",
          "updatedAt": "2019-07-02T08:40:44Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "I'd say they should be queryable on any MessageContext, but for sent messages, this is currently only possible after send. I'll add a note for this.",
              "createdAt": "2019-07-02T08:40:44Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NzUzNDYx",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T08:55:56Z",
          "updatedAt": "2019-07-02T08:55:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Okay \u2026 I see your point.\r\n\r\nThis design was not made for replying, but to allow to match errors to sends without creating an explicit message context first. I have no strong opinion what is worse - having a return value that is often ignored or needing to create a message context for matching error events to sends - so let's make this an issue and decide in Montreal whether to drop the return value.\r\n\r\nFor replying, one would use the ```MessageContext``` returned by the ```recv``` event for this. Also for matching replies, using  I would suspect rather using an explicit message context than saving the implicitly generated one.",
              "createdAt": "2019-07-02T08:55:56Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NzU2MTg0",
          "commit": {
            "abbreviatedOid": "68489b0"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T09:00:33Z",
          "updatedAt": "2019-07-02T09:00:33Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "fixed",
              "createdAt": "2019-07-02T09:00:33Z",
              "updatedAt": "2019-07-02T09:06:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDcwNTQy",
          "commit": {
            "abbreviatedOid": "dd416a3"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-02T18:24:19Z",
          "updatedAt": "2019-07-02T18:24:19Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6f5a28ec8c9cf996e5b1f61f169cc3c3a982fdbe",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln-msgref-reply",
      "headRefOid": "dd416a3f4337b9e6f45872f2f142e8c82339e94b",
      "mergeCommit": {
        "oid": "cc632a3269bc30eabeef7edd791f5546430f2369"
      }
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc2MzY0MTMw",
      "title": "Add details to the Framer Interface",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/323",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "This PR is based on the presentation given at IETF 104 and the received feedback regarding Framers. This enhances and clarifies the API text around how framers are set up and used.",
      "createdAt": "2019-05-06T22:16:10Z",
      "updatedAt": "2020-09-11T16:31:25Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d696d05f42e0bee4bb46d7af9d74c87ac8ebcb53",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/framer-api",
      "headRefOid": "cb02f56d3538796046bc84ef119dbc02a0040073",
      "closedAt": "2019-06-30T18:16:34Z",
      "mergedAt": "2019-06-30T18:16:34Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6f5a28ec8c9cf996e5b1f61f169cc3c3a982fdbe"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I agree that we should have an example somewhere, but I also thought this should be a different PR.",
          "createdAt": "2019-05-07T16:29:20Z",
          "updatedAt": "2019-05-07T16:29:20Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One comment/request: I would assume that most framers would have a length field. I wonder if it would be make sense to provide an interface to indicate where to find the length and move the parsing task into the transport. That would implementing simple framers that only have a length super easy...",
          "createdAt": "2019-05-08T12:36:06Z",
          "updatedAt": "2019-05-08T12:36:06Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not done, but did some cleanup to remove the Instance object, etc. Now there's just a MessageFramer that interacts with the Connection, which simplifies things a bunch.\r\n\r\nI'd like to add some diagrams, but also a code example of a simple length-value header framer.\r\n\r\nI was looking at our \"sample\" code for a client and server, and it's not clear to me in our syntax how we show what the code does upon receiving an event. Let's say, I want to show that my message framer is called to handle a new sent message. Where do I write that \"block\" of code? @britram @mwelzl ?",
          "createdAt": "2019-06-14T20:29:59Z",
          "updatedAt": "2019-06-14T20:29:59Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Earlier when we discussed an example, we agreed that we need it but that we could leave it out of this PR. Another answer: I think the receiving code is also changed by PR #332. ISTM that landing this one as well as #332 first, and then writing this example code would be a good sequence.\r\n\r\nUPDATE: I just noticed that you approved PR #332 three minutes ago, so I just clicked the \"merge\" button. I hope that this makes things easier.",
          "createdAt": "2019-06-14T21:21:28Z",
          "updatedAt": "2019-06-14T21:24:16Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln thanks for the comments! I added more clarification that there's a Message Framer object that delivers events to the framer implementation code, and made it more clear that this \"framer implementation\" code is something that the application or some other library does, and it's what receives the events to actual do the framing and run its code.",
          "createdAt": "2019-06-20T00:36:42Z",
          "updatedAt": "2019-06-20T00:36:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl @britram can you take another look at the state of the PR? I'd like to see this merged and then iterate more if we need, to make sure that other work (like the message context PR) make sense with this and don't get out of sync.",
          "createdAt": "2019-06-27T15:12:47Z",
          "updatedAt": "2019-06-27T15:12:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So sorry for leaving this dangling!  I looked at this PR recently but was too clumsy to notice that my requests have long been addressed  :(    now, I'd be fine with merging this, but again I'm afraid of my clumsiness because this talks of conflicts...   my suggestion: give @britram a day or two too, and then just go ahead and merge this in yourself. Either way, I think it's easy to agree that we should merge this now, and if there would be small fixes needed they can still be done later.",
          "createdAt": "2019-06-27T16:11:36Z",
          "updatedAt": "2019-06-27T16:11:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, based on @mwelzl's request, merging in now. Please file new issues for further changes!",
          "createdAt": "2019-06-30T18:16:29Z",
          "updatedAt": "2019-06-30T18:16:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0Mzc4NDgz",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I made some minor requests. Why I don't want to require this to be part of this PR, I do think that we've reached a point with framers where we really need a simple example - more concretely than the \"example\" paragraph that talks about how to parse a header length field, in the form of Pseudocode. E.g., an application with TLV encoding perhaps?",
          "createdAt": "2019-05-07T08:30:15Z",
          "updatedAt": "2019-05-07T08:45:02Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "A protocol usually includes more than just adding and parsing headers: it also defines a sequence of communication (and that may come with timeouts and such). I think framers can be simpler than that - if a framer just adds and removes a header, I think it's wrong to call it a protocol. You talk about simple application protocols as framers by example later in the text, and I think that's okay - I just don't like the statement here that says that they \"are implementations of simple protocols\". Also, there's no need for them to be simple... I also wouldn't want to claim that. Can we just rephrase this to something like \"Message Framers are converters that translate between application Message data and raw transport protocol data.\"  ?",
              "createdAt": "2019-05-07T08:30:16Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 184,
              "body": "First, a nit: this should be \"an object\".\r\n\r\nSecond, more importantly: this is now written for object-oriented languages. I think there's no good way to write text about framers without deciding either to talk about objects or to talk about callbacks... so my proposal would be to preface this sentence with a statement like the following:\r\n\r\nWe describe Message Framers assuming an object-oriented programming language. In the case of programming languages that are not object-oriented, a Message Framer can be thought of as a number of functions and static data that they operate on. Adding a Framer to a MessageContext, as below, would then mean to register a callback to a function of the framer.",
              "createdAt": "2019-05-07T08:40:20Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 270,
              "body": "\"send a data\" sounds broken. \"send a block of data\" or \"send data\" ?",
              "createdAt": "2019-05-07T08:41:05Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 282,
              "body": "s/even/event",
              "createdAt": "2019-05-07T08:41:29Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 240,
              "body": "Here, and below, I wonder about this use of \"instance\". Above you talk about a a FramerInstance and call Start and Stop on it. Why has this FramerInstance only become \"instance\" all of a sudden?",
              "createdAt": "2019-05-07T08:42:54Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NTM0MDk1",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the general representation of framers and we should definitely in that direction.\r\n\r\nHowever, I am a bit puzzled with regards on the interactions between the objects. It looks somehow mixed up and either needs fixing or explanation. \r\n\r\nIn addition, I have the feeling we should give a hint what kind of data to put in the message context and what in the message object. At the moment, one could pass NULL messages and add all bits and pieces to the message context.",
          "createdAt": "2019-05-07T14:02:55Z",
          "updatedAt": "2019-05-07T14:22:01Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "@mwelzl: This is true for most of our API description and not specific to framers.\r\nI would not add this kind of hit here, but maybe at a more general place.",
              "createdAt": "2019-05-07T14:02:55Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 211,
              "body": "This syntax overlaps with the syntax for message properties \u2013 while this is very elegant, it might add a lot of confusion for languages without polymorphism.",
              "createdAt": "2019-05-07T14:06:21Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 198,
              "body": "How do we do the ordering of framers here?\r\nHow can I slide in framers later, e.g., for STARTTLS?",
              "createdAt": "2019-05-07T14:07:33Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 262,
              "body": "While this is a valid comment, is this really something that belongs in the API?",
              "createdAt": "2019-05-07T14:09:17Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 279,
              "body": "This example broken:\r\n- FramerInstance is the receiver of the event, not the sender\r\n- We have no other events with \"handle\" in the name\r\n- Arguments (Data + Context are missing)",
              "createdAt": "2019-05-07T14:13:41Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 288,
              "body": "why is this a call on the framer, and not on the connection?",
              "createdAt": "2019-05-07T14:15:33Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI0NTE0",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:25:18Z",
          "updatedAt": "2019-05-07T16:25:18Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "Yeah, that's a typo. Should be `send a block of data`.",
              "createdAt": "2019-05-07T16:25:18Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI0NTg1",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:25:26Z",
          "updatedAt": "2019-05-07T16:25:26Z",
          "comments": [
            {
              "originalPosition": 282,
              "body": "Yup, thanks.",
              "createdAt": "2019-05-07T16:25:26Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI1MTI3",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:26:32Z",
          "updatedAt": "2019-05-07T16:26:33Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Not sure on our pseudocode parlance, but this was representing the call that an app would make on a local variable that holds their reference to a FramerInstance. Having `FramerInstance.ready()` looks like a \"class method\" rather than an \"instance method\".",
              "createdAt": "2019-05-07T16:26:32Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI1NzQ0",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:27:43Z",
          "updatedAt": "2019-05-07T16:27:44Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "They are one of the simplest forms of protocol, I'd argue. They certainly can have flags, etc, in their headers that do some communication. For example, WebSocket is a protocol and certainly is something you'd implement as a framer.",
              "createdAt": "2019-05-07T16:27:43Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI2Mjk0",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:28:49Z",
          "updatedAt": "2019-05-07T16:28:49Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "Thanks for the typo.\r\n\r\nMainly, I'm using object since we are using object in the rest of the interface description. Even for a non-object oriented language, you can still refer to an allocated structure with defined functions to use as an \"object\". A Connection is an object, etc.",
              "createdAt": "2019-05-07T16:28:49Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI2OTA2",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:30:06Z",
          "updatedAt": "2019-05-07T16:30:06Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Because this is what the framer implementation does to read out the bytes. You can't call it on the top of a connection\u2014that's for the application. There can be multiple framers in a connection, and you want to be able to parse the inbound data available for your instance of a framer.",
              "createdAt": "2019-05-07T16:30:06Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI3Nzc3",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:31:48Z",
          "updatedAt": "2019-05-07T16:31:48Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "No, FramerInstance is not the receiver of the event, it *is* the sender. It's the handle to the representation of the framer within the Connection that you interact with. It's your state. It says: your framer now has data available.\r\n\r\nThe data for new inbound data should not be provided in this event\u2014the implementation of the framer needs to parse the data out. The data may not be in a form that is efficiently consumable as a single data object (it's an entire stream).",
              "createdAt": "2019-05-07T16:31:48Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI3OTk0",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:32:18Z",
          "updatedAt": "2019-05-07T16:32:18Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "This is based on the discussion at IETF 104 that indicated we wanted to ensure that the API allows for 0-copy. That is an API semantic decision.",
              "createdAt": "2019-05-07T16:32:18Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI4MTY4",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:32:38Z",
          "updatedAt": "2019-05-07T16:32:39Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Yes, you should be able to dynamically add. We'd need new text for that.",
              "createdAt": "2019-05-07T16:32:38Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjI4MzY2",
          "commit": {
            "abbreviatedOid": "bcc7251"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:33:02Z",
          "updatedAt": "2019-05-07T16:33:02Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Sure, in another language, you could have it be `addFramerMessageValue` or something.",
              "createdAt": "2019-05-07T16:33:02Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NjMxMTY4",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T16:38:44Z",
          "updatedAt": "2019-05-07T16:38:45Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Added text for this.",
              "createdAt": "2019-05-07T16:38:44Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzQ5OTI3",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I agree with Philipp in that the general direction is good but I am also very confused on why some things are events and who fires them, why the application appears to set up eventhandlers for the framer and the general interaction between the connection, application and framer. ",
          "createdAt": "2019-05-07T20:40:06Z",
          "updatedAt": "2019-05-07T21:15:07Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "I am confused by this part,[ if FramerInstance, i.e. the framer object created by the application, is the sender of the event, who is the receiver?](https://github.com/ietf-tapswg/api-drafts/pull/323/files#r281719368) How does the framer learn of a new connection? \r\n\r\nIt might just be me not understanding the notation correctly because in the text you do say that the framer _receives_ the event.\r\n\r\nIf FramerInstance is not the same as framer, maybe it would be good to clarify what it actually is. ",
              "createdAt": "2019-05-07T20:40:06Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 190,
              "body": "I am unsure what the point of these event handlers is, is the framer supposed to directly interact with the application without going through the connection?",
              "createdAt": "2019-05-07T20:44:19Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 235,
              "body": "If the framer calls 'ready', what does the interface with the connection look like? Why is this not an event that gets fired but rather a callable? \r\n\r\nSame questions for instance.failed(Error).",
              "createdAt": "2019-05-07T20:55:46Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 271,
              "body": "What happens if the final protocol has been reached? How does the message that went through all layers of framers get returned to the connection so it can be send out?",
              "createdAt": "2019-05-07T21:00:23Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 275,
              "body": "What exactly is this call supposed to do? Does it actually send out the message? If it does, why should the framer and not the connection be responsible for sending now?",
              "createdAt": "2019-05-07T21:04:06Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 313,
              "body": "This is another point where I am unsure on how the framer actually interfaces with the connection. Who calls instance.advanceReceiveCursor? ",
              "createdAt": "2019-05-07T21:12:14Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgxMTgz",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:55:51Z",
          "updatedAt": "2019-05-07T21:55:52Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "FramerInstance is not created by the application. It is created by the connection, as the handle to the instance of the framer. The MessageFramer object is the definition created by the application.",
              "createdAt": "2019-05-07T21:55:52Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgxMzY1",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:56:23Z",
          "updatedAt": "2019-05-07T21:56:23Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "You need something to add to the connection. The MessageFramer is the object that the application creates to do this.",
              "createdAt": "2019-05-07T21:56:23Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgxNTgw",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:57:00Z",
          "updatedAt": "2019-05-07T21:57:00Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "This is the event that the application's implementation of the framer sends to influence the main ready callbacks on the connection itself. It causes the event on the connection.",
              "createdAt": "2019-05-07T21:57:00Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgxOTU2",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:58:08Z",
          "updatedAt": "2019-05-07T21:58:08Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "The framers are part of the connection protocol stack.. they go down to the transport next.",
              "createdAt": "2019-05-07T21:58:08Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgyMTkz",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:58:46Z",
          "updatedAt": "2019-05-07T21:58:46Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "It sends data down to the next protocol down in the stack. The application sends original data on the connection, it gets sent to the first framer, which sends it to the next, which eventually sends it to the transport, which sends it out the device.",
              "createdAt": "2019-05-07T21:58:46Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0NzgyMjY4",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T21:58:59Z",
          "updatedAt": "2019-05-07T21:58:59Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "The application's implementation of the framer.",
              "createdAt": "2019-05-07T21:58:59Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0OTAxODI2",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T07:25:03Z",
          "updatedAt": "2019-05-08T07:25:03Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "Okay - I got it. Also makes sense not to specify who receives this Event, as it could be another Framer or the connection object to forward it to the application.\r\n\r\nCan we try to make this event match the Received/ReceivedPartial event somehow? \r\nThis would look much more consistent and allows to directly send it from the Framer.",
              "createdAt": "2019-05-08T07:25:03Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0OTAyNjYz",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T07:27:12Z",
          "updatedAt": "2019-05-08T07:27:12Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "As with the ```HandleReceivedData<>```, making it analogous to ``` Received/ReceivedPartial``` would cause less confusion here",
              "createdAt": "2019-05-08T07:27:12Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0OTAzNTQ4",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T07:29:25Z",
          "updatedAt": "2019-05-08T07:29:25Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Why this? This deprives the application of the ability to pass arguments to the Framer's constructor.",
              "createdAt": "2019-05-08T07:29:25Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0OTA0MDg5",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T07:30:47Z",
          "updatedAt": "2019-05-08T07:30:48Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "Firing a Send-Event to the next instance would look much more consistent here\u2026",
              "createdAt": "2019-05-08T07:30:47Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0OTI5NTE3",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T08:32:39Z",
          "updatedAt": "2019-05-08T08:32:40Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Oh I finally I think I understand where my confusion comes from. I assumed that the application was free to create their own framer class that had to expose certain functions for interaction with the connection, so I was looking for that interface. Sorry, my bad.\r\n\r\nThe place where the application now implements the behavior of framer is in the eventHandlers it sets, is that correct? ",
              "createdAt": "2019-05-08T08:32:39Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MDM3NTgy",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "adfalk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T12:52:35Z",
          "updatedAt": "2019-05-08T12:52:36Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "Maybe consider adding a railroad diagram to better illustrate the flow?",
              "createdAt": "2019-05-08T12:52:36Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MDU3NTA4",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T13:32:08Z",
          "updatedAt": "2019-05-08T13:32:08Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "You say \"can\", and I agree, but that doesn't cover all cases. I agree that they *can* be simple protocols, but I think the simplest possible framer is no protocol. E.g., a  TLV encoding alone really isn't a protocol, it's just a format. So I think this is wrong to state.",
              "createdAt": "2019-05-08T13:32:08Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MDU4NzQ3",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T13:34:28Z",
          "updatedAt": "2019-05-08T13:34:28Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "@fpauly I agree that there is some OO flavor through the whole document anyway. So maybe it's fine. I agree to not do anything about this now - and I agree with @philsbln that this is a more general thing and might better be written at a more general place, if we end up writing such a thing at all.\r\n\r\nConclusion: for this PR, I agree to leave it as it is.",
              "createdAt": "2019-05-08T13:34:28Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MDU5NDc3",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T13:36:00Z",
          "updatedAt": "2019-05-08T13:36:00Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "...because of the capitalization?  :-)\r\nI guess what makes this most confusing is that the Framer, if it's a class, shouldn't be called FramerInstance. Not sure how to best clean this up, but it does need cleaning.",
              "createdAt": "2019-05-08T13:36:00Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MTE3Mzc2",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the text and starting the discussion!\r\n\r\nTwo high-level comments:\r\n\r\n(1) This seems to have a particular implementation too specifically in mind. Please generalize. \r\n\r\n(2) Pictures and examples would help, too.\r\n\r\n(Will re-review after the rest of the raft of comments have been addressed.)",
          "createdAt": "2019-05-08T15:12:16Z",
          "updatedAt": "2019-05-08T16:19:45Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "is this intentional?",
              "createdAt": "2019-05-08T15:12:17Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 26,
              "body": "nit: \"Message Framer\" suffices here.",
              "createdAt": "2019-05-08T15:13:31Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 131,
              "body": "ISTM that \"simple protocol\" is technically correct (\"the best kind of correct!\") but is likely be more confusing that clarifying. I'd try framing (ha!) this differently.",
              "createdAt": "2019-05-08T15:29:10Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 231,
              "body": "How much of this is essential to the interface, and how much of it is particular to a given implementation approach? Exposing a thing called FramerInstance is a yellow flag to me here...",
              "createdAt": "2019-05-08T15:33:21Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 190,
              "body": "so I think that @MaxF12 is on to something here. The generalized interface should be simpler and allow idiomatic implementation.  In most languages (I'm familiar with) the idiomatic way to use an interface would be something like:\r\n\r\n(1) application implements a framer or grabs an implementation off the shelf, and makes this framer available to the preconnection/listener.\r\n\r\n(2) taps maintains a framer context for each connection, where the contents of the framer context are framer specific. \r\n\r\nIn idiomatic Java, for instance, the implementation would be a TransportServicesConnectionFramerFactory which would spit out TransportServicesConnectionFramers. In C, the framer is a struct of function pointers each of which takes a context. In a CSP patterned Go implementation, it's a struct with funcs reading messages/bytechunks from channels, each connection of which gets those funcs running as goroutines. And so on. \r\n\r\nThis arrangement seems to make these sorts of idioms more difficult.",
              "createdAt": "2019-05-08T15:47:48Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MTU5NDQ3",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T16:27:41Z",
          "updatedAt": "2019-05-08T16:27:41Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Whoops, that was meant to just be author",
              "createdAt": "2019-05-08T16:27:41Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MjkzMTIz",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T21:06:45Z",
          "updatedAt": "2019-05-08T21:06:45Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Thank you Brian, thats exactly what I couldn't quite put my finger on. \r\n\r\nThe previous iteration of framers made it very simple for applications that had no interest in implementing them to grab a framer implementation someone else provided and use it. All the calls and callbacks between the implementation and the TAPS system stayed the same, independent of whether or not a framer was used. I think its important to keep the part of the interface application developers use simple while adding complexity in the part someone that implements a framer would use, because at least to me these are two different groups of people.",
              "createdAt": "2019-05-08T21:06:45Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1Mjk4Njgx",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T21:20:13Z",
          "updatedAt": "2019-05-08T21:20:13Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Agreed. The code here is just how you implement a custom framer. The calls to actually add it to a connection (the common action) is below.",
              "createdAt": "2019-05-08T21:20:13Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM1MzIwNDY5",
          "commit": {
            "abbreviatedOid": "acf5371"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-08T22:22:13Z",
          "updatedAt": "2019-05-08T22:22:13Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "Of course, my bad. I totally missed that part, that makes things a lot clearer and I now understand the advantage of doing it this way around, thanks.\r\n\r\nOn a different note, why is the framer explicitly exposing a setEventHandlers call while neither the preconnection nor the connection expose something similar even though they issue events as well? ",
              "createdAt": "2019-05-08T22:22:13Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTA2ODc3",
          "commit": {
            "abbreviatedOid": "390ef93"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T20:27:11Z",
          "updatedAt": "2019-06-14T20:27:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Fixed",
              "createdAt": "2019-06-14T20:27:11Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTA2OTE5",
          "commit": {
            "abbreviatedOid": "390ef93"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-14T20:27:18Z",
          "updatedAt": "2019-06-14T20:27:18Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Fixed",
              "createdAt": "2019-06-14T20:27:18Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxNTcxMjU4",
          "commit": {
            "abbreviatedOid": "390ef93"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for making the Interface clearer and easier.\r\n\r\nI am still a little confused by the interaction pattern and what a Framer object really is.\r\n - Is a Framer object something provided by the Transport System that tracks state of the de-framing process, like a Cursor or\r\n - Is a Framer an object provided by the application or a library that implements the Framer protocol.\r\n\r\nAt the moment, the beginning of the texts suggests the latter while the interaction pattern suggest the former. ",
          "createdAt": "2019-06-19T09:16:08Z",
          "updatedAt": "2019-06-19T10:12:25Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Maybe add a forward reference how to prependFramer here",
              "createdAt": "2019-06-19T09:16:08Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 211,
              "body": "works for me",
              "createdAt": "2019-06-19T09:16:25Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 237,
              "body": "This Syntax is inconsistent. It says the MessageFramer emits a Start/Stop Event, but the text says it consumes it.",
              "createdAt": "2019-06-19T09:19:14Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 262,
              "body": "Do we only want to support prepend here or should we also allow to append framers here?",
              "createdAt": "2019-06-19T09:48:13Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 266,
              "body": "deliver or get?",
              "createdAt": "2019-06-19T09:49:50Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            },
            {
              "originalPosition": 303,
              "body": "This implies a Framer would always operate on a byte stream / partial message.\r\nShould we add an Interface to de-frame data that is already a Message?",
              "createdAt": "2019-06-19T10:01:37Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDMyMjM2",
          "commit": {
            "abbreviatedOid": "390ef93"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:24:03Z",
          "updatedAt": "2019-06-20T00:24:03Z",
          "comments": [
            {
              "originalPosition": 303,
              "body": "Hm, so it should be able to handle messages fine, since this is handling partial messages. I think the most common case of framer is over a bye stream, so I think handling that by default is important. But if you have a high `MinimumIncompleteLength`, any shorter Message will just be delivered along with `IsEndOfMessage`.\r\n\r\nI suppose the thing to add here is the Message object itself.",
              "createdAt": "2019-06-20T00:24:03Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDM0MzU5",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:35:03Z",
          "updatedAt": "2019-06-20T00:35:03Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Added!",
              "createdAt": "2019-06-20T00:35:03Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDM0Mzk4",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:35:15Z",
          "updatedAt": "2019-06-20T00:35:15Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "Clarified event delivery",
              "createdAt": "2019-06-20T00:35:15Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDM0NDc3",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:35:39Z",
          "updatedAt": "2019-06-20T00:35:40Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "I think, since handshakes build from the bottom up, and you don't want outstanding data in the stream below you, it's only safe to prepend.",
              "createdAt": "2019-06-20T00:35:40Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDM0NDkz",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:35:43Z",
          "updatedAt": "2019-06-20T00:35:43Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Clarified event delivery",
              "createdAt": "2019-06-20T00:35:43Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMDM0NTE2",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T00:35:51Z",
          "updatedAt": "2019-06-20T00:35:51Z",
          "comments": [
            {
              "originalPosition": 303,
              "body": "Added MessageContext here.",
              "createdAt": "2019-06-20T00:35:51Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMjAyOTI4",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-20T10:12:17Z",
          "updatedAt": "2019-06-20T10:12:18Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Right. So if a would do some kind of multiplexing within my framer, i can not easily reuse other framers that further process my messages. Anyway, this would require to dispatch stuff to another framer, not appending it.",
              "createdAt": "2019-06-20T10:12:17Z",
              "updatedAt": "2019-06-30T18:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUyMjM0NzU2",
          "commit": {
            "abbreviatedOid": "7e5b550"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you @tfpauly for clarifying - now it is clear what a framer is.\r\n\r\nI still don't like the the design of a framer being an object provided by the transport system that takes care of the buffer management, while the actual framing is done in in callbacks interacting with it. \r\nWhile this is a very reasonable design to minimise copying data, it really feels wrong from an OO perspective.\r\n\r\nDespite this dislike, I think we should land this PR now and discuss the design in Montreal.",
          "createdAt": "2019-06-20T11:31:08Z",
          "updatedAt": "2019-06-20T11:31:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 326,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5MTEwMDE1",
      "title": "Note that Idempotent is needed for UDP like protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/326",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #302 ",
      "createdAt": "2019-05-15T13:56:03Z",
      "updatedAt": "2019-06-17T07:59:15Z",
      "closedAt": "2019-05-29T07:50:23Z",
      "mergedAt": "2019-05-29T07:50:23Z",
      "mergedBy": "philsbln",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4MjExNjEx",
          "commit": {
            "abbreviatedOid": "12d0143"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the approach but it needs a fix IMO, see my suggestions.",
          "createdAt": "2019-05-16T07:09:49Z",
          "updatedAt": "2019-05-16T07:13:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I would add an extra sentence here to say, e.g.: \"For protocols that do not protect against duplicated messages, e.g., UDP, a default Message Property of Idempotent=enabled must be assigned.\"",
              "createdAt": "2019-05-16T07:09:49Z",
              "updatedAt": "2019-05-16T08:07:00Z"
            },
            {
              "originalPosition": 20,
              "body": "This is good, but I think it's important to add something like this: \"If Idempotent has been chosen as a default for the Preconnection, it may not be possible to enable it per Message later.\"\r\n\r\nI mean, once UDP has been chosen, disabling Idempotent can't work, right?  So if the transport system still offers it, this produces a wrong expectation for an application. We should think if there are other Message Properties that have the same kind of behavior. I guess so - what if reliability = off by default? We MAY be able to enable it later (e.g. if SCTP with partial reliability was chosen, or even TCP, simply sending everything reliable), but it can't be promised (e.g. if UDP was chosen).",
              "createdAt": "2019-05-16T07:13:12Z",
              "updatedAt": "2019-05-16T08:07:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4MjMwMDM5",
          "commit": {
            "abbreviatedOid": "12d0143"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-16T07:55:24Z",
          "updatedAt": "2019-05-16T07:55:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I thought about it, but decided against putting it there. This is a general section, and does not describe special cases. We may add it as an example here, but still looks like an odd place for this.",
              "createdAt": "2019-05-16T07:55:24Z",
              "updatedAt": "2019-05-16T08:07:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4MjMwNzM0",
          "commit": {
            "abbreviatedOid": "12d0143"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-16T07:56:53Z",
          "updatedAt": "2019-05-16T07:56:53Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "If you disable idempotent later, this may or may not work (as most message properties) I will add a hint here.",
              "createdAt": "2019-05-16T07:56:53Z",
              "updatedAt": "2019-05-16T08:07:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4MzEyMjEz",
          "commit": {
            "abbreviatedOid": "12d0143"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-16T10:38:54Z",
          "updatedAt": "2019-05-16T10:38:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That works for me",
              "createdAt": "2019-05-16T10:38:54Z",
              "updatedAt": "2019-05-16T10:38:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4Mzc0Njcy",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-16T12:59:58Z",
          "updatedAt": "2019-05-16T12:59:59Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with @philsbln that it does not fit to add such details here.",
              "createdAt": "2019-05-16T12:59:59Z",
              "updatedAt": "2019-05-16T12:59:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4ODQyMTM5",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-17T10:05:40Z",
          "updatedAt": "2019-05-17T10:05:41Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Should you be able to change the default message properties after connection establishment? Right now you would not be able to as the preconnection gets consumed. ",
              "createdAt": "2019-05-17T10:05:41Z",
              "updatedAt": "2019-05-17T10:05:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4ODQ2NzUw",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-17T10:16:39Z",
          "updatedAt": "2019-05-17T10:16:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure this is necessary to specify. Clearly a connection can change the per-message properties at any time - but I suggest that changing the default established in the preconnection adds more  text which isn't strictly necessary. Omitting this does not prevent an API providing it as an additional feature, but then it would then need to work out what to do when the connection is cloned and preconnection properties are replicated. I'd rather not delve there.",
              "createdAt": "2019-05-17T10:16:39Z",
              "updatedAt": "2019-05-17T10:16:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4ODQ3MDI1",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-17T10:17:18Z",
          "updatedAt": "2019-05-17T10:17:19Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@MaxF12 This is possible by changing the properties on the Connection object. Doing it on the Preconnection would be harmful, as we want to make the preconnection reusable. If you think this needs discussion, please open a new Issue for that.",
              "createdAt": "2019-05-17T10:17:19Z",
              "updatedAt": "2019-05-17T10:17:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MzEwNDI4",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "wfm",
          "createdAt": "2019-05-20T06:25:48Z",
          "updatedAt": "2019-05-20T06:25:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQyNzU1MjAy",
          "commit": {
            "abbreviatedOid": "72ae9f6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-28T15:38:20Z",
          "updatedAt": "2019-05-28T15:38:20Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7bb305f5bf8a3b4904ac381b56f85cc7fef45d83",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/udp-idempotence",
      "headRefOid": "72ae9f6a55870610743529b205fd99f2dbe9569f",
      "mergeCommit": {
        "oid": "238e09fd4abc332388e055f4071589c982d49090"
      }
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5ODYzMTg1",
      "title": "Adding a way of forcing the use of specific protocols",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/327",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This fixes issue #324.\r\n\r\nThe solution involves specifying protocol sets on the local endpoint.\r\nNote that the text is dependent the introduction of Transport Property Profiles.",
      "createdAt": "2019-05-17T11:56:30Z",
      "updatedAt": "2020-09-11T16:31:29Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e896126119b6eea9ace1f7f43a90e440c6915a59",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/explicit-protocols",
      "headRefOid": "e9a924e97c49db52e77b4cb114d1e5eb381cc2a6",
      "closedAt": "2019-07-24T20:48:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this extension, and thanks for opening the issue.\r\n\r\nAs written, it leaves me guessing about at least one assumption, which I think would be:\r\n\r\nIf the constrained protocol choice conflicts with the default TransportProperties, the TransportProperties _also_ must be set to something compatible, or you'd get an error when calling connect or listen, correct?\r\n\r\n In particular, I think this would always fail with error:\r\n\r\n~~~\r\n   Preconnection := NewPreconnection(\r\n           NewLocalEndpoint.WithProtocols(\"udp\"),\r\n           NewRemoteEndpoint.WithHostname(\"example.com\").WithPort(9000),\r\n           NewTransportProperties(),\r\n           NewSecurityParameters())\r\n~~~\r\n\r\nFixing it would require explicitly suppressing the several default-require transport properties that conflict with udp in order to have a chance at not erroring:\r\n\r\n~~~\r\n   Preconnection := NewPreconnection(\r\n           NewLocalEndpoint.WithProtocols(\"udp\"),\r\n           NewRemoteEndpoint.WithHostname(\"example.com\").WithPort(9000),\r\n           NewTransportProperties()\r\n                .Ignore(reliability)\r\n                .Ignore(preserve-order)\r\n                .Ignore(congestion-control),\r\n           NewSecurityParameters())\r\n~~~\r\n\r\nIs that expected?  Does it need to be made explicit?\r\n\r\nAnd was there an intent for this to be made simpler with protocol-based profiles for TransportProperties?",
          "createdAt": "2019-05-20T17:08:02Z",
          "updatedAt": "2019-05-20T17:08:02Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suspect with the addition of profiles, the solution should rather look like:\r\n\r\n~~~\r\n   Preconnection := NewPreconnection(\r\n           NewLocalEndpoint.WithProtocols(\"udp\"),\r\n           NewRemoteEndpoint.WithHostname(\"example.com\").WithPort(9000),\r\n           NewTransportProperties(unreliable-datagram)\r\n           NewSecurityParameters())\r\n~~~\r\n\r\nwith \"unreliable datagram\" implying\r\n\r\n~~~\r\n           NewTransportProperties()\r\n                .avoid(reliability)\r\n                .avoid(preserve-order)\r\n                .avoid(congestion-control)\r\n                .add(idempotent, true)\r\n           }\r\n~~~",
          "createdAt": "2019-05-21T07:08:14Z",
          "updatedAt": "2019-05-21T07:08:14Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See PR #328 for a concrete proposal for profiles",
          "createdAt": "2019-05-21T09:39:37Z",
          "updatedAt": "2019-05-21T09:39:37Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm confused: after you have #328, why do you need this?",
          "createdAt": "2019-07-03T13:55:24Z",
          "updatedAt": "2019-07-03T13:55:24Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram I share your confusion after re-reading it\u2026 there was something mixed up.\r\n\r\nI see the following two cases:\r\n\r\n1. If you need a UDP like protocol #328 solves your problem:\r\n~~~\r\n   Preconnection := NewPreconnection(\r\n           NewRemoteEndpoint.WithHostname(\"example.com\").WithPort(9000),\r\n           NewTransportProperties(unreliable-datagram)\r\n           NewSecurityParameters())\r\n~~~\r\n\r\n2. If you need exactly UDP because you defined a behaviour based on the protocol headers -- I don't find an example where this is useful, but I have several for TCP -- you need #327:\r\n~~~\r\n   Preconnection := NewPreconnection(\r\n           NewLocalEndpoint.WithProtocols(\"udp\"),\r\n           NewRemoteEndpoint.WithHostname(\"example.com\").WithPort(9000),\r\n           NewTransportProperties(unreliable-datagram)\r\n           NewSecurityParameters())\r\n~~~",
          "createdAt": "2019-07-04T09:13:39Z",
          "updatedAt": "2019-07-04T09:13:39Z"
        },
        {
          "author": "GrumpyOldTroll",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It just occurred to me to wonder: Is there any reason we shouldn't do exact protocol selection as an inheriting subclass of a transport property profile?\r\n\r\nSo maybe \"exact-udp\" inherits from \"unreliable-datagram\", and app designer just picks what they need as a transport profile?\r\n\r\nI usually don't much care for inheritance, but are there cases where this wouldn't be as good or better? \r\nI agree with Anna I don't much like exact protocol selection in LocalEndpoint.",
          "createdAt": "2019-07-08T01:38:10Z",
          "updatedAt": "2019-07-08T01:38:10Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As suggested several times, I changed the way of forcing specific protocol stacks into an ordinary Selection Property. This comes at the cost of introducing a list type for properties.\r\n\r\n@GrumpyOldTroll I don't think inheritance solves the problem here, as one may want to give the transport system a choice between multiple sets of protocols. For example, SIP is defined to operate over SCTP, UDP or TCP \u2013 therefore, we would need a fairly generic set of Selection Properties that allows to use any of these and the newly introduced Property to force to us no other matching protocol.",
          "createdAt": "2019-07-08T08:41:12Z",
          "updatedAt": "2019-07-08T08:41:12Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay. I'm still not a giant fan of this, because I'm pretty sure it'll get abused. Some extra text stating that this is basically only intended for special circumstances (e.g., implementing a layer-4+-topped stack over a specific layer-4-topped stack) would address that as best we can in an abstract API, though.",
          "createdAt": "2019-07-22T17:43:55Z",
          "updatedAt": "2019-07-22T17:43:55Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm also not a fan. I think it should be a bit hard to force use of one specific protocol because the whole idea of this exercise is to have an interface that is NOT protocol-specific.",
          "createdAt": "2019-07-22T17:55:23Z",
          "updatedAt": "2019-07-22T17:55:23Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought the text in this PR is already quite clear that this property is only for wired special cases.\r\n  \r\n@britram please make a suggestion how to make the text even more hostile for people that want to use the property. ",
          "createdAt": "2019-07-23T15:23:05Z",
          "updatedAt": "2019-07-23T15:23:05Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Per discussion on #324, we're going to do this another way.",
          "createdAt": "2019-07-24T20:48:36Z",
          "updatedAt": "2019-07-24T20:48:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4OTQ1MjQ0",
          "commit": {
            "abbreviatedOid": "6c2f580"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like the fact that this gets added but I think there might be a change required in arch and/or impl that notes how racing behaves and what happens to specified transport properties if one or multiple protocols are forced.",
          "createdAt": "2019-05-17T14:07:10Z",
          "updatedAt": "2019-05-17T14:08:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Why is this done on the local endpoint object rather than on the transport properties object? ",
              "createdAt": "2019-05-17T14:07:10Z",
              "updatedAt": "2019-07-23T20:56:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MTk3Njgw",
          "commit": {
            "abbreviatedOid": "6c2f580"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-18T12:58:17Z",
          "updatedAt": "2019-05-18T12:58:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The reason is that really forcing a protocol end-to-end is hard and requires crypto. Therefore, we only force the protocol at the local endpoint. On the path, there may be proxies or protocol converters, so that the Remote Endpoint may use another protocol. Adding it on the Local Endpoint object makes this explicit.",
              "createdAt": "2019-05-18T12:58:17Z",
              "updatedAt": "2019-07-23T20:56:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNjUzMTk5",
          "commit": {
            "abbreviatedOid": "6c2f580"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-24T09:55:51Z",
          "updatedAt": "2019-05-24T09:55:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I also find using the endpoint object confusing and agree with Max that it should be a transport property. It is used as a property for the selection and racing so we should keep all this together. (I am not convinced by the argument for why we should use the endpoint object. The path could violate other transport properties as well then.)",
              "createdAt": "2019-05-24T09:55:52Z",
              "updatedAt": "2019-07-23T20:56:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MzM2NjA3",
          "commit": {
            "abbreviatedOid": "6c2f580"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-05T10:31:57Z",
          "updatedAt": "2019-07-05T10:31:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "There is another argument why realising this as Transport Property is a little painful: what would the following mean:\r\n~~~\r\ntransportPorperties.require(protocol, UDP)\r\ntransportPorperties.require(protocol, TCP)\r\ntransportPorperties.require(protocol, IPv4)\r\ntransportPorperties.require(protocol, IPv6)\r\n~~~\r\nDoes it mean what I intended (require to use TCP or UDP and prefer IPv4), or is this only satisfied by TCPoverUDPoverIPv6overIPv4 or TCPoverUDPoverIPv4overIPv6?\r\n\r\n~~~\r\nNewLocalEndpoint.WithProtocols(\"udp\",\"tcp\")\r\nNewLocalEndpoint.WithProtocols(\"IPv4\",\"IPv6\"),\r\n~~~\r\nIs clear - I want either TCP or UDP over IPv4 or IPv6 - and does not allow to use other preferences and thus reduces complexity.",
              "createdAt": "2019-07-05T10:31:57Z",
              "updatedAt": "2019-07-23T20:56:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjMyNTc2",
          "commit": {
            "abbreviatedOid": "6c2f580"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T15:42:33Z",
          "updatedAt": "2019-07-07T15:42:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think the example that you give here makes the endpoint case clear because you assume an implicit \"or\" between parameters of one call. In the other case, you arrive at something ambiguous because you have only one flat property called \"protocol\".\r\n\r\nThe distinction that creates the problem here, to me, isn't about the local endpoint or use of a transport property; it's about semantics of the defined call that you use (or assume).",
              "createdAt": "2019-07-07T15:42:33Z",
              "updatedAt": "2019-07-23T20:56:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwNzAwODQ5",
      "title": "Add Transport Property Profiles",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/328",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This addresses Issue #325",
      "createdAt": "2019-05-21T09:38:22Z",
      "updatedAt": "2019-07-24T21:24:25Z",
      "closedAt": "2019-07-24T20:26:21Z",
      "mergedAt": "2019-07-24T20:26:20Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So, some comments:\r\n- First I suggest that we explicitly refer to these but the service they provide, not the protocol they resemble. Hence:\r\n\r\n\u2022 The final one would be \"datagram service\" and UDP is an example of such. \r\n\r\n\u2022 I would also suggest it is useful to say that the application-supplied properties can now override these defaults, hence in the Datagram case, the property permitting/requiring partial coverage could result in UDP-Lite being selected instead of UDP to supply this service.\r\n\r\n\u2022 Then, I have a question about the specific UDP/Datagram service. This currently says:\r\n\r\n | Property                 | Value     |\r\n  |:-------------------------|:----------|\r\n  | reliability              | avoid     |\r\n  | preserve-order           | avoid     |\r\n  | congestion-control       | avoid     |\r\n  | preserve-msg-boundaries  | require   |\r\n  | idempotent               | true      |\r\n\r\nTo me some of these are not really requirements, but to me seem like side affects. The requirement could be to need low latency, and idempotence, preserve-msg-boundaries, etc \r\nbut I wouldn't care if the service also happened to provide the following, as long as those requirements (or whatever we agree upon) were prioritised: reliability,  preserve-order , congestion-control. (Of course UDP would not offer these, and that would also be fine).\r\n\r\nThoughts?\r\n\r\n",
          "createdAt": "2019-05-21T10:42:44Z",
          "updatedAt": "2019-05-21T10:42:44Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the first point and updated the PR accordingly.\r\n\r\nFor the second one, I also agree that avoiding reliability, order preservation, and congestion-control are side effects of latency or other optimisations and do not really belong into the profile. Therefore, I changed \"avoid\" to \"ignore\".\r\nI am a bit hesitant about speaking about UDP lite here given your first point, tried to incorporate it as a hint in a slightly different way. \r\n\r\nAfter these changes, I would like to raise the question whether we should mention \"udp like\" or \"tcp like\" for the impatient searching the document.",
          "createdAt": "2019-05-21T12:24:34Z",
          "updatedAt": "2019-05-21T12:24:34Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Something to help start thinking: we could say something like this datagram service resembles the service offered by the socket API that binds to the UDP transport?\r\n",
          "createdAt": "2019-05-21T13:05:46Z",
          "updatedAt": "2019-05-21T13:05:46Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Something to help start thinking: we could say something like this datagram service resembles the service offered by the socket API that binds to the UDP transport?\r\n",
          "createdAt": "2019-05-21T13:05:49Z",
          "updatedAt": "2019-05-21T13:05:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I checked this now and like it. I also read the dialogue and agree with all points that were raised and how they were answered.\r\n\r\nRegarding @gorryfair 's suggestion to say: \"we could say something like this datagram service resembles the service offered by the socket API that binds to the UDP transport?\" - actually, when reading the update first before looking at the comments, I thought \"why doesn't this say: 'an example of a protocol that provides this service is UDP' ?\". I think this is almost the same thing, but I like my own phrasing better  :)   the whole \"socket API that binds to\" thing seems a bit clumsy to me and I don't think we need it.",
          "createdAt": "2019-05-24T08:43:01Z",
          "updatedAt": "2019-05-24T08:43:01Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I liked the split between saying \"there are profiles\" in the normative part and defining examples for these in the appendix. If this is a Problem, we should rather move the profiles into the property section. I have a bad feeling about modifying function signatures defined in the main documents in the appendix.\r\n\r\nAny other opinions? \r\nLeave un-merged and discuss in Montreal?\r\n",
          "createdAt": "2019-07-04T09:33:25Z",
          "updatedAt": "2019-07-04T09:33:25Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I actually think this is useful but more an implementation question. I don't think this need to a part of the base API, so having this in the appendix or the implementation draft seems more suitable for me.",
          "createdAt": "2019-07-08T09:56:17Z",
          "updatedAt": "2019-07-08T09:56:17Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak What about the Parameter to pass the profile \u2013 is re-defining it in the appendix the right way?",
          "createdAt": "2019-07-08T10:00:34Z",
          "updatedAt": "2019-07-08T10:00:34Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The API we define is anyway mostly a recommendation and will not be normative; so you will always she slight variations in the implementation. Proposing an optional parameter (in the appendix or implementation draft) seems okay.",
          "createdAt": "2019-07-08T10:05:33Z",
          "updatedAt": "2019-07-08T10:05:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTAyOTIy",
          "commit": {
            "abbreviatedOid": "9f6df7d"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, this is useful! However, I think it would be better self-contained in the appendix.",
          "createdAt": "2019-07-03T13:54:04Z",
          "updatedAt": "2019-07-03T13:54:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think this is very useful in the appendix, but adding language here in the normative section might lead to some of the confusion that putting this in the appendixi is meant to avoid. Consider leaving this section unchanged, and make the modification to NewTransportProperties() in the appendix where properties are introduced.",
              "createdAt": "2019-07-03T13:54:05Z",
              "updatedAt": "2019-07-23T20:51:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3OTMyNjMz",
          "commit": {
            "abbreviatedOid": "9f6df7d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T09:27:57Z",
          "updatedAt": "2019-07-04T09:27:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmm\u2026 I think it is a much worse idea to modify function signatures in the appendix",
              "createdAt": "2019-07-04T09:27:57Z",
              "updatedAt": "2019-07-23T20:51:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0OTc4MDU2",
          "commit": {
            "abbreviatedOid": "9f6df7d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I believe that profiles are conveniences that are layers implementations can build on top of the TAPS interface, but they do not need to belong in the API definition, and I think they're unnecessary to add here. At the most, we can say that implementations MAY make conveniences that are implementation -specific.",
          "createdAt": "2019-07-22T18:31:21Z",
          "updatedAt": "2019-07-22T18:31:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2MjY1Nzc3",
          "commit": {
            "abbreviatedOid": "2ae4b59"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-24T20:25:53Z",
          "updatedAt": "2019-07-24T20:25:53Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e896126119b6eea9ace1f7f43a90e440c6915a59",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/propery-profiles",
      "headRefOid": "2ae4b59d03f5d2fa2f184f983af250799c698f6a",
      "mergeCommit": {
        "oid": "6d91305e6984467e5e0478886cd48871beafca29"
      }
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxOTU4OTQ4",
      "title": "Updated contact information Philipp S. Tiesel",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/329",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-24T10:28:41Z",
      "updatedAt": "2019-05-24T10:44:45Z",
      "closedAt": "2019-05-24T10:29:13Z",
      "mergedAt": "2019-05-24T10:29:13Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm considering to change mine to \"Russian oligarch villa, Ibiza\"  :-)",
          "createdAt": "2019-05-24T10:44:45Z",
          "updatedAt": "2019-05-24T10:44:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7bb305f5bf8a3b4904ac381b56f85cc7fef45d83",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/update-contact",
      "headRefOid": "99cb42fdcaef4094220034c12ecfcaa1b17e0c34",
      "mergeCommit": {
        "oid": "78b7c6ecbcc6582d365a14413a9b2f22bd273c62"
      }
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxOTYwMzMx",
      "title": "Some defaults and editorial fixes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/330",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #319, #318. Partially addresses #315.",
      "createdAt": "2019-05-24T10:33:13Z",
      "updatedAt": "2020-09-11T16:31:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "78b7c6ecbcc6582d365a14413a9b2f22bd273c62",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-defaults-and-some-editorial-fixes",
      "headRefOid": "6d35f202302222909648c6225d841192b196ff90",
      "closedAt": "2019-06-26T08:47:33Z",
      "mergedAt": "2019-06-26T08:47:33Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "d696d05f42e0bee4bb46d7af9d74c87ac8ebcb53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxODgzNjA4",
          "commit": {
            "abbreviatedOid": "6d35f20"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T18:20:18Z",
          "updatedAt": "2019-05-24T18:20:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzMDkwNDk4",
          "commit": {
            "abbreviatedOid": "6d35f20"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks for adding this - makes things more consistent",
          "createdAt": "2019-05-29T07:52:40Z",
          "updatedAt": "2019-05-29T07:52:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg3NTM0ODQ0",
      "title": "Added Listener object to the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/332",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This adds an explicit Listener object to the API (closes #301) to\r\n - clarify behaviour of multi-streaming protocols (closes #269)\r\n - clarify behaviour and enable re-use of Preconnections (closes #222)",
      "createdAt": "2019-06-12T14:27:45Z",
      "updatedAt": "2019-06-17T07:59:13Z",
      "closedAt": "2019-06-14T21:22:30Z",
      "mergedAt": "2019-06-14T21:22:30Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MTc4Nzkz",
          "commit": {
            "abbreviatedOid": "b60d3f1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This looks just right to me, thanks a lot for doing this!\r\nIn particular having read #269 again, I believe that @tfpauly should definitely have the last word on this one. So I'll go with whatever @tfpauly says.",
          "createdAt": "2019-06-13T07:50:38Z",
          "updatedAt": "2019-06-13T07:50:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMTMyODc1",
          "commit": {
            "abbreviatedOid": "b60d3f1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-14T21:19:06Z",
          "updatedAt": "2019-06-14T21:19:06Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "238e09fd4abc332388e055f4071589c982d49090",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/listener-obj",
      "headRefOid": "b60d3f10dd2fe3080db084b8a525a2e743309419",
      "mergeCommit": {
        "oid": "74649d852a8df6671eb4fea95c464d71a7d1ab86"
      }
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MDY5NTk2",
      "title": "Make protocol-specific mappings in TAPS Implementation more rigorous",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/333",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Starting to address #128 \r\n\r\nThis is an early review, to check if we like the structure. I'd also like help filling out the SCTP section!",
      "createdAt": "2019-06-18T00:56:34Z",
      "updatedAt": "2020-09-11T16:31:28Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2fdcae7034b23914c6dbe7d234f1ba81b7080557",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/impl-protocols",
      "headRefOid": "a3bd74120ab3459847bce15825d1353bdd412dde",
      "closedAt": "2019-07-07T01:16:10Z",
      "mergedAt": "2019-07-07T01:16:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6eb9287056ea6caafd4a61e257e29ecc8fcd21ea"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can also help with SCTP, which I would do in the same style that I suggest above (for TCP, in my example of \"Abort\") - also later.",
          "createdAt": "2019-06-26T11:25:27Z",
          "updatedAt": "2019-06-26T11:25:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0NTM5MzQx",
          "commit": {
            "abbreviatedOid": "84c997a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this is a good step forward.\r\n\r\nThis said, I think we should describe things focusing on the transport's API call to be made (in line with the spec - that's why we have RFCs 8303 and 8304) rather than protocol internals. E.g., rather than saying that Abort on a TCP connection transmits a RST, I think we should simply say that Abort calls ABORT.TCP [RFC 8303, Section 4.1].\r\n\r\nI can take care of these things, later. I'd still like to focus more on the API doc at this time.",
          "createdAt": "2019-06-26T11:06:16Z",
          "updatedAt": "2019-06-26T11:27:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Did you want to write \"Multiplexed Connected protocols share properties...\" ?  Else this seems grammatically wrong to me?  (but maybe it's just me)",
              "createdAt": "2019-06-26T11:06:16Z",
              "updatedAt": "2019-07-07T01:15:02Z"
            },
            {
              "originalPosition": 30,
              "body": "s/maps/map",
              "createdAt": "2019-06-26T11:14:56Z",
              "updatedAt": "2019-07-07T01:15:02Z"
            },
            {
              "originalPosition": 45,
              "body": "s/due to receive/due to receiving",
              "createdAt": "2019-06-26T11:16:59Z",
              "updatedAt": "2019-07-07T01:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDY4NzEw",
          "commit": {
            "abbreviatedOid": "84c997a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo mwelzl changes.",
          "createdAt": "2019-07-03T12:59:56Z",
          "updatedAt": "2019-07-03T12:59:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNjUzOTA5",
      "title": "Various minor issues - closes #314, #315 #316 and #331",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/335",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "... and some nits (capitalization, ..)\r\n\r\n#314: 0-rtt establishment: fixed default as requested by @gorryfair and incorporated text fix suggestion\r\n#315: last missing update to hopefully close this issue: adjusted the wording of checksum related selection properties\r\n#316: fixed some text details regarding how transport properties are to be specified, based on a converged discussion.\r\n#331: wrote some defaults for parameters in section 9.1",
      "createdAt": "2019-07-02T09:07:16Z",
      "updatedAt": "2020-09-11T16:31:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6f5a28ec8c9cf996e5b1f61f169cc3c3a982fdbe",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "Minor-issues-#314,-#315-#316-and-#331",
      "headRefOid": "654029d8a927ee25511c09eaffc74301c3746608",
      "closedAt": "2019-07-03T13:56:09Z",
      "mergedAt": "2019-07-03T13:56:09Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "2fdcae7034b23914c6dbe7d234f1ba81b7080557"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDY3Mzkx",
          "commit": {
            "abbreviatedOid": "2bde376"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, modulo suggested nit about integers.",
          "createdAt": "2019-07-03T12:57:37Z",
          "updatedAt": "2019-07-03T12:58:52Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "-1 is not a positive integer :P\r\n\r\n```suggestion\r\n: Integer / Integer\r\n```",
              "createdAt": "2019-07-03T12:57:37Z",
              "updatedAt": "2019-07-03T13:06:02Z"
            },
            {
              "originalPosition": 283,
              "body": "(On second thought, do we want to restrict this beyond Numeric?)",
              "createdAt": "2019-07-03T12:58:18Z",
              "updatedAt": "2019-07-03T13:06:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDcwNzcy",
          "commit": {
            "abbreviatedOid": "2bde376"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T13:03:35Z",
          "updatedAt": "2019-07-03T13:03:35Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "Tsssssssssssk what a silly mistake!  Thanks!\r\nRe: numeric, I absolutely agree!  I even thought about it as I made this PR and wanted to fix this (because it was an Integer before) but somehow forgot it.",
              "createdAt": "2019-07-03T13:03:35Z",
              "updatedAt": "2019-07-03T13:06:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDcwMTkz",
      "title": "Remove the message context returned by send",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/345",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This closes first half of Issue #336 as discussed today",
      "createdAt": "2019-07-22T23:03:21Z",
      "updatedAt": "2019-07-23T14:40:37Z",
      "closedAt": "2019-07-23T14:14:20Z",
      "mergedAt": "2019-07-23T14:14:20Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1Mzc5MTQ1",
          "commit": {
            "abbreviatedOid": "176e89e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Ship it!",
          "createdAt": "2019-07-23T12:43:27Z",
          "updatedAt": "2019-07-23T12:43:27Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c65f349c7505051a0f4ddb16befe8c96a66aa5c6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/send-no-return",
      "headRefOid": "176e89eb4115ded8e61f82992516f69defadf14c",
      "mergeCommit": {
        "oid": "e896126119b6eea9ace1f7f43a90e440c6915a59"
      }
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAxNjEyNjQx",
      "title": "Fixes #313 per Gorry's comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/346",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This handles all of Gorry's editorial comments in #313, save \r\n\r\n> \"Once configured, parameters may also be supplied during connection establishment. These are best handled as client-provided callbacks. \u201c: Is a callback what the TAPS architecture refers to as an Event?\r\n\r\nwhich should be discussed in a new issue.",
      "createdAt": "2019-07-26T16:48:07Z",
      "updatedAt": "2019-11-21T07:17:18Z",
      "closedAt": "2019-10-30T10:15:58Z",
      "mergedAt": "2019-10-30T10:15:58Z",
      "mergedBy": "philsbln",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "unaddressed comment in #347",
          "createdAt": "2019-07-26T16:59:42Z",
          "updatedAt": "2019-07-26T16:59:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this is ready to be merged, but requires merging by someone who's less prone than me to mess something up when pressing the \"Resolve conflicts\" button.  @britram? Please?",
          "createdAt": "2019-10-21T08:06:40Z",
          "updatedAt": "2019-10-21T08:06:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNDg0MTAz",
          "commit": {
            "abbreviatedOid": "28fdd7d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2019-08-27T21:31:15Z",
          "updatedAt": "2019-08-27T21:31:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjA5NDM3",
          "commit": {
            "abbreviatedOid": "28fdd7d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-28T06:19:46Z",
          "updatedAt": "2019-08-28T06:19:46Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "1ac1e180805f84726d9cb4babdc4c7301df24789",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "editorial-313",
      "headRefOid": "c56c6c3fa95c17f21cf84184bbf7d9366367b624",
      "mergeCommit": {
        "oid": "64ed9f83b01af70c8fdf3522be00b0a396226baa"
      }
    },
    {
      "number": 349,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA5MjczMTk5",
      "title": "Address review comments on architecture draft",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/349",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Addresses Gorry's great comments from #312!",
      "createdAt": "2019-08-20T23:56:52Z",
      "updatedAt": "2020-09-11T16:31:31Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "46ec43cb3c04d2d3a859edb1efa5212a99bfe8a3",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-nits",
      "headRefOid": "5679a1b599cd51fdf89e13b617783887d24cf719",
      "closedAt": "2019-08-27T21:11:02Z",
      "mergedAt": "2019-08-27T21:11:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "68b88daf16dd1f5ed94b4feac0566e74b3f12986"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc3NzUwMDk2",
          "commit": {
            "abbreviatedOid": "f6d0b74"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo two minor comments.",
          "createdAt": "2019-08-21T12:14:28Z",
          "updatedAt": "2019-08-21T12:20:38Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "This is a new request - sorry - but: please replace the two occurrences of \"Functional Features\" with \"Functional or Optimizing Features\". That's because we have three categories in minset: Functional, Optimizing, Automatable (see the first 4 paragraphs of https://tools.ietf.org/html/draft-ietf-taps-minset-11#section-3 ).",
              "createdAt": "2019-08-21T12:14:28Z",
              "updatedAt": "2019-08-21T15:56:45Z"
            },
            {
              "originalPosition": 276,
              "body": "Another new request, sorry again to only bring this up now: the mention of TFO and ECN here seems strange, because these mechanisms are internal to a protocol (the TCP implementation can try and fall back), whereas our transport system would just use protocols as they are. For that reason, these things do also not match our definition of \"Transport Features\" (as defined in RFC 8095, and then repeated in RFC 8303 and minset). I would just remove all the text from \"unlike ....\"  until \"... standard configurations\".",
              "createdAt": "2019-08-21T12:19:35Z",
              "updatedAt": "2019-08-21T15:56:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc3OTAwMTgx",
          "commit": {
            "abbreviatedOid": "f6d0b74"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-21T15:56:44Z",
          "updatedAt": "2019-08-21T15:56:44Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Fixed!",
              "createdAt": "2019-08-21T15:56:44Z",
              "updatedAt": "2019-08-21T15:56:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc3OTAwMjE5",
          "commit": {
            "abbreviatedOid": "5679a1b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-21T15:56:47Z",
          "updatedAt": "2019-08-21T15:56:47Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Fixed!",
              "createdAt": "2019-08-21T15:56:47Z",
              "updatedAt": "2019-08-21T15:56:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "MDExOlB1bGxSZXF1ZXN0MzExNTc2MDQx",
      "title": "Allow setting new connection limits for inbound connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/350",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "This implements what we discussed on #343 ",
      "createdAt": "2019-08-27T21:29:56Z",
      "updatedAt": "2019-11-24T05:17:29Z",
      "closedAt": "2019-08-30T14:48:08Z",
      "mergedAt": "2019-08-30T14:48:08Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjEwOTUy",
          "commit": {
            "abbreviatedOid": "026f573"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is surely useful as-is. Considering the recent discussion on the list (dynamic per-IP rejection possibilities), I'm not sure it's rich enough... but it's certainly a good starting point. I'm also not sure how much of what's been discussed *really* should be a part of the spec.",
          "createdAt": "2019-08-28T06:24:25Z",
          "updatedAt": "2019-08-28T06:37:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The terminology section writes events as Events and in other places the word is capitalized too. I suggest to keep this as \"Event\" now to be reasonably consistent - if you want Events (and, I guess, then also Actions) to be lowercase, this can be discussed, but then let's do this for the whole document at some point.\r\n(Personally, I couldn't care less, but I do want things to be as consistent as possible.)",
              "createdAt": "2019-08-28T06:24:25Z",
              "updatedAt": "2019-08-28T16:06:51Z"
            },
            {
              "originalPosition": 11,
              "body": "so the \"Event\" vs. \"event\" thing applies here too.",
              "createdAt": "2019-08-28T06:24:46Z",
              "updatedAt": "2019-08-28T16:06:51Z"
            },
            {
              "originalPosition": 17,
              "body": "remove \"it\" before \"that will be\"",
              "createdAt": "2019-08-28T06:26:17Z",
              "updatedAt": "2019-08-28T16:06:51Z"
            },
            {
              "originalPosition": 23,
              "body": "This may just be me (as I'm not a native speaker), but shouldn't the word order be \"The caller is also able to reset...\" ?",
              "createdAt": "2019-08-28T06:27:50Z",
              "updatedAt": "2019-08-28T16:06:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwOTQxNTEw",
          "commit": {
            "abbreviatedOid": "3d5fc4d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T16:07:27Z",
          "updatedAt": "2019-08-28T16:07:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Okay, fixed more places in the listener section, then. The majority here was lower-case, but I've made it upper-case now. Agreed both on not really caring and on wanting consistency!",
              "createdAt": "2019-08-28T16:07:27Z",
              "updatedAt": "2019-08-28T16:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwOTQxNTYw",
          "commit": {
            "abbreviatedOid": "3d5fc4d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T16:07:31Z",
          "updatedAt": "2019-08-28T16:07:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Fixed",
              "createdAt": "2019-08-28T16:07:31Z",
              "updatedAt": "2019-08-28T16:07:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwOTQxNjgy",
          "commit": {
            "abbreviatedOid": "3d5fc4d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T16:07:43Z",
          "updatedAt": "2019-08-28T16:07:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fixed!",
              "createdAt": "2019-08-28T16:07:43Z",
              "updatedAt": "2019-08-28T16:07:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwOTQxODI5",
          "commit": {
            "abbreviatedOid": "3d5fc4d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T16:07:59Z",
          "updatedAt": "2019-08-28T16:07:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Yeah, it can *technically* work either way but your suggestion reads more smoothly.",
              "createdAt": "2019-08-28T16:07:59Z",
              "updatedAt": "2019-08-28T16:07:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxOTY3NzQ4",
          "commit": {
            "abbreviatedOid": "3d5fc4d"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2019-08-30T11:04:21Z",
          "updatedAt": "2019-08-30T11:04:21Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "68b88daf16dd1f5ed94b4feac0566e74b3f12986",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/connection-limits",
      "headRefOid": "3d5fc4d0a4972043d5d340349df164cfacd8026d",
      "mergeCommit": {
        "oid": "7ce8feef624314fc629218fbd3ac978f39dc1beb"
      }
    },
    {
      "number": 351,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MTkzNTIx",
      "title": "Allow for error events to include an optional reason",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/351",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #341 and #342 ",
      "createdAt": "2019-09-19T09:58:41Z",
      "updatedAt": "2019-11-01T16:54:33Z",
      "closedAt": "2019-11-01T16:54:33Z",
      "mergedAt": "2019-11-01T16:54:33Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for working on this!",
          "createdAt": "2019-09-19T16:02:56Z",
          "updatedAt": "2019-09-19T16:02:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTQ4NjUy",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this PR!\r\n\r\nThe changes to the API draft look good to me.\r\n\r\nIn the implementation draft, I think having some examples for possible errors is a useful thing to have. After all, it does provide some really useful guidance to implementation developers about distinguishing between error cases. \r\nHowever, in this PR, it does invite some discussion and possible bikeshedding around naming. ;)\r\n\r\nIn this discussion, we should be clear that we are not trying to enumerate every possible reason an error occured. Ultimately, the exact error codes and their semantics are going to be implementation-specific anyway. But the examples we give here do need to be clear enough.\r\n\r\nSo, while I'm okay with trying to flesh out these error codes a bit more, I would also be fine with merging or deleting some of the less clear ones.\r\n\r\nOne nit in general: \"TAPS system\" --> \"transport system\"",
          "createdAt": "2019-09-19T13:02:59Z",
          "updatedAt": "2019-09-19T13:18:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'm not sure we really need to count the error types here, so I suggest deleting \"the seven\" here.",
              "createdAt": "2019-09-19T13:02:59Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 13,
              "body": "Here, let's maybe make the difference from BadConfiguration explicit: \"The configuration is valid, but none of the available transport protocols...\"",
              "createdAt": "2019-09-19T13:05:09Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 16,
              "body": "Maybe change this to \"ResolutionFailed\" or similar - \"Unresolvable\" sounds like an inherent and persistent problem with the specifier, but it might just be a problem with the resolver.",
              "createdAt": "2019-09-19T13:06:43Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 28,
              "body": "Nits: \r\n\"ToLarge\" --> \"TooLarge\"\r\n\"taps system\" --> \"transport system\"",
              "createdAt": "2019-09-19T13:08:11Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 31,
              "body": "What's the difference to \"CantEstablish\"?",
              "createdAt": "2019-09-19T13:08:51Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 43,
              "body": "Nit: \"remote endpoint\"?",
              "createdAt": "2019-09-19T13:12:38Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            },
            {
              "originalPosition": 46,
              "body": "Nit: \"remote endpoint\"?",
              "createdAt": "2019-09-19T13:12:49Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc2Mzcz",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:00:56Z",
          "updatedAt": "2019-09-19T16:00:57Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agreed. Suggest using \"several\" or \"various\".",
              "createdAt": "2019-09-19T16:00:56Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc2NDYw",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:01:06Z",
          "updatedAt": "2019-09-19T16:01:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "+1",
              "createdAt": "2019-09-19T16:01:06Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc2OTA4",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:01:51Z",
          "updatedAt": "2019-09-19T16:01:52Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "We shouldn't use contractions in terms like these; \"CannotEstablish\" would be usable here, but \"EstablishmentFailed\" may be better?",
              "createdAt": "2019-09-19T16:01:51Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc3MDY1",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:02:08Z",
          "updatedAt": "2019-09-19T16:02:08Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "\"Invalid\" is preferable to \"Bad\"",
              "createdAt": "2019-09-19T16:02:08Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc3MjA4",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:02:24Z",
          "updatedAt": "2019-09-19T16:02:24Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Overall, please use \"Transport Services\" rather than \"TAPS\"",
              "createdAt": "2019-09-19T16:02:24Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNjc3MjY0",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T16:02:30Z",
          "updatedAt": "2019-09-19T16:02:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "What does this case mean?",
              "createdAt": "2019-09-19T16:02:30Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzY4NjUy",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T18:43:23Z",
          "updatedAt": "2019-09-19T18:43:23Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "While the underlying transport was able to receive everything properly, the transport system implementation itself was not. I wanted to keep the two distinct but that might not be necessary. ",
              "createdAt": "2019-09-19T18:43:23Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzY5MjM5",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T18:44:24Z",
          "updatedAt": "2019-09-19T18:44:25Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I wanted to make it clear that this is the other side of the connection and not the remote endpoint object. There might be a better term for this than \"remote\". ",
              "createdAt": "2019-09-19T18:44:25Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzcwOTA1",
          "commit": {
            "abbreviatedOid": "f28dbe2"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T18:47:09Z",
          "updatedAt": "2019-09-19T18:47:09Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "This one was intended to be used for protocol failures during receive and send. It might not be necessary to keep both as ProtocolFailure pretty much covers \"CantEstablish\".",
              "createdAt": "2019-09-19T18:47:09Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxNTEwOTcx",
          "commit": {
            "abbreviatedOid": "1c32c79"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-22T14:18:16Z",
          "updatedAt": "2019-09-22T14:18:16Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "If not \"remote endpoint\", maybe \"peer\"?",
              "createdAt": "2019-09-22T14:18:16Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxNTExMjA0",
          "commit": {
            "abbreviatedOid": "1c32c79"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-22T14:23:20Z",
          "updatedAt": "2019-09-22T14:23:20Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "That makes sense.\r\nIn this particular case, I think \"message delivery\" already implies that it's delivery to the other side of the connection, so making that explicit is not necessary here.\r\n\r\nHowever, reading the entire description again, I'm wondering if it makes sense to rephrase it entirely.\r\nHow about \"Message delivery failed due to a timeout\"?",
              "createdAt": "2019-09-22T14:23:20Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMDc3NzY2",
          "commit": {
            "abbreviatedOid": "604df6d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T13:31:33Z",
          "updatedAt": "2019-09-25T13:31:34Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Does it make sense to split this case between \"LocalReceivFailure\" und \"DeframingFailure\"?",
              "createdAt": "2019-09-25T13:31:33Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MDc5MDc2",
          "commit": {
            "abbreviatedOid": "604df6d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This PR sill has a few small issues, but should be easily merge-able after fixing these and pulling the most recent changes,  ",
          "createdAt": "2019-10-30T09:59:27Z",
          "updatedAt": "2019-10-30T10:02:48Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n* InvalidConfiguration:\r\n```",
              "createdAt": "2019-10-30T09:59:27Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzQ3NjUx",
          "commit": {
            "abbreviatedOid": "604df6d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Almost there - I think once Philipp's comment and the resolution of the ReceivedFailed issue are resolved, this is ready to merge.",
          "createdAt": "2019-10-30T16:30:57Z",
          "updatedAt": "2019-10-30T16:32:20Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Another suggestion: ProtocolReceiveFail and SystemReceiveFail.\r\nOr get rid of the distinction here (it's just a suggestion anyway) and just go with ReceiveFailed, which would be in analogy to ResolutionFailed and EstablishmentFailed.",
              "createdAt": "2019-10-30T16:30:57Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NDI0MDQ4",
          "commit": {
            "abbreviatedOid": "604df6d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T18:20:10Z",
          "updatedAt": "2019-10-30T18:20:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I guess we should either have a distinction or not include the example. If we have ReceiveError and the reason is ReceiveFailed I am not sure it provides much extra information? Perhaps ProtocolReceiveFailure and DeframingFailure if we want to include something for ReceiveFailed.",
              "createdAt": "2019-10-30T18:20:11Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NDI4OTkw",
          "commit": {
            "abbreviatedOid": "604df6d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T18:27:07Z",
          "updatedAt": "2019-10-30T18:27:07Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "And perhaps Failed rather than Failure above to be consistent across error reasons.",
              "createdAt": "2019-10-30T18:27:07Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMTg4MjA3",
          "commit": {
            "abbreviatedOid": "4c14e85"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T21:18:42Z",
          "updatedAt": "2019-10-31T21:18:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjE5MTAw",
          "commit": {
            "abbreviatedOid": "4c14e85"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T22:39:05Z",
          "updatedAt": "2019-10-31T22:39:05Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "One small nit: \"was unable to be deframed\" reads a bit odd I think. Suggest to replace by \"could not be deframed\".",
              "createdAt": "2019-10-31T22:39:05Z",
              "updatedAt": "2019-10-31T22:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjM0MjI1",
          "commit": {
            "abbreviatedOid": "919c561"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks Max, LGTM.",
          "createdAt": "2019-10-31T23:35:19Z",
          "updatedAt": "2019-10-31T23:35:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTY2ODE2",
          "commit": {
            "abbreviatedOid": "919c561"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me now! I think this is ready to merge.",
          "createdAt": "2019-11-01T16:44:58Z",
          "updatedAt": "2019-11-01T16:44:58Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "1b4f59e554ddd3dd2534c0af34f456e4bbb88834",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "919c561435cfecfdd6645a0da90c5b77c5760b13",
      "mergeCommit": {
        "oid": "2317a56988c3509c94e010d50d1eeca11b43f6e2"
      }
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5NzgwNzkz",
      "title": "Implementation: mapping back to RFC 8303",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/352",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #337 (SCTP mapping)\r\nThis uses a new approach for such text for TCP, UDP and SCTP.\r\nAlso: updates appendix D of interface.",
      "createdAt": "2019-10-18T14:53:15Z",
      "updatedAt": "2019-11-24T05:17:23Z",
      "closedAt": "2019-10-22T21:02:59Z",
      "mergedAt": "2019-10-22T21:02:59Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MDM4NTA4",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-18T17:39:29Z",
          "updatedAt": "2019-10-18T17:39:29Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Can we have this be an issue rather that a note in the markdown? Not a huge deal either way.\r\n\r\nI do like the format!",
              "createdAt": "2019-10-18T17:39:29Z",
              "updatedAt": "2019-10-22T07:42:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MDYyOTgz",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-18T18:25:38Z",
          "updatedAt": "2019-10-18T18:25:38Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "If we're good with the format (waiting for an ACK from @britram), it's more efficient to just leave the editor comment for now and remove it with the follow-up PR (to change UDP and TCP in the same way), which I'll then do fast.",
              "createdAt": "2019-10-18T18:25:38Z",
              "updatedAt": "2019-10-22T07:42:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MDYzMTcy",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-18T18:26:00Z",
          "updatedAt": "2019-10-18T18:26:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": ".... and thanks for looking at this so quickly btw!",
              "createdAt": "2019-10-18T18:26:00Z",
              "updatedAt": "2019-10-22T07:42:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTA3NTAx",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-18T19:58:08Z",
          "updatedAt": "2019-10-18T19:58:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "woops, forgot @abrunstrom  ... adding her too.  Quick answers would be appreciated, so I can continue this method early next week if folks agree.",
              "createdAt": "2019-10-18T19:58:08Z",
              "updatedAt": "2019-10-22T07:42:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTIyODgy",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-18T20:31:58Z",
          "updatedAt": "2019-10-18T20:31:58Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Wouldn't this make the Listen call blocking? Shouldn't the Listener object be returned immediately and then ConnectionReceived be called once the message arrives?",
              "createdAt": "2019-10-18T20:31:58Z",
              "updatedAt": "2019-10-22T07:42:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MjU2MDU4",
          "commit": {
            "abbreviatedOid": "7f83149"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-20T12:13:31Z",
          "updatedAt": "2019-10-20T12:13:31Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Good catch, thanks! Fixed. There was no need to say \"will return upon reception\".\r\n\r\nJFYI: anyway these primitives are abstract - just a writing style to find the original part of the spec for the functionality. E.g., the text describing \"LISTEN.SCTP\" in section 4 of RFC 8303 says: \"Pass 1 primitive/event: 'Initialize', followed by the 'Communication Up' or 'Restart' notification and possibly the  'Adaptation Layer' notification\" - so in fact it's (supposed to be) non-blocking even with the standard SCTP socket interface, under the hood.",
              "createdAt": "2019-10-20T12:13:31Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NDczODc3",
          "commit": {
            "abbreviatedOid": "4b589a6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-21T10:45:43Z",
          "updatedAt": "2019-10-21T10:45:43Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done",
              "createdAt": "2019-10-21T10:45:43Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NjMyODQ2",
          "commit": {
            "abbreviatedOid": "11ff9d4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-21T15:05:25Z",
          "updatedAt": "2019-10-21T15:05:26Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I don't quite follow this; Ready is the event that comes back after Initiate or InitiateWithSend to indicate that there was no error; the definition now is a bit tautological. The point of this was to say what the notion of being ready meant, which is just the part about the three-way handshake",
              "createdAt": "2019-10-21T15:05:26Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NjMzMzI4",
          "commit": {
            "abbreviatedOid": "11ff9d4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-21T15:06:05Z",
          "updatedAt": "2019-10-21T15:06:06Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This doesn't lead to the ABORT-EVENT.TCP or TIMEOUT.TCP events I think-- rather the ABORT-EVENT.TCP or TIMEOUT.TCP events lead to the ConnectionError event!",
              "createdAt": "2019-10-21T15:06:05Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NjM0NjE0",
          "commit": {
            "abbreviatedOid": "11ff9d4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good! I mainly just have nits about the Ready and ConnectionError events for TCP.",
          "createdAt": "2019-10-21T15:07:47Z",
          "updatedAt": "2019-10-21T15:07:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1MDAzNzc2",
          "commit": {
            "abbreviatedOid": "11ff9d4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-22T07:28:47Z",
          "updatedAt": "2019-10-22T07:28:48Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Agreed, I'll just remove this new bit again.",
              "createdAt": "2019-10-22T07:28:47Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1MDAzODk5",
          "commit": {
            "abbreviatedOid": "11ff9d4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-22T07:29:04Z",
          "updatedAt": "2019-10-22T07:29:05Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Of course, you're right! Thanks, I'll fix this!",
              "createdAt": "2019-10-22T07:29:04Z",
              "updatedAt": "2019-10-22T07:42:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NTA2NjA3",
          "commit": {
            "abbreviatedOid": "2f5056b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-22T21:02:37Z",
          "updatedAt": "2019-10-22T21:02:37Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7ce8feef624314fc629218fbd3ac978f39dc1beb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW-impl-based-on-TAPS-RFCs",
      "headRefOid": "2f5056b2ff71475f3361cae7850a0ebc5fd548b0",
      "mergeCommit": {
        "oid": "bc7d21c8711e4c97205b5e54317b62b4280e6dbb"
      }
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5OTQ4MzA5",
      "title": "Rename \"Basic Objects\" to \"Connection Objects\" to reduce confusion",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/353",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #255 ",
      "createdAt": "2019-10-18T22:43:44Z",
      "updatedAt": "2019-11-24T05:17:28Z",
      "closedAt": "2019-10-18T22:57:56Z",
      "mergedAt": "2019-10-18T22:57:56Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTY4NTc5",
          "commit": {
            "abbreviatedOid": "0a6b864"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-18T22:47:12Z",
          "updatedAt": "2019-10-18T22:47:12Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7ce8feef624314fc629218fbd3ac978f39dc1beb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/basic-objects",
      "headRefOid": "0a6b8643c1434dcc0090874516e815c7ce638faf",
      "mergeCommit": {
        "oid": "71a474697e58802058099a0f17bbad3587eb6205"
      }
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5OTUwOTky",
      "title": "Cleanup diagram to remove message, and add rendezvous",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/354",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #257 ",
      "createdAt": "2019-10-18T22:57:39Z",
      "updatedAt": "2019-11-24T05:17:26Z",
      "closedAt": "2019-10-18T23:19:36Z",
      "mergedAt": "2019-10-18T23:19:36Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTczMzQ1",
          "commit": {
            "abbreviatedOid": "01be3d0"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-18T23:09:41Z",
          "updatedAt": "2019-10-18T23:09:41Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7ce8feef624314fc629218fbd3ac978f39dc1beb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-diagram",
      "headRefOid": "01be3d0f26bb1b7ecba1d05438809365cb487739",
      "mergeCommit": {
        "oid": "f2cae0e36d28a22d5563d5e3af9c3932163f4718"
      }
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5OTU3MjA1",
      "title": "Architecture: Make overview section an actual overview",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/355",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Based on discussion with @mirjak, rearrange things to put a proper document overview in the intro, and split out the API Model discussion into its own section outside of the introduction.",
      "createdAt": "2019-10-18T23:33:37Z",
      "updatedAt": "2019-11-24T05:17:25Z",
      "closedAt": "2019-10-21T14:58:25Z",
      "mergedAt": "2019-10-21T14:58:25Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTc3NzI1",
          "commit": {
            "abbreviatedOid": "ce65f17"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-18T23:33:52Z",
          "updatedAt": "2019-10-18T23:33:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0Mzg2MDQ4",
          "commit": {
            "abbreviatedOid": "ce65f17"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM (modulo one nit)",
          "createdAt": "2019-10-21T08:05:15Z",
          "updatedAt": "2019-10-21T08:05:34Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "\"changes by applications\" seems odd - as if the applications would change something (the transport system, the protocols, ...). I think you want to say \"changes to applications\" or \"changes in applications\" or \"changes by application developers\", or something like that.",
              "createdAt": "2019-10-21T08:05:15Z",
              "updatedAt": "2019-10-21T14:57:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NDk3MjAw",
          "commit": {
            "abbreviatedOid": "ce65f17"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you @tfpauly to do this - really improves the structure.",
          "createdAt": "2019-10-21T11:36:55Z",
          "updatedAt": "2019-10-21T11:36:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NjI3MTc1",
          "commit": {
            "abbreviatedOid": "78a12bf"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-21T14:58:02Z",
          "updatedAt": "2019-10-21T14:58:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Agreed! Changed to `changes by application developers`.",
              "createdAt": "2019-10-21T14:58:02Z",
              "updatedAt": "2019-10-21T14:58:02Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f2cae0e36d28a22d5563d5e3af9c3932163f4718",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/overview",
      "headRefOid": "78a12bfbc91e9bc247374fd95267756c98951e37",
      "mergeCommit": {
        "oid": "2d47d1ba04cb960dfd11038321fa7dac3368b178"
      }
    },
    {
      "number": 358,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMzNjkxNDYx",
      "title": "Introduce pooled connections as optional implementation detail",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/358",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #339",
      "createdAt": "2019-10-29T15:28:35Z",
      "updatedAt": "2019-11-21T07:17:09Z",
      "closedAt": "2019-11-04T18:20:49Z",
      "mergedAt": "2019-11-04T18:20:49Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4ODA2MTM3",
          "commit": {
            "abbreviatedOid": "9c8c4c4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-29T20:19:10Z",
          "updatedAt": "2019-10-29T20:19:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nFor protocols that require in-order request/response pairs, like HTTP, interactions can be automatically distributed across several underlying transport connections. \r\n```",
              "createdAt": "2019-10-29T20:19:11Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MDY3NDQ5",
          "commit": {
            "abbreviatedOid": "9c8c4c4"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T09:41:17Z",
          "updatedAt": "2019-10-30T09:41:18Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Thank you for your suggestion \u2013 I think you got me wrong, as I wanted to stress that there is no ordering requirement across different requests, but the ordering between request/response  is certainly ordered.\r\nI update the text to make this clearer.",
              "createdAt": "2019-10-30T09:41:17Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MTIzOTg1",
          "commit": {
            "abbreviatedOid": "ab73402"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM\r\n\r\nAnd: thanks for doing this! This can make the transport system a lot more powerful, and it's good to tell people about these interesting implementation options this draft, IMO.",
          "createdAt": "2019-10-30T11:17:23Z",
          "updatedAt": "2019-10-30T11:20:27Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I would prefer \"For application protocols that employ\" instead of just \"For protocols that employ\", to be even less ambiguous.",
              "createdAt": "2019-10-30T11:17:23Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            },
            {
              "originalPosition": 24,
              "body": "I *believe* (but remember that I'm not a native speaker) that \"underlaying\" should be \"underlying\" in this paragraph.",
              "createdAt": "2019-10-30T11:18:45Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MTg4OTg5",
          "commit": {
            "abbreviatedOid": "ab73402"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T13:16:29Z",
          "updatedAt": "2019-10-30T13:16:30Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I somewhat agree, but as HTTP has become a transport for more or less everything, I prefer being unspecific here.",
              "createdAt": "2019-10-30T13:16:29Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MjgwMDg2",
          "commit": {
            "abbreviatedOid": "ad8d370"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this!\r\nJust a few minor points from my side.",
          "createdAt": "2019-10-30T15:07:40Z",
          "updatedAt": "2019-10-30T15:21:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why is only the latter not recommended? Shouldn't the last sentence apply to pooled connections as well?",
              "createdAt": "2019-10-30T15:07:41Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            },
            {
              "originalPosition": 15,
              "body": "I agree that it's fine to leave this as \"protocols that employ\" - as long as it's above \"underlying transport connections\", I don't think we care about the purpose of the protocol as long as it's request/response.",
              "createdAt": "2019-10-30T15:11:06Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            },
            {
              "originalPosition": 16,
              "body": "Maybe here it's worth saying explicitly that the implementation exposes a single Connection object? Then it becomes clear that we are not defining a new object for the API here, but just use a regular Connection object.\r\n\r\nSuggestion:\r\n\"For these kinds of protocols, implementations may hide the connection management of the underlying transport connections and only expose expose the individual requests/responses as messages sent and received on a single Connection object, called Pooled Connection.\"",
              "createdAt": "2019-10-30T15:18:36Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            },
            {
              "originalPosition": 17,
              "body": "How does one \"satisfly the preferences\"? I think satisfying the Requires and Prohibits is enough here.",
              "createdAt": "2019-10-30T15:20:07Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzE5OTQy",
          "commit": {
            "abbreviatedOid": "ad8d370"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T15:54:44Z",
          "updatedAt": "2019-10-30T15:54:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "In case of pooled connections, you may have per-message path selection, failover or other mechanisms in place that mitigate these \"less desirable properties\" - therefore, I don't think we need to recommend against this.",
              "createdAt": "2019-10-30T15:54:44Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzI0MzE0",
          "commit": {
            "abbreviatedOid": "ad8d370"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T15:59:44Z",
          "updatedAt": "2019-10-30T15:59:45Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thanks for this suggestion, I incorporate the Idea to stress we are using a single Connection object, but otherwise leave the sentence as simple as possible",
              "createdAt": "2019-10-30T15:59:44Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzI1NzAx",
          "commit": {
            "abbreviatedOid": "ad8d370"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T16:01:22Z",
          "updatedAt": "2019-10-30T16:01:22Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "right - fixed",
              "createdAt": "2019-10-30T16:01:22Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzM4MjYw",
          "commit": {
            "abbreviatedOid": "87bcbfa"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T16:18:11Z",
          "updatedAt": "2019-10-30T16:18:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Okay, fine with me.",
              "createdAt": "2019-10-30T16:18:11Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzQwMDE5",
          "commit": {
            "abbreviatedOid": "87bcbfa"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for the fixes - I think this can be merged now.",
          "createdAt": "2019-10-30T16:20:37Z",
          "updatedAt": "2019-10-30T16:20:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5Mzk3ODU5",
          "commit": {
            "abbreviatedOid": "87bcbfa"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T17:41:20Z",
          "updatedAt": "2019-10-30T17:41:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think you should remove \"automatically\". It is the implementation that distributes I guess so it is not automatic?",
              "createdAt": "2019-10-30T17:41:20Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzMwMTg1",
          "commit": {
            "abbreviatedOid": "87bcbfa"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T08:01:13Z",
          "updatedAt": "2019-11-01T08:01:14Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I mean \"automatically from perspective of the application\" so yes, the automatism has to be realised by the implementation.\r\nIf that is unclear, I can add \"by the transport system implementation\"",
              "createdAt": "2019-11-01T08:01:14Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzYwODc2",
          "commit": {
            "abbreviatedOid": "87bcbfa"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T09:33:34Z",
          "updatedAt": "2019-11-01T09:33:34Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "As this is the implementation draft, I think the perspective should be from the implementation, so perhaps \"the transport implementation may choose to distribute interactions across several underlying transport connections\"?",
              "createdAt": "2019-11-01T09:33:34Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTM1ODUy",
          "commit": {
            "abbreviatedOid": "5ac96ed"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T15:48:43Z",
          "updatedAt": "2019-11-01T15:48:43Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "works for me.",
              "createdAt": "2019-11-01T15:48:43Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNTQwNDgx",
          "commit": {
            "abbreviatedOid": "5ac96ed"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-01T15:55:57Z",
          "updatedAt": "2019-11-01T15:57:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't think that mentioning the pooled connections here is really of too much value\u2014this sentence is about connections that lost races (using worse addresses or interfaces). Do we really want to recommend using these for pools?",
              "createdAt": "2019-11-01T15:55:57Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            },
            {
              "originalPosition": 15,
              "body": "HTTP/2 is not a good case to use multiple underlying TCP/TLS connections... we generally want to multiplex. Or is this just meaning that the HTTP/2 streams themselves are a pool?",
              "createdAt": "2019-11-01T15:56:59Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzg2ODA0",
          "commit": {
            "abbreviatedOid": "5ac96ed"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T20:10:56Z",
          "updatedAt": "2019-11-02T20:10:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Depends on the purpose of the pool:\r\n - If it is to improve reliability, keeping a second worse connection as backup makes sense.\r\n - If it is to optimise on a per-request basis, there might be one low-latency low-throughput and one high-latency high-throughput interface. The latter will loose the race, but may be more desirable for some requests.\r\n\r\nI will update the text up make this clearer.",
              "createdAt": "2019-11-02T20:10:56Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzg2OTkx",
          "commit": {
            "abbreviatedOid": "5ac96ed"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T20:16:19Z",
          "updatedAt": "2019-11-02T20:16:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I only thought about the HTTP/2 Interface, not about the protocol itself. Perhaps it would be better to speak of HTTP without version. \r\nYes, we want to multiplex, but maybe we want to multiplex over several connections, e.g., using different paths or interfaces (there are other reasons like getting twice the TCP share do not want to advocate for).",
              "createdAt": "2019-11-02T20:16:19Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQ4MjY5",
          "commit": {
            "abbreviatedOid": "cf32c70"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T23:31:04Z",
          "updatedAt": "2019-11-03T23:31:05Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yes, that change I think does help!",
              "createdAt": "2019-11-03T23:31:05Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQ4NDQy",
          "commit": {
            "abbreviatedOid": "cf32c70"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T23:32:44Z",
          "updatedAt": "2019-11-03T23:32:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nIf a leaf node has successfully completed its connection, all other attempts should be made ineligible for use by the application for the original request. New connection attempts that involve transmitting data on the network should not be started after another leaf node has completed successfully, as the connection as a whole has been established. An implementation may choose to let certain handshakes and negotiations complete in order to gather metrics to influence future connections. Similarly, an implementation may choose to hold onto fully established leaf nodes that were not the first to establish for use as part of a Pooled Connection, see {{pooled-connections}}, or in future connections. In both cases, keeping additional connections is generally not recommended since those attempts were slower to connect and may exhibit less desirable properties. Still, implementations that, for example, realize fallback using connection pools or do per-request path selection, may make use of these.\r\n```",
              "createdAt": "2019-11-03T23:32:44Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQ4NTg3",
          "commit": {
            "abbreviatedOid": "cf32c70"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T23:33:43Z",
          "updatedAt": "2019-11-03T23:33:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The new text has a couple typos (see other comment), but I still don't totally get the example scenarios described in which this would be wanted. How about just saying implementations may use them, but they're not recommended in general?",
              "createdAt": "2019-11-03T23:33:43Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwOTIzMjE5",
          "commit": {
            "abbreviatedOid": "5ac96ed"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T08:32:24Z",
          "updatedAt": "2019-11-04T08:32:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "fine with me",
              "createdAt": "2019-11-04T08:32:24Z",
              "updatedAt": "2019-11-04T08:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjY0NDI4",
          "commit": {
            "abbreviatedOid": "dfe8f94"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T18:20:43Z",
          "updatedAt": "2019-11-04T18:20:43Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "1ac1e180805f84726d9cb4babdc4c7301df24789",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/impl-pooling",
      "headRefOid": "dfe8f941f5093d5a0b3d40be2c64d906fce2c51c",
      "mergeCommit": {
        "oid": "0360fd130aa6ece7caee158afd32c03a006a8670"
      }
    },
    {
      "number": 359,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2Mzg0MzYz",
      "title": "Move Message Framer implementation details to implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/359",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Completes #344 ",
      "createdAt": "2019-11-04T17:05:20Z",
      "updatedAt": "2019-11-24T05:17:19Z",
      "closedAt": "2019-11-04T20:09:20Z",
      "mergedAt": "2019-11-04T20:09:20Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjY0Mjc1",
          "commit": {
            "abbreviatedOid": "054f916"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks Tommy! I had a very quick look and the text split and move of text looks good to me, so no problem merging this. I noticed two nits and one question for what seemed to be an inconsistency to me.",
          "createdAt": "2019-11-04T18:20:26Z",
          "updatedAt": "2019-11-04T18:46:00Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "an received --> a received",
              "createdAt": "2019-11-04T18:20:26Z",
              "updatedAt": "2019-11-04T18:59:19Z"
            },
            {
              "originalPosition": 18,
              "body": "to indicates --> to indicate",
              "createdAt": "2019-11-04T18:24:21Z",
              "updatedAt": "2019-11-04T18:59:19Z"
            },
            {
              "originalPosition": 37,
              "body": "How does \"Message Framer objects will deliver events to code that is written either as part of the application or a helper library\" relate to the Transport Services implementation providing common framers as mentioned earlier? ",
              "createdAt": "2019-11-04T18:41:21Z",
              "updatedAt": "2019-11-04T18:59:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjg3MjY4",
          "commit": {
            "abbreviatedOid": "582bd8b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T18:59:43Z",
          "updatedAt": "2019-11-04T18:59:44Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Good call. Reworded this section!",
              "createdAt": "2019-11-04T18:59:43Z",
              "updatedAt": "2019-11-04T18:59:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjg3Mjk1",
          "commit": {
            "abbreviatedOid": "582bd8b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T18:59:46Z",
          "updatedAt": "2019-11-04T18:59:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Fixed",
              "createdAt": "2019-11-04T18:59:46Z",
              "updatedAt": "2019-11-04T18:59:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjg3MzM1",
          "commit": {
            "abbreviatedOid": "582bd8b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T18:59:51Z",
          "updatedAt": "2019-11-04T18:59:52Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Fixed",
              "createdAt": "2019-11-04T18:59:51Z",
              "updatedAt": "2019-11-04T18:59:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjkwNzQ4",
          "commit": {
            "abbreviatedOid": "582bd8b"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-04T19:05:36Z",
          "updatedAt": "2019-11-04T19:05:36Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2317a56988c3509c94e010d50d1eeca11b43f6e2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/framer-to-impl",
      "headRefOid": "582bd8b9b2185d40d5e432747be1857edd3fc23a",
      "mergeCommit": {
        "oid": "0425a8397cd2394c695732e058831afea9f6c2e8"
      }
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxODA1Njg3",
      "title": "udp multicast receive (#150)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/360",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/ietf-tapswg/api-drafts/issues/150\r\n\r\nAfter some discussion with Max and Theresa, we believe the interface draft does not need any changes.  This adds a UDP Multicast Receive protocol-specific section to outline the specific considerations for a UDP multicast receive connection.",
      "createdAt": "2019-11-17T00:32:29Z",
      "updatedAt": "2019-11-20T02:49:07Z",
      "closedAt": "2019-11-20T02:49:07Z",
      "mergedAt": "2019-11-20T02:49:06Z",
      "mergedBy": "britram",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Of course it's fantastic if we can keep things as simple as that!  ...but I must be missing something.\r\nE.g., from this PR:\r\n\r\n> SEND.UDP(-Lite). Calling `Send` on a UDP Multicast Receive connection causes an immediate SendError.  This is an unsupported operation.\r\n\r\nSo this means that I can create a connection but never use a Send on it. Actually, I can't even use Initiate. Fine... but where in the process do I learn (or, rather, specify and then expect) that this is the case?",
          "createdAt": "2019-11-19T00:52:54Z",
          "updatedAt": "2019-11-19T00:52:54Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You need to specify a selection property requesting a unidirectional/receive connection, therefore you are aware of it when the connection is ready. \r\n",
          "createdAt": "2019-11-19T02:53:09Z",
          "updatedAt": "2019-11-19T02:53:09Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, that's how I'd also do it - but that selection property doesn't exist AFAICT.  So, that's the required change to the API then.",
          "createdAt": "2019-11-19T04:32:37Z",
          "updatedAt": "2019-11-19T04:32:37Z"
        },
        {
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "body": "The way we are doing it is that we check if the address of the local endpoint is a mc group address. So thats where the distinction between unicast and multicast is made. If that is the case we also require the transport properties to include that the direction is unidirection receive.\r\n\r\n",
          "createdAt": "2019-11-19T04:49:34Z",
          "updatedAt": "2019-11-19T04:49:34Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, sure. That makes the most sense. Still, that's also not written in the API document. I'm just saying this should be there.",
          "createdAt": "2019-11-19T04:59:59Z",
          "updatedAt": "2019-11-19T04:59:59Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, there is a Connection Property called \"Direction of communication\" (Section 5.2.13 in the API draft).\r\nMaybe this should be a Selection Property instead? Because those you have to specify before the Connection gets established.\r\n\r\nAlso, do you think it's worth adding to that section that it's not supported to call Send() on a unidirectional receive Connection or Receive() on a unidirectional send Connection?\r\nInitiate() being unsupported is probably not something that applies to all unidirectional receive Connections, even though I haven't thought about use cases other than multicast yet.",
          "createdAt": "2019-11-19T05:16:16Z",
          "updatedAt": "2019-11-19T05:16:16Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes and yes. \"Direction of communication\" should be a selection property, as it's unlikely to make sense as something to change later. Also, just because that exists, there's no relationship to multicast in the text - the word \"multicast\" doesn't exist in the API draft right now. I'm thinking that somewhere, almost literally the statement from @MaxF12 above should be added. Something like this:\r\n\r\nIf the address of the local endpoint is a multicast group address:\r\n\r\n- The \"Direction of communication\" selection property must be set to unidirectional receive.\r\n- Initiate, Send, ... (list them all here) are not supported.\r\n- (whatever else should be said.)\r\n",
          "createdAt": "2019-11-19T05:22:19Z",
          "updatedAt": "2019-11-19T05:22:19Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I just realized that \"Direction of communication\" already is a Selection Property, so we don't need to change anything there.\r\nBut yes, it probably makes sense to add a paragraph on multicast to the \"Specifying Endpoints\" section 5.1 in the API draft.",
          "createdAt": "2019-11-19T05:40:27Z",
          "updatedAt": "2019-11-19T05:40:27Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We did not make it a selection property, because\r\n\r\n1. it is not of Preference type\r\n2. it should be queryable and probably may change to bidi after establishment if the underlaying protocol is bi-directional\r\n3. it my be settable from bidi to recv to half-close connections.\r\n\r\nYes, this is one of the properties where our categories do not work so great.",
          "createdAt": "2019-11-19T05:48:01Z",
          "updatedAt": "2019-11-19T05:49:10Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln - that's ok, then we leave the property type as it is.",
          "createdAt": "2019-11-19T06:09:02Z",
          "updatedAt": "2019-11-19T06:09:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTk2MjYz",
          "commit": {
            "abbreviatedOid": "b5ba1b0"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this is the mapping that works best for multicast. \r\n\r\nJust to give a bit of context:\r\nFirst, we tried to fit multicast into Initiate() because the multicast receiver actively joins a group. However, this doesn't work for Any-source Multicast, as Initiate() requires a remote endpoint.\r\n\r\nRe-reading our definitions in the architecture draft for Listener, Connection, and so on, I think we don't need to change them, as they are already generic enough for multicast to fit in there.\r\nIn the Implementation draft, at the beginning of Section 2 it says that a listener is \"a passive waiting object\". Here, \"passive waiting\" sounds a bit off to me if a listener can actively join a multicast group. So maybe we want to change that to just say that a listener is \"an object that can receive incoming connections\".",
          "createdAt": "2019-11-17T01:18:16Z",
          "updatedAt": "2019-11-17T01:18:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4Nzk3NzA5",
          "commit": {
            "abbreviatedOid": "b5ba1b0"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this is fine besides a little nit.",
          "createdAt": "2019-11-19T05:53:57Z",
          "updatedAt": "2019-11-19T05:54:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n: Established UDP Multicast Receive connections represent a pair of specific IP addresses and ports.  The \"direction\" transport property must be set to \"unidirectional receive\", and the local endpoint must be configured with a group IP address and a port.\r\n```",
              "createdAt": "2019-11-19T05:53:57Z",
              "updatedAt": "2019-11-19T05:54:58Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0425a8397cd2394c695732e058831afea9f6c2e8",
      "headRepository": "GrumpyOldTroll/taps-api-drafts",
      "headRefName": "udp-multicast",
      "headRefOid": "b5ba1b0efc9ab84b04ab6d788f9c642dd684d259",
      "mergeCommit": {
        "oid": "11e3d258d2b83ffb6a55a69901aa766feeefe00d"
      }
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxODA1Njk0",
      "title": "fixes for a few nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/361",
      "state": "MERGED",
      "author": "GrumpyOldTroll",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-17T00:32:36Z",
      "updatedAt": "2019-11-18T21:49:42Z",
      "closedAt": "2019-11-18T21:49:42Z",
      "mergedAt": "2019-11-18T21:49:42Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTk1NzUw",
          "commit": {
            "abbreviatedOid": "017c9fa"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-17T00:59:20Z",
          "updatedAt": "2019-11-17T00:59:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTk2MTAz",
          "commit": {
            "abbreviatedOid": "017c9fa"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-17T01:13:01Z",
          "updatedAt": "2019-11-17T01:13:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NjIxOTk4",
          "commit": {
            "abbreviatedOid": "017c9fa"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for the fixes!",
          "createdAt": "2019-11-18T20:53:38Z",
          "updatedAt": "2019-11-18T20:53:38Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0425a8397cd2394c695732e058831afea9f6c2e8",
      "headRepository": "GrumpyOldTroll/taps-api-drafts",
      "headRefName": "nits",
      "headRefOid": "017c9fa355a0dfee5188c9176bcbf6ac8bdfcd84",
      "mergeCommit": {
        "oid": "3dcda5a28052829cb2229eb6cc367879b46418ad"
      }
    },
    {
      "number": 368,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzMTg0Nzk4",
      "title": "be explicit and careful about callbacks vs events; fix #347",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/368",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-20T05:58:32Z",
      "updatedAt": "2019-11-21T04:32:38Z",
      "closedAt": "2019-11-21T04:32:34Z",
      "mergedAt": "2019-11-21T04:32:34Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTQ1OTQ3",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-20T06:05:53Z",
          "updatedAt": "2019-11-20T06:06:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Not sure if we want to say it won't \"return immediately\"... that's not quite true for async callbacks depending on the language. The function will return immediately, but have a delayed callback.\r\n\r\nHow about \"its request/call to read will not complete immediately\"?",
              "createdAt": "2019-11-20T06:05:53Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            },
            {
              "originalPosition": 11,
              "body": "I don't think callbacks are really all that specific to security associations, right? Even the send/receive events are callbacks conceptually, I think.",
              "createdAt": "2019-11-20T06:06:47Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTcxOTE4",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T06:23:16Z",
          "updatedAt": "2019-11-20T06:23:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Well... yeah, this is a little fuzzy, because from the interface standpoint, events (architectural) might turn into callbacks (implementation), but callbacks (architectural) that will always be implemented as callbacks.\r\n\r\nI'll drop the last sentence.",
              "createdAt": "2019-11-20T06:23:16Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTc0Mzkx",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-20T06:26:34Z",
          "updatedAt": "2019-11-20T06:30:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Send and Recv events can be implemented using callbacks, but can be implemented by other means (co-routines, closures, \u2026) according to your language.\r\nInstead of introducing a more specific concept for security association establishment, I would prefer to call these events too.",
              "createdAt": "2019-11-20T06:26:34Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTc0Mzg0",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "2 comments. One is very minor, and one is probably just me being confused or wrong about something.",
          "createdAt": "2019-11-20T06:26:32Z",
          "updatedAt": "2019-11-20T06:32:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I find \"will not return immediately\" odd. I understand that you wanted to remove \"will not fail\", but \"will not return immediately\" doesn't seem better, as this makes it sound like a blocking call. Suggest: \"For example, if the application wants to read, its call to read will schedule the invocation of an event containing the received data once it is available.\"",
              "createdAt": "2019-11-20T06:26:32Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            },
            {
              "originalPosition": 15,
              "body": "This just got me confused. I wanted to complain about this saying \"once per Message to be received\" because I'm quite sure that there was a plan for @tfpauly to write that multiple message receives can be scheduled by just providing a parameter?  Yet, I don't see this in our current text and it's also not an open issue... have we ended up deciding that it's really a 1-1 relationship after all?  Strange.....",
              "createdAt": "2019-11-20T06:31:53Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTc3NjEx",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T06:36:55Z",
          "updatedAt": "2019-11-20T06:36:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "It would be nice to have this, maybe add it to the convenience features section? ",
              "createdAt": "2019-11-20T06:36:55Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NTgwMTUx",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-20T06:45:12Z",
          "updatedAt": "2019-11-20T06:45:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjQxNDMw",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T07:46:47Z",
          "updatedAt": "2019-11-20T07:46:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't know? What confuses me is that I'm quite sure that it was once agreed to change this, in general... I think @tfpauly even wanted it, and we said yes, and I even believe it happened???  Am I looking at the wrong section of the interface draft only, or what?",
              "createdAt": "2019-11-20T07:46:47Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5Nzc5NTE3",
          "commit": {
            "abbreviatedOid": "404b530"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T11:43:33Z",
          "updatedAt": "2019-11-20T11:43:34Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Its definitely not in any of the drafts or Ive totally overread it as well. Having to call individual receives is one of the most annoying things about the PyTAPS API.",
              "createdAt": "2019-11-20T11:43:33Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTA0NzYz",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Just two small nits, otherwise looks good!",
          "createdAt": "2019-11-20T23:17:45Z",
          "updatedAt": "2019-11-20T23:27:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Suggest to reword first sentence as \"Unlike sockets, all interaction with a Transport Services...\" , the \"unlike sockets\" at the end does not read well for me.\r\nAlso wondering if \"will not complete immediately\" should better be \"may not complete immediately\" as the data may have arrived before the read.",
              "createdAt": "2019-11-20T23:17:46Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            },
            {
              "originalPosition": 15,
              "body": "@mwelzl maybe you are thinking about the similar discussion of a call to Listen returning more than one Connection? Anyway this seems to be a separate discussion. ",
              "createdAt": "2019-11-20T23:21:55Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTkzODM5",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T01:36:56Z",
          "updatedAt": "2019-11-21T01:36:56Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "@mwelzl we agreed on this for listen, but not for recv. recv is a little different as it implicitly manages backpressure. Yust call recv in the event handler.",
              "createdAt": "2019-11-21T01:36:56Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTk2NDk3",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T01:46:47Z",
          "updatedAt": "2019-11-21T01:46:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Thanks, @abrunstrom and @philsbln for refreshing my memory!  Then I agree, it's a separate issue - but perhaps worth opening an issue for. I'll do that (and include a reminder that this particular text would have to be adapted along with the interface update in case we make this change).",
              "createdAt": "2019-11-21T01:46:47Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTk3NTUy",
          "commit": {
            "abbreviatedOid": "e7b94b6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T01:50:51Z",
          "updatedAt": "2019-11-21T01:50:51Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Sorry, I just changed my mind: I'm *not* opening an issue. This would complicate things (due to questions related to parameters), and I'm not going to add more complications. I might approve them at best  :-)   if someone else asks for it...",
              "createdAt": "2019-11-21T01:50:51Z",
              "updatedAt": "2019-11-21T04:31:48Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cb100a2e4a06022a1b0ca0c22b3948bd19c86655",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "callbacks-347",
      "headRefOid": "275f976477c36dbc7ca6a3411b1d2cc453fe2b0d",
      "mergeCommit": {
        "oid": "7e1b47fdd01fbf7afa8da6911836399c3dd65cc7"
      }
    },
    {
      "number": 369,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzMTg4Nzkx",
      "title": "add dates to references, and clean up spurious ones",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/369",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is necessary to allow CircleCI builds, which have changed to use XMLv3 in the workflow, to continue: XMLv3 requires a <date year> attribute in all refs, where v2 did not.",
      "createdAt": "2019-11-20T06:13:47Z",
      "updatedAt": "2019-11-24T05:16:48Z",
      "closedAt": "2019-11-20T06:14:06Z",
      "mergedAt": "2019-11-20T06:14:06Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3471e89a0ee7536bcab1b79a3b4e684f19df2d88",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "v2v3-fixes",
      "headRefOid": "814222b673cc0e15ddd8ea3b8dedd18fb73717ca",
      "mergeCommit": {
        "oid": "cb100a2e4a06022a1b0ca0c22b3948bd19c86655"
      }
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzMTk2OTkz",
      "title": "Add multipath property enumeration",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/370",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Complete #303 ",
      "createdAt": "2019-11-20T06:43:14Z",
      "updatedAt": "2019-11-24T05:17:16Z",
      "closedAt": "2019-11-21T04:30:06Z",
      "mergedAt": "2019-11-21T04:30:06Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjM1NjAy",
          "commit": {
            "abbreviatedOid": "6ad3969"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good except that I don't think we should *promise* a certain connection multipath behavior. It's a request from the application, only disallowing multipath should be mandatory to support as requested.",
          "createdAt": "2019-11-20T07:43:09Z",
          "updatedAt": "2019-11-20T07:45:19Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\"will\" makes these choices sound like promises, when they are only expressing a wish by the application that may or may not be granted. I'd like to request changing the three instances of \"The connection will support ...\"  above into \"The connection should support ...\". The only promise we can keep is the Disabled choice, \"will not support\" is fine.",
              "createdAt": "2019-11-20T07:43:09Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjUwMzcz",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T07:59:44Z",
          "updatedAt": "2019-11-20T07:59:44Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Good call, fixed! Please take a look.",
              "createdAt": "2019-11-20T07:59:44Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjUxODE1",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-20T08:03:11Z",
          "updatedAt": "2019-11-20T08:03:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjUxOTA5",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T08:03:25Z",
          "updatedAt": "2019-11-20T08:03:26Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Thanks for fixing this!",
              "createdAt": "2019-11-20T08:03:25Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5Njk5NzM1",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This remove the preference from the multipath property \u2013 I guess we should add the functionality selection as a set of preferences",
          "createdAt": "2019-11-20T09:32:00Z",
          "updatedAt": "2019-11-20T09:39:15Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This removes the possibility to prefer vs require multipath functionality.\r\nI would rather make it a set of tuples like the Interface type:\r\n```suggestion\r\n:  Set (Preference, Enumeration)\r\n```",
              "createdAt": "2019-11-20T09:32:01Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            },
            {
              "originalPosition": 18,
              "body": "If we do the above, we can remove the disabled state",
              "createdAt": "2019-11-20T09:35:17Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            },
            {
              "originalPosition": 29,
              "body": "\u2026 and need to change the default:\r\n```suggestion\r\nThe default is to prohibit aggregate and ignore the other multipath functionalities.\r\n```",
              "createdAt": "2019-11-20T09:37:18Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwMzk3MjU3",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T22:22:00Z",
          "updatedAt": "2019-11-20T22:22:00Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yes, this would perhaps be more consistent. But the semantics are not so clear to me. If I set Aggregate to prohibit, what does it mean for the other alternatives? Ignore? But then if I set Hnadover to prohibit, would that mean Ignore for the other alternatives and I could in theory get Aggregate?\r\nSo in that sense maybe sticking to Enumerate will give simpler semantics. I see that the \"preference level\" has been embedded in Tommy's wording for this case. Maybe it does not make sens to require multipath anyway.",
              "createdAt": "2019-11-20T22:22:00Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNDA4Mjg2",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T22:29:16Z",
          "updatedAt": "2019-11-20T22:29:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "How will I then turn it off? By setting prohibit for all other alternatives? That does not seem right. I think we would still need Disabled if we go this route. But the more <i think baout it, the more I think Enumerate is the right call here.",
              "createdAt": "2019-11-20T22:29:16Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNDQ2NTQ0",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks Tommy! I think this looks good The meaning of Interactive is a bit fuzzy, but not sure if we can solve that.",
          "createdAt": "2019-11-20T22:55:17Z",
          "updatedAt": "2019-11-20T22:58:48Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "This one is a bit fuzzy, particularly \"delay\". Does it mean \"delay spikes\" or the base delay is over a given delay target? But perhaps it is hard to be precise? I think this will vary from implementation to implementation. ",
              "createdAt": "2019-11-20T22:55:17Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTkxMDU0",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T01:26:27Z",
          "updatedAt": "2019-11-21T01:26:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "The semantics are like preference of the individual operation levels. Maybe we should add a shortcut for \"set all\".\r\n\r\nOverall, this is a design choice we can make, and I am not too opposed to, but when  we make this choice, we should be explicit abut it and tell how it interacts with the preferences. Maybe \"If it is set to something except disable, a taps system should prefer protocols that provide the chosen mode of operation.\". ",
              "createdAt": "2019-11-21T01:26:27Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjMzNDg4",
          "commit": {
            "abbreviatedOid": "342efba"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T04:23:32Z",
          "updatedAt": "2019-11-21T04:23:32Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The proposed default here surfaces the complexity that Set { Preference, Enumeration } adds. Is this additional complexity useful?",
              "createdAt": "2019-11-21T04:23:32Z",
              "updatedAt": "2019-11-21T04:28:53Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cb100a2e4a06022a1b0ca0c22b3948bd19c86655",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/multipath",
      "headRefOid": "c29a73a9293a449ba3f73ddcfec416545d4a67e2",
      "mergeCommit": {
        "oid": "e657b02d8ff3919f42988c7c501f04909f0474c4"
      }
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzMjE5NzEz",
      "title": "Address privacy property, #300",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/372",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Address #300",
      "createdAt": "2019-11-20T07:57:52Z",
      "updatedAt": "2019-11-24T05:17:17Z",
      "closedAt": "2019-11-21T04:18:28Z",
      "mergedAt": "2019-11-21T04:18:28Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5NjUwODE3",
          "commit": {
            "abbreviatedOid": "fde6a52"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks fine, just nits",
          "createdAt": "2019-11-20T08:00:48Z",
          "updatedAt": "2019-11-20T08:02:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "typo s/Prefere/Prefer",
              "createdAt": "2019-11-20T08:00:48Z",
              "updatedAt": "2019-11-20T14:00:10Z"
            },
            {
              "originalPosition": 24,
              "body": "I would remove this sentence - obviously \"Default\" is the default. We should generally avoid this repetition whenever we have \"Default\" as a value choice IMO.",
              "createdAt": "2019-11-20T08:01:46Z",
              "updatedAt": "2019-11-20T14:00:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5ODU4NDY1",
          "commit": {
            "abbreviatedOid": "eee6f05"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T14:00:21Z",
          "updatedAt": "2019-11-20T14:00:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Fixed!",
              "createdAt": "2019-11-20T14:00:21Z",
              "updatedAt": "2019-11-20T14:00:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5ODU4NTcx",
          "commit": {
            "abbreviatedOid": "eee6f05"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-20T14:00:30Z",
          "updatedAt": "2019-11-20T14:00:31Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Removed!",
              "createdAt": "2019-11-20T14:00:30Z",
              "updatedAt": "2019-11-20T14:00:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5ODYzNzQw",
          "commit": {
            "abbreviatedOid": "eee6f05"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-20T14:07:34Z",
          "updatedAt": "2019-11-20T14:07:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNDcyNDQz",
          "commit": {
            "abbreviatedOid": "eee6f05"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-11-20T23:05:14Z",
          "updatedAt": "2019-11-20T23:05:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNTkyNTQy",
          "commit": {
            "abbreviatedOid": "eee6f05"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you! I was really missing this one .",
          "createdAt": "2019-11-21T01:31:58Z",
          "updatedAt": "2019-11-21T01:31:58Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cb100a2e4a06022a1b0ca0c22b3948bd19c86655",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/temporary-address",
      "headRefOid": "eee6f05ecca16777fff2a33ca8acccb7d394c0cd",
      "mergeCommit": {
        "oid": "21b590d58a008c136d7a1e55084953001385f45a"
      }
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODQzMTMz",
      "title": "Add text for server-side \"racing\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/376",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Address #206 ",
      "createdAt": "2019-11-21T04:52:45Z",
      "updatedAt": "2019-11-24T05:17:14Z",
      "closedAt": "2019-11-21T05:01:00Z",
      "mergedAt": "2019-11-21T05:01:00Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjQwOTY5",
          "commit": {
            "abbreviatedOid": "96e4186"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine - works",
          "createdAt": "2019-11-21T05:00:45Z",
          "updatedAt": "2019-11-21T05:00:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjQxMTA2",
          "commit": {
            "abbreviatedOid": "96e4186"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "meh okay if we must. :P nah this is great, already merged it.",
          "createdAt": "2019-11-21T05:01:24Z",
          "updatedAt": "2019-11-21T05:01:24Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7e1b47fdd01fbf7afa8da6911836399c3dd65cc7",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/server-racing",
      "headRefOid": "96e4186cd8f3c6797dc0d842c2ff963027dbbc47",
      "mergeCommit": {
        "oid": "420364abebb3b58c353e24d6ccdf59686c74b5a1"
      }
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODQ0NTg4",
      "title": "Partial receives are not reordering preferences; fix #309",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/377",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-21T04:59:27Z",
      "updatedAt": "2019-11-24T05:16:46Z",
      "closedAt": "2019-11-21T05:00:40Z",
      "mergedAt": "2019-11-21T05:00:40Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjQwODgw",
          "commit": {
            "abbreviatedOid": "b2704fc"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-21T05:00:12Z",
          "updatedAt": "2019-11-21T05:00:12Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7e1b47fdd01fbf7afa8da6911836399c3dd65cc7",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "partial-means-partial-309",
      "headRefOid": "b2704fc0fde822a94ee5d069d56fdc561b40a7c6",
      "mergeCommit": {
        "oid": "98a435c03cf071b25ba3fa1932e554acb519dfe9"
      }
    },
    {
      "number": 378,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODQ1OTc0",
      "title": "closes #324",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/378",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This adds a few lines of text to the intro",
      "createdAt": "2019-11-21T05:04:52Z",
      "updatedAt": "2020-09-11T16:31:32Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "420364abebb3b58c353e24d6ccdf59686c74b5a1",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW-add_explicit_protocol_selection",
      "headRefOid": "e61c6f4db59365a281dcf7e3a04de685a14999fb",
      "closedAt": "2019-11-21T05:10:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "git merge master then git push; superceded by #379 ",
          "createdAt": "2019-11-21T05:10:34Z",
          "updatedAt": "2019-11-21T05:10:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODQ3MDA0",
      "title": "TAPS allows you to dynamically choose protocol stacks, we should say so.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/379",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-21T05:10:01Z",
      "updatedAt": "2019-11-24T05:16:44Z",
      "closedAt": "2019-11-21T05:13:33Z",
      "mergedAt": "2019-11-21T05:13:33Z",
      "mergedBy": "britram",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "420364abebb3b58c353e24d6ccdf59686c74b5a1",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "close-324-again",
      "headRefOid": "4efeced636691dc62e2656d3678805c2ca5b4882",
      "mergeCommit": {
        "oid": "ae9b32c214b064f7f80350ed8417409fae72c47b"
      }
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODQ3ODE2",
      "title": "Add clarification on Multicast receive to API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/380",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-21T05:14:24Z",
      "updatedAt": "2019-11-22T01:34:02Z",
      "closedAt": "2019-11-22T01:34:02Z",
      "mergedAt": "2019-11-22T01:34:01Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe add the ASN source address (set source address), source filter (add remote addresses)?\r\nMaybe also add that for sending, you specify the group as remote and the socket becomes write-only?\r\n\r\nShould we require specifying direction? This would be slightly harder to use, but future proof in case someone implements reliable ASN on TAPS\u2026",
          "createdAt": "2019-11-21T06:57:45Z",
          "updatedAt": "2019-11-21T06:57:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjQ5ODE2",
          "commit": {
            "abbreviatedOid": "fe6ce9d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "small things that we discussed",
          "createdAt": "2019-11-21T05:40:01Z",
          "updatedAt": "2019-11-21T05:43:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "suggest to replace:\r\nThis will restrict the application to establishing the Preconnection by calling Listen(). The application is unable to send messages on any resulting connections. \r\n\r\nwith:\r\nThis will restrict the application to establishing the Preconnection by calling Listen(). The application will be unable to send messages on any resulting Connections, which will have the Transport Property \"Direction of communication\" set to \"Unidirectional receive\".\r\n\r\nAlso, as discussed, there should be a sentence here about the function of the specified remote endpoint as a filter.",
              "createdAt": "2019-11-21T05:40:02Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjUxMzI3",
          "commit": {
            "abbreviatedOid": "fe6ce9d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T05:45:52Z",
          "updatedAt": "2019-11-21T05:45:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just to explain, I think @tfpauly's concern was that the previous text sounded like requiring extra work (\"the application must set ...\") - but I think you made this a little *too* implicit  :)  That is, I think it's fine to point at the \"unidirectional\" property choice, but not phrase it as something the application must take care of.",
              "createdAt": "2019-11-21T05:45:52Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjU0MTk5",
          "commit": {
            "abbreviatedOid": "13224a4"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T05:57:16Z",
          "updatedAt": "2019-11-21T05:57:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Fixed!",
              "createdAt": "2019-11-21T05:57:16Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjY0OTA1",
          "commit": {
            "abbreviatedOid": "13224a4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T06:36:17Z",
          "updatedAt": "2019-11-21T06:36:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just a typo left: conenction",
              "createdAt": "2019-11-21T06:36:18Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjY1NzEy",
          "commit": {
            "abbreviatedOid": "3973298"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T06:39:07Z",
          "updatedAt": "2019-11-21T06:39:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Whoops, fixed thanks!",
              "createdAt": "2019-11-21T06:39:07Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjY1OTk0",
          "commit": {
            "abbreviatedOid": "3973298"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-21T06:40:04Z",
          "updatedAt": "2019-11-21T06:40:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjk2MjMx",
          "commit": {
            "abbreviatedOid": "3973298"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-21T08:04:28Z",
          "updatedAt": "2019-11-21T08:04:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxMDYwNDEz",
          "commit": {
            "abbreviatedOid": "3973298"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-21T17:29:25Z",
          "updatedAt": "2019-11-21T17:29:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "For consistency, should we perhaps add to the last sentence: \"and the Transport Property \"Direction of communication\" will be set to \"Unidirectional send\".",
              "createdAt": "2019-11-21T17:29:25Z",
              "updatedAt": "2019-11-22T01:26:42Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ae9b32c214b064f7f80350ed8417409fae72c47b",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "6b9b632747c616c935ed966dd3de18a9cca82e56",
      "mergeCommit": {
        "oid": "fa73aaf7b679f6958cf940e27d67c220e2df3a97"
      }
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODc2OTk3",
      "title": "Move Transport Properties text and close #373",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/381",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #373",
      "createdAt": "2019-11-21T07:07:16Z",
      "updatedAt": "2020-09-11T16:31:35Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ae9b32c214b064f7f80350ed8417409fae72c47b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/close-373",
      "headRefOid": "3375e89f4b291f60632141845242191552121c34",
      "closedAt": "2019-12-17T09:41:15Z",
      "mergedAt": "2019-12-17T09:41:15Z",
      "mergedBy": "philsbln",
      "mergeCommit": {
        "oid": "a542da8f73d4dd46ac7945a65bcc7cc7083ec8cb"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose this diff instead\u2014just indent Transport Properties where it is, as a sub-part of Preconnection:\r\n\r\n```\r\n-* Transport Properties: Transport Properties can be specified as part of a Preconnection to allow the application to configure the Transport System and express their requirements, prohibitions, and preferences. There are three kinds of Transport Properties: \r\n+  * Transport Properties: Transport Properties can be specified as part of a Preconnection to allow the application to configure the Transport System and express their requirements, prohibitions, and preferences. There are three kinds of Transport Properties: \r\n \r\n-  * Selection Properties ({{preestablishment}})\r\n-  * Connection Properties ({{preestablishment}})\r\n-  * and Message Properties ({{datatransfer}}); note that Message Properties can also be specified during data transfer to affect specific Messages.\r\n+    * Selection Properties ({{preestablishment}})\r\n+    * Connection Properties ({{preestablishment}})\r\n+    * and Message Properties ({{datatransfer}}); note that Message Properties can also be specified during data transfer to affect specific Messages.\r\n```",
          "createdAt": "2019-11-26T15:24:35Z",
          "updatedAt": "2019-11-26T15:24:35Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tried that\u2026 looks strange:\r\n\r\n```\r\n4.1.1.  Connection Objects\r\n\r\n   o  Preconnection: A Preconnection object is a representation of a\r\n      potential connection.  It has state that describes parameters of a\r\n      Connection that might exist in the future: the Local Endpoint from\r\n      which that Connection will be established, the Remote Endpoint\r\n      (Section 4.1.2) to which it will connect, and Selection Properties\r\n      (Section 4.1.2) that influence the paths and protocols a\r\n      Connection will use.  A Preconnection can be fully specified such\r\n      that it represents a single possible Connection, or it can be\r\n      partially specified such that it represents a family of possible\r\n      Connections.  The Local Endpoint (Section 4.1.2) MUST be specified\r\n      if the Preconnection is used to Listen for incoming connections.\r\n      The Local Endpoint is OPTIONAL if it is used to Initiate\r\n      connections.  The Remote Endpoint MUST be specified in the\r\n      Preconnection that is used to Initiate connections.  The Remote\r\n      Endpoint is OPTIONAL if it is used to Listen for incoming\r\n      connections.  The Local Endpoint and the Remote Endpoint MUST both\r\n      be specified if a peer-to-peer Rendezvous is to occur based on the\r\n      Preconnection.\r\n\r\n      *  Transport Properties can be specified to allow the application\r\n         to configure the Transport System and express their\r\n\r\n\r\n\r\n\r\nPauly, et al.             Expires May 29, 2020                 [Page 14]\r\n\f\r\nInternet-Draft              TAPS Architecture              November 2019\r\n\r\n\r\n         requirements, prohibitions, and preferences.  There are three\r\n         kinds of Transport Properties:\r\n\r\n         +  Selection Properties (Section 4.1.2) that can only be\r\n            specified as part of a Preconnection.\r\n\r\n         +  Connection Properties (Section 4.1.2) that may be changed on\r\n            the Connection.\r\n\r\n         +  and Message Properties (Section 4.1.4) that can also be\r\n            specified during data transfer to affect specific Messages.\r\n```",
          "createdAt": "2019-11-26T20:13:26Z",
          "updatedAt": "2019-11-26T20:13:26Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "eh... it looks a little odd but it is technically more correct. ",
          "createdAt": "2019-11-26T20:37:42Z",
          "updatedAt": "2019-11-26T20:37:42Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the whole point of this text is to introduce the term Transport Properties I think. Otherwise we could have just removed it as the three kinds are described in detail in later sections. Perhaps we can just insert this as running text at the end of the Preconnection description instead to make it look less awkward. Something like:\r\n\r\nSelection Properties (Section 4.1.2) can only be specified as part of a Preconnection. Connection Properties (Section 4.1.2) may also be specified as part of a Preconnection, but may also be changed on the Connection. Together with Message Properties (Section 4.1.4), which can also be specified during data transfer to affect specific Messages, they are the three kinds of Transport Properties that an application can specify to configure the Transport System and express its requirements, prohibitions, and preferences.",
          "createdAt": "2019-11-26T23:48:35Z",
          "updatedAt": "2019-11-26T23:48:35Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I double-checked with the interface: there. transport properties are also an object that is passed to the preconnection and that can retrieved from a connection.\r\nTherefore, I made it a Connection Object and slightly rephrased the text.\r\n\r\nDoes this work better?",
          "createdAt": "2019-11-27T08:55:57Z",
          "updatedAt": "2019-11-27T08:55:57Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is very similar to where we started I think, so did not help much for me unfortunately. I still do not think it fits as a Connection Object on the same level as the rest. What did you think about my suggestion to introduce it in running text as part of the description of the Preconnection?",
          "createdAt": "2019-11-27T10:01:50Z",
          "updatedAt": "2019-11-27T10:01:50Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I thought about your suggestion, but my problem with that is that Transport Properties are actually:\r\n1. An actual Object in the API\r\n2. Also used for introspecting and manipulating Connections\r\n\r\nTherefore, putting them into the Preconnection seems wrong to me.",
          "createdAt": "2019-11-27T12:36:05Z",
          "updatedAt": "2019-11-27T12:36:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNjk2Nzg0",
          "commit": {
            "abbreviatedOid": "53e6ad1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-21T08:05:46Z",
          "updatedAt": "2019-11-21T08:05:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Please  have these be a sub-section of the Pre-Establishment. This should not be a top-level phase of the connection.",
              "createdAt": "2019-11-21T08:05:46Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxMzEyODA2",
          "commit": {
            "abbreviatedOid": "53e6ad1"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-22T03:01:48Z",
          "updatedAt": "2019-11-22T03:01:48Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This was my first idea too, but it did not work out:  In Pre-Establishment, we have a detailed description (two lengthy bullet points out of five) how selection and connection properties work in detail. All ways of rewriting Pre-Establishment to fit the high-level concept of Transport Properties there look awkward to me.\r\n\r\nWe moved that one around a lot just to avoid do making it an API Concept - but it is.",
              "createdAt": "2019-11-22T03:01:48Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxMzY4Mjc1",
          "commit": {
            "abbreviatedOid": "53e6ad1"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Agreed, this rearrangement is not great, but I don't like any of the alternatives either.",
          "createdAt": "2019-11-22T07:19:37Z",
          "updatedAt": "2019-11-22T07:19:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMDY2MDQ3",
          "commit": {
            "abbreviatedOid": "53e6ad1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T15:25:34Z",
          "updatedAt": "2019-11-26T15:25:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Please see my other comment. I think these still belong with Preconnection, as the text indicates.",
              "createdAt": "2019-11-26T15:25:34Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMjU4OTYw",
          "commit": {
            "abbreviatedOid": "53e6ad1"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T20:18:12Z",
          "updatedAt": "2019-11-26T20:18:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The concept of Transport Properties spans all connection objects \u2013 not only the Preconnection \u2013 and therefore I would prefer not to put them in the Preconnection.\r\nNevertheless, they are most often used on the Preconnection and the Selection Properties work only on this one.",
              "createdAt": "2019-11-26T20:18:12Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzOTQ2MjEz",
          "commit": {
            "abbreviatedOid": "9e99bb6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-27T21:09:46Z",
          "updatedAt": "2019-11-27T21:09:46Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Inconsistent spacing here (two vs one)",
              "createdAt": "2019-11-27T21:09:46Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzOTQ2Mjc0",
          "commit": {
            "abbreviatedOid": "9e99bb6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-27T21:09:55Z",
          "updatedAt": "2019-11-27T21:09:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Why the extra space at the beginning?",
              "createdAt": "2019-11-27T21:09:56Z",
              "updatedAt": "2019-11-28T09:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTgwNTI2",
          "commit": {
            "abbreviatedOid": "3375e89"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-02T01:10:38Z",
          "updatedAt": "2019-12-02T01:10:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 383,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0MzA0NjI3",
      "title": "Editorial comments, fixes #365",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/383",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-22T01:07:27Z",
      "updatedAt": "2019-11-24T05:17:33Z",
      "closedAt": "2019-11-22T01:11:54Z",
      "mergedAt": "2019-11-22T01:11:54Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIxMjg1NjAw",
          "commit": {
            "abbreviatedOid": "922a007"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-22T01:09:47Z",
          "updatedAt": "2019-11-22T01:10:00Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nApplications need to ensure that they use security APIs appropriately. In cases where\r\n```",
              "createdAt": "2019-11-22T01:09:47Z",
              "updatedAt": "2019-11-22T01:10:08Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "52b2cc7604beecd42984a360b6883cafb86ca9e0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "arch-editorial-comments",
      "headRefOid": "2fae54f977df768e9975a13a741094e1bd1c371b",
      "mergeCommit": {
        "oid": "3c84028e7bfcb993e8e4913bd2e0377b57fa1b6f"
      }
    },
    {
      "number": 386,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0ODc1Mjg1",
      "title": "Minor editorial tweaks to Architecture",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/386",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Note that Security Considerations and Acknowledgments changes are newline-rewrap only.",
      "createdAt": "2019-11-24T05:34:52Z",
      "updatedAt": "2020-09-11T16:31:33Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d9a75a070c235353ad6b39a86207cb0c32254f6c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "bht-arch-editorial",
      "headRefOid": "f039ae5cfcfc196adcbd5aa4c9fb1664caffe51a",
      "closedAt": "2019-11-26T11:33:03Z",
      "mergedAt": "2019-11-26T11:33:03Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "67d6c5f794f1fec253c2b51da325ac66d6e8eb96"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 387,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ1MDc2MjUx",
      "title": "Fix #385: Resolution is key to path and stack agility. Say so.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/387",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-25T08:05:43Z",
      "updatedAt": "2020-09-11T16:31:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d9a75a070c235353ad6b39a86207cb0c32254f6c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "arch-resolution-385",
      "headRefOid": "233d4c22af1e2bf4f085bedfbb76dfbd3fbe107e",
      "closedAt": "2019-11-29T20:41:57Z",
      "mergedAt": "2019-11-29T20:41:57Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "b4bbafe4ff06d781ad3b31c0d13f9095e3ebf178"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a lightweight proposal to address #385.",
          "createdAt": "2019-11-25T13:24:40Z",
          "updatedAt": "2019-11-25T13:24:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNjMwMzMx",
          "commit": {
            "abbreviatedOid": "ba710cb"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I had some problems with the figures. Do we need to update them or perhaps it is enough to update the text?",
          "createdAt": "2019-11-25T22:49:55Z",
          "updatedAt": "2019-11-25T22:58:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This looks strange to me. It looks like the stub resolver bypasses the kernel protocol implementations. It should also rather run on top.",
              "createdAt": "2019-11-25T22:49:55Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            },
            {
              "originalPosition": 58,
              "body": "Also do not like the \"(resolution + connection)\". What about sending and receiving data? Also looks like the API exposes resolution and connection as separate entities rather than the opposite.",
              "createdAt": "2019-11-25T22:50:03Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            },
            {
              "originalPosition": 47,
              "body": "Reading this again now and seeing the figures, I wonder if \r\n\r\n> The Transport Services architecture maintains this general model of interaction, but aims to both modernize the API surface \r\n\r\nmay lead the reader to thinking that the Transport System Implementation runs in the kernel? Separate issue I guess, but a bit realted to the bypass comment above.",
              "createdAt": "2019-11-25T22:56:15Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNzQxMTY2",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T05:47:09Z",
          "updatedAt": "2019-11-26T05:47:10Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yep, tweaked this.",
              "createdAt": "2019-11-26T05:47:10Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNzQxNDc0",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T05:48:18Z",
          "updatedAt": "2019-11-26T05:48:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Yep, have reverted this, it's clear in contrast with the previous figure.",
              "createdAt": "2019-11-26T05:48:18Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNzQxNDk2",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T05:48:22Z",
          "updatedAt": "2019-11-26T05:48:22Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I tweaked this language slightly, but would point out that nothing in the *architecture* precludes a kernel TAPS implementation.",
              "createdAt": "2019-11-26T05:48:22Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNzQxNjIz",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "made a few edits for Anna's comments",
          "createdAt": "2019-11-26T05:48:47Z",
          "updatedAt": "2019-11-26T05:48:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyODEwODk4",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T08:52:46Z",
          "updatedAt": "2019-11-26T08:52:47Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "still looks strange\u2026 is it not rather that way:\r\n```suggestion\r\n        |                  |                  |\r\n  +------------+     +------------+    +--------------+\r\n  |    stub    |     | Stream API |    | Datagram API |\r\n  |  resolver  |     +------------+    +--------------+\r\n  +------------+           |                  |\r\n  |    DNS.    |           |                  |\r\n  +------------+--------------------------------------+\r\n  |                       TCP                UDP      |\r\n  |              Kernel Networking Stack              |\r\n  +---------------------------------------------------+```",
              "createdAt": "2019-11-26T08:52:47Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyODExODY4",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Much clearer than before",
          "createdAt": "2019-11-26T08:54:22Z",
          "updatedAt": "2019-11-26T08:54:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMDYxODE2",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-26T15:20:19Z",
          "updatedAt": "2019-11-26T15:21:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Agreed with @philsbln that the DNS resolver doesn't belong in the kernel.\r\n\r\nHow about just this:\r\n\r\n```\r\n        |                 |                  |\r\n   +------------+     +------------+    +--------------+\r\n   |    stub    |     | Stream API |    | Datagram API |\r\n   |  resolver  |     +------------+    +--------------+\r\n   +------------+         |                  |\r\n                     +---------------------------------+\r\n                     |    TCP                UDP       |\r\n                     |    Kernel Networking Stack      |\r\n                     +---------------------------------+\r\n                                      |\r\n```",
              "createdAt": "2019-11-26T15:20:20Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            },
            {
              "originalPosition": 47,
              "body": "Do we need `identifier address resolution` or can this just be `name resolution`?\r\n\r\nAlso, typo on `resoulution`.",
              "createdAt": "2019-11-26T15:21:24Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMjYxMTk2",
          "commit": {
            "abbreviatedOid": "e90b159"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T20:22:28Z",
          "updatedAt": "2019-11-26T20:22:28Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "works for me either way",
              "createdAt": "2019-11-26T20:22:28Z",
              "updatedAt": "2019-11-26T20:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMjk4MjQ5",
          "commit": {
            "abbreviatedOid": "233d4c2"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yip - I like",
          "createdAt": "2019-11-26T21:32:55Z",
          "updatedAt": "2019-11-26T21:32:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzMzQ3MzAx",
          "commit": {
            "abbreviatedOid": "233d4c2"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-26T23:24:48Z",
          "updatedAt": "2019-11-26T23:24:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think this is much better than the first suggestion, but is there a reason the box for the kernel networking stack does not expand also under the stub resolver? (But leaving DNS out.) This would seem most natural to me, but if the rest of you do not like that we can leave it as is.",
              "createdAt": "2019-11-26T23:24:48Z",
              "updatedAt": "2019-11-26T23:24:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIzNzkxNTA4",
          "commit": {
            "abbreviatedOid": "233d4c2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-27T16:12:43Z",
          "updatedAt": "2019-11-27T16:12:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 388,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ3MDIyOTU1",
      "title": "Change example of Specialized Feature to multipath, fixes #363",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/388",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changed example of a Specialized Feature (non-minset) from \"encryption\" to \"automatic handover or failover\", as suggested by Anna in #363.\r\nIf anyone has an alternative suggestion how to word this, I'm open.\r\n\r\nIdeas for alternative solutions include:\r\n- Go back to the \"encryption\" example, but do not make \"encryption\" sound like a generic feature but rather talk about specific security protocols, e.g.: \"For example, if an application requires encryption of its transport data, it could select a specific security protocol. In this case, only protocol stacks that include this security protocol are eligible to be used.\"\r\n- Find a different example\r\n- Give up and throw out the example entirely, maybe even changing what a \"specialized feature\" is\r\n\r\nLooking for guidance from the authors here :)",
      "createdAt": "2019-11-29T12:13:55Z",
      "updatedAt": "2020-09-11T16:31:36Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "67d6c5f794f1fec253c2b51da325ac66d6e8eb96",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "specialized-features-example",
      "headRefOid": "0debf0251e75bdf5bfae95bd23c3153d0b8d91fa",
      "closedAt": "2019-11-29T20:40:23Z",
      "mergedAt": "2019-11-29T20:40:23Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c6238300f54e7a7dad46a8c0b68a381f1eb875af"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0ODI2NTk5",
          "commit": {
            "abbreviatedOid": "0debf02"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-29T18:23:29Z",
          "updatedAt": "2019-11-29T18:23:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 389,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ3MDMwODc3",
      "title": "Define equivalence, addresses #305 and #364",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/389",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses two issues related to protocol stack equivalence:\r\n\r\n- TCP and UDP can now be equivalent if the application does not care about message boundaries (see mailing list discussion in July 2019)\r\n- Security protocol and parameters need to be equivalent, not \"features\" which implied abstract security features.\r\n\r\nBasically, equivalent stacks are all stacks that satisfy whatever the application requested.\r\nIf you want to race different security protocols (like TLS 1.2 and 1.3), your application has to specify that it considers these protocol equivalent.\r\n\r\nQuestion to authors: Should the SHOULD in 3. become a MUST?",
      "createdAt": "2019-11-29T12:38:15Z",
      "updatedAt": "2020-09-11T16:31:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "67d6c5f794f1fec253c2b51da325ac66d6e8eb96",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "protocol-stack-equivalence",
      "headRefOid": "0ed0c243711995a14b2bbb353308735c8b5e7c7b",
      "closedAt": "2019-11-29T20:43:26Z",
      "mergedAt": "2019-11-29T20:43:26Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "267dd0e09b3ddcb5156d3bda20bfb4c4389024a2"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the SHOULD, I'd rather leave it as a SHOULD for now, to give some wiggle room to implementations.",
          "createdAt": "2019-11-29T18:22:39Z",
          "updatedAt": "2019-11-29T18:22:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0ODI2MzIy",
          "commit": {
            "abbreviatedOid": "0ed0c24"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Nice!",
          "createdAt": "2019-11-29T18:21:53Z",
          "updatedAt": "2019-11-29T18:21:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 390,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ3NzY5ODcy",
      "title": "Mw arch read through",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/390",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A complete arch. read-through, leading to a couple of nit fixes and other minor suggestions",
      "createdAt": "2019-12-02T17:05:05Z",
      "updatedAt": "2020-09-11T16:31:41Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "267dd0e09b3ddcb5156d3bda20bfb4c4389024a2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw_arch_ReadThrough",
      "headRefOid": "e6d88439bfcfab60bc425972ef1f7c7bd177c00c",
      "closedAt": "2019-12-02T18:54:02Z",
      "mergedAt": "2019-12-02T18:54:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "9bcef86e04aadcf57e7eaab881a2ebb79c2ea167"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1NDU1NTU1",
          "commit": {
            "abbreviatedOid": "e6d8843"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-02T18:53:28Z",
          "updatedAt": "2019-12-02T18:53:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 391,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4MjU1NTY4",
      "title": "minset appendix update: section references",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/391",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This also addresses two inline [EDITOR's NOTE] items.\r\n\r\nOne was about the per-message override capacity profile being inconsistent with the other one; this was solved by removing details, such that the other one defines the possible choices.\r\n\r\nAnother was about selection vs. connection properties, with broken text. There was no need to add the references as the editor's note says, I thought.\r\n",
      "createdAt": "2019-12-03T10:44:30Z",
      "updatedAt": "2020-09-11T16:31:42Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "40331b88d15d5f1147cb32aa9b757f1dbd03edbc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW-updating_minset_appendix",
      "headRefOid": "96844aa617594a91ba57d18738fa9220a1fac0f2",
      "closedAt": "2019-12-20T16:06:05Z",
      "mergedAt": "2019-12-20T16:06:05Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "f6e7d3db97ddf47118be9352491e207cb607a124"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2MzU1Njc1",
          "commit": {
            "abbreviatedOid": "91f3341"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-03T18:27:16Z",
          "updatedAt": "2019-12-03T18:27:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n### Parallel Use of Multiple Paths {#parallel-multipath}\r\n```",
              "createdAt": "2019-12-03T18:27:16Z",
              "updatedAt": "2019-12-04T12:12:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2MzcyMDA2",
          "commit": {
            "abbreviatedOid": "91f3341"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T18:54:46Z",
          "updatedAt": "2019-12-03T18:54:47Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "protocol and path selection --> connection (as this property is a connection property)",
              "createdAt": "2019-12-03T18:54:46Z",
              "updatedAt": "2019-12-04T12:12:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2ODAwMDQx",
          "commit": {
            "abbreviatedOid": "d53fe96"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T12:09:55Z",
          "updatedAt": "2019-12-04T12:09:55Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Fixed! This was old terminology. Good catch, thanks!",
              "createdAt": "2019-12-04T12:09:55Z",
              "updatedAt": "2019-12-17T09:47:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MzQzNjMy",
          "commit": {
            "abbreviatedOid": "96844aa"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "this LGTM, thanks!",
          "createdAt": "2019-12-20T16:05:59Z",
          "updatedAt": "2019-12-20T16:05:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ5OTMzNjg2",
      "title": "Few very minor architecture nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/393",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-06T12:45:26Z",
      "updatedAt": "2019-12-06T17:50:18Z",
      "closedAt": "2019-12-06T17:50:17Z",
      "mergedAt": "2019-12-06T17:50:17Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4Mjg0MDI1",
          "commit": {
            "abbreviatedOid": "7132047"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure if I agree with removing hyphens; what's the rationale on this? Other changes look good =)",
          "createdAt": "2019-12-06T15:42:48Z",
          "updatedAt": "2019-12-06T15:43:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why no hyphens here?",
              "createdAt": "2019-12-06T15:42:49Z",
              "updatedAt": "2019-12-06T16:17:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4Mjk4MTMz",
          "commit": {
            "abbreviatedOid": "7132047"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-06T16:03:57Z",
          "updatedAt": "2019-12-06T16:03:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It was just for consistentcy, some times hyphens were used and sometimes they were not. I am used to the version without them, if its more common to use them I can change it to that. ",
              "createdAt": "2019-12-06T16:03:57Z",
              "updatedAt": "2019-12-06T16:17:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4MzAxOTI1",
          "commit": {
            "abbreviatedOid": "7132047"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-06T16:09:46Z",
          "updatedAt": "2019-12-06T16:09:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Cases where we say \"the transport layer\" should not be hyphenated, which is the case. However, if you use the term as an adjective, such as \"a transport-layer address\", you need to add a hyphen.\r\n\r\nThe one error I see in the document by those rules is just that \"available network layer interfaces\" should be \"available network-layer interfaces\".",
              "createdAt": "2019-12-06T16:09:46Z",
              "updatedAt": "2019-12-06T16:17:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4MzA3OTEw",
          "commit": {
            "abbreviatedOid": "0f8e441"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-06T16:18:58Z",
          "updatedAt": "2019-12-06T16:18:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Oh of course, sorry my bad. Thanks for the explanation, fixed!",
              "createdAt": "2019-12-06T16:18:58Z",
              "updatedAt": "2019-12-06T16:18:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4MzU5NzE0",
          "commit": {
            "abbreviatedOid": "0f8e441"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-06T17:50:06Z",
          "updatedAt": "2019-12-06T17:50:06Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "40331b88d15d5f1147cb32aa9b757f1dbd03edbc",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "0f8e441d1e33e044a7cd868014ae14bc31d4620f",
      "mergeCommit": {
        "oid": "b4a4f1100ad97823aea47bb61a2d26e7dd766c6a"
      }
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0MDMzMzEy",
      "title": "Address Arch NiTS",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/394",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closed #392",
      "createdAt": "2019-12-17T10:38:17Z",
      "updatedAt": "2020-09-11T16:33:36Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a542da8f73d4dd46ac7945a65bcc7cc7083ec8cb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/nits-392",
      "headRefOid": "cd36a160a177b7de5d68613ec1b66aaaa7b75f5e",
      "closedAt": "2019-12-20T16:07:11Z",
      "mergedAt": "2019-12-20T16:07:11Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3f5e60b0c548e0dd29f647024f296d9dddf582d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0MTgxOTg3",
          "commit": {
            "abbreviatedOid": "57d6837"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T18:40:52Z",
          "updatedAt": "2019-12-18T18:40:52Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I don't think I agree with adding the commas here. Can we revert this change?",
              "createdAt": "2019-12-18T18:40:52Z",
              "updatedAt": "2019-12-19T13:36:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NjM0NTMy",
          "commit": {
            "abbreviatedOid": "cd36a16"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-19T13:37:13Z",
          "updatedAt": "2019-12-19T13:37:14Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I was quite sure they are optional and improve readability, but can remove them.  ",
              "createdAt": "2019-12-19T13:37:13Z",
              "updatedAt": "2019-12-19T13:37:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NzY3ODEw",
          "commit": {
            "abbreviatedOid": "cd36a16"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-19T16:52:06Z",
          "updatedAt": "2019-12-19T16:52:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MzQ0MTk0",
          "commit": {
            "abbreviatedOid": "cd36a16"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-12-20T16:07:05Z",
          "updatedAt": "2019-12-20T16:07:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 399,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODI4NzE2",
      "title": "Colin's points and interim edits, fix #395",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/399",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-20T17:37:31Z",
      "updatedAt": "2020-09-11T16:33:49Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3f5e60b0c548e0dd29f647024f296d9dddf582d6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "arch-nits-395",
      "headRefOid": "00688d2a7b7519d802da8aa4667f43b6543d0321",
      "closedAt": "2019-12-20T19:29:56Z",
      "mergedAt": "2019-12-20T19:29:56Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "bd804cad2aad599fedab836bc96668866e095861"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDEyMjg1",
          "commit": {
            "abbreviatedOid": "fa523a2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good, pending my one remaining nit about how to phrase racing =)",
          "createdAt": "2019-12-20T17:50:31Z",
          "updatedAt": "2019-12-20T17:50:50Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "```suggestion\r\nConnection establishment attempts for a set of candidates may be performed simultaneously, synchronously, serially, or some combination of all of these. We refer to this process as racing, borrowing terminology from Happy Eyeballs {{?RFC8305}}.\r\n```",
              "createdAt": "2019-12-20T17:50:31Z",
              "updatedAt": "2019-12-20T19:28:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDQ0NzA5",
          "commit": {
            "abbreviatedOid": "fa523a2"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T18:42:45Z",
          "updatedAt": "2019-12-20T18:42:46Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "...for a set of candidates?",
              "createdAt": "2019-12-20T18:42:46Z",
              "updatedAt": "2019-12-20T19:28:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDYxMTc4",
          "commit": {
            "abbreviatedOid": "fa523a2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T19:00:08Z",
          "updatedAt": "2019-12-20T19:00:09Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Updated!",
              "createdAt": "2019-12-20T19:00:09Z",
              "updatedAt": "2019-12-20T19:28:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 400,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODYwNTMw",
      "title": "Explain half-close vs close()",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/400",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Completes #397 ",
      "createdAt": "2019-12-20T18:58:25Z",
      "updatedAt": "2020-09-11T16:33:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3f5e60b0c548e0dd29f647024f296d9dddf582d6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp-arch-half-close",
      "headRefOid": "6fda4a3ed9b84fd36440a81c9bb50b5d6ef5d3da",
      "closedAt": "2019-12-20T20:50:18Z",
      "mergedAt": "2019-12-20T20:50:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "d998a6e82f333dce22f7a0d20cce94c3de1cfb94"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDc1Mjc3",
          "commit": {
            "abbreviatedOid": "6fda4a3"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2019-12-20T19:30:32Z",
          "updatedAt": "2019-12-20T19:30:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDk1OTYw",
          "commit": {
            "abbreviatedOid": "6fda4a3"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is *perfect* IMO!",
          "createdAt": "2019-12-20T20:08:29Z",
          "updatedAt": "2019-12-20T20:08:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU2MTI5OTEy",
      "title": "Update description of rendezvous",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/401",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Generalise the discussion of Rendezvous in arch.\r\n\r\nCloses #396 ",
      "createdAt": "2019-12-22T23:21:17Z",
      "updatedAt": "2020-09-11T16:33:50Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d998a6e82f333dce22f7a0d20cce94c3de1cfb94",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-rendezvous",
      "headRefOid": "51390dbee15525b2792f541a9499dbdd88fd390a",
      "closedAt": "2019-12-23T14:52:28Z",
      "mergedAt": "2019-12-23T14:52:27Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "de6a71a864da7f2fb4ca8b1270ce21aab6711157"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NzUyMzE5",
          "commit": {
            "abbreviatedOid": "4b50e3b"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-23T08:12:23Z",
          "updatedAt": "2019-12-23T08:12:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODkwMjMy",
          "commit": {
            "abbreviatedOid": "4b50e3b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-23T14:50:38Z",
          "updatedAt": "2019-12-23T14:50:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  a Remote Endpoint while listening for an incoming connection from that\r\n```",
              "createdAt": "2019-12-23T14:50:39Z",
              "updatedAt": "2019-12-23T14:50:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 402,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU4NTE0MDM4",
      "title": "Add some details to framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/402",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #340 ",
      "createdAt": "2020-01-01T20:06:51Z",
      "updatedAt": "2020-01-03T00:02:58Z",
      "closedAt": "2020-01-03T00:02:58Z",
      "mergedAt": "2020-01-03T00:02:58Z",
      "mergedBy": "tfpauly",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODIyODcw",
          "commit": {
            "abbreviatedOid": "cf4ffba"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the changes!",
          "createdAt": "2020-01-02T19:40:18Z",
          "updatedAt": "2020-01-02T19:40:27Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Two things here:\r\n1. This should take an error, like `FailConnection`\r\n2. I think this doesn't need to be distinct from `FailConnection` overall. If the place where the framer is running is during candidate racing, then its failing its view of the connection is only failing one candidate. I don't know if we should have the term \"candidate\" bubbling up into the API.",
              "createdAt": "2020-01-02T19:40:18Z",
              "updatedAt": "2020-01-02T23:46:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTA5MTM5",
          "commit": {
            "abbreviatedOid": "aa968f4"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T23:47:55Z",
          "updatedAt": "2020-01-02T23:47:56Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Good call, really no need to have it as a distinct call!",
              "createdAt": "2020-01-02T23:47:56Z",
              "updatedAt": "2020-01-02T23:47:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTExOTU2",
          "commit": {
            "abbreviatedOid": "aa968f4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-03T00:02:52Z",
          "updatedAt": "2020-01-03T00:02:52Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "de6a71a864da7f2fb4ca8b1270ce21aab6711157",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "aa968f45b215673c969f066a51379f9bd47b44e8",
      "mergeCommit": {
        "oid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8"
      }
    },
    {
      "number": 403,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyMDQxMzYy",
      "title": "Some small proposed fixes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/403",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "- Example code updates: this is to try to avoid people stumbling over, e.g., \"send\" being part of the \"main code\". I believe it's a little cleaner with these added comments.\r\n\r\n- Lifetime Message property: mentioned -1 as a special value for infinite, else it's a bit odd to only use \"infinite\" for an integer\r\n\r\n- very minor text fix about corruption protection length Message property",
      "createdAt": "2020-01-13T10:29:48Z",
      "updatedAt": "2020-09-11T16:32:05Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "91c94ba30c107a521a27c1fffa16062a9682bd8a",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW-small_fixes",
      "headRefOid": "5cabcbf2fd5a8792d79be4b0b0cf44893967587e",
      "closedAt": "2020-01-22T08:49:51Z",
      "mergedAt": "2020-01-22T08:49:51Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "a3c17e0d832ca22074acc4cf88bbbf58907607f7"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, so I think I addressed @tfpauly's comments here, and agreed with @theri that we could adjust things further later on if needed - so now I'll just merge this one, seems safe to do to me.",
          "createdAt": "2020-01-22T08:46:35Z",
          "updatedAt": "2020-01-22T08:46:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjMzMzMx",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T00:47:11Z",
          "updatedAt": "2020-01-14T00:47:12Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Technically, isn't everything after this line part of the receive handler? That also includes stopping listening\u2014or at least listen stop shouldn't be called until ConnectionReceived fires.",
              "createdAt": "2020-01-14T00:47:11Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjMzNzIz",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T00:48:34Z",
          "updatedAt": "2020-01-14T00:48:34Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Do we need to specify an integer value like this at all?",
              "createdAt": "2020-01-14T00:48:34Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMzI3OTQx",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T07:19:29Z",
          "updatedAt": "2020-01-14T07:19:29Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I thought about this and wasn't sure; I guess yes, since this code assumes only a single connection, it's easiest to put it inside the receive handler. Maybe we should change the comment line to say:\r\n// Stop listening for incoming Connections (this example supports only one Connection)\r\n",
              "createdAt": "2020-01-14T07:19:29Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMzI4NjMw",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T07:21:38Z",
          "updatedAt": "2020-01-14T07:21:39Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Ah, I agree, changing this to \"Numeric\" is a better solution!",
              "createdAt": "2020-01-14T07:21:38Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDQ0MDIy",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for fixing the code examples - I agree it's cleaner to make explicit that the event handlers are separate pieces of code.\r\nI've added some suggestions on how we could make this even cleaner. You can do that in this PR, or I can also do a separate PR later.",
          "createdAt": "2020-01-14T10:51:38Z",
          "updatedAt": "2020-01-14T10:57:55Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yes, I guess it's good to say explicitly that this example receives a single connection and then stops listening.\r\n\r\nI think it'd make sense to adjust the text above the example (\"This is an example of how an application might listen for incoming Connections [\u2026]\" --> \"This is an example of how an application might listen for an incoming Connection\").\r\n\r\nTo make it clearer that the handler is a separate piece of code, we could put it into a separate code snippet, above which we say something like \"This is an example of a receive handler which gets called when an incoming Connection is received, reads a Message, sends a response, and then stops listening for incoming Connections\".",
              "createdAt": "2020-01-14T10:51:38Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            },
            {
              "originalPosition": 22,
              "body": "Again, here we could use separate snippets of code to make it clearer that this is separate code, which gets called when the event happens.",
              "createdAt": "2020-01-14T10:54:01Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNDkyNDUy",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T12:22:37Z",
          "updatedAt": "2020-01-14T12:23:08Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I thought about this too, but on the positive side, the example as it stands also reflects the sequence in which things happen - even if the code being part of the main code isn't quite right. My suggestion: I fix it as @tfpauly suggested and also incorporate your updated comment, in this PR, and once this lands, you can fine-tune it further with your suggestion to split the code out and we can see what folks think?",
              "createdAt": "2020-01-14T12:22:37Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            },
            {
              "originalPosition": 22,
              "body": "Suggested approach as above",
              "createdAt": "2020-01-14T12:23:05Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTU0MDg4",
          "commit": {
            "abbreviatedOid": "ba06b74"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T14:05:26Z",
          "updatedAt": "2020-01-14T14:05:26Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Fine with me :)",
              "createdAt": "2020-01-14T14:05:26Z",
              "updatedAt": "2020-01-22T08:48:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 405,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyNjU5NTA1",
      "title": "API draft: Minor fixes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/405",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I read the API draft and fixed a couple of minor issues. That is, they're minor as far as I can see - please tell me if you disagree.",
      "createdAt": "2020-01-14T14:18:14Z",
      "updatedAt": "2020-09-11T16:34:01Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-minor-fixes",
      "headRefOid": "67f576fc7f156f4822c9a6fa619762744e37f3f7",
      "closedAt": "2020-01-16T12:39:30Z",
      "mergedAt": "2020-01-16T12:39:30Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "4c5bc5e058b48685a087d743dcd3fd2c77aaa9c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTkwMzM1",
          "commit": {
            "abbreviatedOid": "67f576f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Go ahead \u2013 Thank you for the fixes.",
          "createdAt": "2020-01-14T14:53:09Z",
          "updatedAt": "2020-01-14T14:53:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODgxMzk0",
          "commit": {
            "abbreviatedOid": "67f576f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Lots of good finds, I was surprised to see how many I must have overlooked when I last read this!  Thanks for doing this!",
          "createdAt": "2020-01-16T12:38:24Z",
          "updatedAt": "2020-01-16T12:38:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyNjYxMDc1",
      "title": "Add a reference to DPLPMTUD for Message Size before fragmentation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/406",
      "state": "MERGED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Add a reference to MPS in DPLPMTUD for the Message Size Before Fragmentation property.",
      "createdAt": "2020-01-14T14:21:19Z",
      "updatedAt": "2020-09-11T16:34:21Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "adventureloop-patch-1",
      "headRefOid": "73e1f3ce94e29bec171b7e8a1f5edc761ab129f5",
      "closedAt": "2020-01-16T12:51:13Z",
      "mergedAt": "2020-01-16T12:51:13Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "64c2b9ec5426c2c7b7da7498a4c5dd343392de1f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTcyNjI0",
          "commit": {
            "abbreviatedOid": "0d79e1a"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGMT, just replace \"models\" with something more suitable.",
          "createdAt": "2020-01-14T14:29:53Z",
          "updatedAt": "2020-01-14T14:31:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nsegmentation at the sender. This property exposes the Maximum Packet Size (MPS)\r\n```",
              "createdAt": "2020-01-14T14:29:54Z",
              "updatedAt": "2020-01-16T12:47:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyNjY4OTUy",
      "title": "API draft: Replace \"Protocol Properties\" with updated terms",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/407",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "When reading the API draft, I noticed that in some places it was still using the outdated term \"Protocol Properties\" where it actually means Connection Properties or Message Properties.\r\nI replaced the terms in this PR.\r\n\r\nWe do still define \"Specific Protocol Properties\", so I kept these.",
      "createdAt": "2020-01-14T14:37:00Z",
      "updatedAt": "2020-09-11T16:34:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-protocol-properties",
      "headRefOid": "0ac3a72257edfcbf3ac09ca27194294f8d48ecd5",
      "closedAt": "2020-01-16T12:50:50Z",
      "mergedAt": "2020-01-16T12:50:50Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "33fbf49aebb7858d2b9340c98e7ed8837922fe35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTgzOTM1",
          "commit": {
            "abbreviatedOid": "a1d85d8"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Fine with me except the change on  L1313",
          "createdAt": "2020-01-14T14:44:52Z",
          "updatedAt": "2020-01-14T14:46:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would prefer to keep this generic, as later documents may add Connection Properties.",
              "createdAt": "2020-01-14T14:44:52Z",
              "updatedAt": "2020-01-14T15:11:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNjA1NDIy",
          "commit": {
            "abbreviatedOid": "0ac3a72"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-14T15:12:08Z",
          "updatedAt": "2020-01-14T15:12:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I made the text less exclusive, so now \"Priority (Connection)\" is an example for a non-shared Connection Property, but the text no longer implies that it is the only one.",
              "createdAt": "2020-01-14T15:12:09Z",
              "updatedAt": "2020-01-14T15:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTkwMDE3",
          "commit": {
            "abbreviatedOid": "0ac3a72"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2020-01-15T12:40:54Z",
          "updatedAt": "2020-01-15T12:40:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 411,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyODM3ODM5",
      "title": "Address on Gorry's WGLC comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/411",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "From the email:\r\n\r\n```\r\nIn Section 2\r\n/The Socket API/\r\nThe text uses /sockets/, but previously the text in 2.1 talks about the Socket API. \r\nI didn\u2019t see a problem here while we were working on the spec, but I think it world be better is section 2 explicating introduced the word /sockets/ and defined the Socket API as a definition of the sockets method. At least /sockets/ needs to be explained before it is used in Sections 2.1 2.2, 2.3, etc.\r\n---\r\nIn Section 3.2\r\n/handover or failover for a Connection/\r\n- should this use a lower case letter \u2018c\u2019 for connection. This seems to be before the document defines a specific meaning for a TAPS Connection.\r\n---\r\nIn Title of Figure 4: \r\nTitle: /The lifetime of a connection/\r\n- I think this does warrant a capital letter \u2018C\u2019 for connection? or alternatively a re-wording to say something abstract, like: /The lifetime of a connection in the TAPS archicture/\r\n---\r\nIn Section 4.1.1.\r\n/A Preconnection object is a representation of a\r\npotential connection./\r\n- Does this warrant a capital letter \u2018C\u2019 for connection? (if not then I think it should say a /connection to be established? or similar).\r\n---\r\nIn Section 4.1.2.\r\n/ requirements around the Maximum Transmission Unit (MTU) or path\r\n      MTU (PMTU),/\r\n- The example is OK, but the words are not really correct. I don\u2019t think general purpose apps need to know about the local MTU ever, they may care bout the PMTU - but really they care about the maximum packet size they\r\ncan send along a path. That\u2019s an application-layer quantity, and isn\u2019t related to the ultimate size of packet emitted by an interface. In writing the DPLPMTUD spec we have ben encouraged to make this difference more explicit, and I think TAPS should also not confuse interface limits, network limits and application limits. Packet Size anyway have little bearing on transports that perform message segmentation and are hugely important when they don\u2019t.\r\nMy suggested text would be:\r\n/ requirements around the largest packet that can be sent,/\r\n---\r\nIn Section 4.2:\r\n/ A single stack can be simple (a single transport\r\n      protocol instance over IP), or complex (multiple application\r\n      protocol streams going through a single security and transport\r\n      protocol, over IP; or, a multi-path transport protocol over\r\n      multiple transport sub-flows).\r\n/\r\n- This has become quite a long and complex sentence! I\u2019d really prefer to use numbers or some way to highlight the two concepts of simple and complex. I don\u2019t know what is best. Another possibility could be to make it even longer, but more clear:\r\n/ A single stack can be either simple (a single transport\r\n      protocol instance over IP), or it can be complex (multiple application\r\n      protocol streams going through a single security and transport\r\n      protocol, over IP; or, a multi-path transport protocol over\r\n      multiple transport sub-flows).\r\n---\r\nIn Section 4.2: Candidate Path:\r\nThe clause:\r\n/, of which there can be several./ \r\nappears in bullet two for Candidate Protocol Stack:, but not for Candidate Path. I expect there be multiple candidate paths also in this case, can we add this?\r\n---\r\nIn Section 4.2: Candidate Protocol Selection\r\n/represents the act of choosing one or more sets of protocol stacks/\r\n- why not capitilised /Protocol Stacks/?\r\n---\r\nIn Section 4.2: Remote Endpoint Racing: \r\n/that differ based on the specific\r\n      representation of the Remote Endpoint, such as IP addresses\r\n      resolved from a DNS hostname./\r\n- do we have use of singular/plural correct here, or should this be more like:\r\n/that differ based on the specific\r\n      representation of the Remote Endpoint, such as a\r\n      specific IP address that was\r\n      resolved from a DNS hostname./\r\n---\r\nIn Section 4.2.3: Protocol Stack Equivalence\r\n/The Transport Services architecture defines a mechanism that allows\r\n   applications to easily use different network paths and Protocol\r\n   Stacks./\r\n- Is this /use/ , i.e. are we talking about how to use these - which looks\r\nlike just multipath, or is this better as:\r\n/The Transport Services architecture defines a mechanism that allows\r\n   applications to easily communicate when there can be different network paths and Protocol Stacks./\r\n---\r\nIn Section 4.2.4:\r\n/   The interface to specify these groups MAY expose fine-grained tuning\r\n   for which properties and cached state is allowed to be shared with\r\n   other Connections. /\r\n- I think it would be nice if this sentence actually was self-contained, since it contains a RFC2119 keyword. Perhaps we could say:\r\n/   The interface to specify a Connection Group MAY expose fine-grained tuning for which properties and cached state is allowed to be shared with   other Connections. /\r\n---\r\n```",
      "createdAt": "2020-01-14T21:04:15Z",
      "updatedAt": "2020-09-11T16:34:03Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/gorry-wglc",
      "headRefOid": "d8c199042b8721347012c2e28f057b1fbfeae7f9",
      "closedAt": "2020-01-15T17:39:11Z",
      "mergedAt": "2020-01-15T17:39:11Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "88c941de750d43159bcd46bbc01bba4614905602"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTkyMDE0",
          "commit": {
            "abbreviatedOid": "d8c1990"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for addressing this \u2013 Looks good!",
          "createdAt": "2020-01-15T12:45:02Z",
          "updatedAt": "2020-01-15T12:45:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 412,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMDk5NDA2",
      "title": "Add one sentence about fallback in sec 2.3",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/412",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "Just a proposal...",
      "createdAt": "2020-01-15T11:52:23Z",
      "updatedAt": "2020-09-11T16:34:15Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-fallback-sec2.3",
      "headRefOid": "1b1af09207b092b04001626bd6e8559cb2fc040e",
      "closedAt": "2020-01-22T20:25:24Z",
      "mergedAt": "2020-01-22T20:25:24Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c99da9a7bbe916ab7b2974a93b6fb959f43c6523"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTk0NDM4",
          "commit": {
            "abbreviatedOid": "176833f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Fallback after connection establishment (the context if the bullet point) looks really complex for me. \r\n\r\nMaybe make it a separate bullet point and make clear protocol fallback during connection establishment and path fallback after  connection establishment is a goal.",
          "createdAt": "2020-01-15T12:49:45Z",
          "updatedAt": "2020-01-15T12:49:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDAxMzQ2",
          "commit": {
            "abbreviatedOid": "176833f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-15T17:42:07Z",
          "updatedAt": "2020-01-15T17:42:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I like the sentence, but I'm not sure that it fits in this paragraph. This new sentence mentions a protocol failing establishment, but the paragraph begins `Flexibility after connection establishment...`.\r\n\r\nRather, this feels like it belongs with the previous paragraph, `Transport Services implementations are meant to be flexible at connection establishment time...`",
              "createdAt": "2020-01-15T17:42:08Z",
              "updatedAt": "2020-01-15T17:47:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDA0OTUy",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T17:47:54Z",
          "updatedAt": "2020-01-15T17:47:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2020-01-15T17:47:54Z",
              "updatedAt": "2020-01-15T17:47:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDEwMDc2",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-01-15T17:56:11Z",
          "updatedAt": "2020-01-15T17:56:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDU3NjIy",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-15T19:16:16Z",
          "updatedAt": "2020-01-15T19:16:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I find the \"can further implement\" a bit confusing as it sound like it is an additional thing, but I guess it is a clarification as racing gives you fallback? So maybe \"In this way, Transport Services implementations can provide...\" or something similar",
              "createdAt": "2020-01-15T19:16:17Z",
              "updatedAt": "2020-01-15T19:16:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzQwOTg0",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2020-01-16T08:29:50Z",
          "updatedAt": "2020-01-16T08:30:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I see both options: Using racing in first place, but having an alt-srv like mechanism to discover more candidates or use transport level redirects.",
              "createdAt": "2020-01-16T08:29:51Z",
              "updatedAt": "2020-01-16T08:30:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzU3NjA4",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T09:00:44Z",
          "updatedAt": "2020-01-16T09:00:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do I need to change something now or not?",
              "createdAt": "2020-01-16T09:00:45Z",
              "updatedAt": "2020-01-16T09:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTI4NjA1",
          "commit": {
            "abbreviatedOid": "1b1af09"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T13:57:28Z",
          "updatedAt": "2020-01-16T13:57:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I still think something needs to change. Indicating that \"fallback mechanisms if connection establishment of one protocol fails\" is something different from racing is not correct I think and not consistent with how racing is described elsewhere. But the sentence describes two things. The first to me is a clarification of what racing provides. The second \"fallback if performance is detected to be unsatisfactory\" is different and could perhaps be part of the general description that is given before, but could also be an add on. Perhaps just split the parts up?",
              "createdAt": "2020-01-16T13:57:28Z",
              "updatedAt": "2020-01-16T13:57:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMTE2Mjkw",
      "title": "nit - \"within a message\" twice",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/415",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "\"within a message\" twice in the same sentence",
      "createdAt": "2020-01-15T12:36:55Z",
      "updatedAt": "2020-09-11T16:34:06Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c5ea5f8ff85da881c2c318e6b1f36ac582dde9c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-nit-1",
      "headRefOid": "73973a8e6d6dbbf15c45b7d05b3221fcfdc85665",
      "closedAt": "2020-01-15T17:39:47Z",
      "mergedAt": "2020-01-15T17:39:47Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "dde86eb9bf94e884da3af095259972877102f30f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzk5ODkx",
          "commit": {
            "abbreviatedOid": "73973a8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-01-15T17:39:38Z",
          "updatedAt": "2020-01-15T17:39:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 421,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjA1MjE0",
      "title": "Proposed alternative intro text for API doc",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/421",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I think the intro currently doesn't fit well the content of the document as any motivation for this work should be in the Arch doc. If we want to retain the text that I deleted we can maybe add it to the Intro or background section in the Arch doc...?\r\n\r\nNote that the second paragraph I've added is stolen from the intro of the Arch doc.",
      "createdAt": "2020-01-15T15:45:56Z",
      "updatedAt": "2020-09-11T16:34:08Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0e8559a75a589ff9654a503b6d1742736f187f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-intro-api",
      "headRefOid": "31f7ed12c608f4f2c9206d4484857b00220b846e",
      "closedAt": "2020-01-22T20:26:54Z",
      "mergedAt": "2020-01-22T20:26:54Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "5b8d02dc1005c1bd8e4a137a52b509cdf490472a"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri I can't see how the existing text that @mirjak proposed to delete could reasonably be merged with the intro text of the architecture doc? and the text that's there now motivates TAPS just as nicely, IMO. I would be inclined to just delete the text and do the update exactly as @mirjak proposes here.",
          "createdAt": "2020-01-16T12:57:55Z",
          "updatedAt": "2020-01-16T12:57:55Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @mwelzl , I like the new text much better and I do not think we should add the removed text to arch. ",
          "createdAt": "2020-01-16T13:09:44Z",
          "updatedAt": "2020-01-16T13:09:44Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the text did its duty and it's time to let go... ",
          "createdAt": "2020-01-22T22:10:21Z",
          "updatedAt": "2020-01-22T22:10:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzk0MDc3",
          "commit": {
            "abbreviatedOid": "31f7ed1"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't have a strong opinion on this, for me it's fine to have some motivation in this document as well.\r\nHowever, if we delete the motivation from this document, let's put it in the -architecture, please - I would really like us to keep this text somewhere.",
          "createdAt": "2020-01-16T09:59:42Z",
          "updatedAt": "2020-01-16T09:59:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODkwNzA3",
          "commit": {
            "abbreviatedOid": "31f7ed1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like this; I think it improves the flow of the text, and I agree that the prior text is too motivational in style for this document. Even stealing a paragraph from the arch draft won't matter, I think.",
          "createdAt": "2020-01-16T12:56:18Z",
          "updatedAt": "2020-01-16T12:56:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDU5MDEy",
          "commit": {
            "abbreviatedOid": "31f7ed1"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I really like this new intro and would like to have it irrespectively of moving the text as proposed in #484",
          "createdAt": "2020-01-22T09:50:38Z",
          "updatedAt": "2020-01-22T09:50:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODc5NDU2",
          "commit": {
            "abbreviatedOid": "31f7ed1"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "and so dies the last text from the original post sockets paper ;( lgtm :)",
          "createdAt": "2020-01-22T20:26:48Z",
          "updatedAt": "2020-01-22T20:26:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 422,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjA4Mzk2",
      "title": "minor edit to sec 4",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/422",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "s/messages can be sent/messages can be sent and received/",
      "createdAt": "2020-01-15T15:52:19Z",
      "updatedAt": "2020-09-11T16:34:10Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0e8559a75a589ff9654a503b6d1742736f187f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-minor-sec4-api",
      "headRefOid": "56023a09a89fb100e4b3b8f47aeebb060b10af13",
      "closedAt": "2020-01-16T13:00:20Z",
      "mergedAt": "2020-01-16T13:00:20Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "28b2563dd4da6d7a3bb0d299b37d659d94648a55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzYzNDYy",
          "commit": {
            "abbreviatedOid": "56023a0"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-16T09:11:21Z",
          "updatedAt": "2020-01-16T09:11:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 423,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjExMDcx",
      "title": "editorial: be more concrete about phases in Arch doc",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/423",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-15T15:57:35Z",
      "updatedAt": "2020-09-11T16:31:48Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0e8559a75a589ff9654a503b6d1742736f187f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-phases-sec4-api",
      "headRefOid": "8583f3672c169dfeaaebc2f4673b7097857ac2a3",
      "closedAt": "2020-01-16T15:19:25Z",
      "mergedAt": "2020-01-16T15:19:25Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "3380d755678e939674a6afc63ada2d996cd7963c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODk0MTgy",
          "commit": {
            "abbreviatedOid": "90f083a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM modulo a super tiny nit",
          "createdAt": "2020-01-16T13:02:29Z",
          "updatedAt": "2020-01-16T13:02:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "suggest: s/in sec. 4.1 in/in sec 4.1 of\r\n",
              "createdAt": "2020-01-16T13:02:29Z",
              "updatedAt": "2020-01-16T14:07:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTM1NDg0",
          "commit": {
            "abbreviatedOid": "8583f36"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T14:07:19Z",
          "updatedAt": "2020-01-16T14:07:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "fixed",
              "createdAt": "2020-01-16T14:07:19Z",
              "updatedAt": "2020-01-16T14:07:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjIwMDg1",
      "title": "Protocol Specific Properties are not well defined",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/424",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "The term Protocol Specific Properties is not well introduced. In the Arch doc we have a section about \"Specialized Features\" and I not added a reference and rephrased the sentence respectively. Do we need to say more than that?",
      "createdAt": "2020-01-15T16:15:50Z",
      "updatedAt": "2020-09-11T16:31:46Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0e8559a75a589ff9654a503b6d1742736f187f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-psp-api",
      "headRefOid": "f8db1810120db73e25bd6dba1cda05ef87665d4e",
      "closedAt": "2020-01-16T15:18:52Z",
      "mergedAt": "2020-01-16T15:18:52Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "5e69447ccab78d42bbe8c7cdd7fa9cd2be58027a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzYyNTE1",
          "commit": {
            "abbreviatedOid": "5351bc4"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me, except one nit.",
          "createdAt": "2020-01-16T09:09:39Z",
          "updatedAt": "2020-01-16T09:10:31Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "s/sec/Section/",
              "createdAt": "2020-01-16T09:09:39Z",
              "updatedAt": "2020-01-16T14:04:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzY5MDM3",
          "commit": {
            "abbreviatedOid": "2e3ad93"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T09:20:54Z",
          "updatedAt": "2020-01-16T09:20:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done",
              "createdAt": "2020-01-16T09:20:54Z",
              "updatedAt": "2020-01-16T14:04:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODk3OTIw",
          "commit": {
            "abbreviatedOid": "2e3ad93"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM modulo two nits",
          "createdAt": "2020-01-16T13:09:27Z",
          "updatedAt": "2020-01-16T13:14:18Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think it should be \"which enable\" instead of \"that enable\" here, because this adds information Protocol Specific Properties (explaining what they are) rather than narrowing down the set of Protocol Specific Properties.",
              "createdAt": "2020-01-16T13:09:27Z",
              "updatedAt": "2020-01-16T14:04:45Z"
            },
            {
              "originalPosition": 11,
              "body": "s/Specialized Features/specialized features",
              "createdAt": "2020-01-16T13:14:04Z",
              "updatedAt": "2020-01-16T14:04:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTM0NTM5",
          "commit": {
            "abbreviatedOid": "f8db181"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T14:05:56Z",
          "updatedAt": "2020-01-16T14:05:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Done",
              "createdAt": "2020-01-16T14:05:57Z",
              "updatedAt": "2020-01-16T14:05:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTM0NTk2",
          "commit": {
            "abbreviatedOid": "f8db181"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T14:06:02Z",
          "updatedAt": "2020-01-16T14:06:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done",
              "createdAt": "2020-01-16T14:06:02Z",
              "updatedAt": "2020-01-16T14:06:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjI1NDI5",
      "title": "Normative language for property namespace",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/425",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "It looks like we should use normative language here. We could also use the keywords of the IANA protocol number registry to indicate reserved namespaces for IETF protocols (that can not be used in the vendor or implementation specific namespaces anyway). See https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml",
      "createdAt": "2020-01-15T16:26:48Z",
      "updatedAt": "2020-09-11T16:34:23Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0e8559a75a589ff9654a503b6d1742736f187f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-namespace-api",
      "headRefOid": "e607f8efc5f723e90615bfe8519b59d70a03d2be",
      "closedAt": "2020-01-22T08:52:42Z",
      "mergedAt": "2020-01-22T08:52:42Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "cb8e15e2f52573ef14095c51be6c3b850981513b"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I agree, also with the suggestion to use the keywords of the IANA protocol number registry for IETF protocols, though I note that this PR doesn't include a pointer to this registry. Would you mind adding this?\r\n\r\nLike this?",
          "createdAt": "2020-01-16T14:03:19Z",
          "updatedAt": "2020-01-16T14:03:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTAzNjMx",
          "commit": {
            "abbreviatedOid": "e36045a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I agree, also with the suggestion to use the keywords of the IANA protocol number registry for IETF protocols, though I note that this PR doesn't include a pointer to this registry. Would you mind adding this?",
          "createdAt": "2020-01-16T13:19:12Z",
          "updatedAt": "2020-01-16T13:19:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTg5NDUw",
          "commit": {
            "abbreviatedOid": "e607f8e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is great, thanks!",
          "createdAt": "2020-01-16T15:17:38Z",
          "updatedAt": "2020-01-16T15:17:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjQ2ODU3",
      "title": "Local/Remote Endpoint type or Object?",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/428",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-15T17:11:55Z",
      "updatedAt": "2020-09-11T16:34:11Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "64c300276fb5b0ad8c077b40cf8985ab6b4e9a4b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-endpoint-api",
      "headRefOid": "7c7d546eae1fbed2c7a0da2a30afc0f8ed94d5f4",
      "closedAt": "2020-01-22T08:53:09Z",
      "mergedAt": "2020-01-22T08:53:09Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "a18d017041e8b4d8ca8fd0c0bce4c990d296d3d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzgzNTAx",
          "commit": {
            "abbreviatedOid": "7c7d546"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Agree, they're definitely objects.\r\nWhile an implementation might choose to implement different types of endpoint identifiers as subtypes of such objects, we don't want to be that specific here.",
          "createdAt": "2020-01-16T09:43:31Z",
          "updatedAt": "2020-01-16T09:43:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTA0NDQz",
          "commit": {
            "abbreviatedOid": "7c7d546"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-01-16T13:20:31Z",
          "updatedAt": "2020-01-16T13:20:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 430,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjU0NDg5",
      "title": "Too many commas",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/430",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I guess we could actually remove all commas in this sentence but previously there were definitely too many...",
      "createdAt": "2020-01-15T17:30:12Z",
      "updatedAt": "2020-09-11T16:34:13Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ce6cf4534cbef5dda4771887ab6b6f0fd9d9e3f6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-commas-api",
      "headRefOid": "2e09eca30790e9544b258d99d1e17e51152182af",
      "closedAt": "2020-01-16T12:27:51Z",
      "mergedAt": "2020-01-16T12:27:51Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "609a4b3471ecf10effa4f80fbef0f6c0c88c7d67"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzczMzE0",
          "commit": {
            "abbreviatedOid": "2e09eca"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-16T09:27:33Z",
          "updatedAt": "2020-01-16T09:27:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 431,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjU2NDYx",
      "title": "More MAYs?",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/431",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-15T17:35:24Z",
      "updatedAt": "2020-09-11T16:31:55Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ce6cf4534cbef5dda4771887ab6b6f0fd9d9e3f6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-may-api",
      "headRefOid": "909ba88bd40b009f99e4bf8b016d5be9f72be483",
      "closedAt": "2020-01-22T20:27:26Z",
      "mergedAt": "2020-01-22T20:27:26Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "84ab3205eae562c659167f5eede0b95ec5da51a7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzU2MTc2",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T08:58:26Z",
          "updatedAt": "2020-01-16T08:58:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Starting \"As\" is not great English... Maybe we should say:\r\nPreference-typed Selection Properties can be used frequently, implementations MAY therefore provide additional convenience functions, outlined in  {{preference-conv}}.",
              "createdAt": "2020-01-16T08:58:26Z",
              "updatedAt": "2020-01-20T09:51:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTA1NDAx",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM but I'd suggest to follow the suggestion by @gorryfair",
          "createdAt": "2020-01-16T13:22:08Z",
          "updatedAt": "2020-01-16T13:22:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjQxNzc3",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T15:10:22Z",
          "updatedAt": "2020-01-17T15:10:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm not the native speaker but the sentence doesn't make sense me without the \"as\". These are simply now two sentences and should have dot and not a comma. I guess we could separate by a semi-colon but that's even uglier...",
              "createdAt": "2020-01-17T15:10:22Z",
              "updatedAt": "2020-01-20T09:51:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTM5Nzk1",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-18T11:45:23Z",
          "updatedAt": "2020-01-18T11:45:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Sorry adding \"as\" but not meaning the progress of time, isn't cool. Splitting into two sentences, is of course OK, how about:\r\n\r\nPreference-typed Selection Properties can be frequently used. Implementations MAY therefore provide additional convenience functions, outlined in {{preference-conv}}.\r\n",
              "createdAt": "2020-01-18T11:45:23Z",
              "updatedAt": "2020-01-20T09:51:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQwNjQ4",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-18T12:08:54Z",
          "updatedAt": "2020-01-18T12:08:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Are the conveninece functions outlined in the doc the only possible ones? It kind of sounds like it now.  So unless the second \"as\" was also bad English I would keep that to make it a bit more generic? So:\r\n\r\nPreference-typed Selection Properties can be frequently used. Implementations MAY therefore provide additional convenience functions as outlined in {{preference-conv}}.\r\n\r\nor perhaps\r\n\r\nPreference-typed Selection Properties can be frequently used. Implementations MAY therefore provide additional convenience functions, see {{preference-conv}} for examples.",
              "createdAt": "2020-01-18T12:08:54Z",
              "updatedAt": "2020-01-20T09:51:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQ2Njk5",
          "commit": {
            "abbreviatedOid": "77ba932"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-18T14:49:19Z",
          "updatedAt": "2020-01-18T14:49:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yes - I think these are a sample not a definitive list. Either of the the above are fine for me:-), and the second is clearest probably.",
              "createdAt": "2020-01-18T14:49:19Z",
              "updatedAt": "2020-01-20T09:51:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTg4Mjg2",
          "commit": {
            "abbreviatedOid": "909ba88"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T09:51:38Z",
          "updatedAt": "2020-01-20T09:51:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "done",
              "createdAt": "2020-01-20T09:51:38Z",
              "updatedAt": "2020-01-20T09:51:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzI5NTcx",
          "commit": {
            "abbreviatedOid": "909ba88"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-01-20T14:05:35Z",
          "updatedAt": "2020-01-20T14:05:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDI1NTY2",
          "commit": {
            "abbreviatedOid": "909ba88"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-22T08:56:31Z",
          "updatedAt": "2020-01-22T08:56:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTM5Nzg0",
          "commit": {
            "abbreviatedOid": "909ba88"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-01-22T12:08:48Z",
          "updatedAt": "2020-01-22T12:08:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 432,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMjU5NDgw",
      "title": "\"must provide sensible defaults\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/432",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "I was about to change this must to MUST, however, MUST and \"sensible\" doesn't work well together, so I proposed this recommendation instead.",
      "createdAt": "2020-01-15T17:43:31Z",
      "updatedAt": "2020-09-11T16:33:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "dde86eb9bf94e884da3af095259972877102f30f",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-defaults-api",
      "headRefOid": "7268b499877459aeb5939ea882b53e9899385691",
      "closedAt": "2020-06-19T16:33:34Z",
      "mergedAt": "2020-06-19T16:33:34Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "39e5719acc57ab7d7d2f340c07347513dc0f90d8"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wrote SHOULD because the next sentence explain when you can use other default values, so it seem to me that only SHOULD makes sense. There is a MUST later saying that some default MUST be used.",
          "createdAt": "2020-01-16T13:58:21Z",
          "updatedAt": "2020-01-16T13:58:21Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok!",
          "createdAt": "2020-01-16T15:15:54Z",
          "updatedAt": "2020-01-16T15:15:54Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also like this and agree with the SHOULD. The MUST in the example that follows look odd to me though. I think that should be a MAY (or possibly a SHOULD).",
          "createdAt": "2020-01-16T16:50:10Z",
          "updatedAt": "2020-01-16T16:50:10Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point about the MUST is that \"default values MUST lead to a possible/implemented protocol\". Maybe there is a better way to phrase that?",
          "createdAt": "2020-01-17T15:05:59Z",
          "updatedAt": "2020-01-17T15:05:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Btw. similar as in Arch I think we have to spread a couple more MUSTs, SHOULDs, and MAYs over the whole doc...",
          "createdAt": "2020-01-17T15:06:36Z",
          "updatedAt": "2020-01-17T15:06:36Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not convinced that \"default values MUST lead to an implemented protocol\" is a MUST. If the TAPS default values do not lead to an implemented protocol (i.e. TCP or a protocol with similar functionality is not implemented), maybe you want applications that assume those values to get an error rather than transparently ending up with UDP? Maybe you know that your applications are aware and then you should be allowed to change them, but maybe you want to make sure that applications are aware that they get an unrelaible service and not a reliable service and then you should be allowed to keep the TAPS default values and generate an error.  ",
          "createdAt": "2020-01-17T15:43:52Z",
          "updatedAt": "2020-01-17T15:45:20Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @abrunstrom but I think this means we need more text explaining this. Any proposals?",
          "createdAt": "2020-01-22T10:22:14Z",
          "updatedAt": "2020-01-22T10:22:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't this be:\r\n- MUST provide some default that chooses an implemented protocol\r\n- SHOULD use the ones we specify here\r\n\r\nThe suggestion is to invert the sentences to clarify.",
          "createdAt": "2020-01-24T17:57:33Z",
          "updatedAt": "2020-01-24T17:57:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or, we say that you can use the TCP defaults and raise an error if TCP isn't implemented.",
          "createdAt": "2020-01-24T17:58:44Z",
          "updatedAt": "2020-01-24T17:58:44Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be allowed to use the TAPS defaults and raise an error if no protocol that implements the TAPS defaults is available. \r\nIn case the implementation prefers to do so. But I agree with Aaron that it is a corener case and in that sense perhaps not terribly important what we pick.",
          "createdAt": "2020-01-24T18:34:42Z",
          "updatedAt": "2020-01-24T18:34:42Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking about this a bit more, I think that it is a must requirement that any chosen set of default values MUST NOT lead to an error, because what's otherwise the point about having default values....? However, I think we should add some big warning text that if other defaults are used that most be communicated to the users of this API others they might be really surprised...",
          "createdAt": "2020-01-24T19:56:00Z",
          "updatedAt": "2020-01-24T19:56:00Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this has moved in a curious direction. My thoughts are still that this has been edited in the wrong direction.\r\nI quite like the SHOULD.\r\nWhilst the language is fine, I really do not agree at all with the direction of the \"the implementation MUST specify  default Protocol Selection Properties that represents a configuration that can be implemented over the preferred protocol, such as UDP.\"\r\nThis is not the way I saw TAPS - I expected the exact opposite outcome, i.e.:\r\n\"the users of such an implementation MUST explicitly specify Properties that result in theimplemented over the preferred protocol, such as UDP.\"\r\n",
          "createdAt": "2020-05-28T19:06:10Z",
          "updatedAt": "2020-05-28T19:06:10Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I lost a bit track here and your proposed text in the last comment doesn't parse fully. Can you make a concrete proposal what to change?",
          "createdAt": "2020-05-29T15:57:31Z",
          "updatedAt": "2020-05-29T16:43:45Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, but this is different to your proposal, it is not clarifying your text:\r\n\r\nAn implementation of this interface must provide sensible defaults for Selection Properties. The default values represent a configuration that can be implemented over TCP. If TCP is not supported by an implementation then an application using the default set of Properties might not succeed. For example, the application might need to be designed to also support a connectionless mode, and explicitly specify a different set of Protocol Selection Properties that result in a usable protocol.\r\n\r\n",
          "createdAt": "2020-05-29T16:09:24Z",
          "updatedAt": "2020-05-29T16:46:28Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ready to merge",
          "createdAt": "2020-06-19T15:35:15Z",
          "updatedAt": "2020-06-19T15:35:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzkwNjM0",
          "commit": {
            "abbreviatedOid": "31db814"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I agree with this.\r\n\r\nPreviously we had some discussion on whether to make the defaults normative, see IETF 105 notes under \"Parameters & Defaults\" https://datatracker.ietf.org/doc/minutes-105-taps/\r\nI don't really see a clear consensus in these notes, but I think your suggestion seems reasonable - different defaults for different platforms are possible, but then they have to be stated clearly.",
          "createdAt": "2020-01-16T09:54:38Z",
          "updatedAt": "2020-01-16T09:54:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTA4MDIz",
          "commit": {
            "abbreviatedOid": "31db814"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I like the update. I think that the \"sensible defaults\" text stems from a time when we did not have all defaults specified. Now that we do, and with your text that has the \"sensible\" bit removed, I wonder what made you write SHOULD instead of MUST?  I think a MUST makes more sense, considering that these are only default values anyway, and having these defaults equal everywhere makes TAPS implementations behave more consistently.",
          "createdAt": "2020-01-16T13:26:26Z",
          "updatedAt": "2020-01-16T13:26:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTg4Mjgw",
          "commit": {
            "abbreviatedOid": "31db814"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-16T15:16:11Z",
          "updatedAt": "2020-01-16T15:16:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDI3OTM0",
          "commit": {
            "abbreviatedOid": "31db814"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I approved this too early: I agree with @abrunstrom about the change to the second sentence.",
          "createdAt": "2020-01-22T09:00:44Z",
          "updatedAt": "2020-01-22T09:00:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDQ3OTk0",
          "commit": {
            "abbreviatedOid": "1dc864c"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "We look close, some comments.",
          "createdAt": "2020-06-03T11:09:14Z",
          "updatedAt": "2020-06-03T11:14:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "/the different implementation/different implementations/",
              "createdAt": "2020-06-03T11:09:14Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            },
            {
              "originalPosition": 17,
              "body": "/let to/lead to/",
              "createdAt": "2020-06-03T11:09:48Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            },
            {
              "originalPosition": 23,
              "body": "/for application use/ - seems awkward.\r\n\r\n... Another aspect we did not speak about concerns the ability to provide examples of usage. If the defaults are common between systems, then common example methods and tutorials and libraries can rely on using the default Selection Properties. ",
              "createdAt": "2020-06-03T11:14:31Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDYyMzQx",
          "commit": {
            "abbreviatedOid": "f6e95e6"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T11:32:22Z",
          "updatedAt": "2020-06-03T11:32:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Not sure what you mean which concerns you mean in \"the ability to provide examples\"...? Can you further explain or provide a text proposal?",
              "createdAt": "2020-06-03T11:32:22Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUxNzc3",
          "commit": {
            "abbreviatedOid": "f6e95e6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:08:25Z",
          "updatedAt": "2020-06-19T15:08:25Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nand TCP is not supported by a Transport Services implementation, then an application using the\r\n```",
              "createdAt": "2020-06-19T15:08:25Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUxODgz",
          "commit": {
            "abbreviatedOid": "f6e95e6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:08:35Z",
          "updatedAt": "2020-06-19T15:08:35Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nthe same default values for independent Transport Services implementations can be beneficical\r\n```",
              "createdAt": "2020-06-19T15:08:35Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTU3MDkz",
          "commit": {
            "abbreviatedOid": "5e32e6d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:15:56Z",
          "updatedAt": "2020-06-19T15:24:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "/can recognized/can recognize/",
              "createdAt": "2020-06-19T15:15:56Z",
              "updatedAt": "2020-06-19T15:33:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 433,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzNTQ4NDc1",
      "title": "Editorial nits to improve consistency",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/433",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-16T09:43:45Z",
      "updatedAt": "2020-09-11T16:34:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "dde86eb9bf94e884da3af095259972877102f30f",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-properties-api",
      "headRefOid": "42ca26dbb0c811b901d16dd51e66ffad8794bc6a",
      "closedAt": "2020-04-02T12:03:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Folks, all changes that I requested here are related to sentences dealing with defaults. Now, these sentences shouldn't be there anymore at all: defaults are shown in a different style, in a list. My suggestion is:\r\n- delete this PR\r\n- directly do an update to the master, incorporating the other changes that @mirjak suggested here (everything but the sentences talking about defaults)\r\n\r\nIs this ok with people? If so, I'll do that.",
          "createdAt": "2020-03-09T08:11:55Z",
          "updatedAt": "2020-03-09T08:11:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, so I'll do this today.",
          "createdAt": "2020-04-02T11:41:50Z",
          "updatedAt": "2020-04-02T11:41:50Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text about defaults disappeared anyway, and two other suggestions here were incorporated with a direct commit to master.",
          "createdAt": "2020-04-02T12:03:59Z",
          "updatedAt": "2020-04-02T12:03:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzg1OTM1",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T09:47:24Z",
          "updatedAt": "2020-01-16T09:47:25Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Note, this sentence was redundant (see two paragraphs up).",
              "createdAt": "2020-01-16T09:47:24Z",
              "updatedAt": "2020-01-16T09:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTExMjU0",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Lots of good finds here, thanks!  ...but a few things to discuss.",
          "createdAt": "2020-01-16T13:31:30Z",
          "updatedAt": "2020-01-16T13:39:26Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't see why switching the order here would be an improvement? Since the \"entails\" statement gives more detail about what the property's behavior, I think this reads better in the previous version. You must have had a reason to propose this... what am I missing?",
              "createdAt": "2020-01-16T13:31:30Z",
              "updatedAt": "2020-01-16T13:39:26Z"
            },
            {
              "originalPosition": 16,
              "body": "I think the previous name was better: \"Per-Message Reliability\" reads as if \"True\" means that all messages will be reliably transferred. This, however, expresses a desire to be able to *configure* it per message.",
              "createdAt": "2020-01-16T13:34:14Z",
              "updatedAt": "2020-01-16T13:39:26Z"
            },
            {
              "originalPosition": 25,
              "body": "I don't like this either - even if we'd go back to the previous name. I agree that \"option\" doesn't fit though - I think we could either repeat the name as you suggest, but without \"this\" before it, or we could say \"Selection Property\". I see that this is a general inconsistency, \"this option\" appears in multiple places and should be fixed uniformly, everywhere, so it's a good catch, thanks!",
              "createdAt": "2020-01-16T13:37:01Z",
              "updatedAt": "2020-01-16T13:39:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTI2MTA1",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T13:53:50Z",
          "updatedAt": "2020-01-16T13:53:51Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Maybe you are right. The point was that you only get this notification if this property is enabled. Maybe that's what we should say...",
              "createdAt": "2020-01-16T13:53:50Z",
              "updatedAt": "2020-01-16T13:53:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTI2NzA4",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T13:54:43Z",
          "updatedAt": "2020-01-16T13:54:43Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This was in order to be consistent with all other heading. Isn't you point to for other properties as well?",
              "createdAt": "2020-01-16T13:54:43Z",
              "updatedAt": "2020-01-16T13:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTI3Mzc1",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-16T13:55:43Z",
          "updatedAt": "2020-01-16T13:55:43Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "yes forgot to remove \"this\". The whole point was consistency. Feel free to take another approach.",
              "createdAt": "2020-01-16T13:55:43Z",
              "updatedAt": "2020-01-16T13:55:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTg1MDI5",
          "commit": {
            "abbreviatedOid": "42ca26d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-16T15:11:54Z",
          "updatedAt": "2020-01-16T15:14:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "No - e.g. \"Reliable Data Transfer (Connection)\" means: I'd like to be able to send reliably. It doesn't mean \"I want to be able to turn it on/off per-message\". \"Preservation of Message Boundaries\" also just means \"I want that, if possible\". \"Preservation of Data Ordering\" means \"I'd like in-order\" - it doesn't mean \"I care about configuring in-order per message\". and so forth.",
              "createdAt": "2020-01-16T15:11:55Z",
              "updatedAt": "2020-01-16T15:14:57Z"
            },
            {
              "originalPosition": 7,
              "body": "Agreed - suggestion: switch the order back, but change the sentence - e.g.: \"This also entails being notified when a Connection is closed or aborted when Reliable Data Transfer is enabled. The default is to Require Reliable Data Transfer.\"",
              "createdAt": "2020-01-16T15:14:11Z",
              "updatedAt": "2020-01-16T15:14:58Z"
            },
            {
              "originalPosition": 25,
              "body": "It's fine without \"this\", thanks!",
              "createdAt": "2020-01-16T15:14:26Z",
              "updatedAt": "2020-01-16T15:14:58Z"
            },
            {
              "originalPosition": 25,
              "body": "(and I must remember to fix this uniformly everywhere...)",
              "createdAt": "2020-01-16T15:14:43Z",
              "updatedAt": "2020-01-16T15:14:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzNTYxODY5",
      "title": "Boolean property can not be set to Ignore",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/439",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-16T10:12:25Z",
      "updatedAt": "2020-09-11T16:34:22Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "dde86eb9bf94e884da3af095259972877102f30f",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-icmp-api",
      "headRefOid": "5e89071248860e8abdb822b2149c9755b4d51b83",
      "closedAt": "2020-01-16T13:42:37Z",
      "mergedAt": "2020-01-16T13:42:37Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "39daedbcc66838f415a76ab947fe0ac66043d1c8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 442,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzNjc1ODQ4",
      "title": "Add one more pointer to Framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/442",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-16T14:31:43Z",
      "updatedAt": "2020-09-11T16:32:06Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39daedbcc66838f415a76ab947fe0ac66043d1c8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-send-api",
      "headRefOid": "98180a6bab8871a2862b88775d4435300ed22655",
      "closedAt": "2020-01-31T16:35:58Z",
      "mergedAt": "2020-01-31T16:35:58Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "39485b77029e9d6e0c6c9da6b4cf0a4b5b8fb5d5"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done",
          "createdAt": "2020-01-22T10:20:25Z",
          "updatedAt": "2020-01-22T10:20:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDY4Njgx",
          "commit": {
            "abbreviatedOid": "0c23cee"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-17T09:54:22Z",
          "updatedAt": "2020-01-17T09:54:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"pre- or suspend\" doesn't seem right. I think you mean to say \"pre- or append\" - and then it would have to be \"pre- or append additional information to the message data\" rather than \"message data with...\". Also, I'm not sure it's correct to say that a \"transport service\" is instructed to do something? Finally, there are typos (\"reeceiver\" and \"bourndaries\").\r\n\r\nI suggest to replace the first sentence with:\r\n\"Framers can be used to instruct the transport system to extend the message data with additional information that can be used at the receiver to detect message boundaries.\".",
              "createdAt": "2020-01-17T09:54:23Z",
              "updatedAt": "2020-01-22T10:19:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTEzNzUz",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T11:17:09Z",
          "updatedAt": "2020-01-17T11:17:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done",
              "createdAt": "2020-01-17T11:17:09Z",
              "updatedAt": "2020-01-22T10:19:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTIxMDY5",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T11:32:14Z",
          "updatedAt": "2020-01-17T11:32:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Actually \"instruct\" is probably really not the right term here.. ",
              "createdAt": "2020-01-17T11:32:15Z",
              "updatedAt": "2020-01-22T10:19:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTQzNDE4",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T12:21:35Z",
          "updatedAt": "2020-01-17T12:21:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks. And I think \"instruct\" is ok (I don't have a better idea)",
              "createdAt": "2020-01-17T12:21:35Z",
              "updatedAt": "2020-01-22T10:19:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTQzNTM0",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-01-17T12:21:47Z",
          "updatedAt": "2020-01-17T12:21:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjIxNDIx",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think its right to say that the framer instructs the transport system to do something, the framer itself just changes the message data.\r\n\r\nMaybe just \"Framers can be used to extend or modify the original message data...\"?",
          "createdAt": "2020-01-20T10:45:23Z",
          "updatedAt": "2020-01-20T10:45:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDMwMTA1",
          "commit": {
            "abbreviatedOid": "65788d7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I approved this too soon: I think the comment from @MaxF12 should be addressed.",
          "createdAt": "2020-01-22T09:04:35Z",
          "updatedAt": "2020-01-22T09:05:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTYxMzE0",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this addition is useful, but would frame it slightly different.",
          "createdAt": "2020-01-22T12:49:16Z",
          "updatedAt": "2020-01-22T12:50:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nwith additional information that can be processed at the receiver and to determine message\r\n```",
              "createdAt": "2020-01-22T12:49:17Z",
              "updatedAt": "2020-01-22T12:50:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTc5Mjcz",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-22T13:20:04Z",
          "updatedAt": "2020-01-22T13:20:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTg4ODIx",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-22T13:35:14Z",
          "updatedAt": "2020-01-22T13:35:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Now this reads strangely - as if processing at the receiver is one thing, and determining message boundaries is another. First, what's your motivation to change it - what else would you want to do with framers at the receiver? This text could be changed to say \", e.g., to determine message boundaries at the receiver\" - which would read better, but immediately raise the question: \"what else?\". So we'd need another example.",
              "createdAt": "2020-01-22T13:35:14Z",
              "updatedAt": "2020-01-22T13:35:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjE5MDUx",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T14:17:24Z",
          "updatedAt": "2020-01-22T14:17:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I agree with Michael that the proposed changed reads a bit awkward. I'd prefer to just not change it",
              "createdAt": "2020-01-22T14:17:25Z",
              "updatedAt": "2020-01-22T14:17:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTQwMzU1",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T09:00:55Z",
          "updatedAt": "2020-01-23T09:00:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The motivation was to clarify that framers can be used for other things than \"just\" determining message boundaries, e.g., extracting information and making them available through the message context. \u2013 it is a nit here anyway",
              "createdAt": "2020-01-23T09:00:55Z",
              "updatedAt": "2020-01-23T09:00:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzE2MDI0",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-25T08:14:15Z",
          "updatedAt": "2020-01-25T08:14:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Then I suggest to keep the old text. We elaborate on what framers can do in the {{framing}} section that this points too anyway.",
              "createdAt": "2020-01-25T08:14:15Z",
              "updatedAt": "2020-01-25T08:14:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzE2MDQy",
          "commit": {
            "abbreviatedOid": "98180a6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "good to go as it is, IMO",
          "createdAt": "2020-01-25T08:14:52Z",
          "updatedAt": "2020-01-25T08:14:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MDQxODY0",
      "title": "Indicate use of streams for unordered messages as example",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/444",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Just a proposal...",
      "createdAt": "2020-01-17T09:13:48Z",
      "updatedAt": "2020-09-11T16:31:52Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3380d755678e939674a6afc63ada2d996cd7963c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-order-api",
      "headRefOid": "c628eed69c84f3c42cbe4e5e5f72f707a1ba1e15",
      "closedAt": "2020-01-20T14:44:16Z",
      "mergedAt": "2020-01-20T14:44:16Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "c2e4e9aa1161cdb52161145e0a0100e27cd3beb4"
      },
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, you could do it with streams in SCTP as well so as an example it seems approriate. And good with an example I think.",
          "createdAt": "2020-01-17T10:57:52Z",
          "updatedAt": "2020-01-17T10:57:52Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we do have actually these kind of examples in many cases in the doc and I just thought when reading one could help here as well.",
          "createdAt": "2020-01-17T11:14:43Z",
          "updatedAt": "2020-01-17T11:14:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand why one would need streams for this in SCTP, but it doesn't matter. As I said I have no strong opinion, I'm fine with adding this example (and I just fixed the nit).",
          "createdAt": "2020-01-17T11:51:14Z",
          "updatedAt": "2020-01-17T11:51:14Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl you do not need to, as there are multiple ways to do it in SCTP, but you could.",
          "createdAt": "2020-01-17T16:15:01Z",
          "updatedAt": "2020-01-17T16:15:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDYzMTg5",
          "commit": {
            "abbreviatedOid": "81a605e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't know... I'd approve this because I don't think it matters. Generally we don't hint much about what happens below, and e.g. SCTP would do out of order delivery without using streams. Just because this is how one would implement it with QUIC, well...   but I have no strong opinion either way.\r\n\r\nAnyway I request changes because of a nit.",
          "createdAt": "2020-01-17T09:45:23Z",
          "updatedAt": "2020-01-17T09:48:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "s/multiplex/multiplexing",
              "createdAt": "2020-01-17T09:45:24Z",
              "updatedAt": "2020-01-17T11:50:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTI5NDcw",
          "commit": {
            "abbreviatedOid": "c628eed"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-17T11:50:27Z",
          "updatedAt": "2020-01-17T11:50:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2020-01-17T11:50:28Z",
              "updatedAt": "2020-01-17T11:50:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTI5OTIw",
          "commit": {
            "abbreviatedOid": "c628eed"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-17T11:51:30Z",
          "updatedAt": "2020-01-17T11:51:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 445,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MDQ0ODM0",
      "title": "checksum default and clarification",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/445",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not quite sure what I meant by \"Only full coverage is guaranteed, any other requests are advisory\". I assume we mean that even if a partial checksum is requested you get full coverage because requesting partial coverage and getting no checksum doesn't seem right...?",
      "createdAt": "2020-01-17T09:20:53Z",
      "updatedAt": "2020-09-11T16:31:49Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3380d755678e939674a6afc63ada2d996cd7963c",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-checksum-api",
      "headRefOid": "59dce1a2a8e0203df49314edf7ddd7e27593b4c7",
      "closedAt": "2020-01-17T09:43:19Z",
      "mergedAt": "2020-01-17T09:43:19Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "3efc48147bbcac5c51d7834f1df430df84018aa0"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Exactly, and you made it clearer. Thanks!",
          "createdAt": "2020-01-17T09:43:04Z",
          "updatedAt": "2020-01-17T09:43:04Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MDY5OTYy",
      "title": "fix brackets in example",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/452",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-17T10:22:18Z",
      "updatedAt": "2020-09-11T16:31:50Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3efc48147bbcac5c51d7834f1df430df84018aa0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-brackets-api",
      "headRefOid": "bd07db3fcce5207e93710746b71e370e82ed0469",
      "closedAt": "2020-01-17T12:18:25Z",
      "mergedAt": "2020-01-17T12:18:25Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MDk3MzE4",
      "title": "Moving section on Message Contexts",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/456",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "The section on Message Contexts is really misplaced at the moment. I suggest to have it just before the section on Message Properties because it actually used there (also in the example).",
      "createdAt": "2020-01-17T11:28:23Z",
      "updatedAt": "2020-09-11T16:31:51Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3efc48147bbcac5c51d7834f1df430df84018aa0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-mes-context-api",
      "headRefOid": "d10bd3b73cd94a6627f33d604af9478bae4e2e92",
      "closedAt": "2020-01-22T20:28:22Z",
      "mergedAt": "2020-01-22T20:28:22Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "82099c2ca7bb8e08ddf4a9ae3736795f5bd72b8c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDMxNjE4",
          "commit": {
            "abbreviatedOid": "d10bd3b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-22T09:07:21Z",
          "updatedAt": "2020-01-22T09:07:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDQ1MjY3",
          "commit": {
            "abbreviatedOid": "d10bd3b"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fits better \u2013 Thanks!\r\nStill, I am not sure if this is the optimal place or whether there is one\u2026 ",
          "createdAt": "2020-01-22T09:29:21Z",
          "updatedAt": "2020-01-22T09:29:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 459,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MTExODgy",
      "title": "Add another pointer to Connection Groups",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/459",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-17T12:09:26Z",
      "updatedAt": "2020-09-11T16:31:53Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3efc48147bbcac5c51d7834f1df430df84018aa0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-groups-api",
      "headRefOid": "83b2671772a0fa66e10f6ae477ce761fe7e2ecbe",
      "closedAt": "2020-01-17T12:17:19Z",
      "mergedAt": "2020-01-17T12:17:19Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "e662d5b326a1b58237189759bfccacffb852d1d0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MTEzMTI1",
      "title": "editorial fix",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/460",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Comma in the first section was wrong but better to rephrase anyway...",
      "createdAt": "2020-01-17T12:13:08Z",
      "updatedAt": "2020-09-11T16:32:10Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3efc48147bbcac5c51d7834f1df430df84018aa0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-comma-api",
      "headRefOid": "7e82a47294717790e8b1b439bd089e62433f6a9e",
      "closedAt": "2020-01-23T10:47:22Z",
      "mergedAt": "2020-01-23T10:47:22Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "e5af7d119699e9dbb2432d695301326c25be1a37"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTQxMDE4",
          "commit": {
            "abbreviatedOid": "c86436c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "nit",
          "createdAt": "2020-01-17T12:16:00Z",
          "updatedAt": "2020-01-17T12:16:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "s/therefor/therefore\r\nand: I'm really unsure about the \"are\" after \"therefore\". It might be correct, but I'm slightly more sure that the sentence is ok *without* the \"are\", i.e.: \"Generic Connection Properties are defined independent of the chosen protocol stack and therefore available on all Connections.\"",
              "createdAt": "2020-01-17T12:16:00Z",
              "updatedAt": "2020-01-23T10:47:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 463,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MTM2Mzc0",
      "title": "Mostly Editorial changes on Capacity Profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/463",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-17T13:15:35Z",
      "updatedAt": "2020-09-11T16:34:38Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-profile-api",
      "headRefOid": "6f5d5f39aa2d75eb62b9c2b35c5a4a0ba32b6ca4",
      "closedAt": "2020-03-03T08:55:47Z",
      "mergedAt": "2020-03-03T08:55:47Z",
      "mergedBy": "philsbln",
      "mergeCommit": {
        "oid": "236a4edace7121b532b4f597f349ac97643fa9ae"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done",
          "createdAt": "2020-01-28T12:51:38Z",
          "updatedAt": "2020-01-28T12:51:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQ4MzYw",
          "commit": {
            "abbreviatedOid": "5319d4b"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this!\r\nFor the default behavior, I'd like the text to stay explicit about what this means regarding tradeoffs.",
          "createdAt": "2020-01-18T15:28:12Z",
          "updatedAt": "2020-01-18T15:36:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "s/now/no/\r\n\r\nI think it's good to say explicitly what \"providing no information\" means.\r\nFor example, this could be: \"The application provides no information about its expected capacity profile, so it does not indicate any preference for optimizations of any tradeoffs between delay, delay variation, loss, and bandwidth efficiency.\"",
              "createdAt": "2020-01-18T15:28:12Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTg1OTg5",
          "commit": {
            "abbreviatedOid": "5319d4b"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T09:48:09Z",
          "updatedAt": "2020-01-20T09:48:09Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I can add this. However, I did cut the part about delay, delay variation, loss, and bandwidth efficiency because this is the first time something like this was mentioned and I found it  rather \"unclear\" at this point. I think we should rather say at the top then, that the indication of the what capacity profile the application expects can be used to optimise delay, delay variation, loss, and bandwidth efficiency. \r\n\r\nBtw. given we talk about delay here as well, should this rather be called traffic profile and not capacity profile.",
              "createdAt": "2020-01-20T09:48:09Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzMyMjI2",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T14:09:54Z",
          "updatedAt": "2020-01-20T14:09:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'm also fine with adding this at the top. I just want us to make the Default clear in relation to the other options, which do talk about tradeoffs like \"loss or latency\", \"delay or delay variation VS. bandwidth efficiency\", and more.",
              "createdAt": "2020-01-20T14:09:54Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzM0ODcy",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T14:13:54Z",
          "updatedAt": "2020-01-20T14:13:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Oh, regarding \"should this rather be called traffic profile\": I think \"traffic profile\" sounds like the application is characterizing the traffic it is going to send and I vaguely remember that at some point we agreed that this is a bad idea, as we cannot predict the future. Instead, the application says that it prefers a certain way to deal with the tradeoffs of limited capacity, so Capacity Profile makes sense to me. ",
              "createdAt": "2020-01-20T14:13:54Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDM2NjEx",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-22T09:15:33Z",
          "updatedAt": "2020-01-22T09:15:41Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm fine with all other changes, but I wonder why you removed \"when the Connection is multiplexed, the guidelines in Section 6 of {{?RFC7657}} apply.\" everywhere?\r\n\r\nOne could see this as an implementation detail, but then this part gives some hints about the expected behavior regarding DSCP values, if an implementation should choose to adapt the DSCP based on the Capacity Profile. These chosen DSCP values will be different in case of multiplexing, as Section 6 of RFC 7657 explains. So I would prefer to see this sentence stay, everywhere.",
              "createdAt": "2020-01-22T09:15:33Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDM3Nzk5",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T09:17:22Z",
          "updatedAt": "2020-01-22T09:17:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "It has not been removed, just moved from the individual items to the top, as it applies to all classes.",
              "createdAt": "2020-01-22T09:17:23Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDM4MTk2",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you - makes it clearer and shorter",
          "createdAt": "2020-01-22T09:17:55Z",
          "updatedAt": "2020-01-22T09:17:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDU0OTQ0",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T09:44:23Z",
          "updatedAt": "2020-01-22T09:44:24Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "There's been some probably well-intentioned editing of the DS-related text and I think this isn't now quite as it should be.\r\n\r\nFirst:  \"The Capacity Profile may also be used\r\n to set priorities on the wire for Protocol Stacks supporting prioritization. \r\n Recommendations for use with DSCP are provided below for each profile; note that\r\n when a Connection is multiplexed, the guidelines in Section 6 of {{?RFC7657}} apply.\"\r\n- that seems to somehow imply that stacks supporting prioritisation (which I see as a layer 2 QoS thing) and DSCP are similar. They are not, these are different things. Just as PvD is at still higher level.\r\n\r\nSecond, the proposal seems to assert there can be default DSCP mapping behaviours. Whether that is desirable or not for the IETF to specify, can be discussed on the TSVWG. I expect that is not a trivial discussion. I'd suggest we don't do that except for very specific cases: Scavenger; Default; Using one of the AF classes to provide more assurance than Default; etc.\r\n\r\nThird, DSCPs should be set per flow aggregate - using multiple DSCPs within an aggregate or changing them mid-flow is generally unwise, but possible, and needs to always come with the warning in RFC7657.\r\n\r\nSo, back to the main point:  \"Traffic\" seems the wrong descriptor, to me in this context, it relates to the characteristics of the aggregate (rate, variance, etc); as in traffic-conditioning-agreeement. What I think this is about is the future intentions of the apps to use the network service. They likely won't have a way to characterise their traffic against a profile... but they probably can describe what class of service they expect across the path ... at it's simplest: is it AF? is it Default? is it LE?  ",
              "createdAt": "2020-01-22T09:44:23Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDYwMjMy",
          "commit": {
            "abbreviatedOid": "a784d1e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T16:11:06Z",
          "updatedAt": "2020-01-24T16:11:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nis implementation-specific. The Capacity Profile MAY also be used\r\n```",
              "createdAt": "2020-01-24T16:11:07Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDY0MTAx",
          "commit": {
            "abbreviatedOid": "4dd2353"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-24T16:16:48Z",
          "updatedAt": "2020-01-24T16:16:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzE2MTMz",
          "commit": {
            "abbreviatedOid": "4dd2353"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-25T08:17:17Z",
          "updatedAt": "2020-01-25T08:17:18Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "From the interim: @gorryfair agrees that this is probably ok but he needs to read it again and we should wait for another ACK from him.\r\n\r\nI think that this should be merged once we have that ACK. ",
              "createdAt": "2020-01-25T08:17:17Z",
              "updatedAt": "2020-01-28T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4ODE4MzAy",
          "commit": {
            "abbreviatedOid": "4dd2353"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Before merging, could you still add the sentence at the top that the indication of the what capacity profile the application expects can be used to optimise delay, delay variation, loss, and bandwidth efficiency, please?\r\n\r\nThen there's something I noticed: The sentence on RFC7657, which has been moved to the top, should also be removed from the last two paragraphs, Constant-Rate Streaming and High Throughput Data, right?\r\n\r\nThanks!",
          "createdAt": "2020-01-27T16:53:27Z",
          "updatedAt": "2020-01-27T16:53:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NDkyMTU0",
          "commit": {
            "abbreviatedOid": "6f5d5f3"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! Looks good to me now.",
          "createdAt": "2020-01-28T15:57:53Z",
          "updatedAt": "2020-01-28T15:57:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MTQxMjg4",
      "title": "Restructure TCP UTO section",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/464",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Btw why do we have (only) properties for the TCP UTO?",
      "createdAt": "2020-01-17T13:27:29Z",
      "updatedAt": "2020-09-11T16:32:03Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-uto-api",
      "headRefOid": "2f573802c323c62e57cdad5208d65794fb88b8aa",
      "closedAt": "2020-01-24T17:39:21Z",
      "mergedAt": "2020-01-24T17:39:20Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "0e7b359127c3d49c79c52bd8131bc508ff3924fd"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't get that this is only an example, so yes we should say this more explicitly. Not sure where to put that though. Maybe we can just merge this PR for now and have a separate PR to add this somewhere.",
          "createdAt": "2020-01-20T16:38:16Z",
          "updatedAt": "2020-01-20T16:38:16Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I actually also just added \"as an example for a protocol-specific property\" in that section but maybe we want to say it somewhere else again...?",
          "createdAt": "2020-01-20T16:41:45Z",
          "updatedAt": "2020-01-20T16:41:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It isn't just an example. The reasons it's there go back to minset (if you remove it, you lose this functionality forever), yet there were arguments for this being a special TCP thing only, and being too awkward to include as general functionality - much like there are now arguments that might lead to ECN becoming UDP-specific.",
          "createdAt": "2020-01-20T20:32:01Z",
          "updatedAt": "2020-01-20T20:32:01Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some more explanations:\r\n\r\n- why is this included? From appendix C, we can see that it relates to \"Suggest timeout to the peer\" in minset. The argument for including this, in appendix A of the minset draft, is: \"Functional because this is closely related to potentially assumed reliable data delivery.\" Indeed, the last paragraph of section 1 in RFC 5482 gives examples where communication might just fail for applications expecting their connections to stay up. in reality, this doesn't seem to be needed much, and so this is hardly implemented (if at all!).\r\n\r\n- why is it TCP specific? This was discussed in issue #109: https://github.com/ietf-tapswg/api-drafts/issues/109\r\nThe key statement against having this as a general thing is probably this sentence from @tfpauly:\r\n\"If we had a timeout on overall connection establishment, from Initiate() to Ready(), then that's trying to set a timeout not just on TCP, but on DNS, racing, proxies, TLS, and who knows what else.\"\r\n",
          "createdAt": "2020-01-22T09:29:12Z",
          "updatedAt": "2020-01-22T09:29:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzM3NjIy",
          "commit": {
            "abbreviatedOid": "fb4373e"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this structure makes much more sense. Just one small nit and a question.\r\n\r\nAlso, I'm wondering if we should make it explicit here that this is just an example for Protocol-Specific Properties and that it's of course possible to define more? The beginning of Section 11 already points that way by saying \"Specific Protocol Properties are defined in a transport- and implementation-specific way\", but I think it's easy to miss this for a reader, and then wonder why there's only UTO and not some other Protocol-Specific Properties defined in this document.",
          "createdAt": "2020-01-20T14:18:06Z",
          "updatedAt": "2020-01-20T14:24:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Leftover bracket, please remove",
              "createdAt": "2020-01-20T14:18:07Z",
              "updatedAt": "2020-01-21T09:33:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDI5NjUy",
          "commit": {
            "abbreviatedOid": "5965915"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T16:41:17Z",
          "updatedAt": "2020-01-20T16:41:17Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Done",
              "createdAt": "2020-01-20T16:41:17Z",
              "updatedAt": "2020-01-21T09:33:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTIyNjIw",
          "commit": {
            "abbreviatedOid": "5965915"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I agree that the structure is better. Still I have some change requests.",
          "createdAt": "2020-01-20T20:36:20Z",
          "updatedAt": "2020-01-20T20:38:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This section defines only one TCP-specific property, so plural is very confusing / misleading here.",
              "createdAt": "2020-01-20T20:36:20Z",
              "updatedAt": "2020-01-21T09:33:30Z"
            },
            {
              "originalPosition": 9,
              "body": "It's not an example, it's one out of many properties in the list, and we designated this as being TCP-specific. I would remove everything from (and including) \"as an example\" in this sentence.",
              "createdAt": "2020-01-20T20:37:36Z",
              "updatedAt": "2020-01-21T09:33:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzM3NzMw",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T09:34:16Z",
          "updatedAt": "2020-01-21T09:34:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done. However, there are multiple configuration parameters...",
              "createdAt": "2020-01-21T09:34:16Z",
              "updatedAt": "2020-01-21T09:34:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzM4MDg2",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T09:34:51Z",
          "updatedAt": "2020-01-21T09:34:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Removed this again but I think we should say something about why this is the one and only TCP property that is included.",
              "createdAt": "2020-01-21T09:34:51Z",
              "updatedAt": "2020-01-21T09:34:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzQ4MjA5",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Okay, let's merge this and then think about how to motivate that we specify UTO. If we do it because it's in minset, that means that implementations have to expose UTO to be TAPS-compliant because TAPS requires that implementations at least expose the features in minset.\r\nAlso, I think we should say is that there's more Protocol-Specific Properties and we don't specify all of them here, but implementations are free to add their own.",
          "createdAt": "2020-01-21T09:50:47Z",
          "updatedAt": "2020-01-21T09:50:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjAwNzkx",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Specification/Type is missing",
          "createdAt": "2020-01-22T13:52:47Z",
          "updatedAt": "2020-01-22T13:53:47Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n\r\nName:\r\n: tcp.uto\r\n\r\nType:\r\n: Numeric\r\n\r\n```",
              "createdAt": "2020-01-22T13:52:47Z",
              "updatedAt": "2020-01-22T13:53:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjEwMzY3",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T14:05:53Z",
          "updatedAt": "2020-01-22T14:05:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is just the section heading. The actually configuration properties are defined below.",
              "createdAt": "2020-01-22T14:05:53Z",
              "updatedAt": "2020-01-22T14:05:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM2NjIy",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T08:54:05Z",
          "updatedAt": "2020-01-23T08:54:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "sorry, my fault",
              "createdAt": "2020-01-23T08:54:05Z",
              "updatedAt": "2020-01-23T08:54:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM2ODM3",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T08:54:29Z",
          "updatedAt": "2020-01-23T08:54:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MzY4NTg3",
          "commit": {
            "abbreviatedOid": "2f57380"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T15:06:33Z",
          "updatedAt": "2020-01-23T15:06:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 465,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MTQ0MTIz",
      "title": "New upper section for connection events",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/465",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Btw. does this cover all events? There is an issue where I also ask if we e.g. need an event that sending failed due to lifetime expiry. is there a way to double-check if we considered all needed events? Should we also mention ConnectionErrors here? Maybe we anyway need to say more about error?",
      "createdAt": "2020-01-17T13:34:25Z",
      "updatedAt": "2020-09-11T16:34:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-conn-events-api",
      "headRefOid": "b65b8d742bbf43e68b39c7589bf33986ca39b313",
      "closedAt": "2020-01-31T16:34:15Z",
      "mergedAt": "2020-01-31T16:34:15Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "2506a5fb2755d04b6fa55cb1ac64eeb30a1610cd"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are not all events (just search for the word \"event\" in the document), and generally they are not all lumped together - e.g. sending related events such as \"Sent\" appear in the \"Sending Data\" section - which, in fact, has its own subsection called \"Send Events\".\r\n\r\nSo, this would be a subsection just related to connection management... but then, you state: \"During the lifetime of a connection there are events that can occur when configured.\" which gives  the (wrong) impression that this would be the list of all events that can happen during a connection's lifetime.\r\n\r\nSo, I wouldn't add this subsection heading and not include that statement. Or maybe add the subsection heading (which is ok but doesn't help much - as you see, there are only very few events in there), but remove that statement.",
          "createdAt": "2020-01-22T09:40:39Z",
          "updatedAt": "2020-01-22T09:40:39Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to calling this \"connection lifecycle events\" or similar (do we refer to a connection lifecycle?)",
          "createdAt": "2020-01-27T09:44:06Z",
          "updatedAt": "2020-01-27T09:44:06Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Changed the heading and fixed the nit. I'm open to have another sentence there if people have proposals. We could even have no text but we usually say something after each heading.",
          "createdAt": "2020-01-27T09:53:18Z",
          "updatedAt": "2020-01-27T09:53:18Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the new heading, I'm fine with the sentence as it is - because the context is clear now, it's no longer misleading (i.e., giving the wrong impression that these would be ALL events).",
          "createdAt": "2020-01-31T16:33:27Z",
          "updatedAt": "2020-01-31T16:33:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDQ2NjIx",
          "commit": {
            "abbreviatedOid": "7d2ae85"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T09:31:30Z",
          "updatedAt": "2020-01-22T09:31:31Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "nit: s/occure/occur",
              "createdAt": "2020-01-22T09:31:30Z",
              "updatedAt": "2020-01-27T09:51:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjI2NzE1",
          "commit": {
            "abbreviatedOid": "b65b8d7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-31T16:33:39Z",
          "updatedAt": "2020-01-31T16:33:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 473,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NDQxMTI5",
      "title": "Arch: Some consistency and clarity fixes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/473",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed some upper-case/lower-case issues where I think I know the right answer.\r\n\r\nAlso, a few sentences seemed incomplete or like they could be clearer.\r\n\r\nMoreover, endpoint resolution occured \"in response to the Initiate call\", but \"during the Rendezvous call\" - I think \"in response to\" is better, as \"during\" sounds like it's a blocking call. Alternatively, this could be \"after [the call]\".",
      "createdAt": "2020-01-18T16:23:14Z",
      "updatedAt": "2020-09-11T16:31:54Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-arch-nits",
      "headRefOid": "5e33b49a9fa4091f805c1e242afccf6e233cd078",
      "closedAt": "2020-01-20T23:08:25Z",
      "mergedAt": "2020-01-20T23:08:25Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "738b81b32f55a95abcf170e370872b7eb7fd4f0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTU3NzM2",
          "commit": {
            "abbreviatedOid": "5e33b49"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T09:02:30Z",
          "updatedAt": "2020-01-20T09:02:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTY2NTIx",
          "commit": {
            "abbreviatedOid": "5e33b49"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T23:08:16Z",
          "updatedAt": "2020-01-20T23:08:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 474,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NDQyNDQz",
      "title": "Arch: Adjust Security Considerations to new Section 4.2.3",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/474",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Following #389, Section 4.2.3 of the Architecture document now says that fallback between different security protocol versions might be allowed.\r\nThe Security Considerations section was out of sync. This PR fixes that.",
      "createdAt": "2020-01-18T16:36:06Z",
      "updatedAt": "2020-09-11T16:31:56Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-arch-adjust-security-considerations",
      "headRefOid": "1cba5381eab9e0b1368cf02b8e8defd027d2a9d3",
      "closedAt": "2020-01-20T23:20:50Z",
      "mergedAt": "2020-01-20T23:20:50Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6b755edf5a88880a4a2f52168d648235a4f8d8d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTU5MjUx",
          "commit": {
            "abbreviatedOid": "84d2d6c"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T09:05:12Z",
          "updatedAt": "2020-01-20T09:05:12Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Maybe this still should be a MUST as you say \"MUST ... unless\". That's always a weird case for normative language...",
              "createdAt": "2020-01-20T09:05:12Z",
              "updatedAt": "2020-01-20T12:01:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjU3ODUz",
          "commit": {
            "abbreviatedOid": "84d2d6c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T11:54:16Z",
          "updatedAt": "2020-01-20T11:54:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Okay, if the \"unless ...\" is the only exception, this should be a MUST.\r\nBut is it?\r\n4.2.3 says \"To ensure that security protocols are not incorrectly swapped, Transport Services systems SHOULD only automatically generate equivalent Protocol Stacks when the transport security protocols within the stacks are identical.\" and that's slightly more open.\r\nI'm fine with either option, but we have to decide for one, so Section 4.2.3 and Section 6 have to match.\r\n\r\nI split the sentence, keeping the more open version that we already have in Section 4.2.3.",
              "createdAt": "2020-01-20T11:54:16Z",
              "updatedAt": "2020-01-20T12:02:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTY5MTQ0",
          "commit": {
            "abbreviatedOid": "1cba538"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T23:20:36Z",
          "updatedAt": "2020-01-20T23:20:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 478,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0ODE0MjUw",
      "title": "Clarify \"adopt\", summarize sec 2.3",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/478",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Proposed some text for #470 - I think this summarizes the \"flexibility\" advantage of TAPS that we elaborate on in Section 2.3.",
      "createdAt": "2020-01-20T12:41:09Z",
      "updatedAt": "2020-09-11T16:31:57Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "arch-adopt-different-protocols",
      "headRefOid": "eb0f3f130728d684073f66c1b58e5d3c23769b55",
      "closedAt": "2020-01-20T23:05:18Z",
      "mergedAt": "2020-01-20T23:05:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "516c97edf1ab6e363bf63f1bf3b274607f8eda31"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTY1ODI5",
          "commit": {
            "abbreviatedOid": "eb0f3f1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T23:05:06Z",
          "updatedAt": "2020-01-20T23:05:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0ODIxNTYy",
      "title": "Allow reusing Preconnections, fixes #222",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/479",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Fixed text in the API draft to allow reusing Preconnections as discussed in #222. \r\nHowever, changes to the Preconnection MUST NOT have any effect on the Connections or Listeners created beforehand - I think normative language is useful here to really highlight this possible pitfall. I omitted any note on deep copy as that's just a way to implement this.",
      "createdAt": "2020-01-20T12:59:53Z",
      "updatedAt": "2020-09-11T16:31:59Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-api-preconnection-reuse",
      "headRefOid": "2f3b00f7295670c2f506fcc28be0d8881affbf96",
      "closedAt": "2020-01-22T20:29:39Z",
      "mergedAt": "2020-01-22T20:29:39Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "20567ac27a025acf64591784220523cfbeb5b4f2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDM0NjMy",
          "commit": {
            "abbreviatedOid": "2f3b00f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you - fix achieved with minimal changes ;-)",
          "createdAt": "2020-01-22T09:12:19Z",
          "updatedAt": "2020-01-22T09:12:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDU3NDU1",
          "commit": {
            "abbreviatedOid": "2f3b00f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Great catch, it makes me wonder why we had closed issue #222? Thanks for doing this!",
          "createdAt": "2020-01-22T09:48:16Z",
          "updatedAt": "2020-01-22T09:48:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0ODQzNTAy",
      "title": "Local Endpoint vs. Selection Property, closes #410",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/480",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "In the \"Specifying Endpoints\" section, added a reference to the Selection Property that does a similar thing but with more fine-grained control.\r\nIt wasn't clear to me what is the best place to add this, so I put it right below the first example of specifying an interface name for the Local Endpoint to say that you can also do it differently. If you have better suggestions, please let me know.\r\n\r\nTo the ListenError and RendezvousError, I added text mentioning the \"reconcile Endpoints and Properties\" pitfall. I think this is probably more general, i.e., there might be more sources of errors than just local interface, so I kept it generic.",
      "createdAt": "2020-01-20T13:49:16Z",
      "updatedAt": "2020-09-11T16:32:00Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-api-local-endpoint-selection-prop",
      "headRefOid": "d32d5718ec1239393880e22a4936fae5ae08008c",
      "closedAt": "2020-01-22T20:30:32Z",
      "mergedAt": "2020-01-22T20:30:32Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "60de94bb8eb34bd2698b8369d63fb11cebba4c38"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDMzNjQ0",
          "commit": {
            "abbreviatedOid": "d32d571"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you - works for me!",
          "createdAt": "2020-01-22T09:10:43Z",
          "updatedAt": "2020-01-22T09:10:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0ODQ4Mzcz",
      "title": "Clarify Clone and Priority, closes #461",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/481",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Make clearer what \"Priority is not entangled\" means, following #461.\r\nAlso added a note that Clone() may result in on-the-wire signaling.",
      "createdAt": "2020-01-20T13:59:58Z",
      "updatedAt": "2020-09-11T16:32:04Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "126628bbba2f292a9f2cb02ac12c7a17d40f8aca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE-api-clone-priority",
      "headRefOid": "afb1117db0066f91aaaa41985c0fa371d7a2ab07",
      "closedAt": "2020-01-22T09:55:19Z",
      "mergedAt": "2020-01-22T09:55:19Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "2365122293a1c1e814563a94852674361ffae7f7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzU0MDYy",
          "commit": {
            "abbreviatedOid": "5c9eb04"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM - and thanks for adding this clarification!",
          "createdAt": "2020-01-20T14:43:05Z",
          "updatedAt": "2020-01-20T14:43:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDMzNzI3",
          "commit": {
            "abbreviatedOid": "5c9eb04"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T16:48:02Z",
          "updatedAt": "2020-01-20T16:48:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Maybe we can be even more concrete here, like \"... may result in on-the-wire signalling, e.g. to open a new connection,..\"?",
              "createdAt": "2020-01-20T16:48:02Z",
              "updatedAt": "2020-01-21T09:39:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzQxMDUw",
          "commit": {
            "abbreviatedOid": "afb1117"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T09:40:12Z",
          "updatedAt": "2020-01-21T09:40:13Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Sure, why not? Done.",
              "createdAt": "2020-01-21T09:40:13Z",
              "updatedAt": "2020-01-21T09:40:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDMyNjM4",
          "commit": {
            "abbreviatedOid": "afb1117"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the clarifications!",
          "createdAt": "2020-01-22T09:09:05Z",
          "updatedAt": "2020-01-22T09:09:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 482,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1MDM2NTcx",
      "title": "Be more consistent in naming Transport Services",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/482",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #471",
      "createdAt": "2020-01-20T23:32:00Z",
      "updatedAt": "2020-09-11T16:32:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6b755edf5a88880a4a2f52168d648235a4f8d8d2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/transport-services-naming",
      "headRefOid": "50cc464e7b313374438e604341c163971f12a1bc",
      "closedAt": "2020-01-21T14:34:46Z",
      "mergedAt": "2020-01-21T14:34:46Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "91c94ba30c107a521a27c1fffa16062a9682bd8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NzU1NzQy",
          "commit": {
            "abbreviatedOid": "50cc464"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks!",
          "createdAt": "2020-01-21T10:01:54Z",
          "updatedAt": "2020-01-21T10:01:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1MjcyMjIz",
      "title": "Minor API nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/483",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-01-21T12:10:50Z",
      "updatedAt": "2020-04-03T10:35:08Z",
      "closedAt": "2020-04-03T10:35:08Z",
      "mergedAt": "2020-04-03T10:35:08Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this discussion has converged and found a happy ending.",
          "createdAt": "2020-04-03T10:35:00Z",
          "updatedAt": "2020-04-03T10:35:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1ODgyNDM2",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T13:40:39Z",
          "updatedAt": "2020-01-21T13:40:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDI1MzA1",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this cleanup \u2013 I really appreciate it.\r\n\r\nPlease consider my comment on the over-specific scoping of Connection Properties",
          "createdAt": "2020-01-22T08:56:03Z",
          "updatedAt": "2020-01-22T09:08:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Does this imply that Connection Properties SHOULD not influence candidate selection?\r\nWe agreed some time ago that Implementations may consider all Transport Properties, including Connection Properties, for candidate selection.\r\nI think this cache makes the sentence even more over-specific than it already is",
              "createdAt": "2020-01-22T08:56:03Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            },
            {
              "originalPosition": 26,
              "body": "Suggested change:\r\n```\r\nSelection Properties (see {{selection-props}}) can only be set during pre-establishment. They are only used to specify which paths and protocol stacks can be used and are preferred by the application. \r\nConnection Properties {{connection-props}}) can also be set and may be changed later and are used to influence decisions made during\testablishment and to fine-tune the established connection. \r\n```",
              "createdAt": "2020-01-22T09:07:15Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDQ0ODk2",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T09:28:45Z",
          "updatedAt": "2020-01-22T09:28:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@philsbln Your suggested text changes the \"can be used to influence decisions\" for Connection properties to \"are used to influence decisions\". I think we should not say \"are used\". Implementations may consider all Transport Properties, but do not have to use them. If it is something required by the application it should go in a Selection Property I think.",
              "createdAt": "2020-01-22T09:28:45Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTY2OTY2",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T12:59:28Z",
          "updatedAt": "2020-01-22T12:59:29Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@abrunstrom The application can use them to influence decisions \u2013 whether he implementation cares about anything that isn't \"require\" or \"prohibit\" or throws an error because the properties are unsupported is implementation specific. Influence does not mean that it is actually chnaging anything.",
              "createdAt": "2020-01-22T12:59:29Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTY5ODQ2",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T13:04:30Z",
          "updatedAt": "2020-01-22T13:04:30Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'd say /influence/ can change end results. Would prefer /inform/ to /influence/?",
              "createdAt": "2020-01-22T13:04:30Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTcxMjMw",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T13:06:50Z",
          "updatedAt": "2020-01-22T13:06:51Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I am also fine with inform.",
              "createdAt": "2020-01-22T13:06:51Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzU5ODM5",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T17:14:17Z",
          "updatedAt": "2020-01-22T17:14:18Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Yes, inform is better so let's use that either way. \r\nBut I would still prefer \"can be used\" rather than \"are used\" also becuase there are two  parts to the sentence and the second part may also not happen. So I think \"are used\" does not read right. @philsbln was there a reason you changed it? I thought it was accidental when reformulating the text. You actually write that \"applications can  use them to influence decisions\" in your latest reply, so seems \"can use\" is also a natural formulation for you?",
              "createdAt": "2020-01-22T17:14:18Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTM1MzU2",
          "commit": {
            "abbreviatedOid": "7051bfe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T08:51:46Z",
          "updatedAt": "2020-01-23T08:51:47Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@abrunstrom the reason I changed it was to avoid having six \"can\"s in four consecutive sentences.\r\nI don't see that this \"are used\" suggests a necessary action except when you really want to do the thing these properties are designed for.",
              "createdAt": "2020-01-23T08:51:46Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NTA4NTY5",
          "commit": {
            "abbreviatedOid": "366700e"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-28T16:17:04Z",
          "updatedAt": "2020-01-28T16:17:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "For me, the original text didn't make a clear enough distinction when and how each set of properties is used. \r\nThanks for the suggestion @philsbln, yours works even better. ",
              "createdAt": "2020-01-28T16:17:04Z",
              "updatedAt": "2020-04-03T10:33:42Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "0039e60619f832524023045ee32103bf75634b87",
      "mergeCommit": {
        "oid": "8796fc3ec79f72f815967e98de91acb15de88825"
      }
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NzU4MzEy",
      "title": "Move text removed by #421 to the arch document",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/484",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-01-22T09:49:34Z",
      "updatedAt": "2020-09-11T16:34:26Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a18d017041e8b4d8ca8fd0c0bce4c990d296d3d3",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/socket-hostory-to-arch",
      "headRefOid": "d49727ec3ea3495b4182e63f2cf2edb9e81a522a",
      "closedAt": "2020-01-24T17:57:51Z",
      "mergedAt": "2020-01-24T17:57:51Z",
      "mergedBy": "philsbln",
      "mergeCommit": {
        "oid": "3c1735c9a59900c924298bef0c6d7b42847cfe25"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "NOTES 1: If this moves, please remember to rephrase the sentences to match the Arch style, content seems OK.\r\nNOTE 2: This probably should deal with my previous issue about defining \"The Socket API (Sockets)\" in such as way as to define \"sockets\".",
          "createdAt": "2020-01-22T09:54:08Z",
          "updatedAt": "2020-01-22T09:54:08Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see value in it as it gives historic context and therefore support @theri's suggestion in #421. \r\nIt is nothing I will really fight for, but something I wanted to try whether it is possible with little effort.",
          "createdAt": "2020-01-22T12:07:41Z",
          "updatedAt": "2020-01-22T12:07:41Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I guess I addressed all knits raised so far \u2013 so this PR is left with @tfpauly's question:\r\n> How much do we think we really need this history here?",
          "createdAt": "2020-01-23T08:40:53Z",
          "updatedAt": "2020-01-23T08:40:53Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reading this again, I actually think we may not need the history and keeping it short may be better. We otherwise have to deal with the overlap. ",
          "createdAt": "2020-01-23T21:47:38Z",
          "updatedAt": "2020-01-23T21:47:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDk4NTQ4",
          "commit": {
            "abbreviatedOid": "65020b4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure this is necessary. Does it make anything better?",
          "createdAt": "2020-01-22T10:52:50Z",
          "updatedAt": "2020-01-22T10:52:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjcxNDY0",
          "commit": {
            "abbreviatedOid": "223e101"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks nice, thanks @philsbln!\r\nI would remove the extra \"new\" you inserted in the second text update though. I do not think it is needed and it can be read as there was a Transport Services architecture before and this is a new one. It also adds an unneccessary time reference that will look odd in a few years when TAPS is no longer new.",
          "createdAt": "2020-01-22T15:22:31Z",
          "updatedAt": "2020-01-22T15:22:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODQxMjM4",
          "commit": {
            "abbreviatedOid": "223e101"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this!\r\nYes, I think it's good to put this text there, is it provides important additional motivation/context.\r\n\r\nJust a few nits from my side.",
          "createdAt": "2020-01-22T19:23:39Z",
          "updatedAt": "2020-01-22T19:31:05Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "s/Threfore/Therefore/",
              "createdAt": "2020-01-22T19:23:39Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            },
            {
              "originalPosition": 22,
              "body": "Why the brackets around \"(Sockets)\"? Without the word, the sentence wouldn't work anymore.\r\nAlso, I think we call it \"Socket API\", not \"Sockets API\" in the rest of the document.",
              "createdAt": "2020-01-22T19:24:53Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            },
            {
              "originalPosition": 26,
              "body": "s/sockets API/Socket API/",
              "createdAt": "2020-01-22T19:25:31Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTIyODI0",
          "commit": {
            "abbreviatedOid": "223e101"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T21:41:12Z",
          "updatedAt": "2020-01-22T21:41:12Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "It also shouldn't have an apostrophe \"API`s\" -> \"APIs\"",
              "createdAt": "2020-01-22T21:41:12Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTIzOTIw",
          "commit": {
            "abbreviatedOid": "223e101"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-22T21:43:08Z",
          "updatedAt": "2020-01-22T21:43:08Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "We also do cover some of the relationship with BSD sockets in the intro.\r\n\r\nHow much do we think we really need this history here?",
              "createdAt": "2020-01-22T21:43:08Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MjA5NTQy",
          "commit": {
            "abbreviatedOid": "844d10f"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, looks good to me now.\r\n\r\nI still think this history fits really well in the Background Section. But yes, the beginning of the Introduction has some more content on the relationship between the Socket API and TAPS.\r\nI'd say both of these parts provide important motivation for TAPS. Maybe we could reshuffle the document to bring them closer together? For example, we could briefly mention that the current Socket API has shortcomings in the beginning and then provide all the details in the Background section?",
          "createdAt": "2020-01-23T10:54:39Z",
          "updatedAt": "2020-01-23T10:54:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NjMxMTg5",
          "commit": {
            "abbreviatedOid": "844d10f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T21:48:45Z",
          "updatedAt": "2020-01-23T21:48:46Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I lkie the small adjustments in the introduction. We should keep those.",
              "createdAt": "2020-01-23T21:48:45Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NjMzMjE0",
          "commit": {
            "abbreviatedOid": "844d10f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T21:52:32Z",
          "updatedAt": "2020-01-23T21:52:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I am fine leaving this extension out and keeping it simple. If we do decide to keep the text. Then I would like \"new Tarnsport Services architecture\" to be just \"Transport Services architecture\". I do not like the \"new\" for reasons previously commented on.",
              "createdAt": "2020-01-23T21:52:32Z",
              "updatedAt": "2020-01-24T17:55:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 485,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MDc2NzIw",
      "title": "Update specific-protocol option example from UDP checksum to TCP UTO",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/485",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Addresses #475 ",
      "createdAt": "2020-01-22T21:39:51Z",
      "updatedAt": "2020-09-11T16:32:09Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "60de94bb8eb34bd2698b8369d63fb11cebba4c38",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-uto-example",
      "headRefOid": "b9b23fa0c9fd8d33b3c1acabee451f93d9260f62",
      "closedAt": "2020-01-23T19:01:37Z",
      "mergedAt": "2020-01-23T19:01:36Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "600d0bd1c6326b55cf4e27476453fd1009aa440d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTMwODM2",
          "commit": {
            "abbreviatedOid": "b9b23fa"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks \u2013 works",
          "createdAt": "2020-01-23T08:43:47Z",
          "updatedAt": "2020-01-23T08:43:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTg1NjEz",
          "commit": {
            "abbreviatedOid": "b9b23fa"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, LGTM!",
          "createdAt": "2020-01-23T10:14:59Z",
          "updatedAt": "2020-01-23T10:14:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 487,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTE2NzA2",
      "title": "Make the singular transmission text clearer",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/487",
      "state": "MERGED",
      "author": "adventureloop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "adventureloop"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #367.",
      "createdAt": "2020-01-24T16:29:08Z",
      "updatedAt": "2020-09-11T16:32:35Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "600d0bd1c6326b55cf4e27476453fd1009aa440d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tj/singular",
      "headRefOid": "72d8f13bc25f267efbc1af929d064fc0ea7ddde1",
      "closedAt": "2020-05-29T09:29:37Z",
      "mergedAt": "2020-05-29T09:29:37Z",
      "mergedBy": "adventureloop",
      "mergeCommit": {
        "oid": "03c867641e37e563268c9e04ab195bf93105dc61"
      },
      "comments": [
        {
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this should close #367 ",
          "createdAt": "2020-01-27T14:15:08Z",
          "updatedAt": "2020-01-27T14:15:08Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right there was a typo: Replacing the last 2 sentences, the last sentence ought to be:\r\n\r\n\" Endpoints should avoid IP fragmentation ({{!RFC8304}}) and when used with transports running over IP version 4 the Don't Fragment bit will be set.\"\r\n\r\nThese are two separate issues that a stack implementor has to decide to do: (1) Decide if the endpoint will fragment; (2) decide if the path can fragment the fragments. In some OS this will be bundled together, in other OS they will not.",
          "createdAt": "2020-01-28T13:35:55Z",
          "updatedAt": "2020-01-28T13:35:55Z"
        },
        {
          "author": "adventureloop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the interim call. The name probably could be much better. We also want to model in the text the atomicity property of UDP transfers. ",
          "createdAt": "2020-02-21T17:46:45Z",
          "updatedAt": "2020-02-21T17:46:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NzY3MTg0",
          "commit": {
            "abbreviatedOid": "d361d6d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Reads much better except the last broken sentence",
          "createdAt": "2020-01-27T15:49:18Z",
          "updatedAt": "2020-01-27T15:49:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- Singular Transmission: When set, this property limits the message size to the Maximum Message Size Before Fragmentation or Segmentation (see Section 10.1.7 of {{I-D.ietf-taps-interface}}).  Messages larger than this size generate an error.  Setting this avoids transport-layer segmentation or network-layer fragmentation. When used with transports running over IP version 4 the Don't Fragment bit will be set to avoid on-path IP fragmentation ({{!RFC8304}}).  \r\n```",
              "createdAt": "2020-01-27T15:49:18Z",
              "updatedAt": "2020-05-29T09:27:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDQzMTY1",
          "commit": {
            "abbreviatedOid": "d361d6d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T09:11:56Z",
          "updatedAt": "2020-04-16T09:11:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This addresses the issue.",
              "createdAt": "2020-04-16T09:11:57Z",
              "updatedAt": "2020-05-29T09:27:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 488,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTM1MDg2",
      "title": "add framer, fix #417",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/488",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-01-24T17:14:28Z",
      "updatedAt": "2020-09-11T16:34:25Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "600d0bd1c6326b55cf4e27476453fd1009aa440d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "framer-ascii-art-417",
      "headRefOid": "877a2290f9206381e6941a78db74f2b58ff19c56",
      "closedAt": "2020-02-04T00:51:18Z",
      "mergedAt": "2020-02-04T00:51:17Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "b9f54e26f0089ba92c722dd4d5f4dae3a6bb76cc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NTM4MjEx",
          "commit": {
            "abbreviatedOid": "877a229"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Should this be on the side or right in the middle were the line is?",
          "createdAt": "2020-01-27T09:50:02Z",
          "updatedAt": "2020-01-27T09:50:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjI0MDUz",
          "commit": {
            "abbreviatedOid": "877a229"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-31T16:29:40Z",
          "updatedAt": "2020-01-31T16:29:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjYzNjI2",
          "commit": {
            "abbreviatedOid": "877a229"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-04T00:51:11Z",
          "updatedAt": "2020-02-04T00:51:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 490,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTQzNDQy",
      "title": "acknowledge all contributors to architecture discussions",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/490",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-01-24T17:37:56Z",
      "updatedAt": "2020-09-11T16:33:32Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "600d0bd1c6326b55cf4e27476453fd1009aa440d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "acks-419",
      "headRefOid": "4dfe501caeb8c060b3116125fb0a210d2a725cdb",
      "closedAt": "2020-01-27T09:42:04Z",
      "mergedAt": "2020-01-27T09:42:04Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixes #419 ",
          "createdAt": "2020-01-24T17:38:44Z",
          "updatedAt": "2020-01-24T17:38:44Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oops, i thought you were an author too. added.",
          "createdAt": "2020-01-27T09:39:18Z",
          "updatedAt": "2020-01-27T09:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzE0MzAy",
          "commit": {
            "abbreviatedOid": "30c362a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "To be honest, I wouldn't mind a mention. I haven't contributed much to this document in particular, I'm sure I did contribute a little too.",
          "createdAt": "2020-01-25T07:14:06Z",
          "updatedAt": "2020-01-25T07:14:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 491,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTgzMTgz",
      "title": "Connection Groups are objects, fix #420",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/491",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-01-24T19:32:56Z",
      "updatedAt": "2020-09-11T16:33:46Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3c1735c9a59900c924298bef0c6d7b42847cfe25",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "groups-420",
      "headRefOid": "1447956d7ac295ed178519f191256754ef059507",
      "closedAt": "2020-01-30T16:03:35Z",
      "mergedAt": "2020-01-30T16:03:35Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "0d286577ebe0a294cc6cf31ec98793fdc4bff4dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MTk4MzI3",
          "commit": {
            "abbreviatedOid": "1447956"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works - Thank you!",
          "createdAt": "2020-01-28T08:36:21Z",
          "updatedAt": "2020-01-28T08:36:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MjMxNjk0",
          "commit": {
            "abbreviatedOid": "1447956"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-28T09:32:23Z",
          "updatedAt": "2020-01-28T09:32:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 492,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTg1MjY1",
      "title": "Remove Go API illustration, fix #469",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/492",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-24T19:39:02Z",
      "updatedAt": "2020-09-11T16:33:45Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3c1735c9a59900c924298bef0c6d7b42847cfe25",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "no-go-469",
      "headRefOid": "68c7ed2c9fc95d9f0af55d3a2969581497516553",
      "closedAt": "2020-01-25T07:12:43Z",
      "mergedAt": "2020-01-25T07:12:43Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "05a2c555f202f8795d901e333549067d7e90c55e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 493,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2OTkxMDQz",
      "title": "figure 4 tweaks, fix #489",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/493",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-24T19:55:06Z",
      "updatedAt": "2020-09-11T16:33:33Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3c1735c9a59900c924298bef0c6d7b42847cfe25",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "figure-four-again-489",
      "headRefOid": "13d302b6bb4543e5ab801d4001bc8eaf43c3ce6c",
      "closedAt": "2020-01-27T09:37:04Z",
      "mergedAt": "2020-01-27T09:37:04Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "2e85b6642a24ea4efc4cf76b51d5f5a5beee4902"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzE0MTkx",
          "commit": {
            "abbreviatedOid": "13d302b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-01-25T07:10:45Z",
          "updatedAt": "2020-01-25T07:10:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 495,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3OTM4NTUy",
      "title": "Minor fixes with messageContexts, fixes #408",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/495",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Tentatively answering my own questions in #408:\r\n\r\n> The RendezvousError (Section 6.3) includes a messageContext (which is even required), but neither the InitiateError nor the ListenError include one. Why? Should this messageContext at least be optional?\r\n\r\nRemoved the messageContext here because the RendezvousError does not necessarily relate to a specific sent Message. If it does, the \"reason\" parameter can point to that message and/or a messageContext.\r\n\r\n> In Section 7.3, it says \"The Sent Event contains an implementation-specific reference to the Message to which it applies.\" - Is this in addition to the messageContext? If yes, why do we need both?\r\n\r\nThe beginning of Section 7 actually already said that this IS the messageContext. I removed the word \"implementation-specific\" because to me this word made it sound like this reference can't be the messageContext.\r\n\r\n> In Section 9, it says \"To get or set Message Properties, the optional scope parameter is left empty, for framing meta-data, the framer is passed.\" - I think this sentence is a bit hard to parse and it wasn't immediately obvious to me what kind of framing meta-data this refers to. Perhaps this refers to Section 10.2, so I think it's worth adding a reference to that section here. Also, I suggest turning this into two sentences, with the sentence on framing meta-data specifying that this is per-Message metadata to be used by the framer.\r\n\r\nSplit into two sentences and changed the second sentence to active voice.\r\n\r\nAlso, I slightly reworded the beginning of Section 7, which is now a bit clearer in my opinion.",
      "createdAt": "2020-01-28T10:35:44Z",
      "updatedAt": "2020-09-11T16:34:28Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/message-context-fixes",
      "headRefOid": "c0545a67948c75c0eb9b9371cd41635c9a3eb9d5",
      "closedAt": "2020-02-21T15:02:28Z",
      "mergedAt": "2020-02-21T15:02:27Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3a762fd73884c109bce3cdd263301aedab93ac73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjIzMzE5",
          "commit": {
            "abbreviatedOid": "c0545a6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks a lot for doing this! It clears things up nicely, I think.",
          "createdAt": "2020-01-31T16:28:36Z",
          "updatedAt": "2020-01-31T16:28:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 496,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3OTUzMzY3",
      "title": "Add justification and normative language, fixes #429",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/496",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Took a stab at normative language for the rules to process Selection Properties, as discussed in #429.\r\n\r\nAs far as I remember, we always said that outcomes have to be deterministic/consistent, so I made everything that matters a MUST.\r\nI guess our example illustrates that even given the same Selection Properties, the outcome might change depending on the situation, e.g., your path might still be Wifi but it might or might not support your preferred protocol.\r\n\r\nSo, does this really have to be all MUST, or is there a SHOULD in there? Discuss. :)\r\n\r\nAlso, if anyone can name a good reason why the outcome has to be deterministic, please suggest text - maybe something like \"avoid surprises for the application\", but this didn't really sound right, so I left it out for now.",
      "createdAt": "2020-01-28T11:09:15Z",
      "updatedAt": "2020-09-11T16:34:35Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/selection-rules",
      "headRefOid": "0261ee91afffe4ea5159cf836e8be3147c62435c",
      "closedAt": "2020-02-23T19:04:55Z",
      "mergedAt": "2020-02-23T19:04:55Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c10cc577723b08a1c42bf07dc50ddd50001176ef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjE5Mjg0",
          "commit": {
            "abbreviatedOid": "0261ee9"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This reads good to me. Regarding the request for text, I don't have any ideas...  but I think this could be fine as it stands?  Needs more eyes though.",
          "createdAt": "2020-01-31T16:22:48Z",
          "updatedAt": "2020-01-31T16:22:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTE1NDYy",
          "commit": {
            "abbreviatedOid": "0261ee9"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, merging this. thanks, Theresa!",
          "createdAt": "2020-02-23T19:04:47Z",
          "updatedAt": "2020-02-23T19:04:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 497,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3OTYyMDY0",
      "title": "Refactor Local Address Preference, fixes #436",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/497",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Following the suggestion in #436, made Local Address Preference a Set(Preference, Enumeration), so an application can now also Require or Prohibit stable addresses.\r\nAdded a sentence warning that, e.g., preferring stable AND temporary addresses does not make sense - but there are less obvious ways to produce a conflicting set of Selection Properties, too, and we know how to deal with them.",
      "createdAt": "2020-01-28T11:29:12Z",
      "updatedAt": "2020-09-11T16:34:47Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "51646656563d8d0024eaa5764d67eebe082b5873",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/local-address-preference",
      "headRefOid": "acce8f2233d2fa943e5c0ba9db8dc6b4a28595f3",
      "closedAt": "2020-03-08T15:37:07Z",
      "mergedAt": "2020-03-08T15:37:07Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "f04602ff929612336b3d7fab495474d62b79f0c7"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim discussion: let's use prohibit/avoid/prefer/require temporary addresses. Default connections to prefer temporary. Default listeners to avoid temporary.",
          "createdAt": "2020-02-21T16:58:57Z",
          "updatedAt": "2020-02-21T16:58:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that it fails without temporary addresses if you require temporary; which makes IPv4 fail.",
          "createdAt": "2020-02-21T16:59:45Z",
          "updatedAt": "2020-02-21T16:59:45Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Simplified this as discussed in the interim.\r\nPlease take another look.",
          "createdAt": "2020-02-24T14:37:34Z",
          "updatedAt": "2020-02-24T14:37:34Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me \u2013 But I am unsure whether we should replace the temporary address with a stable address with Preference. Rational: For IPv6 with outgoing connections, temporary is default anyway, so requiring the special case instead of avoid/prohibit the default looks much more straight forward.\r\n",
          "createdAt": "2020-03-02T12:41:10Z",
          "updatedAt": "2020-03-02T12:41:10Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks good to me \u2013 But I am unsure whether we should replace the temporary address with a stable address with Preference. Rational: For IPv6 with outgoing connections, temporary is default anyway, so requiring the special case instead of avoid/prohibit the default looks much more straight forward.\r\n\r\nI've read this a few times but I'm still not sure: What alternative solution are you proposing here?",
          "createdAt": "2020-03-05T13:31:14Z",
          "updatedAt": "2020-03-05T13:31:14Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Looks good to me \u2013 But I am unsure whether we should replace the temporary address with a stable address with Preference. Rational: For IPv6 with outgoing connections, temporary is default anyway, so requiring the special case instead of avoid/prohibit the default looks much more straight forward.\r\n> \r\n> I've read this a few times but I'm still not sure: What alternative solution are you proposing here?\r\n\r\nI am proposing to Invert the whole name and meaning of the property \u2013 instead of requesting a temporary address, request a stable address.",
          "createdAt": "2020-03-06T12:25:05Z",
          "updatedAt": "2020-03-06T12:25:05Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > > Looks good to me \u2013 But I am unsure whether we should replace the temporary address with a stable address with Preference. Rational: For IPv6 with outgoing connections, temporary is default anyway, so requiring the special case instead of avoid/prohibit the default looks much more straight forward.\r\n> > \r\n> > \r\n> > I've read this a few times but I'm still not sure: What alternative solution are you proposing here?\r\n> \r\n> I am proposing to Invert the whole name and meaning of the property \u2013 instead of requesting a temporary address, request a stable address.\r\n\r\nThanks for clarifying.\r\nI think this Property is straightforward enough as is, no need to invert.",
          "createdAt": "2020-03-08T15:36:04Z",
          "updatedAt": "2020-03-08T15:36:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMzMwMjUz",
          "commit": {
            "abbreviatedOid": "039768c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-31T07:29:55Z",
          "updatedAt": "2020-01-31T07:30:01Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "How could such a conflict arise? If I just use Set here, once, I only have a choice between one or the other, so it looks as if a conflict wouldn't be possible.",
              "createdAt": "2020-01-31T07:29:55Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMzY5Mjk5",
          "commit": {
            "abbreviatedOid": "039768c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-31T09:06:08Z",
          "updatedAt": "2020-01-31T09:06:09Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "But you could call the TransportProperties.Require() twice with different values for the Enum, right? At least I always assumed that was possible and it's certainly needed for, e.g., Interface Instance or Type.",
              "createdAt": "2020-01-31T09:06:08Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjE1OTcx",
          "commit": {
            "abbreviatedOid": "039768c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-31T16:17:59Z",
          "updatedAt": "2020-01-31T16:18:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "This confuses me. Normally, in an API, if I adjust a property with a call and make the call again with a different value, I expect that it's (only) the last call that matters. \"Interface Instance or Type\" has a Set of (Preference, Enum) tuples - like you're writing here. Actually, there, it makes sense to me that it's a set, but I'd assume that one call is made to hand over, e.g.: \"Wifi, Prefer; Cellular, Avoid\". In this case however, it's only about choosing either Stable or Temporary, and preferring it or even requiring it.\r\n\r\nActually, I'm also not sure that all Preference levels make sense here... e.g., what does it mean to call this and specify \"Avoid Stable\"? I would rather say that the enum needs one more value, e.g.: \"Stable_required\".",
              "createdAt": "2020-01-31T16:18:00Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDg4NTQw",
          "commit": {
            "abbreviatedOid": "039768c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T08:40:15Z",
          "updatedAt": "2020-02-03T08:40:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Regarding what happens if you make the call again with a different value, maybe you're right, but I wouldn't expect it to always work this way. For example, how do I specify a RemoteEndpoint with multiple local addresses, other than calling RemoteSpecifier.WithIPv6Address(...) multiple times? And then I'd expect the endpoint to contain all addresses that I specified and not just the last one.\r\nMaybe that's why I'm confused here, too.\r\n\r\nBut perhaps for Properties we should actually specify the behavior as you say.\r\nAnd then, I think for the Local Address Preference, it'd be enough to have one (Preference, Enum) instead of a set. It really does only make sense to specify one of these, and if you do, you implicitly specify the other. For example, if I specify \"Avoid Stable\", this implicitly means I prefer temporary - right?\r\nI don't see why another value would be required - I can just specify \"Require Stable\".",
              "createdAt": "2020-02-03T08:40:15Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjYzMzg5",
          "commit": {
            "abbreviatedOid": "716941c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-04T00:50:27Z",
          "updatedAt": "2020-02-04T00:50:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTAxNDcy",
          "commit": {
            "abbreviatedOid": "716941c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T14:37:04Z",
          "updatedAt": "2020-02-12T14:37:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "\"And then, I think for the Local Address Preference, it'd be enough to have one (Preference, Enum) instead of a set. It really does only make sense to specify one of these\" - does it? I'm not sure, in case of a multi-homed host, for example.  I believe we should discuss this PR at the interim.",
              "createdAt": "2020-02-12T14:37:04Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTAxMDM1",
          "commit": {
            "abbreviatedOid": "716941c"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T10:20:48Z",
          "updatedAt": "2020-02-13T10:20:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't see that it makes sense to, e.g., Prefer stable addresses on one local interface and Avoid them on another for the same Preconnection, and if there's case where it does make sense, the application would probably need more fine-grained control than just a list of preferences. Not sure it makes sense to specify this in our API draft.\r\nThat said, sure, we can discuss this at the interim.",
              "createdAt": "2020-02-13T10:20:48Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MjE1MDY1",
          "commit": {
            "abbreviatedOid": "716941c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T13:30:45Z",
          "updatedAt": "2020-02-13T13:30:45Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "We have some properties, e.g., PvD and Interface, that make sense being called multiple times - so we can't generally say every call cancels out the earlier. \r\n\r\nFor this preference, I would really prefer to keep it a simple enum, probably with Reuire stable / prefer stable / prefer temporary / require temporaray\"\r\n\r\nI guess it makes sense being able to specify this on a per-pvd or per-interface basis, e.g., force stable if on corporate network, otherwise prefer temp, but for me this is strictly optional.",
              "createdAt": "2020-02-13T13:30:45Z",
              "updatedAt": "2020-02-24T14:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MDQyMzYz",
          "commit": {
            "abbreviatedOid": "acce8f2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-02-25T10:45:22Z",
          "updatedAt": "2020-02-25T10:45:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 498,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3OTY5ODYy",
      "title": "Default for interface and PvD is no preference, fixes #435",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/498",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Added defaults for interface and PvD following #435.\r\n\r\nAlso, I caught one leftover \"recommended default\".",
      "createdAt": "2020-01-28T11:48:56Z",
      "updatedAt": "2020-02-04T08:08:52Z",
      "closedAt": "2020-02-04T08:08:48Z",
      "mergedAt": "2020-02-04T08:08:48Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MzQwOTc3",
          "commit": {
            "abbreviatedOid": "f0dfa3d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-28T12:37:29Z",
          "updatedAt": "2020-01-28T12:37:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTc0MjM2",
          "commit": {
            "abbreviatedOid": "f0dfa3d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-01-29T09:44:45Z",
          "updatedAt": "2020-01-29T09:44:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjYzNDg4",
          "commit": {
            "abbreviatedOid": "f0dfa3d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-04T00:50:46Z",
          "updatedAt": "2020-02-04T00:50:46Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/default-interface-pvd",
      "headRefOid": "f0dfa3d8647510930411acc241e43d844d884186",
      "mergeCommit": {
        "oid": "e6112b5a1a8e72e8bbae4ee96e613cb393f72630"
      }
    },
    {
      "number": 499,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY3OTg2OTI3",
      "title": "Justify why TCP UTO is included",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/499",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Following the discussion in #464, explain why TCP UTO is included as a Protocol-Specific Property, while other properties are not.\r\nAlso, some minor consistency fixes.",
      "createdAt": "2020-01-28T12:29:50Z",
      "updatedAt": "2020-02-04T08:07:57Z",
      "closedAt": "2020-02-04T08:07:50Z",
      "mergedAt": "2020-02-04T08:07:50Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MzQwMzIy",
          "commit": {
            "abbreviatedOid": "43b6869"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2020-01-28T12:36:18Z",
          "updatedAt": "2020-01-28T12:36:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTQyNjI3",
          "commit": {
            "abbreviatedOid": "43b6869"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-29T08:52:36Z",
          "updatedAt": "2020-01-29T08:52:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I would rephrase this. Here's a proposal:\r\n\r\nWhile they were deemed to be TCP-specific, these properties are included here because they are part of the minimal set of transport services {{I-D.ietf-taps-minset}}, where they were categorized as \"functional\". This means that they cannot be offered without the application knowing about them, or else they violate assumptions that might cause the application to fail.",
              "createdAt": "2020-01-29T08:52:36Z",
              "updatedAt": "2020-01-29T10:10:45Z"
            },
            {
              "originalPosition": 2,
              "body": "Since we're now using plural, should this be \"Properties\"?",
              "createdAt": "2020-01-29T08:52:39Z",
              "updatedAt": "2020-01-29T10:10:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTkxMjQw",
          "commit": {
            "abbreviatedOid": "0bf37f2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-29T10:10:48Z",
          "updatedAt": "2020-01-29T10:10:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks! I was wondering what to write more and I think mentioning this makes sense.\r\nI expanded this paragraph based on your suggestion trying to make it easier to understand - please tell me if it's correct now.",
              "createdAt": "2020-01-29T10:10:48Z",
              "updatedAt": "2020-01-29T10:10:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTkxNDE2",
          "commit": {
            "abbreviatedOid": "0bf37f2"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-29T10:11:05Z",
          "updatedAt": "2020-01-29T10:11:06Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Yes, I guess so.",
              "createdAt": "2020-01-29T10:11:05Z",
              "updatedAt": "2020-01-29T10:11:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDA2NzUw",
          "commit": {
            "abbreviatedOid": "0bf37f2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for doing this!",
          "createdAt": "2020-01-29T10:35:51Z",
          "updatedAt": "2020-01-29T10:35:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjYzMDg3",
          "commit": {
            "abbreviatedOid": "0bf37f2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-04T00:49:31Z",
          "updatedAt": "2020-02-04T00:49:31Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c9940f0f02ac58660002a24e6e7d4e1a2cb6331e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/tcp-uto-justification",
      "headRefOid": "0bf37f20ab5c44a92c5015fc37a672545b31cf90",
      "mergeCommit": {
        "oid": "741f5f1afc9a9f9ca53faa8a152f676e9aea5275"
      }
    },
    {
      "number": 500,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0MzQwNzI3",
      "title": "Various API fixes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/500",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These are all my self-assigned issues, where I think the discussion has converged.\r\nCloses #404, #426, #434, #438, #441, #443, #451, #462, #467\r\n",
      "createdAt": "2020-02-12T14:32:12Z",
      "updatedAt": "2020-09-11T16:34:40Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e6112b5a1a8e72e8bbae4ee96e613cb393f72630",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "MW-various_interface_fixes",
      "headRefOid": "9a099b89b0039f26d279c46a1f702828647ab1cd",
      "closedAt": "2020-02-21T14:44:16Z",
      "mergedAt": "2020-02-21T14:44:16Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "4d03aa0c44e2a7e2de8a1a9f6aeec45ae62da8ea"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@theri - I wonder if a good way ahead would be to merge this as-is, but remove #441 from the \"closes\" list?  As being discussed in #441, the right way ahead for the Listen / cloning problem may be a bigger change, which I'd rather do in a separate  PR.",
          "createdAt": "2020-02-17T19:23:21Z",
          "updatedAt": "2020-02-17T19:23:40Z"
        },
        {
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @theri - I wonder if a good way ahead would be to merge this as-is, but remove #441 from the \"closes\" list? As being discussed in #441, the right way ahead for the Listen / cloning problem may be a bigger change, which I'd rather do in a separate PR.\r\n\r\nYes, that sounds like a good way to move forward.",
          "createdAt": "2020-02-19T11:53:16Z",
          "updatedAt": "2020-02-19T11:53:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MDgxNTIx",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this!\r\nI added some suggestions and questions.",
          "createdAt": "2020-02-13T09:52:15Z",
          "updatedAt": "2020-02-13T10:17:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I would strike the \"all\" here.",
              "createdAt": "2020-02-13T09:52:15Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 68,
              "body": "As you moved the default to the top, do you want to delete this sentence?",
              "createdAt": "2020-02-13T09:53:30Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 238,
              "body": "Nit: capital F in \"for\"?",
              "createdAt": "2020-02-13T09:54:42Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 345,
              "body": "Wait, \"in this case\", i.e., only if Clone() results in on-the-wire signaling?\r\nWhat does applying Connection Properties have to do with on-the-wire signaling?",
              "createdAt": "2020-02-13T09:57:00Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 348,
              "body": "This sounds as if creating a stream is the only way to implement Clone(), but perhaps it's also possible to implement it differently, i.e., by opening a new connection.",
              "createdAt": "2020-02-13T09:57:58Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 364,
              "body": "I think here we should give a brief explanation why this property is specific to UDP and UDP-Lite.",
              "createdAt": "2020-02-13T09:59:38Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            },
            {
              "originalPosition": 334,
              "body": "I'm wondering if we should a bit more detail about how ListenClone() works.\r\nIs this listening on anything that the original Preconnection has specified (e.g., multiple local interfaces), or is this just listening on the LocalEndpoint where the cloned Connection came in (e.g., just one local interface)?\r\nTo make this clear, we could add text like: \"ListenClone() creates a Listener that listens on the same LocalEndpoint as the cloned Connection is using. Any new Connection received by this Listener will be entangled with the cloned Connection.\"\r\n\r\nIf this is non-trivial, we could also make this another issue or continue discussing in #441.",
              "createdAt": "2020-02-13T10:11:06Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTczNTQ2",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T12:22:07Z",
          "updatedAt": "2020-02-13T12:22:07Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Sure, I did this everywhere but must have missed this one. Thanks!",
              "createdAt": "2020-02-13T12:22:07Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTc1NTU5",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T12:25:49Z",
          "updatedAt": "2020-02-13T12:25:49Z",
          "comments": [
            {
              "originalPosition": 345,
              "body": "It has to do with \"e.g., to open a new connection\"; in this case refers to opening new connections instead of using multiple streams (e.g., when multi-streaming is not available).",
              "createdAt": "2020-02-13T12:25:49Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTc2ODI1",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T12:28:01Z",
          "updatedAt": "2020-02-13T12:28:02Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "Ahh... \"fixed\" this too fast!  I completely agree that this is also a possible implementation, and hence I wanted to remove \"does not support cloning\" - there's no reason not to support it. In doing so, I removed too little because indeed now it sounds even \"narrower\". Thanks!",
              "createdAt": "2020-02-13T12:28:02Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTc3NjU5",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T12:29:31Z",
          "updatedAt": "2020-02-13T12:29:31Z",
          "comments": [
            {
              "originalPosition": 334,
              "body": "I think your proposed sentences fix this nicely.",
              "createdAt": "2020-02-13T12:29:31Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzU1NDky",
          "commit": {
            "abbreviatedOid": "660d518"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T16:18:43Z",
          "updatedAt": "2020-02-13T16:18:43Z",
          "comments": [
            {
              "originalPosition": 345,
              "body": "Oh, that makes sense. Could you change \"In this case\" to \"When opening new connections\" then, please?",
              "createdAt": "2020-02-13T16:18:43Z",
              "updatedAt": "2020-02-13T17:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzM5NjI4",
          "commit": {
            "abbreviatedOid": "9a099b8"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for the fixes! Looks good to me now.",
          "createdAt": "2020-02-15T10:53:14Z",
          "updatedAt": "2020-02-15T10:53:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzUyMjk0",
          "commit": {
            "abbreviatedOid": "9a099b8"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry, spoke too soon. I did find one more thing, see also #441:\r\nThe API draft needs to say whether incoming Connections created by a Listener from Listen() are grouped.\r\n\r\nI'd say they may or may not be grouped, depending on whether we're receiving a new stream on an already established connection (in which case all of these streams are Connections grouped with each other) or whether we have an entirely new non-multiplexed connection.\r\nIf this is the case, maybe we should really add a call to query whether Connections are grouped or not.",
          "createdAt": "2020-02-15T16:02:09Z",
          "updatedAt": "2020-02-15T16:02:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMDUwMjQ3",
          "commit": {
            "abbreviatedOid": "9a099b8"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-19T11:53:27Z",
          "updatedAt": "2020-02-19T11:53:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 501,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2MjAzNDc4",
      "title": "First attempt to write some privacy considerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/501",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This ended up in more text that I thought. I'm not certain if we need all of it. Further I'm unsure about the concrete wording in many cases, so any comments are more than welcome!",
      "createdAt": "2020-02-17T15:43:23Z",
      "updatedAt": "2020-09-11T16:34:48Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e6112b5a1a8e72e8bbae4ee96e613cb393f72630",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-api-privacy",
      "headRefOid": "74de5a73965a2b7fdef310c4debf73d78a4c5475",
      "closedAt": "2020-03-08T15:36:38Z",
      "mergedAt": "2020-03-08T15:36:38Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "42f214ef2bb82a83805b1035133f097a6e1f5835"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is supposed to address issue #177 ",
          "createdAt": "2020-02-17T15:49:35Z",
          "updatedAt": "2020-02-17T15:49:35Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do mentioned name resolution, however, leakage though DNS might rather be a DNS problem and not necessarily an issue that needs to be considered in taps.\r\n\r\nSharing cache state is a good point. I vaguely remember that we already address that somewhere else (could also be in the implementation draft as this is rather an implementation issue). But maybe we can add a pointer...?",
          "createdAt": "2020-02-19T19:00:22Z",
          "updatedAt": "2020-02-19T19:00:22Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Leakage though DNS may need to be addressed by TAPS, as with the current sockets API, the application has complete control about when DNS resolution is done (and, at least as long as things like DoH/DoT are predominantly implemented by nonsystem resolver libraries, *how*). TAPS as envisioned gives the system more control over resolution.",
          "createdAt": "2020-02-23T18:13:08Z",
          "updatedAt": "2020-02-23T18:13:08Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(IIRC the architecture does explicitly address and mention the shared cache issue; adding a line to refer to that in privacy considerations might be nice but isn't IMO necessary.)",
          "createdAt": "2020-02-23T18:54:24Z",
          "updatedAt": "2020-02-23T18:54:24Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Gorry, I addressed all your nits/comments.",
          "createdAt": "2020-03-04T16:14:35Z",
          "updatedAt": "2020-03-04T16:14:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMTgwNDIw",
          "commit": {
            "abbreviatedOid": "e20c399"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think it is a good start, but I miss two aspects:\r\n - Information leakage through DNS, which can also make addresses on different paths linkable\r\n - Information leakage within an application though shared caches, e.g., within a browser.  ",
          "createdAt": "2020-02-19T14:56:07Z",
          "updatedAt": "2020-02-19T14:56:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjY5NjQ2",
          "commit": {
            "abbreviatedOid": "114495b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I agree this is a good starting point; note that I took the liberty to directly fix some nits (such as capitalizing TAPS) and typos; these never change the intended meaning.",
          "createdAt": "2020-03-04T10:38:14Z",
          "updatedAt": "2020-03-04T10:38:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODA1OTQ0",
          "commit": {
            "abbreviatedOid": "114495b"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T14:09:08Z",
          "updatedAt": "2020-03-04T14:17:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "as /a/ library",
              "createdAt": "2020-03-04T14:09:09Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 12,
              "body": "/In any case/In either case/ ? \r\n- and add comma?",
              "createdAt": "2020-03-04T14:09:51Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 17,
              "body": "/as it/because this/",
              "createdAt": "2020-03-04T14:10:33Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 19,
              "body": "/It should first be noted/\r\n-Could be deleted top read easier?",
              "createdAt": "2020-03-04T14:11:20Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 21,
              "body": "/of course/ \r\n- could be deleted?",
              "createdAt": "2020-03-04T14:11:47Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 22,
              "body": "/to which other entities/\r\n- seem to read wrong.. is this: and the other entities that can access this, or something else?",
              "createdAt": "2020-03-04T14:13:04Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 23,
              "body": "/in information/to information/?\r\n/that is visible on the path/... /that can be observed by netwoprkl devices on the path/?",
              "createdAt": "2020-03-04T14:14:09Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 37,
              "body": "/Further,/\r\n\"pull\" ... probably a better word is needed... is this \"provide\"",
              "createdAt": "2020-03-04T14:17:08Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            },
            {
              "originalPosition": 38,
              "body": "insert /the/ before /communications/",
              "createdAt": "2020-03-04T14:17:40Z",
              "updatedAt": "2020-03-04T16:14:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 502,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzQzNDU0",
      "title": "Clean up unnecessary normative language in arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/502",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Addresses #418.\r\n\r\nRemoves most of the normative language in arch, which wasn't strictly necessary. What's left is the careful text around security protocols being raced, etc, which I believe is required.",
      "createdAt": "2020-02-21T15:39:35Z",
      "updatedAt": "2020-09-11T16:34:41Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a762fd73884c109bce3cdd263301aedab93ac73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-less-normative",
      "headRefOid": "bf690998548739c4f659ffd979bef01345d89296",
      "closedAt": "2020-03-09T12:45:22Z",
      "mergedAt": "2020-03-09T12:45:22Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3218bf01127a76f77e35d4ad4eccfebf582f4977"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After the review, I would still be in favour of using RFC2119 language to describe what is required architecturally to be a TAPS system. In my review, I agree the number of requirements is now reduced.\r\n\r\nI really do wonder if we could (please) group all these requirements on architecture into a single subsection, so they are easy to read - and we can they say that these are the architectural requirements, explcitly refererence those in section XX relating to racing.\r\n\r\nI suggest we insert this requirements text either as short text blocks in their own section, or simply a set of bullets in section 1.3 (although I am open to other places where we can call-out the architectural requirements).\r\n\r\nPerhaps we should also check we still have captured something along the lines of: \r\n\r\n\"The System should permit evolution of the system without affecting programs using it. In normal use, TAPS systems are RECOMMENDED to result in consistent selection for the same network conditions when they have the same set of preferences, but applications using the TAPS API are REQUIRED to be robust to the automated selection, including the possibility to express requirements that constrain the choices that can be made by the system.\" And possibly add \"Applications using TAPS can explicitly require or prevent the use of specific transport features (and transport protocols) using the \"REQUIRED\" and \"PROHIBIT\"...\" or something like that.\r\n\r\nIf this seems appropriate to add a section on overall requirements, I would then suggest to use lower case within the document and simply refer to this subsection, where necessary to get the RFC2119 sentences.",
          "createdAt": "2020-03-04T13:53:02Z",
          "updatedAt": "2020-03-08T09:29:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTE1MDA4",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "ISTM we'll need to spend some time on normative language discussion in Vancouver. Until then, this is a good change for a baseline, thanks!",
          "createdAt": "2020-02-23T18:56:55Z",
          "updatedAt": "2020-02-23T18:56:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzU0MDkx",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T12:57:25Z",
          "updatedAt": "2020-03-04T13:56:51Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This is arguably something that could be a REQUIRED or RECOMMENDED - after all the WG worked on Minset, with what I saw as an intention this was the basis of the API. Something has to define what is the TAPS archicture.\r\n---\r\nI would prefer keeping something about:\r\n-  Functionality that is common across multiple transport protocols SHOULD be accessible through a unified set of API calls. An application ought to be able to...\r\n- As a baseline, a Transport Services API is RECOMMENDED to allow access to the distilled minimal ...\r\n",
              "createdAt": "2020-03-04T12:57:25Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 23,
              "body": "I like the proposed change. This might just be encouragment.",
              "createdAt": "2020-03-04T12:59:12Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 26,
              "body": "I like this proposed change -the word  MUST was too strong.",
              "createdAt": "2020-03-04T12:59:56Z",
              "updatedAt": "2020-03-08T09:19:24Z"
            },
            {
              "originalPosition": 35,
              "body": "I don't agree with the change. REQUIRED seems strong - but as above - I think we at least need to RECOMMEND minset.\r\n\r\nALTHOUGH, stating the requirement twice is not good and one statement needs to be changed!",
              "createdAt": "2020-03-04T13:02:32Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 48,
              "body": "Agree in proposal to change to needs.",
              "createdAt": "2020-03-04T13:06:08Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 51,
              "body": "Disagree on this: I think this is an archtiectural requirement:\r\n\r\nIt is RECOMMENDED that any system that provides generic Transport Services,  SHOULD define properties common to multiple transport protocols.",
              "createdAt": "2020-03-04T13:07:53Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 58,
              "body": "Agree",
              "createdAt": "2020-03-04T13:08:45Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 67,
              "body": "I agree with the set of requirements, but these are API requirements, not architectural ones. The new text therefore seems appropriate to me.",
              "createdAt": "2020-03-04T13:10:26Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 81,
              "body": "Don't see this change as sufficient.\r\n\r\nThe idea of adding Send and Receive properties seem close to  encapsulating important TAPS architecture, but as written here seem more appropriate to the API.\r\n\r\nI do think this IS something we ought to call-out as a fundamental aspect of any TAPS system.\r\nA TAPS API is REQUIRED to accept Message Properties specific to how a Message content is to be sent, but the details of how these messages are used can be system-dependent. A TAPS API MAY SUPPLY Message Properties specific to how a Message content is to be received, but the details of how these messages are used can be system-dependent.",
              "createdAt": "2020-03-04T13:19:36Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 107,
              "body": "OK with this proposed change - seems like an API detail.",
              "createdAt": "2020-03-04T13:26:32Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 114,
              "body": "I actually prefer the change proposed to use /can/ .... although others may protest? -  I think that whether a TAPS system /implements/ this is not fundamental to TAPS. ",
              "createdAt": "2020-03-04T13:28:04Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 120,
              "body": "I think the change is OK. Because this is a detail of the API, not an architectural aspect.",
              "createdAt": "2020-03-04T13:28:47Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            },
            {
              "originalPosition": 102,
              "body": "Is this architectural? - it could be seen as explaining something from Minset and referencing section 6.1 about \"close\" could be helpful.\r\n\r\nI think we should use SHOULD here, because it helps explain the requirements for one-sided operation, which is a key architectural feature required of TAPS: A protocol SHOULD signal the close state to the remote system if the transport protocol allows this.",
              "createdAt": "2020-03-04T13:38:13Z",
              "updatedAt": "2020-03-08T09:18:00Z"
            },
            {
              "originalPosition": 6,
              "body": "I think the word /assumes/ is not a good choice of word. Can we change this to something like:\r\n\r\n/and it can provide benefit when an implementation can use multiple IP addresses, multiple protocols, multiple paths, and provide multiple application streams./\r\n",
              "createdAt": "2020-03-04T13:41:03Z",
              "updatedAt": "2020-03-04T13:56:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTI3NDc5",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T12:39:42Z",
          "updatedAt": "2020-03-09T12:39:42Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This one seems like a point for wider discussion at 107 or a future interim. ",
              "createdAt": "2020-03-09T12:39:42Z",
              "updatedAt": "2020-03-09T12:39:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTI3Njgx",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T12:40:05Z",
          "updatedAt": "2020-03-09T12:40:06Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "As above.",
              "createdAt": "2020-03-09T12:40:06Z",
              "updatedAt": "2020-03-09T12:40:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTMwMDM3",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T12:44:12Z",
          "updatedAt": "2020-03-09T12:44:13Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "this also seems tied to the minset discussion, suggest we pick it up at 107 or after.",
              "createdAt": "2020-03-09T12:44:13Z",
              "updatedAt": "2020-03-09T12:44:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTMwMzcz",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T12:44:51Z",
          "updatedAt": "2020-03-09T12:44:51Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "let's pick this up in/after 107.",
              "createdAt": "2020-03-09T12:44:51Z",
              "updatedAt": "2020-03-09T12:44:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTMwNTE2",
          "commit": {
            "abbreviatedOid": "bf69099"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T12:45:06Z",
          "updatedAt": "2020-03-09T12:45:06Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "let's pick this up at/after 107.",
              "createdAt": "2020-03-09T12:45:06Z",
              "updatedAt": "2020-03-09T12:45:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 503,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzQ1NTA4",
      "title": "Address #472",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/503",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-02-21T15:43:56Z",
      "updatedAt": "2020-09-11T16:34:42Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a762fd73884c109bce3cdd263301aedab93ac73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/protocol-stack-equiv",
      "headRefOid": "d012864fc5ccc0846dac161d5745706d76a4d104",
      "closedAt": "2020-02-23T17:17:22Z",
      "mergedAt": "2020-02-23T17:17:22Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "ef1a4713b1ece84c9f712fc9f924cd6ecd17174d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzU2OTc0",
          "commit": {
            "abbreviatedOid": "d012864"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:31:45Z",
          "updatedAt": "2020-02-21T16:31:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 504,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzQ2MzA0",
      "title": "Address #476",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/504",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-21T15:45:38Z",
      "updatedAt": "2020-09-11T16:34:43Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a762fd73884c109bce3cdd263301aedab93ac73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/remove-service-class",
      "headRefOid": "88ef153fbb458a5c4d3b45d9c1706dd737e63be4",
      "closedAt": "2020-02-23T18:08:53Z",
      "mergedAt": "2020-02-23T18:08:53Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "77cbab4dd31d209ea3c2fba4e22e76d086740d05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzU0MDI1",
          "commit": {
            "abbreviatedOid": "88ef153"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:27:50Z",
          "updatedAt": "2020-02-21T16:27:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 505,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzQ4MTU3",
      "title": "Address #416, add message property example",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/505",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "",
      "createdAt": "2020-02-21T15:49:21Z",
      "updatedAt": "2020-09-11T16:34:44Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a762fd73884c109bce3cdd263301aedab93ac73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/message-prop-example",
      "headRefOid": "ea1d3bab0ddbcf54bd10d89362c606ab28930b8f",
      "closedAt": "2020-02-23T19:06:03Z",
      "mergedAt": "2020-02-23T19:06:03Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "51646656563d8d0024eaa5764d67eebe082b5873"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzQxMDEy",
          "commit": {
            "abbreviatedOid": "ea1d3ba"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:09:50Z",
          "updatedAt": "2020-02-21T16:09:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDUzMzQ2",
          "commit": {
            "abbreviatedOid": "ea1d3ba"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM modulo one nit - but see if you agree with my suggestion. If you don't, I'm ok with this anyway.",
          "createdAt": "2020-02-25T21:15:43Z",
          "updatedAt": "2020-02-25T21:16:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"TCP FIN\" feels to protocol specific here; couldn't we say \"... if the peer has requested to Close the Connection.\" ?",
              "createdAt": "2020-02-25T21:15:43Z",
              "updatedAt": "2020-02-25T21:16:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 506,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzUxNzc1",
      "title": "Add security parameters to arch",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/506",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Addresses #413",
      "createdAt": "2020-02-21T15:57:06Z",
      "updatedAt": "2020-09-11T16:34:45Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3a762fd73884c109bce3cdd263301aedab93ac73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/security-parameters",
      "headRefOid": "2379a78c99e8c9e1c761e0620aa384b44a7d1fce",
      "closedAt": "2020-02-23T17:47:50Z",
      "mergedAt": "2020-02-23T17:47:50Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "4dde5a236f62992aeab02dc5f40644a0857afe47"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM0NzI4",
          "commit": {
            "abbreviatedOid": "2379a78"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:01:07Z",
          "updatedAt": "2020-02-21T16:01:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzQwNTM0",
          "commit": {
            "abbreviatedOid": "2379a78"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:09:11Z",
          "updatedAt": "2020-02-21T16:09:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 511,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyMzU4MTk5",
      "title": "Move algorithm text to Implementation draft, make Interface draft more flexible",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/511",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "In the [February 2020 interim](http://etherpad.tools.ietf.org:9000/p/notes-ietf-interim-2020-feb), people found the normative language in #496 too restrictive and agreed with the original suggestion in #429.\r\nTherefore, this PR moves the selection algorithm text to the implementation draft and removes some normative language in the interface draft.\r\nWe still want to provide consistency to applications when possible, so there's a sentence in the implementation draft on this now as well.",
      "createdAt": "2020-03-02T12:31:48Z",
      "updatedAt": "2020-03-09T08:06:55Z",
      "closedAt": "2020-03-09T08:06:42Z",
      "mergedAt": "2020-03-09T08:06:42Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3Nzg5Njk1",
          "commit": {
            "abbreviatedOid": "7182e38"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d Great with one minor knit.",
          "createdAt": "2020-03-03T08:45:31Z",
          "updatedAt": "2020-03-03T08:48:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I would try to avoid having three \"and\"s in the sentence: \r\n```suggestion\r\nDuring Candidate Gathering, an implementation first excludes all protocols and\r\npaths that match a Prohibit or do not match all Require properties.\r\nThen, the implementation will sort branches according to Preferred\r\n```",
              "createdAt": "2020-03-03T08:45:31Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjYyMzk3",
          "commit": {
            "abbreviatedOid": "7182e38"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo the suggestion from @philsbln which I would accept as-is",
          "createdAt": "2020-03-04T10:28:02Z",
          "updatedAt": "2020-03-04T10:28:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTY5ODQ5",
          "commit": {
            "abbreviatedOid": "fc13888"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T13:34:19Z",
          "updatedAt": "2020-03-05T13:34:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good suggestion, thanks!",
              "createdAt": "2020-03-05T13:34:20Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTcxMTU4",
          "commit": {
            "abbreviatedOid": "fc13888"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T13:36:06Z",
          "updatedAt": "2020-03-05T13:40:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'd still love to say \"ought to aim\" \r\n\r\nand then (maybe in there implementation) say  are RECOMMENDED to aim...\r\n- I thin k this is a very useful goal, the SHOULD/RECOMMENDED is admittedly a little weak, in that it's hard t precisely conform, but I still think the intent is important to the usefulness of the TAPS system.\r\n",
              "createdAt": "2020-03-05T13:36:06Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            },
            {
              "originalPosition": 28,
              "body": "/try the path/ seems a tad loose, do you mean to race the path first, or evaluate the path or something else?\r\n... I don't know the best words:-)",
              "createdAt": "2020-03-05T13:39:25Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjE4NjQ3",
          "commit": {
            "abbreviatedOid": "fc13888"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T10:21:37Z",
          "updatedAt": "2020-03-06T10:21:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Sure, \"ought to aim\" sounds good to me as well.\r\nWe don't have normative language in the implementation document, but I'll put a sentence in the API document saying RECOMMENDED.",
              "createdAt": "2020-03-06T10:21:37Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjE5Mzcx",
          "commit": {
            "abbreviatedOid": "fc13888"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T10:22:43Z",
          "updatedAt": "2020-03-06T10:22:43Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I'd say \"race\" works, because it implies that branches with the preferred path are sorted to the top, thus, raced first. Will change, thanks for the suggestion!",
              "createdAt": "2020-03-06T10:22:43Z",
              "updatedAt": "2020-03-06T10:23:29Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "51646656563d8d0024eaa5764d67eebe082b5873",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/selection-algorithm",
      "headRefOid": "c174db3313039e504baa9949342cae57fb777600",
      "mergeCommit": {
        "oid": "fb84d1fa368a490fcfb03050b3e1ca16ab9e99e4"
      }
    },
    {
      "number": 512,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyOTcxMDQy",
      "title": "Update Multipath properties - closes #437",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/512",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #437.\r\n* allow to control active/passive opertaion\r\n* clairify functionality\r\n* allow to control exposure of alternative addresses",
      "createdAt": "2020-03-03T14:06:37Z",
      "updatedAt": "2020-06-19T15:10:38Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a467d4e8fff428e91a891e5bf0b7b4f9637066b6",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/mp-active-passive-altaddr",
      "headRefOid": "cf02c7f68003ead8fa34415ee0b5a02c44e2bbcf",
      "closedAt": "2020-06-19T15:10:29Z",
      "mergedAt": "2020-06-19T15:10:29Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "8596406afbbd2d07c2d6319d4e23a781d5e4359c"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think having one parameter for all interfaces is not enough as you might want to decide differently on a per interface basis. You can also have a look at section 5.3 of rfc6897 for what was recommended for MPTCP. Maybe the Apple people have also more input based in what is currently implemented for MPTCP in their stack?\r\n",
          "createdAt": "2020-03-04T13:10:31Z",
          "updatedAt": "2020-03-04T13:10:31Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak I think this would be a cool extension, but I would prefer to have a basic version first that leaves interface specific decisions to the implementation / system policy.",
          "createdAt": "2020-03-06T09:49:45Z",
          "updatedAt": "2020-03-06T09:49:45Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see that as an extension but an alternative. I just believe a generic config to enable this for all interfaces will not be useful at all because you always want to make a decision on a per interface basis. ",
          "createdAt": "2020-03-06T11:55:29Z",
          "updatedAt": "2020-03-06T11:55:29Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion seems ongoing enough that we shouldn't merge for the 107 draft deadline. Keeping this one open.",
          "createdAt": "2020-03-09T12:47:32Z",
          "updatedAt": "2020-03-09T12:47:32Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom I clarified the relationship between the two multi-path properties. Please review whether this works for you now, as I don't think merging them would make things clearer.\r\n\r\nWith regards to the per-interface choice, I would prefer to use ```Interface Instance``` or ```Interface Type``` Properties and add a few notes how these effect multi-path in a separate PR",
          "createdAt": "2020-04-15T14:33:48Z",
          "updatedAt": "2020-04-16T12:49:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim discussion:\r\n\r\nPossible knobs:\r\n- Who opens the paths? (active/passive/disabled)\r\n- Should we announce our other IP addresses? (allowed or not)\r\n- How are packets scheduled on the subpaths? (handover, interactive, aggregate)\r\n\r\n",
          "createdAt": "2020-04-17T16:38:47Z",
          "updatedAt": "2020-04-17T16:38:47Z"
        },
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made a new version based on the decisions we made in the interim. Please review.",
          "createdAt": "2020-04-24T07:41:28Z",
          "updatedAt": "2020-04-24T07:41:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjMwNTEy",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-04T09:43:43Z",
          "updatedAt": "2020-03-04T09:51:26Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "In #437, @tfpauly writes, as a conclusion from the interim discussion: \"Exposing alternate addresses to the peer and actively migrating is likely a separate property that we should specify.\"  I interpret this as meaning that we don't want \"Handover\" here. If we do want to keep it, I agree with @gorryfair who, in #437, suggests to call this \"Failover\" instead.",
              "createdAt": "2020-03-04T09:43:43Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 32,
              "body": "I agree with @gorryfair and @abrunstrom who call this \"fuzzy\" in #437 (this applies to both \"Interactive\" and \"Passive-Interactive\". Do we need this now, given that we don't seem to have any RFC explaining how to best implement this?  I think it's cool functionality, but I question whether this should be inside a Transport System - would an application be able to trust this to implement just the right trade-off for it, between e.g. capacity usage and delay minimization?\r\n\r\nSide note: if we do keep it, I think the text of this update is better.",
              "createdAt": "2020-03-04T09:49:19Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzU0OTk5",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T12:58:50Z",
          "updatedAt": "2020-03-04T12:58:50Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "No, these are still two separate things:\r\n - Exposure of Alternative Addresses is defined as a separate property below\r\n - You don't need to expose an alternative addresses prior initiating handover.\r\n - Servers will most likely never advertise alternative addresses but still want to support the client in migrating.\r\n\r\nMaybe make this more explicit that the Multipath property really defines path management behaviour while the exposure property defines advertisement. ",
              "createdAt": "2020-03-04T12:58:50Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzU4ODYw",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T13:04:39Z",
          "updatedAt": "2020-03-04T13:04:39Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "This is a slightly extended version of Apple's implementation (apple makes not distinction between passive and active) and can be easily implemented, e.g., for MPTCP by choosing the right path manager. It is a matter of choosing \"Just use the lowest RTT path\" vs. \"use all paths\"",
              "createdAt": "2020-03-04T13:04:39Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzgxMDg4",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T13:36:42Z",
          "updatedAt": "2020-03-04T13:36:43Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "So if you have a long-RTT path with potentially a lot of extra capacity as well as a short-RTT path, this is always going to pick the short-RTT one?  Even if the capacity on the short-RTT one is quite tiny and the RTT difference isn't very large? Or else, how do you choose these thresholds?  => yes there CAN be a simple implementation, but there are also trade-offs in the design.",
              "createdAt": "2020-03-04T13:36:42Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzg0MTQ5",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T13:40:53Z",
          "updatedAt": "2020-03-04T13:40:53Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I saw the Exposure of Alternative Addresses below, and I agree that this is (or can be) separate from \"actively migrating\". My understanding of the sentence was that both of these things should be a separate property (or are somehow combined into a single separate property).",
              "createdAt": "2020-03-04T13:40:53Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODk0NTYx",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T15:49:12Z",
          "updatedAt": "2020-03-04T15:49:12Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I assume this is a weird corner case, but yes there are trade-offs the implementation must make. Do we need text on that?",
              "createdAt": "2020-03-04T15:49:12Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTAwMjkz",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T15:55:33Z",
          "updatedAt": "2020-03-04T15:55:33Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "My understanding was that exposure of addresses (as done by MPTCP) should defiantly be a separate option and active/passive is missing somehow. Yes, one can make active/passive a third option (which would, for the MPTCP case, decide whether to actively open additional sub-flows).\r\nI have no strong opinions whether to put this in two options or three options, but if you choose three, we would go away from the model in NWConnection and end up with:\r\n\r\n - **multipath**: active/passive/disabled\r\n - **multipath-strategy**: failover/interactive/aggregate bandwidth (no disabled, as this would be ambiguous)\r\n - **advertises-altaddr**: true/false\r\n\r\nWould that be better?",
              "createdAt": "2020-03-04T15:55:33Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTM4NDY5",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T16:38:48Z",
          "updatedAt": "2020-03-04T16:38:49Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I don't think it's a weird corner case; I just don't think that many applications would want to say \"give me the lower latency path, at all cost, no matter how miniscule the difference, no matter how much capacity I lose\". I'm not proposing to address this with some discussion in text - I'm proposing not to delegate the algorithm that chooses paths on this basis to the transport system, but leaving it inside the application instead.\r\n\r\nThis said, I don't have a very strong opinion on this matter - I'd like to hear others' views.",
              "createdAt": "2020-03-04T16:38:49Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTk1NTQx",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T09:44:54Z",
          "updatedAt": "2020-03-06T09:44:55Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@tfpauly Do you have a preference?",
              "createdAt": "2020-03-06T09:44:55Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTU5MTA2",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Still some things to sort out, but I think this PR is a good improvement, thanks @philsbln.",
          "createdAt": "2020-03-09T13:10:09Z",
          "updatedAt": "2020-03-09T15:46:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "As long as we do not go to a per interface model (I agree with @philsbln to leave this for later), perhaps we can merge the multipath and advertise-altaddr properties above? Not sure it makes sense to pick active and not advertise any addresses? But for passive this is an important choice so would need to split that in two. Keeping the strategy separate makes sense I think.",
              "createdAt": "2020-03-09T13:10:09Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 42,
              "body": "Should this not be other than Disabled. Passive still requires a protocol with multipath support I guess. And should perhaps also say that Disabled is a requirement?",
              "createdAt": "2020-03-09T15:44:01Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 32,
              "body": "Leaving it to the application may seem attractive, but is not really feasible in practise as it quickly gets very complicated. For instance, if you ask for a packet to be sent on one path and this packet is lost, are you allowed to retransmit it on another path for reliability? What if the path is lost before you manged to send the packet at all?\r\nI think the updated text is an improvement.",
              "createdAt": "2020-03-09T15:44:14Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzMwMTUw",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T16:21:24Z",
          "updatedAt": "2020-03-09T16:21:25Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Ok, glad to hear that you like this - I don't personally have a strong opinion, and I agree that it quickly gets complicated!  (but that's also why I felt quite insecure about simply delegating this to the transport system). I would like to hear @tfpauly's opinion too, though.",
              "createdAt": "2020-03-09T16:21:24Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3Njg2ODA5",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-04T10:16:35Z",
          "updatedAt": "2020-04-04T10:16:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "It makes sense for a client to pick active, as ist allows to initiate additional subflows and, thus, implicitly expose some addresses, but not expose other addresses.\r\nI consider exposing addresses without actively establishing sub-flows rather as a corner-case for things like GPT over SCPT or to bootstrap connection migration through NAT.\r\nNote that I use MPTCP terminology here, but I think this is not limited to MPTCP. ",
              "createdAt": "2020-04-04T10:16:35Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3Njg2OTEy",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-04T10:17:48Z",
          "updatedAt": "2020-04-04T10:17:48Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Ack; I'll fix that",
              "createdAt": "2020-04-04T10:17:48Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MTE4MzI3",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T10:24:27Z",
          "updatedAt": "2020-04-06T10:24:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "You can also be active and only establish connections if a new address is advertised by the peer.",
              "createdAt": "2020-04-06T10:24:27Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MTIwNTQ3",
          "commit": {
            "abbreviatedOid": "ee74036"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T10:27:34Z",
          "updatedAt": "2020-04-06T10:27:34Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I think having \"passive\" here mixes up two things, one is the question of who will establish paths and the other one is how to use paths. These are separate points and should not be mixed together.",
              "createdAt": "2020-04-06T10:27:34Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODUwMTQw",
          "commit": {
            "abbreviatedOid": "b38be66"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo a few nits that I commented on",
          "createdAt": "2020-04-14T11:48:22Z",
          "updatedAt": "2020-04-14T11:56:37Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think that \"principally\" here is a German-ism ... I guess you mean \"in principle\". However, even this doesn't really add anything useful to the statement, IMO. Can we just remove the word \"principally\"?",
              "createdAt": "2020-04-14T11:48:22Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 29,
              "body": "s/my depend/may depend\r\nand, please: s/bandwidth provided/capacity provided\r\n",
              "createdAt": "2020-04-14T11:50:48Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 39,
              "body": "s/only if using/only using",
              "createdAt": "2020-04-14T11:54:38Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 56,
              "body": "s/advertises/advertised",
              "createdAt": "2020-04-14T11:55:56Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NjczMTY3",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good! Some typos, naming, and explanation issues, but mainly the right idea.",
          "createdAt": "2020-05-07T17:12:09Z",
          "updatedAt": "2020-05-07T17:20:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n: The connection will not use multiple paths once established, even if the chosen transport supports using multiple paths.\r\n```",
              "createdAt": "2020-05-07T17:12:09Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n: The connection will negotiate the use of multiple paths if the chosen transport supports this. It will actively bring up paths based on the multipath policy ({{multipath-objective}}) selected by the application, as limited by the Interface Instance and Provisioning Domain Instance properties (see {{prop-interface}} and {{prop-pvd}}).\r\n```",
              "createdAt": "2020-05-07T17:15:25Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\n: The connection will support the use of multiple paths if the remote endpoint requests it. The connection will not actively initiate the use of any new paths, but will accept paths initiated by the remote endpoint.\r\n```",
              "createdAt": "2020-05-07T17:16:52Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 6,
              "body": "How about \"Support for Multiple Parallel Paths\"?",
              "createdAt": "2020-05-07T17:17:27Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 51,
              "body": "Advertisement of Alternative Addresses?",
              "createdAt": "2020-05-07T17:17:54Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 75,
              "body": "Typo on Ojective -> Objective. Beyond that, I'd call this \"Multipath Policy\" or something similar. Objective doesn't seem like the right word.",
              "createdAt": "2020-05-07T17:18:34Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 89,
              "body": "Does this value make sense? It seems like it's a duplicate of Passive; why not just say Passive doesn't use the multi path policy?",
              "createdAt": "2020-05-07T17:19:30Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 92,
              "body": "Rather than unreliable, let's say \"unusable\". Unreliable could just mean it has some loss\u2014many links aren't reliable, but are good enough to use.",
              "createdAt": "2020-05-07T17:20:02Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 101,
              "body": "Again, policy rather than objective?",
              "createdAt": "2020-05-07T17:20:15Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTcwNzA3",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T11:19:58Z",
          "updatedAt": "2020-05-08T11:19:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Okay, sorry, but I must ask: how do you people do this? I can't find how to make such direct text change proposals",
              "createdAt": "2020-05-08T11:19:58Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTgyOTcy",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo the comments from @tfpauly which I all agree with.",
          "createdAt": "2020-05-08T11:47:23Z",
          "updatedAt": "2020-05-08T11:47:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODI1NDU4",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T13:51:49Z",
          "updatedAt": "2020-05-14T13:51:49Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "This had been my first idea too, but calling it policy does not really tell you whether it is the policy with regards to allowing multipath or the policy how to perform multipath. Objective makes that clear. Any better suggejstions?",
              "createdAt": "2020-05-14T13:51:49Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODM1MDM4",
          "commit": {
            "abbreviatedOid": "aa577a5"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:01:13Z",
          "updatedAt": "2020-05-14T14:01:13Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Sorry Phil, I don't understand \"objective\" in this context, if we need a word to describe the mode, we need another word. ",
              "createdAt": "2020-05-14T14:01:13Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODUwNjQ4",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:17:20Z",
          "updatedAt": "2020-05-14T14:17:20Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "This property only effects the packet scheduler, not to the path manager as above. \r\nAs a server, you may choose passive above and \"Aggregate\" or \"Interactive\" here.\r\n\r\nI am unsure whether we need it, as the difference i see between \"None\" and \"Handover\" is really small. In iOS, I would expect it turns off WiFi Assist and does hand-over once a path breaks.",
              "createdAt": "2020-05-14T14:17:20Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODU0MTQ3",
          "commit": {
            "abbreviatedOid": "386485c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:20:44Z",
          "updatedAt": "2020-05-14T14:20:45Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "This depends on whether to include \"None\" or not \u2013 if we drop \"None\", we should change it to unusable, but otherwise, I see more freedom to declare a path \"bad enough to hand over to something else\".",
              "createdAt": "2020-05-14T14:20:44Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTU2MzU1",
          "commit": {
            "abbreviatedOid": "aa577a5"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-14T16:04:11Z",
          "updatedAt": "2020-05-14T16:18:36Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I afraid I don't fully understand this. In case of MPTCP does disabled mean I will not open any new sub flows, reject all sub flows (SYNs) from the other end, or not even include the MPTCP option in the handshake of the initial connection? ",
              "createdAt": "2020-05-14T16:04:11Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 75,
              "body": "yes objective doesn't seem right. I think policy is fine here.",
              "createdAt": "2020-05-14T16:07:55Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 89,
              "body": "I would remove this and only have \"handover\"",
              "createdAt": "2020-05-14T16:09:25Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 92,
              "body": "+1 to unusable or another term. unreliable doesn't seem right",
              "createdAt": "2020-05-14T16:10:32Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 96,
              "body": "Actually you don't use multiple that _in parallel_ You always just use one but decide to switch over based on latency. I'm also not sure I understand the second sentence. Is that needed?",
              "createdAt": "2020-05-14T16:12:00Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 99,
              "body": "Not sure we need this half sentence about \"trading delay for bandwidth\". If the \"needed\" capacity is larger than what a single path can provide, there is no other chance than to use both. If you don't want that choose the \"interactive\" option instead",
              "createdAt": "2020-05-14T16:14:01Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 6,
              "body": "Or \"management of multiple parallel paths\"...?",
              "createdAt": "2020-05-14T16:16:06Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            },
            {
              "originalPosition": 15,
              "body": "Or let me put this differently: if multi path support is enabled and a MP option sent in the initial handshake, I think we only need \"active\" and \"passive\" as modes because otherwise if I reject all your SYNs why should I even include the MPTCP option in the initial handshake?",
              "createdAt": "2020-05-14T16:18:24Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MTY2MTU3",
          "commit": {
            "abbreviatedOid": "aac6917"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T10:25:41Z",
          "updatedAt": "2020-05-26T10:25:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We need Disabled here:\r\n- Disabled results in not sending the MPTCP option, \r\n- Passive results in sending the MPTCP option it but not opening additional subflows.\r\n- Active results in sending the MPTCP option and opening additional subflows",
              "createdAt": "2020-05-26T10:25:41Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MTc3NzU2",
          "commit": {
            "abbreviatedOid": "addd4e1"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T10:43:25Z",
          "updatedAt": "2020-05-26T10:43:25Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "You may, e.g., to probe/monitor the other paths latency to have a decision criteria when to switch. ",
              "createdAt": "2020-05-26T10:43:25Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MjMyMTEw",
          "commit": {
            "abbreviatedOid": "addd4e1"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T12:07:29Z",
          "updatedAt": "2020-05-26T12:07:29Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Still not sure here because the decision to open a new subflows really depends on the path/interface. Not sure you even want to say: whenever you see a new IP address, immediately open a new subflow. So I think you only want disable and enable here and leave the decision to open new subflows on the interface level.",
              "createdAt": "2020-05-26T12:07:29Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5MDQwMDI5",
          "commit": {
            "abbreviatedOid": "addd4e1"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T09:59:24Z",
          "updatedAt": "2020-05-27T09:59:25Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I agree that we should have some control on the Interface level, but relying on this also for the active/passive path establishment looks to over-complicate things for me.\r\nThis Property just controls whether the local side accepts additional incoming sub-flows or whether it also actively tries to establish them. I suspect that this one most applications can easily set:\r\n- Passive in the Server-Case\r\n- Active or Disabled in the Client case\r\nThe per-interface one is a major hassle and I believe most programmer really want the implementation to take care here.\r\n\r\nWhat we should discuss is whether we want to make \"Passive\" also the default for connections created through initiate and rendezvous\u2026",
              "createdAt": "2020-05-27T09:59:24Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDU0ODk3",
          "commit": {
            "abbreviatedOid": "addd4e1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:23:18Z",
          "updatedAt": "2020-05-29T15:23:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDY5Njky",
          "commit": {
            "abbreviatedOid": "addd4e1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T15:41:38Z",
          "updatedAt": "2020-05-29T15:41:38Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\n: The connection should attempt to use multiple paths in parallel in order to minimize loss and delay. The actual strategy is implementation specific.\r\n```",
              "createdAt": "2020-05-29T15:41:38Z",
              "updatedAt": "2020-06-15T12:53:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 513,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNDgyODMw",
      "title": "API receive semantics and DSCP text fixes; closes minor issues #454 #450 #494",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/513",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#454: added a statement about data arriving before Receive is issued;\r\n#450: removed the confusing sentence;\r\n#494: carried out replacements suggested by @gorryfair",
      "createdAt": "2020-03-04T11:03:31Z",
      "updatedAt": "2020-03-09T08:04:34Z",
      "closedAt": "2020-03-09T08:04:29Z",
      "mergedAt": "2020-03-09T08:04:28Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Njg3NjAw",
          "commit": {
            "abbreviatedOid": "524e708"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Seems good to me.",
          "createdAt": "2020-03-04T11:05:20Z",
          "updatedAt": "2020-03-04T11:05:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODgzOTU2",
          "commit": {
            "abbreviatedOid": "524e708"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T15:37:41Z",
          "updatedAt": "2020-03-04T15:37:41Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ea1bb1f201270dda00aa75f40518fadc1e7f56e5",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "Minor-issues-#454,-#450,-#494",
      "headRefOid": "524e7088e66bf74516ab2402293cc8955337c2e3",
      "mergeCommit": {
        "oid": "2de3c9620883db32e60ea4e969d8964c59f5ff3c"
      }
    },
    {
      "number": 514,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNTk2NzE2",
      "title": "Addressing some of Kyle Rose's comments",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/514",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Here's the list of comments that this resolves, along with answers on how I did it:\r\n\r\n\r\n2. Terminology and Notation\r\n\r\n * \"The method for\r\n   dispatching and handling Events is an implementation detail, with the\r\n   caveat that the interface for receiving Messages must require the\r\n   application to invoke the Connection.Receive() Action once per\r\n   Message to be received (see Section 8).\"\r\n\r\nThis isn't true if ReceivedPartial events are triggered, right? Also, it's not really clear that any of this discussion belongs in a section titled \"Terminology and Notation\". This issue is alluded to later in the doc, and probably mostly belongs in the implementation doc.\r\n\r\nMW: Agreed, removed this sentence.\r\n\r\n\r\n3. Interface Design Principles\r\n\r\n * What does \"long-term caching of cryptographic identities\" mean? The implication seems to be that credentials and transport security parameters can be configured once and used repeatedly. I'm not sure time interval (\"long-term\") is the right modifier here, and the word \"caching\" might be misunderstood as it means something subtly different in the realm of computer hardware and software than the dictionary definition implies. Maybe something like:\r\n\r\n   \"...and for configuration of cryptographic identities and transport security parameters persistent across multiple Connections\"\r\n\r\nMW: replaced as you suggest, because I believe that was the intended meaning anyway.\r\n\r\n\r\n * \"An application primarily interacts with this interface...\" This seems awkward. An interface is the means by which an application interacts with the underlying transports.\r\n\r\nMW: replaced \"interface\" with \"API\".\r\n\r\n\r\n4.3. Scope of the Interface Definition\r\n\r\n * \"Implementations of this interface SHOULD implement each Selection\r\n      Property, Connection Property, and Message Context Property\r\n      specified in this document, exclusive of appendices.  Each\r\n      interface SHOULD be implemented even when this will always result\r\n      in no operation, e.g. there is no action when the API specifies a\r\n      Property that is not available in a transport protocol implemented\r\n      on a specific platform.\"\r\n\r\nThis seems like it implies that a property that is unavailable should silently fail to be activated, which conflicts with the \"Require\" preference referenced later. There may be some way to reword this to be clear that it's referring to implementing all of the properties in the API so that compile-time or runtime errors don't spuriously occur when some symbol hasn't been defined.\r\n\r\nMW: this wasn't about spuriously occurring compile-time or runtime errors but about implementing fall-backs because the API contract generally is only \"best effort\" except for things that will work over TCP. I inserted some more text here to clarify this better with examples.\r\n\r\n\r\nAlso: why \"exclusive of appendices\"?\r\n\r\nMW: Good catch! That's a historical thing; I removed it. That appendix doesn't even exist anymore.\r\n\r\n\r\n5.2. Specifying Transport Properties\r\n\r\n * \"As preference typed selection properties...\" I can't parse this.\r\n\r\nMW: it seems that this sentence has disappeared by now. There was another occurrence of \"Preference-typed\", which I changed into \"of type 'Preference' \".\r\n\r\n\r\n6.4. Connection Groups\r\n\r\n * \"An ideal transport system\" for whom? The capacity partitioning recommended here seems purely subjective. I'd just remove it.\r\n\r\nMW: I replaced \"An ideal transport system implementation would\" with \"A transport system implementation should, if possible,\". I believe that recommending a partitioning is necessary so that an application knows what to expect if things really work out. The particular described partitioning method is as good as any other, because, if it is implemented, an application can tune things as it wants anyway using the priority values. Without at least some sort of guidance on partitioning, the priorities become quite meaningless. With it, an application can at least say \"this is how I'd like to divide the capacity, if at all possible\".\r\n\r\n\r\n7.4.9. Singular Transmission\r\n\r\n * Might be worth pointing out there's no guarantee here, either, considering resegmenting TCP middleboxes.\r\n\r\nMW: done (by adding \", if possible\" to the first sentence).\r\n\r\n\r\n9. Message Contexts\r\n\r\n * \"To get or set Message Properties, the optional scope parameter is\r\n   left empty, for framing meta-data, the framer is passed.\" I can't parse this.\r\n\r\nMW: It seems that this sentence has disappeared, auto-resolving this problem :)\r\n\r\n\r\n11.1.3. Priority (Connection)\r\n\r\n * I'm not sure what \"relative inverse priority\" means. Is P1 higher priority than P5, and therefore lower inverse priority than P5? Or the other way around?\r\n\r\nMW: lower means higher priority. I added a bracket to clarify this.\r\n\r\n\r\n11.2. Soft Errors\r\n\r\n * Should the SoftError Event carry some information about e.g. the ICMP message received?\r\n\r\nMW: yes. The text said \"This event informs the application about the receipt of an ICMP error message related to the Connection\"  ... and I replaced \"receipt\" with \"receipt and content\".\r\n",
      "createdAt": "2020-03-04T14:34:54Z",
      "updatedAt": "2020-09-11T16:34:47Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ea1bb1f201270dda00aa75f40518fadc1e7f56e5",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "Some-comments-from-Kyle-Rose-review",
      "headRefOid": "e99d22b48479559738245624245a54bf0860e61a",
      "closedAt": "2020-03-09T12:46:41Z",
      "mergedAt": "2020-03-09T12:46:41Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "4520a0a31bcf30744b7b7ec4cc68759226916ccc"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging this one to get new drafts out; let's continue the discussion at or after 107.",
          "createdAt": "2020-03-09T12:46:36Z",
          "updatedAt": "2020-03-09T12:46:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzgzOTE0",
          "commit": {
            "abbreviatedOid": "e99d22b"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T17:49:35Z",
          "updatedAt": "2020-03-05T17:54:25Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Is it the case that all properties have such an escape clause if they can't be satisfied? The way this is worded, a developer might rely on a property that can't be satisfied on a particular platform or with a particular protocol, but which then fails silently. If it's made explicit that any requested property might fail silently, that issue is resolved, but the end result might be perverse. (E.g., on a hypothetical platform lacking support for TCP or QUIC, ordering may simply be unsatisfiable; is preserve-order then considered unimplemented, or implemented but ignored? What implication does that have for \"require\"?)",
              "createdAt": "2020-03-05T17:49:36Z",
              "updatedAt": "2020-03-05T17:54:25Z"
            },
            {
              "originalPosition": 100,
              "body": "So, it's okay for this to fail? Or for the singular send to succeed, but for a middlebox to re-segment the data? The receiver therefore cannot rely on this property even if it knows a priori that the sender employed it.\r\n\r\nAre we being clear enough that negotiated properties do not comprise a contract between sender and receiver?",
              "createdAt": "2020-03-05T17:54:20Z",
              "updatedAt": "2020-03-05T17:54:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTY4MjU3",
          "commit": {
            "abbreviatedOid": "e99d22b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T07:59:08Z",
          "updatedAt": "2020-03-09T07:59:09Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Everything is designed to be able to operate over TCP in the worst case - ensuring this, while not losing functionality, was the goal of the \"minset\" draft. So yes, all properties have an escape clause like this, or at least they should. Perverse results such as the one you describe shouldn't happen because one would fall back to ordered, not unordered. Picking out the ordering example: for message ordering, section 7.5.3, the text makes it clear that, if the application sets this to \"true\", it would only get ordered delivery. If it sets it to \"false\", according to the text, it *may* get its messages delivered out of order.\r\n\r\nWhat implication does that have for \"require\": the idea is for \"prefer\" to work like we're discussing here, but for \"require\" to fail.",
              "createdAt": "2020-03-09T07:59:08Z",
              "updatedAt": "2020-03-09T07:59:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTY4OTM3",
          "commit": {
            "abbreviatedOid": "e99d22b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T08:00:51Z",
          "updatedAt": "2020-03-09T08:00:51Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Yes, it's ok for this to fail. Regarding the receiver and negotation: this is all one-sided!  There isn't any negotiation here. A TAPS system can talk to a TAPS system on the other side, but it can also talk to a \"normal\" TCP peer, for instance.",
              "createdAt": "2020-03-09T08:00:51Z",
              "updatedAt": "2020-03-09T08:00:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 527,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk3NjI3NDQz",
      "title": "Closes #515.  + addresses a few more of the easy things from Kyle's review.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/527",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "... such as: using CamlCase instead of dashes for property names.\r\nAlso: fixes consistency problem of apostrophs / quotation marks  (` vs `` vs \" )",
      "createdAt": "2020-04-02T14:49:14Z",
      "updatedAt": "2020-04-07T09:48:19Z",
      "closedAt": "2020-04-07T09:48:13Z",
      "mergedAt": "2020-04-07T09:48:13Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll just merge this now, to avoid conflicts with a new PR I'm writing (I'd like to continue using camlCase for property names). Moving to camlCase has been discussed on the list, and the other things here - ensuring uniform appearance of quotation marks, and replacing \"-1\" with special values - seem quite non-controversial.",
          "createdAt": "2020-04-07T09:48:04Z",
          "updatedAt": "2020-04-07T09:48:04Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "13c1971a80e152a43fd1896b02c9c435e3d3570d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-easy-fixes",
      "headRefOid": "e778eabe5d7b733f5c22e3a924891f13eff3b0c8",
      "mergeCommit": {
        "oid": "a9c835fe8d6ed64e6456bd3ab52740d7f70b70cc"
      }
    },
    {
      "number": 529,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5NzQyNzM5",
      "title": "No reference in abstract",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/529",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "You cannot have references in the abstract. Initially I only wanted to remove that reference but then I also took the opportunity to rewrite the abstract a bit to not only talk about the architecture but an TAPS _system_ and the interface that this guide helps with its implementation.",
      "createdAt": "2020-04-06T15:55:29Z",
      "updatedAt": "2020-09-11T16:34:50Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8796fc3ec79f72f815967e98de91acb15de88825",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-1",
      "headRefOid": "dabc791629fd837e6d04066ff37e0d1a0471e952",
      "closedAt": "2020-04-06T17:16:19Z",
      "mergedAt": "2020-04-06T17:16:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "99190d451f67158f993029b2de1217c03b37f9d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDA1MjYx",
          "commit": {
            "abbreviatedOid": "dabc791"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM  (I fixed a tiny nit directly with a commit)",
          "createdAt": "2020-04-06T16:12:47Z",
          "updatedAt": "2020-04-06T16:12:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDM4MjEx",
          "commit": {
            "abbreviatedOid": "dabc791"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks looks good.",
          "createdAt": "2020-04-06T16:52:45Z",
          "updatedAt": "2020-04-06T16:52:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDU2Nzgx",
          "commit": {
            "abbreviatedOid": "dabc791"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T17:16:13Z",
          "updatedAt": "2020-04-06T17:16:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 530,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5NzU2MTcw",
      "title": "Introduce the term Message early on",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/530",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-06T16:18:27Z",
      "updatedAt": "2020-09-11T16:32:17Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8796fc3ec79f72f815967e98de91acb15de88825",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-impl-message",
      "headRefOid": "bb9d3e97b7203c6e92cdb64d03769d54a9bc9fa7",
      "closedAt": "2020-04-06T17:16:42Z",
      "mergedAt": "2020-04-06T17:16:42Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7cfb3de561229e0c9711268f86311a4b81855604"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDU3MTAy",
          "commit": {
            "abbreviatedOid": "bb9d3e9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T17:16:38Z",
          "updatedAt": "2020-04-06T17:16:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 532,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5NzcwMDk3",
      "title": "Add reference to RFC8445 on first occurrence of ICE",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/532",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "and spell out ICE.",
      "createdAt": "2020-04-06T16:44:56Z",
      "updatedAt": "2020-09-11T16:32:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8796fc3ec79f72f815967e98de91acb15de88825",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-impl-ice",
      "headRefOid": "c47455e9760faf44a4fe7c188d7f24b4cb25efb0",
      "closedAt": "2020-04-06T17:14:54Z",
      "mergedAt": "2020-04-06T17:14:54Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "789e7168a7f4a68a661ac3761486bf28dbd448bf"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also updated a later reference and added references for STUN and TURN in this same PR now.",
          "createdAt": "2020-04-06T16:54:54Z",
          "updatedAt": "2020-04-06T16:54:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDU0NzY0",
          "commit": {
            "abbreviatedOid": "321237d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T17:13:38Z",
          "updatedAt": "2020-04-06T17:13:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nIf NAT traversal is required, the process of gathering Local Endpoints becomes broadly equivalent to the ICE candidate gathering phase (see Section 5.1.1. of {{RFC8445}}).  The endpoint determines its server reflexive Local Endpoints (i.e., the translated address of a local, on the other side of a NAT, e.g via a STUN sever {{?RFC5389}}) and relayed locals (e.g., via a TURN server {{?RFC5766}} or other relay), for each interface and network protocol.  These are added to the set of candidate Local Endpoints for this connection.\r\n```",
              "createdAt": "2020-04-06T17:13:38Z",
              "updatedAt": "2020-04-06T17:14:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 534,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5NzgzODc5",
      "title": "RFC references for mDNS and DNS-SD",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/534",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-06T17:11:09Z",
      "updatedAt": "2020-09-11T16:32:18Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6ac3b8b41c0764c6c858b315da1f99d3b8a6cd30",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-impl-dns",
      "headRefOid": "3916ac1fe80d451b408726603e15160b431b26ff",
      "closedAt": "2020-04-06T17:12:32Z",
      "mergedAt": "2020-04-06T17:12:32Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "11b67870853aeee8270f01a4f89c803df3a763bc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDUzNzkx",
          "commit": {
            "abbreviatedOid": "3916ac1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T17:12:21Z",
          "updatedAt": "2020-04-06T17:12:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 535,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5ODAyMzE1",
      "title": "Adjust level of branching related subsections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/535",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is just an minor oversight that needs fixing but I would like someone to double-check before merged...",
      "createdAt": "2020-04-06T17:44:40Z",
      "updatedAt": "2020-09-11T16:32:21Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7cfb3de561229e0c9711268f86311a4b81855604",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-impl-branch",
      "headRefOid": "a5091598134f3ea933a346991dea002c1627aa28",
      "closedAt": "2020-04-06T17:51:18Z",
      "mergedAt": "2020-04-06T17:51:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a3d62013e24957920813b78c4a354f071754d5a0"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think that this is more correct also. Thanks!",
          "createdAt": "2020-04-06T17:51:11Z",
          "updatedAt": "2020-04-06T17:51:11Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 541,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMTc4MjU3",
      "title": "Added a selection property for a special communication pattern",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/541",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": ".. that gets in the way of using streams when cloning.\r\nCloses #441.",
      "createdAt": "2020-04-07T10:25:31Z",
      "updatedAt": "2020-07-03T04:43:41Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a9c835fe8d6ed64e6456bd3ab52740d7f70b70cc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "more-on-cloning",
      "headRefOid": "6a6c1e36dbfb7fb99a734f67e6ad9358e06e4379",
      "closedAt": "2020-06-19T09:10:14Z",
      "mergedAt": "2020-06-19T09:10:14Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "0cba09fb504a791a060a4315bfe37e1fcd94cfbf"
      },
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How does this interact with `Rendezvous()`?",
          "createdAt": "2020-04-17T14:29:41Z",
          "updatedAt": "2020-04-17T14:29:41Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - this now states that it is irrelevant for Rendezvous(), and explicitly mentions the Initiate() and Listen() calls when talking about actively and passively opening a Connection.\r\n\r\nWhy is it irrelevant?\r\n\r\nRemember, the problem is that you actively open a Connection that could be mapped to a stream, in which case an active Open doesn't do anything on the wire - and then, right away, you want to read. Then the peer never heard from you, you haven't even tried sending anything to it.\r\n\r\nEnabling this property will allow the TAPS system to carry out such a Connection = stream mapping. When calling rendezvous(), however, just using a stream is out of the question - you need signaling, and chances are that you're going to actively send stuff in any case. In other words, I don't think there's a mapping that would work with rendezvous() that enabling this property would allow, and hence the property is irrelevant for rendezvous().",
          "createdAt": "2020-06-03T14:30:48Z",
          "updatedAt": "2020-06-03T14:30:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging this now: I think I have addressed the comment by @csperkins. We can always fix things later again if we must - but for now, this closes #441, and it also relates to #508, which gates #507.... so it's probably better to move forward at this point.",
          "createdAt": "2020-06-19T09:10:08Z",
          "updatedAt": "2020-06-19T09:10:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTY4NzU3",
          "commit": {
            "abbreviatedOid": "77c3066"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T12:10:56Z",
          "updatedAt": "2020-04-16T12:10:56Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I get the problem for read-after-active-open, but what is the problem with passive open and immediately writing \u2013 this is fairly common in TCP based protocols and you can easily put the write in the connection ready. ",
              "createdAt": "2020-04-16T12:10:56Z",
              "updatedAt": "2020-06-03T14:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTgwODk4",
          "commit": {
            "abbreviatedOid": "77c3066"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T12:27:47Z",
          "updatedAt": "2020-04-16T12:27:47Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "It's the same thing with multi-streaming: a stream only comes into being when the first message is sent on it. So, \"passive open and immediately writing\" doesn't map onto anything with streams - there is no such thing as a stream becoming available without data arriving on it.",
              "createdAt": "2020-04-16T12:27:47Z",
              "updatedAt": "2020-06-03T14:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MzgwNDA2",
          "commit": {
            "abbreviatedOid": "77c3066"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me, but changing the name might help to get the pattern clearer",
          "createdAt": "2020-04-17T11:38:30Z",
          "updatedAt": "2020-04-17T11:40:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n### Initiating side is not the first to write {#active-read-before-send}\r\n```",
              "createdAt": "2020-04-17T11:38:30Z",
              "updatedAt": "2020-06-03T14:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTA2MDEz",
          "commit": {
            "abbreviatedOid": "7d3d6db"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T14:30:59Z",
          "updatedAt": "2020-04-17T14:30:59Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I wonder if this should be `Type: Enumeration`, with values `InitiatorSendsFirst` (the default) and `ListenerSendsFirst`?",
              "createdAt": "2020-04-17T14:30:59Z",
              "updatedAt": "2020-06-03T14:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjMxMzc0",
          "commit": {
            "abbreviatedOid": "7d3d6db"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-04-17T17:13:28Z",
          "updatedAt": "2020-04-17T17:13:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDUyMzcw",
          "commit": {
            "abbreviatedOid": "7d3d6db"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:20:08Z",
          "updatedAt": "2020-05-29T15:20:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTk5MzM5",
          "commit": {
            "abbreviatedOid": "7d3d6db"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T14:16:39Z",
          "updatedAt": "2020-06-03T14:16:39Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Why make it so limiting? Preference allows for values such as Prefer, Avoid, Require, ...",
              "createdAt": "2020-06-03T14:16:39Z",
              "updatedAt": "2020-06-03T14:24:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTQ1NzMy",
          "commit": {
            "abbreviatedOid": "6a6c1e3"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:00:09Z",
          "updatedAt": "2020-06-19T15:00:10Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "How does a preference work here? If the application protocol requires the listener to send first, then it need to do this or fail. ",
              "createdAt": "2020-06-19T15:00:10Z",
              "updatedAt": "2020-06-19T15:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUzMzE4",
          "commit": {
            "abbreviatedOid": "6a6c1e3"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:10:38Z",
          "updatedAt": "2020-06-19T15:10:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "\"irrelevant\" isn't right here - maybe \"is ignored\"?",
              "createdAt": "2020-06-19T15:10:38Z",
              "updatedAt": "2020-06-19T15:10:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTQyMzE5",
          "commit": {
            "abbreviatedOid": "6a6c1e3"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T04:43:40Z",
          "updatedAt": "2020-07-03T04:43:41Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "ACK, fixed with a commit to the master",
              "createdAt": "2020-07-03T04:43:40Z",
              "updatedAt": "2020-07-03T04:43:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 544,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMjMwODUz",
      "title": "Editorial edits on fast open",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/544",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2020-04-07T12:16:42Z",
      "updatedAt": "2020-06-03T11:24:00Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "03c867641e37e563268c9e04ab195bf93105dc61",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-2",
      "headRefOid": "56da160c3989c57c806a40c4aa2656bd98ebfe37",
      "closedAt": "2020-06-03T11:23:56Z",
      "mergedAt": "2020-06-03T11:23:56Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "2d39515fbc533f28b3a46ba88d584f703749e115"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would further recommend to move this section into 4 somewhere as this section is more about connection establishment than sending messages",
          "createdAt": "2020-04-07T12:23:54Z",
          "updatedAt": "2020-04-07T12:23:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzA5OTg1",
          "commit": {
            "abbreviatedOid": "adefa45"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-13T17:46:43Z",
          "updatedAt": "2020-04-13T17:48:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nIf the application has 0-RTT data to send in any protocol handshakes, it needs to provide this data before any handshake is initiated. When racing, this means that the data should be provided before the process of connection establishment has begun. If the application wants to send 0-RTT data, it indicates this to the implementation by setting the Idempotent flag in the message context to true and providing initial data to send at the connection initiation. In general, 0-RTT data may be replayed (for example, if a TCP SYN contains data, and the SYN is retransmitted, the data will be retransmitted as well but may be considered as a new connection instead of a retransmission). Also, when racing connections, different leaf nodes may send the same data independently. If data is truly idempotent, this should be permissible.\r\n```",
              "createdAt": "2020-04-13T17:46:44Z",
              "updatedAt": "2020-05-29T15:22:02Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n0-RTT handshakes often rely on previous state, such as TCP Fast Open cookies, previously established TLS tickets, or out-of-band distributed pre-shared keys (PSKs). Implementations should be aware of security concerns around using these tokens across multiple addresses or paths when racing. In the case of TLS, any given ticket or PSK should only be used on one leaf node, since servers will likely reject duplicate tickets in order to prevent replays (see section-8.1 {{?RFC8446}}). If implementations have multiple tickets available from a previous connection, each leaf node attempt can use a different ticket. In effect, each leaf node will send the same early application data, yet encoded (encrypted) differently on the wire.\r\n```",
              "createdAt": "2020-04-13T17:48:11Z",
              "updatedAt": "2020-05-29T15:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzExMDYz",
          "commit": {
            "abbreviatedOid": "f95cf32"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-04-14T08:29:23Z",
          "updatedAt": "2020-04-14T08:29:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 547,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMzQ3ODE0",
      "title": "Add reference to draft-ietf-tcpm-2140bis",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/547",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "",
      "createdAt": "2020-04-07T15:41:42Z",
      "updatedAt": "2020-06-03T11:19:31Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a9c835fe8d6ed64e6456bd3ab52740d7f70b70cc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-3",
      "headRefOid": "f25f49fec20cba45657dcc56ff4f267dac5e1a45",
      "closedAt": "2020-06-03T11:19:26Z",
      "mergedAt": "2020-06-03T11:19:26Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "87ed324539b341a3e28564bb200d7f90ad9bf8ce"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MjUwODEy",
          "commit": {
            "abbreviatedOid": "e9612d4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like this of course!  :-)",
          "createdAt": "2020-04-07T15:47:47Z",
          "updatedAt": "2020-04-07T15:47:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzA4NTA3",
          "commit": {
            "abbreviatedOid": "e9612d4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-04-13T17:44:29Z",
          "updatedAt": "2020-04-13T17:44:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This says it is \"one example\"; what's it an example of? The text above doesn't discuss sharing the cached information with peers. If anything, this is a new suggestion that could start \"In addition, cached information may be used to share information with peers...\"",
              "createdAt": "2020-04-13T17:44:29Z",
              "updatedAt": "2020-06-03T11:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzAwNTM4",
          "commit": {
            "abbreviatedOid": "e9612d4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-14T08:15:23Z",
          "updatedAt": "2020-04-14T08:15:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@tfpauly, I don't understand what you say about \"peers\" here. Obviously, everything here is about caching things locally, but per peer, right?\r\n\r\nRegarding the reference, I agree, \"As one example,\" should simply be removed.",
              "createdAt": "2020-04-14T08:15:24Z",
              "updatedAt": "2020-06-03T11:18:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 550,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwNjQ2NDUx",
      "title": "Text around \"PRIMITIVENAME\" in implementation draft (issue #549)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/550",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #549.",
      "createdAt": "2020-04-08T06:03:26Z",
      "updatedAt": "2020-09-11T16:32:22Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a9c835fe8d6ed64e6456bd3ab52740d7f70b70cc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-issue549",
      "headRefOid": "be7013a47e130135aed2046f68bc89adce103413",
      "closedAt": "2020-04-08T23:04:52Z",
      "mergedAt": "2020-04-08T23:04:52Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6480c39ee77f7d64e02209fde4afaceb84aeb68e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzg5MzY3",
          "commit": {
            "abbreviatedOid": "be7013a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-08T23:04:42Z",
          "updatedAt": "2020-04-08T23:04:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 554,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwODI3NDA3",
      "title": "preamble text in security considerations section",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/554",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Mainly adding references to arch and API docs...",
      "createdAt": "2020-04-08T12:47:17Z",
      "updatedAt": "2020-09-11T16:32:23Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a9c835fe8d6ed64e6456bd3ab52740d7f70b70cc",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-impl-sec",
      "headRefOid": "3ea1661282ec678a5315487ed5e0426d8789eb21",
      "closedAt": "2020-04-08T23:03:55Z",
      "mergedAt": "2020-04-08T23:03:55Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "b94f60c493df5186c12db12552a5147c871c54bd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzg5MDM3",
          "commit": {
            "abbreviatedOid": "3ea1661"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-08T23:03:49Z",
          "updatedAt": "2020-04-08T23:03:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTQ1MjYx",
          "commit": {
            "abbreviatedOid": "3ea1661"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-09T07:18:20Z",
          "updatedAt": "2020-04-09T07:18:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "/This document provides/ after describing something,  is often trouble to work which /this/ is. Is it the former or the ID itself? - I think it's the former, can we replace by \", which provides\" or something?",
              "createdAt": "2020-04-09T07:18:20Z",
              "updatedAt": "2020-04-09T07:18:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 555,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMTExMzUz",
      "title": "Partial send: remove sentence about re-using the same object",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/555",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "... as suggested by @tfpauly.\r\nCloses #448.",
      "createdAt": "2020-04-14T10:51:53Z",
      "updatedAt": "2020-04-14T11:58:36Z",
      "closedAt": "2020-04-14T11:58:31Z",
      "mergedAt": "2020-04-14T11:58:31Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODQ4NDU1",
          "commit": {
            "abbreviatedOid": "e88b4d7"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-14T11:45:43Z",
          "updatedAt": "2020-04-14T11:45:43Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6480c39ee77f7d64e02209fde4afaceb84aeb68e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-partialsend-nit",
      "headRefOid": "e88b4d7e38583377e10fd38bb8363e03cd861079",
      "mergeCommit": {
        "oid": "b500addcab54b561b9cf7320f863629e29723269"
      }
    },
    {
      "number": 556,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMTE1MzI2",
      "title": "API: state \"Ephemeral port used when no Local Endpoint specified\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/556",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #539.",
      "createdAt": "2020-04-14T11:01:06Z",
      "updatedAt": "2020-04-16T10:42:30Z",
      "closedAt": "2020-04-16T10:42:21Z",
      "mergedAt": "2020-04-16T10:42:21Z",
      "mergedBy": "mwelzl",
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done.",
          "createdAt": "2020-04-14T12:22:27Z",
          "updatedAt": "2020-04-14T12:22:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODUwMTUw",
          "commit": {
            "abbreviatedOid": "32746ec"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This change is fine. You also need to adapt the implementation doc to remove the \"or\" part: \"either use an ephemeral port or generate an error.\"",
          "createdAt": "2020-04-14T11:48:23Z",
          "updatedAt": "2020-04-14T11:48:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NDQwMDgz",
          "commit": {
            "abbreviatedOid": "738fa72"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This seems like what was agreed.",
          "createdAt": "2020-04-16T09:08:03Z",
          "updatedAt": "2020-04-16T09:08:03Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6480c39ee77f7d64e02209fde4afaceb84aeb68e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-ephemeral",
      "headRefOid": "738fa725650c1d4889c629f0ebcbf754c4245499",
      "mergeCommit": {
        "oid": "f972ca06dd168a3c4f8ca232c22f5d5c39af970e"
      }
    },
    {
      "number": 557,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMTQ3MDU5",
      "title": "Define a new type to use when selection properties are queried",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/557",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #528.\r\nI chose boolean, because, when querying, it only matters whether a Selection Property was chosen or not (I believe).",
      "createdAt": "2020-04-14T12:13:11Z",
      "updatedAt": "2020-09-11T16:32:30Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b500addcab54b561b9cf7320f863629e29723269",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-querying-transport-properties",
      "headRefOid": "553a725330676420392495e819964d8d60f0daa4",
      "closedAt": "2020-04-17T17:07:57Z",
      "mergedAt": "2020-04-17T17:07:57Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "e36526d49902210d4344fee87adc45528d9ef4ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Mzc3Njc0",
          "commit": {
            "abbreviatedOid": "bb9ee01"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I really like this change (I remember writing similar text earlier that got removed during edits).\r\n\r\nPlease also add a hint about this \"type mutation\" around line 532.",
          "createdAt": "2020-04-17T11:33:22Z",
          "updatedAt": "2020-04-17T11:33:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MzkxMzAy",
          "commit": {
            "abbreviatedOid": "553a725"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2020-04-17T11:58:19Z",
          "updatedAt": "2020-04-17T11:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 558,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMzMzNDIz",
      "title": "Clarifications about per-connection vs per-message defaults",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/558",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #520. I inserted the text that I quoted in this issue, with a minor tweak.",
      "createdAt": "2020-04-14T18:02:22Z",
      "updatedAt": "2020-04-17T09:27:29Z",
      "closedAt": "2020-04-17T09:27:24Z",
      "mergedAt": "2020-04-17T09:27:23Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjEwMjM1",
          "commit": {
            "abbreviatedOid": "b639d90"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-14T18:59:16Z",
          "updatedAt": "2020-04-14T18:59:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzE3ODI2",
          "commit": {
            "abbreviatedOid": "b639d90"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The suggested text is not fully consistent with the specification of the Reliable Data Transfer message property.",
          "createdAt": "2020-04-14T21:43:52Z",
          "updatedAt": "2020-04-14T21:45:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Reliable Data Transfer (Message) is a Boolean so the 'Prefer' does not make sense. Also in the description of the property is says \r\n\r\n>  Changing the Reliable Data Transfer property on Messages is only possible for Connections that were established with the Selection Property Configure Per-Message Reliability enabled. When this is not the case, changing it will generate an error.\r\n\r\nSo maybe the text about the error should also be aligned.",
              "createdAt": "2020-04-14T21:43:53Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNDgzMTQ4",
          "commit": {
            "abbreviatedOid": "b639d90"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-15T06:19:05Z",
          "updatedAt": "2020-04-15T06:19:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good catch, thanks!  I fixed the \"type should be Boolean\" problem, and regarding the error, I resorted to repeating the statement that we already have at the end of this paragraph (\"Note that...\").",
              "createdAt": "2020-04-15T06:19:05Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNzMzMjM4",
          "commit": {
            "abbreviatedOid": "bea5b80"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-15T12:39:56Z",
          "updatedAt": "2020-04-15T12:39:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks! Reading it again I am wondering if is is not better to swap the example though? Setting the connection property to required and the per message property to false? I think it will read better.",
              "createdAt": "2020-04-15T12:39:56Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDQ0MzY4",
          "commit": {
            "abbreviatedOid": "a96b760"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-15T18:50:06Z",
          "updatedAt": "2020-04-15T18:50:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done - better now?",
              "createdAt": "2020-04-15T18:50:07Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjAwMDQ4",
          "commit": {
            "abbreviatedOid": "9122b54"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T12:51:58Z",
          "updatedAt": "2020-04-16T12:51:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Suggested change: cause --> allow\r\nAlso I think the part about the error can actually be removed. I think the error should rather come if the Per-Message Reliability property is not set to enabled. At least this is what the description later in the text says.",
              "createdAt": "2020-04-16T12:51:58Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjA0MDMz",
          "commit": {
            "abbreviatedOid": "9122b54"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T12:56:56Z",
          "updatedAt": "2020-04-16T12:56:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "At least for me, the last sentence would need to be more like: \r\n\"If the underlying protocol can not support a required per-Message behavior, this Message Property choice will yield an error.\" - since prefer would not yield an error.",
              "createdAt": "2020-04-16T12:56:56Z",
              "updatedAt": "2020-04-16T15:49:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzcwNDUy",
          "commit": {
            "abbreviatedOid": "c2f5064"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T15:50:51Z",
          "updatedAt": "2020-04-16T15:50:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@abrunstrom done; I did remove the part about the error as you suggested, so I think that also addresses @gorryfair's suggestion in some sense (he suggested to rephrase the sentence, but I removed it now  :)  )",
              "createdAt": "2020-04-16T15:50:51Z",
              "updatedAt": "2020-04-16T15:50:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0ODc3MDk5",
          "commit": {
            "abbreviatedOid": "c2f5064"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! No more comments now :)",
          "createdAt": "2020-04-16T18:04:41Z",
          "updatedAt": "2020-04-16T18:04:41Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b500addcab54b561b9cf7320f863629e29723269",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-connection-vs-msg-defaults",
      "headRefOid": "c2f506403303a163573c3dcae86edc6ef174b5e6",
      "mergeCommit": {
        "oid": "0e90c170b9d7170d461277d6715c123c75468974"
      }
    },
    {
      "number": 559,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNzA5MjQx",
      "title": "Referencing RFC 7231 and quoting its idempotency definition",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/559",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #522.",
      "createdAt": "2020-04-15T11:43:43Z",
      "updatedAt": "2020-04-16T08:17:55Z",
      "closedAt": "2020-04-16T08:17:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b500addcab54b561b9cf7320f863629e29723269",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-define-idempotency",
      "headRefOid": "0474bc4b228f8247229237131181ae38964f9724",
      "mergeCommit": null
    },
    {
      "number": 560,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0MDMwMTU3",
      "title": "Architecture NiT: /assumes/",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/560",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "Address #518",
      "createdAt": "2020-04-15T23:00:14Z",
      "updatedAt": "2020-09-11T16:32:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fd23a3181b97b34c73d98240081fe092155361ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/nit-assumes",
      "headRefOid": "d12a680d639e1031a2d2f395e787654fbe739ad7",
      "closedAt": "2020-04-17T15:52:03Z",
      "mergedAt": "2020-04-17T15:52:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "3f31936f9c78d490fb84cd24c775cb12cc287141"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzczMjQz",
          "commit": {
            "abbreviatedOid": "d12a680"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-16T07:40:32Z",
          "updatedAt": "2020-04-16T07:40:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTM4NDEw",
          "commit": {
            "abbreviatedOid": "d12a680"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Exactly what I expected to see!",
          "createdAt": "2020-04-16T11:24:17Z",
          "updatedAt": "2020-04-16T11:24:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 561,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0MjEyOTQ5",
      "title": "Replace \"idempotent\" with \"safely replayable\" everywhere",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/561",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Closes #522.\r\nThis replaces a previous PR for the same issue, which I deleted: in this PR, I just added the definition of idempotency from RFC 7231, but this isn't good enough. We can't guarantee that these Messages would only *consecutively* arrive as duplicates, so these should be called \"safely replayable\" instead. See the discussion in #522.",
      "createdAt": "2020-04-16T08:55:15Z",
      "updatedAt": "2020-09-11T16:32:25Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fd23a3181b97b34c73d98240081fe092155361ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-add-safely-replayable",
      "headRefOid": "f151b98750846a7064a0f0d235393d080dd48ac3",
      "closedAt": "2020-04-17T17:05:15Z",
      "mergedAt": "2020-04-17T17:05:15Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "bcf80963f6700232c8d1b8430dbeede3db68cbff"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I don't understand the point here. Why is it important that messages arrive \"consecutively as duplicates\"? ",
          "createdAt": "2020-04-16T13:39:55Z",
          "updatedAt": "2020-04-16T13:39:55Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See the discussion in #522; the issue is explained in the last message there from @squarooticus",
          "createdAt": "2020-04-16T17:30:42Z",
          "updatedAt": "2020-04-16T17:30:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTM5MzEx",
          "commit": {
            "abbreviatedOid": "e907941"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I have no objection to the new choice of term.",
          "createdAt": "2020-04-16T11:25:43Z",
          "updatedAt": "2020-04-16T11:25:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjEwNTUy",
          "commit": {
            "abbreviatedOid": "e907941"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! Noted one nit, otherwise LGTM!",
          "createdAt": "2020-04-16T13:04:39Z",
          "updatedAt": "2020-04-16T13:05:23Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "TCP Fast Option should be TCP Fast Open I think.",
              "createdAt": "2020-04-16T13:04:39Z",
              "updatedAt": "2020-04-16T17:34:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0ODU1NTA0",
          "commit": {
            "abbreviatedOid": "f151b98"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-16T17:36:03Z",
          "updatedAt": "2020-04-16T17:36:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Fixed; I almost hesitated to fix it, we could have left it in there as an Easter Egg of some kind. An April 1 (2021) RFC could then have followed up and fully spec'ed the TCP Fast Option...",
              "createdAt": "2020-04-16T17:36:03Z",
              "updatedAt": "2020-04-16T17:36:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 562,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0MjcwNzkw",
      "title": "Connection state diagram",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/562",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #466",
      "createdAt": "2020-04-16T10:39:24Z",
      "updatedAt": "2020-04-17T09:29:32Z",
      "closedAt": "2020-04-17T09:29:23Z",
      "mergedAt": "2020-04-17T09:29:23Z",
      "mergedBy": "mwelzl",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTY5NzI1",
          "commit": {
            "abbreviatedOid": "83e5beb"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me",
          "createdAt": "2020-04-16T12:12:21Z",
          "updatedAt": "2020-04-16T12:12:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjIzMTA5",
          "commit": {
            "abbreviatedOid": "83e5beb"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! I guess you could add a loop for sent<> and received<> in established state but maybe that also too much.",
          "createdAt": "2020-04-16T13:19:02Z",
          "updatedAt": "2020-04-16T13:19:02Z",
          "comments": []
        }
      ],
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fd23a3181b97b34c73d98240081fe092155361ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-conn-state-transition-diagram",
      "headRefOid": "83e5beb5cf8de15656968585215bab9c37e11ded",
      "mergeCommit": {
        "oid": "8adc8003c526d0048899f774775811f0d4b66342"
      }
    },
    {
      "number": 564,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0NTg3Njk5",
      "title": "Consolidate normative language in architecture",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/564",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture"
      ],
      "body": "This proposal consolidates normative language into the section on design principles (now requirements), using the suggestions in #519.",
      "createdAt": "2020-04-16T18:22:12Z",
      "updatedAt": "2020-09-11T16:32:29Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f972ca06dd168a3c4f8ca232c22f5d5c39af970e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/arch-normative",
      "headRefOid": "46508d12b48426416129efd2d54fa0b77b36a15b",
      "closedAt": "2020-04-23T20:02:54Z",
      "mergedAt": "2020-04-23T20:02:54Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f21bd889af397edcbaac18b9c56730f37b60703e"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please review the latest updates!",
          "createdAt": "2020-04-20T23:54:06Z",
          "updatedAt": "2020-04-20T23:54:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MjM0Njg2",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks I checked each of these requirements. I think all are covered, and the list is very similar to the one in #519.  The reworked racing text is solid and correct. The security requirements are correct and unchanged.\r\nCan I check with people: I see you didn't use 'REQUIRED' in place of 'MUST' and 'RECOMMENDED' in place of 'SHOULD', which is what I would have done for architectural requirements rather than protocol interactions, but if that is what is preferred, I am content.\r\nI see you did use 'in order to' rather than 'so that' - which I'd have personally favoured (favored).",
          "createdAt": "2020-04-17T07:50:17Z",
          "updatedAt": "2020-04-17T08:20:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "/too many/ can be read several ways. I think we could say /minimal/ or there could be something better still?",
              "createdAt": "2020-04-17T07:50:18Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 22,
              "body": "/should/ or simply say \"follow\" to avoid saying that word?",
              "createdAt": "2020-04-17T07:52:33Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MjM0NjUy",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly nits, only one slightly more hairy issue",
          "createdAt": "2020-04-17T07:50:13Z",
          "updatedAt": "2020-04-17T08:33:17Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "a nit: \"...to a variety _of_ network layer ...\"",
              "createdAt": "2020-04-17T07:50:13Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 34,
              "body": "A few things here, all minor though:\r\n1) maybe this is just my limited English, but is \"Properties defaults\" ok?  I would have thought that this should be \"Property defaults\" or \"Default values of properties\".\r\n2) to me, saying \"data reliability\" just makes this harder to read - I would replace this with \"reliability\", the sentence is long enough already anyway.\r\n3) I stumble over the word \"required\" in \"...reliability ought to be required by default.\" Perhaps you were thinking of the Selection Property Preference level - but these are not defined in this document AFAIK. Second, just reading this, would make me wonder: \"required... from whom?\" - the application? or the transport system?  So, I believe that \"enabled\" would be a better word here.",
              "createdAt": "2020-04-17T07:59:20Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 64,
              "body": "The first sentence lays out a very strict requirement.\r\nThe second is in line with the first, but it describes something broader nevertheless - i.e., it makes me think: \"if you say that they must be *identical*, why tell me that falling back to a weaker version is disallowed?\r\nThe third sentence, then, is an outright contradiction to the first.\r\n\r\nI'm not sure how to best solve this... maybe precede the third sentence with \"As an exception, ...\", and swap order: move the second sentence to the end.",
              "createdAt": "2020-04-17T08:11:45Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 70,
              "body": "Regarding the ability to communicate with \"any existing system that implements the transport protocol(s) selected by the transport system\" (or have been selected by the peer, in the passive case): this is sadly not the case, see issue #516.\r\n\r\nWe could say \"With the exception of cases where applications make protocol-specific assumptions, ...\"   ... but that sounds clumsy, and it also loses a benefit that we have: I think the statement IS correct for TCP. Perhaps for UDP too? Beyond that... harder. I'm not sure how to best phrase this then, sorry :(",
              "createdAt": "2020-04-17T08:21:42Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MjY5MjEx",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T08:42:10Z",
          "updatedAt": "2020-04-17T08:42:10Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd suggest: \"The default for Properties\". \r\nI'd suggest: \"The default for this property is to require reliability\". \r\n.... because we need to be careful in how we use the word 'require' in TAPS ",
              "createdAt": "2020-04-17T08:42:10Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Mjc1NzY0",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T08:51:38Z",
          "updatedAt": "2020-04-17T08:51:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Or...\r\nI think my thought was more along the lines of:\r\n\"A Transport Services system acting as a connection initiator is able to communicate with any existing system that implements the transport protocol(s) selected by the Transport Services system.\" \r\nDo I understand your comment as additionally thinking also when an endpoint asks for additional property X then if that's not supported we still don't then have a connection? \r\nIf so... then \"A Transport Services system acting as a connection initiator is able to communicate with any existing system that implements the transport protocol(s) and all the required properties selected by the Transport Services system.\" ",
              "createdAt": "2020-04-17T08:51:38Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MjgxNTk5",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T08:59:58Z",
          "updatedAt": "2020-04-17T08:59:58Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Yes - as you say, \"when an endpoint asks for additional property X then if that's not supported we still don't then have a connection\". The concrete problem on my mind is stream numbers: if we don't expose them (and I believe we don't), a TAPS Transport System cannot talk to an SCTP or QUIC peer where the application makes assumptions about stream numbers.\r\n\r\nStream numbers specifically should probably be included as a protocol-specific property, to avoid disappointing people implementing QUIC, which is why I filed issue #516.\r\n\r\nYour proposed sentence at the end here, with \"...and all the required properties selected by the Transport Services system\"  sounds like a good way out to me!",
              "createdAt": "2020-04-17T08:59:58Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTQ4MDIy",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T15:21:01Z",
          "updatedAt": "2020-04-17T15:42:49Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Agree with @mwelzl that there's a contradiction here.\r\nIn previous text (now to be deleted), we start out by saying that the Transpor Services system MUST offer security features as requested by the application. Maybe we want to say this here, too, and then continue with SHOULD be identical and MUST NOT race or automatically fall back?",
              "createdAt": "2020-04-17T15:21:01Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 36,
              "body": "I don't really understand the second part.\r\nThey are REQUIRED to be robust, given [that the have or are being given] the ability?\r\nOr they are REQUIRED to be given the ability?\r\n\r\nI feel like there may be a verb missing here.",
              "createdAt": "2020-04-17T15:24:30Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 34,
              "body": "I'm wondering why the path selection (or \"selection of network interfaces\") sentence starts with \"In contrast\" - where's the contrast? Aren't both examples about having the default settings be as broad as possible?",
              "createdAt": "2020-04-17T15:27:21Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 40,
              "body": "I don't quite understand this yet:\r\nWhat does \"exposed differently\" mean here? Is this about us not standardizing specific protocol selection and/or other specific features? Basically \"make this harder to use so it doesn't become default and, thus, unnecessarily constrains selection\"?\r\n\r\nHowever: Couldn't one argue that some of the Selection Properties we have in the API draft are pretty specialized, too?\r\nE.g., the User Timeout Option, which we give as an example below, is a Selection Property just like the others.",
              "createdAt": "2020-04-17T15:36:46Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            },
            {
              "originalPosition": 58,
              "body": "nit: Isn't this \"The following example shows equivalent Protocol Stacks:\"?\r\nAfter all, it's two stacks that could be regarded equivalent.",
              "createdAt": "2020-04-17T15:39:08Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTc2NzIy",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T15:56:26Z",
          "updatedAt": "2020-04-17T15:56:26Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I like Gorry's second sentence as well but I am confused in relation to issue #516 . Isn't the problem there rather that an application that relies on a protocol specific property can not use a TAPS system that does not expose this property? This is different from what is used by the TAPS system when setting up a connection.",
              "createdAt": "2020-04-17T15:56:26Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTg2NzI5",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T16:09:13Z",
          "updatedAt": "2020-04-17T16:09:14Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Interim: Add a comment that this is the only normative section of the document",
              "createdAt": "2020-04-17T16:09:13Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjAzNTU1",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T16:32:32Z",
          "updatedAt": "2020-04-17T16:32:32Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "The subsection with requirements could also be called out in the overview as one sentence in 1.2? ",
              "createdAt": "2020-04-17T16:32:32Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTAzNDkz",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-18T10:52:41Z",
          "updatedAt": "2020-04-18T10:52:42Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "For this PR, we can then conclude that we agree that this is just an editorial fix that can be solved by using Gorry's second sentence.\r\n\r\n@abrunstrom: regarding #516, I'm not sure I fully get what you say here because (to me) you make it sound like a local problem. It is related to setting up a connection though. I had the concrete case from NEAT in mind, where Michael Tuexen wanted stream numbers so that he could write a NEAT client that can talk to a non-NEAT SCTP server which makes assumptions about stream numbers. So, my concern is the peer relying on a protocol specific property.\r\n\r\nConsidering this example, the sentence: \"A Transport Services system acting as a connection initiator can communicate with any existing system that implements the transport protocol(s) selected by the Transport Services system.\" is just not true unless we expose stream numbers (and whatever else a peer may expect to be used). That's how #516 and the text above are related.",
              "createdAt": "2020-04-18T10:52:41Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTA3ODcx",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-18T12:03:19Z",
          "updatedAt": "2020-04-18T12:03:20Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "In the sense that any transport can actually define unique features, the API is never generic, however, can we just keep a general claim with respect to the architecture? What word(s) would you change?",
              "createdAt": "2020-04-18T12:03:19Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTA4MTI1",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-18T12:06:42Z",
          "updatedAt": "2020-04-18T12:06:42Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "/MUST only select Protocol Stacks when the transport security protocols within the stacks are identical./\r\nshould be something like:\r\n/MUST only race Protocol Stacks when the transport security protocols within the stacks are identical.",
              "createdAt": "2020-04-18T12:06:42Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTUyMTIz",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-18T21:23:12Z",
          "updatedAt": "2020-04-18T21:23:13Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "@gorryfair I like your second sentence and do not want to change anything. \r\nI just wanted to point out to @mwelzl that it does not solve his issue #516. That is a related but slightly different issue. But I do not think we need to solve that here.",
              "createdAt": "2020-04-18T21:23:12Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTU1ODMy",
          "commit": {
            "abbreviatedOid": "ec5df09"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-18T22:18:00Z",
          "updatedAt": "2020-04-18T22:18:00Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Yes, let's end this discussion and agree on @gorryfair's second sentence.",
              "createdAt": "2020-04-18T22:18:00Z",
              "updatedAt": "2020-04-20T23:50:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2MjY1",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:50:53Z",
          "updatedAt": "2020-04-20T23:50:53Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Fixed",
              "createdAt": "2020-04-20T23:50:53Z",
              "updatedAt": "2020-04-20T23:50:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2MzEy",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:00Z",
          "updatedAt": "2020-04-20T23:51:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Updated",
              "createdAt": "2020-04-20T23:51:00Z",
              "updatedAt": "2020-04-20T23:51:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2MzYw",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:08Z",
          "updatedAt": "2020-04-20T23:51:08Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Fixed",
              "createdAt": "2020-04-20T23:51:08Z",
              "updatedAt": "2020-04-20T23:51:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2NDI3",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:16Z",
          "updatedAt": "2020-04-20T23:51:16Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Updated",
              "createdAt": "2020-04-20T23:51:16Z",
              "updatedAt": "2020-04-20T23:51:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2NDkz",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:26Z",
          "updatedAt": "2020-04-20T23:51:26Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Fixed up. Please check!",
              "createdAt": "2020-04-20T23:51:26Z",
              "updatedAt": "2020-04-20T23:51:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2NTUz",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:35Z",
          "updatedAt": "2020-04-20T23:51:35Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Took second sentence here.",
              "createdAt": "2020-04-20T23:51:35Z",
              "updatedAt": "2020-04-20T23:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2NjQ5",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:51:51Z",
          "updatedAt": "2020-04-20T23:51:52Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Reworded!",
              "createdAt": "2020-04-20T23:51:51Z",
              "updatedAt": "2020-04-20T23:51:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk2NzU2",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:52:07Z",
          "updatedAt": "2020-04-20T23:52:08Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Made this \"as another example...\"",
              "createdAt": "2020-04-20T23:52:08Z",
              "updatedAt": "2020-04-20T23:52:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk3MjY5",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:53:32Z",
          "updatedAt": "2020-04-20T23:53:33Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Removed the sentence, as I agree it doesn't add much.\r\n\r\nWith regards to User Timeout Option, I think this argues that if an app prefers UTO, it should do a soft prefer or express \"if you use TCP, you must use UTO\" as opposed to simply requiring UTO (which would lead to just using TCP).",
              "createdAt": "2020-04-20T23:53:32Z",
              "updatedAt": "2020-04-20T23:53:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk3MzA1",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:53:37Z",
          "updatedAt": "2020-04-20T23:53:38Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Fixed",
              "createdAt": "2020-04-20T23:53:38Z",
              "updatedAt": "2020-04-20T23:53:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk3MzQz",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:53:43Z",
          "updatedAt": "2020-04-20T23:53:44Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Added",
              "createdAt": "2020-04-20T23:53:43Z",
              "updatedAt": "2020-04-20T23:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODk3Mzg4",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-20T23:53:51Z",
          "updatedAt": "2020-04-20T23:53:51Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Fixed",
              "createdAt": "2020-04-20T23:53:51Z",
              "updatedAt": "2020-04-20T23:53:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MDMzMjM1",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T06:49:43Z",
          "updatedAt": "2020-04-21T06:49:44Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "LGTM; thanks for doing this!",
              "createdAt": "2020-04-21T06:49:43Z",
              "updatedAt": "2020-04-21T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MDM4MTYz",
          "commit": {
            "abbreviatedOid": "46508d1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-21T06:58:09Z",
          "updatedAt": "2020-04-21T06:58:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 565,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1MDM0MzM0",
      "title": "Sentence about minIncompleteLength when rcv. on streams",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/565",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "As described in #543, I removed the condition that requires the application to specify the length upon receiving from this example.\r\nCloses #543.",
      "createdAt": "2020-04-17T09:50:28Z",
      "updatedAt": "2020-09-11T16:32:36Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8adc8003c526d0048899f774775811f0d4b66342",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-minIncompleteLength_streamReceive",
      "headRefOid": "4b9fb5a61fc7ccad7c46727c5560776d006fdd47",
      "closedAt": "2020-05-29T15:18:18Z",
      "mergedAt": "2020-05-29T15:18:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e3ade434e588e8a1a944426ac8a5f265a660fa01"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzY5NTM3",
          "commit": {
            "abbreviatedOid": "b585669"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think removing this is the right thing to do. Rather, we can soften the requirement\u2014it shouldn't be a \"must\", it's just descriptive. How about:\r\n\r\nIf the top-level protocol only supports a byte-stream and no framers were supported, the application can control the flow of received data by specifying the minimum number of bytes of Message content it wants to receive at one time.",
          "createdAt": "2020-04-27T22:22:50Z",
          "updatedAt": "2020-04-27T22:22:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ4OTU1",
          "commit": {
            "abbreviatedOid": "b585669"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-29T15:15:59Z",
          "updatedAt": "2020-05-29T15:16:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nSimilar to sending, Receiving a Message is determined by the top-level protocol in the established Protocol Stack. The main difference with Receiving is that the size and boundaries of the Message are not known beforehand. The application can communicate in its Receive action the parameters for the Message, which can help the implementation know how much data to deliver and when. For example, if the application only wants to receive a complete Message, the implementation should wait until an entire Message (datagram, stream, or frame) is read before delivering any Message content to the application. This requires the implementation to understand where messages end, either via a supplied deframer or because the top-level protocol in the established Protocol Stack preserves message boundaries. If the top-level protocol only supports a byte-stream and no framers were supported, the application can control the flow of received data by specifying the minimum number of bytes of Message content it wants to receive at one time.\r\n```",
              "createdAt": "2020-05-29T15:15:59Z",
              "updatedAt": "2020-05-29T15:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ5NTMx",
          "commit": {
            "abbreviatedOid": "4b9fb5a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:16:41Z",
          "updatedAt": "2020-05-29T15:16:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDUwOTE0",
          "commit": {
            "abbreviatedOid": "4b9fb5a"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This was a long text block - I had a few editorial NiTs you may like to address.",
          "createdAt": "2020-05-29T15:18:24Z",
          "updatedAt": "2020-05-29T15:22:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "/can communicate in its Receive action the parameters for the Message/can communicate the parameters for the Message in its Receive action/",
              "createdAt": "2020-05-29T15:18:24Z",
              "updatedAt": "2020-05-29T15:22:41Z"
            },
            {
              "originalPosition": 5,
              "body": "/the minimum number of bytes of Message content it wants to receive at one time./the minimum number of bytes of Message content that it wants to receive at one time.",
              "createdAt": "2020-05-29T15:20:23Z",
              "updatedAt": "2020-05-29T15:22:41Z"
            },
            {
              "originalPosition": 5,
              "body": "/The main difference with Receiving is that the size and boundaries of the Message are not known beforehand. /The main difference in Receiving a Message is that the size and boundaries of the Message are not known beforehand. /\r\n- or something, this one was hard for me to parse",
              "createdAt": "2020-05-29T15:21:22Z",
              "updatedAt": "2020-05-29T15:22:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 566,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1MjM3ODI0",
      "title": "clarify framers in preconnection, fix #427",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/566",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-17T16:49:01Z",
      "updatedAt": "2020-09-11T16:32:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3f31936f9c78d490fb84cd24c775cb12cc287141",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "must-framers-427",
      "headRefOid": "300c2bb71f87835acf043294010adb76e9b33fc0",
      "closedAt": "2020-04-27T22:18:06Z",
      "mergedAt": "2020-04-27T22:18:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "2e76e357d284d769ff04c007af423b2555b72128"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzY3MzIz",
          "commit": {
            "abbreviatedOid": "300c2bb"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-27T22:17:57Z",
          "updatedAt": "2020-04-27T22:17:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 570,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1MjU0OTgw",
      "title": "clarify that taps interface types are implementation specific, fix #523",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/570",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-17T17:30:23Z",
      "updatedAt": "2020-09-11T16:32:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e36526d49902210d4344fee87adc45528d9ef4ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "no-interface-type-registry-523",
      "headRefOid": "62d9c2698c0de522194eb04434a3dc073dbc0532",
      "closedAt": "2020-04-27T22:18:46Z",
      "mergedAt": "2020-04-27T22:18:46Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a8f4a876759926b47ffac70a74d460d73a6d72f4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzE5OTc0",
          "commit": {
            "abbreviatedOid": "1a84367"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-17T19:31:49Z",
          "updatedAt": "2020-04-17T19:31:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We generally don't say TAPS system",
              "createdAt": "2020-04-17T19:31:49Z",
              "updatedAt": "2020-04-27T22:18:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzIwMDU5",
          "commit": {
            "abbreviatedOid": "1a84367"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-04-17T19:31:58Z",
          "updatedAt": "2020-04-17T19:32:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nTransport Services system is implementation-specific.\r\n```",
              "createdAt": "2020-04-17T19:31:58Z",
              "updatedAt": "2020-04-27T22:18:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzY3NTg3",
          "commit": {
            "abbreviatedOid": "62d9c26"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-27T22:18:28Z",
          "updatedAt": "2020-04-27T22:18:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 572,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1NDU1MTAx",
      "title": "Fix three oddities in the abstract of draft-ietf-taps-interface",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/572",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Fixing three oddities in the abstract, issue #567",
      "createdAt": "2020-04-18T06:50:13Z",
      "updatedAt": "2020-09-11T16:32:31Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e36526d49902210d4344fee87adc45528d9ef4ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-1",
      "headRefOid": "0885c4b829888e14be76fc609d74fd263536067e",
      "closedAt": "2020-04-21T07:44:29Z",
      "mergedAt": "2020-04-21T07:44:29Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "58ec71a9dea88e41319bca9a6f81e27ff2af66a6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTk0OTUw",
          "commit": {
            "abbreviatedOid": "ea590b4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo one nit",
          "createdAt": "2020-04-19T09:16:51Z",
          "updatedAt": "2020-04-19T09:17:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This now looks as if API was an abbreviation for \"abstract programming interface\", which it really isn't  :)   so I suggest to write instead: \"This document describes an abstract application programming interface, API, to the transport...\"",
              "createdAt": "2020-04-19T09:16:51Z",
              "updatedAt": "2020-04-21T07:36:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDAzNzE4",
          "commit": {
            "abbreviatedOid": "ea590b4"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-19T10:59:29Z",
          "updatedAt": "2020-04-19T10:59:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yes, I would think that would be good.",
              "createdAt": "2020-04-19T10:59:29Z",
              "updatedAt": "2020-04-21T07:36:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 573,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1NDU2MTY3",
      "title": "NiTs in section 1",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/573",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Resolving Editorial NiTs in section 1 #569",
      "createdAt": "2020-04-18T07:01:45Z",
      "updatedAt": "2020-09-11T16:32:32Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e36526d49902210d4344fee87adc45528d9ef4ad",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-1-1",
      "headRefOid": "fabd90018f2f55782ed8516a356ab05b898dbe9a",
      "closedAt": "2020-04-21T18:28:29Z",
      "mergedAt": "2020-04-21T18:28:29Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "a467d4e8fff428e91a891e5bf0b7b4f9637066b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDA0MTc5",
          "commit": {
            "abbreviatedOid": "ccf367b"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-19T11:05:11Z",
          "updatedAt": "2020-04-19T11:05:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Should be /abstract Application/ if this to define API, as per MW's comment to abstract.",
              "createdAt": "2020-04-19T11:05:11Z",
              "updatedAt": "2020-04-21T07:47:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MTk5MTg0",
          "commit": {
            "abbreviatedOid": "fabd900"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me, thanks for doing this!",
          "createdAt": "2020-04-21T10:29:27Z",
          "updatedAt": "2020-04-21T10:29:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 574,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMzg1NTk4",
      "title": "Address editorial comments on Implementation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/574",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Addresses comments from #366",
      "createdAt": "2020-05-26T18:42:50Z",
      "updatedAt": "2020-09-11T16:32:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a8f4a876759926b47ffac70a74d460d73a6d72f4",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/impl-nits",
      "headRefOid": "8c2cd946dfdb4692c02c9c62c4c42b2ee84bf994",
      "closedAt": "2020-05-27T20:46:50Z",
      "mergedAt": "2020-05-27T20:46:50Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7c6e0ec82f5e18cf8948542f257ebfe087464cac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5MjU3MTE4",
          "commit": {
            "abbreviatedOid": "458b08a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm, just 2 nits",
          "createdAt": "2020-05-27T14:19:07Z",
          "updatedAt": "2020-05-27T14:32:14Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "typo \"whcih\"",
              "createdAt": "2020-05-27T14:19:08Z",
              "updatedAt": "2020-05-27T18:24:40Z"
            },
            {
              "originalPosition": 115,
              "body": "I think there's a missing article in the first sentence (\"Success and failures of _a_ given attempt...\")",
              "createdAt": "2020-05-27T14:30:02Z",
              "updatedAt": "2020-05-27T18:24:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDk1NTI5",
          "commit": {
            "abbreviatedOid": "458b08a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T18:23:51Z",
          "updatedAt": "2020-05-27T18:24:16Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nDNS-Based Service Discovery {{?RFC6763}} can also provide an endpoint derivation step. When trying to connect to a named service, the client may discover one or more hostname and port pairs on the local network using multicast DNS {{?RFC6762}}. These hostnames should each be treated as a branch that can be attempted independently from other hostnames. Each of these hostnames might resolve to one or more addresses, which would create multiple layers of branching.\r\n```",
              "createdAt": "2020-05-27T18:23:51Z",
              "updatedAt": "2020-05-27T18:24:40Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nSuccesses and failures of a given attempt should be reported up to parent nodes (towards the trunk of the tree). For example, in the following case, if 1.1.1 fails to connect, it reports the failure to 1.1. Since 1.1 has no other child nodes, it also has failed and reports that failure to 1. Because 1.2 has not yet failed, 1 is not considered to have failed. Since 1.2 has not yet started, it is started and the process continues. Similarly, if 1.1.1 successfully connects, then it marks 1.1 as connected, which propagates to the trunk node 1. At this point, the connection as a whole is considered to be successfully connected and ready to process application data\r\n```",
              "createdAt": "2020-05-27T18:24:13Z",
              "updatedAt": "2020-05-27T18:24:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDk2NTgw",
          "commit": {
            "abbreviatedOid": "458b08a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T18:25:14Z",
          "updatedAt": "2020-05-27T18:25:14Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Fixed",
              "createdAt": "2020-05-27T18:25:14Z",
              "updatedAt": "2020-05-27T18:25:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDk2ODI2",
          "commit": {
            "abbreviatedOid": "8c2cd94"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T18:25:35Z",
          "updatedAt": "2020-05-27T18:25:36Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Fixed!",
              "createdAt": "2020-05-27T18:25:35Z",
              "updatedAt": "2020-05-27T18:25:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTY2NDQ5",
          "commit": {
            "abbreviatedOid": "8c2cd94"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks Tommy, LGTM!",
          "createdAt": "2020-05-27T20:02:04Z",
          "updatedAt": "2020-05-27T20:02:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 581,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MjY5OTcw",
      "title": "Remove specification that message is bytes-like",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/581",
      "state": "MERGED",
      "author": "MaxF12",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #477 ",
      "createdAt": "2020-05-29T18:53:49Z",
      "updatedAt": "2020-05-31T20:25:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "43a7b05a24db7166e7b8353ed55eaca5b025d8ea",
      "headRepository": "MaxF12/api-drafts",
      "headRefName": "master",
      "headRefOid": "1256f6fda5c3876781290e823a4d8a1eb6743c8e",
      "closedAt": "2020-05-31T20:25:27Z",
      "mergedAt": "2020-05-31T20:25:27Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a2c8974f8b91d835757154eb0cf50163a29fa1d7"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks fine to me. I wonder if we want to add some text and given some implementation hints. Not sure if that is needed but it could be useful...?",
          "createdAt": "2020-05-29T19:11:26Z",
          "updatedAt": "2020-05-29T19:11:26Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good.",
          "createdAt": "2020-05-29T19:59:10Z",
          "updatedAt": "2020-05-29T19:59:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjE2Njc5",
          "commit": {
            "abbreviatedOid": "1256f6f"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T19:10:43Z",
          "updatedAt": "2020-05-29T19:10:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjY5ODg1",
          "commit": {
            "abbreviatedOid": "1256f6f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T20:33:31Z",
          "updatedAt": "2020-05-29T20:33:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 582,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDM3MDkw",
      "title": "Editorial update to message properties in draft-ietf-taps-impl.md ",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/582",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Changes to address Issue #579",
      "createdAt": "2020-05-30T08:50:43Z",
      "updatedAt": "2020-09-11T16:32:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "43a7b05a24db7166e7b8353ed55eaca5b025d8ea",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-2",
      "headRefOid": "88e961b7476f85d5e16ace5bc270c32c87178f21",
      "closedAt": "2020-05-31T20:21:35Z",
      "mergedAt": "2020-05-31T20:21:35Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ffe74bd43c0db1dc48111834abbbd0e86a090513"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTI0NDUw",
          "commit": {
            "abbreviatedOid": "66e9bf7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, just some more nits on top",
          "createdAt": "2020-05-31T20:17:24Z",
          "updatedAt": "2020-05-31T20:20:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n- Final: when this is true, this means that a transport connection can be closed immediately after transmission of the message.\r\n```",
              "createdAt": "2020-05-31T20:17:25Z",
              "updatedAt": "2020-05-31T20:20:23Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- Lifetime: this should be implemented by removing the Message from the queue of pending Messages after the Lifetime has expired. A queue of pending Messages within the transport system implementation that have yet to be handed to the Protocol Stack can always support this property, but once a Message has been sent into the send buffer of a protocol, only certain protocols may support removing a message. For example, an implementation cannot cannot remove bytes from a TCP send buffer, while it can remove data from a SCTP send buffer using the partial reliability extension {{!RFC8303}}. When there is no standing queue of Messages within the system, and the Protocol Stack does not support the removal of a Message from the stack's send buffer, this property may be ignored.\r\n```",
              "createdAt": "2020-05-31T20:19:54Z",
              "updatedAt": "2020-05-31T20:20:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 583,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDM4NjIx",
      "title": "Rewording of Section 4.1.5 on Properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/583",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "review"
      ],
      "body": "Not intended to change meaning, but intended to improve reading, see issue #576.",
      "createdAt": "2020-05-30T09:06:28Z",
      "updatedAt": "2020-09-11T16:32:38Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "43a7b05a24db7166e7b8353ed55eaca5b025d8ea",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-3",
      "headRefOid": "574e49af03ac699a3b098f2708b2cbd6a0a811e1",
      "closedAt": "2020-05-31T20:24:26Z",
      "mergedAt": "2020-05-31T20:24:26Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "0d770e464cc3f30c5071102c9cf76285528c60fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTI0ODMz",
          "commit": {
            "abbreviatedOid": "0a79240"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-31T20:23:29Z",
          "updatedAt": "2020-05-31T20:23:34Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nThe available protocols and paths on a specific system and in a specific context can change; therefore, the result of sorting and the outcome of racing may vary, even when using the same Selection and Connection Properties. However, an implementation ought to provide a consistent outcome to applications, e.g., by preferring protocols and paths that are already used by existing Connections that specified similar Properties.\r\n```",
              "createdAt": "2020-05-31T20:23:29Z",
              "updatedAt": "2020-05-31T20:23:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 585,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2NjE2NDkx",
      "title": "Correlate send/receive events with calls",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/585",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #509",
      "createdAt": "2020-06-18T16:41:17Z",
      "updatedAt": "2020-09-11T16:33:26Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2d39515fbc533f28b3a46ba88d584f703749e115",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/receive-event-correlation",
      "headRefOid": "22397137f84405830826e8099d27c1d6b56884b9",
      "closedAt": "2020-06-19T15:07:13Z",
      "mergedAt": "2020-06-19T15:07:13Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "bc3b534c628bfea7897ddb8dbc6a0b9fbeda7491"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODY2MDU1",
          "commit": {
            "abbreviatedOid": "2239713"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T07:38:05Z",
          "updatedAt": "2020-06-19T07:38:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 586,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODY1MjA3",
      "title": "Make batch example more clear",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/586",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #449",
      "createdAt": "2020-06-19T03:18:20Z",
      "updatedAt": "2020-09-11T16:33:25Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2d39515fbc533f28b3a46ba88d584f703749e115",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/batch-update",
      "headRefOid": "a1d6c8a2bde7a004d4eb9b0bd758cd0213bfc66e",
      "closedAt": "2020-06-19T15:08:31Z",
      "mergedAt": "2020-06-19T15:08:31Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "877c6dd093adb69f3fc49cdc402545a612a0533b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODY3MTQ3",
          "commit": {
            "abbreviatedOid": "a1d6c8a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T07:39:55Z",
          "updatedAt": "2020-06-19T07:39:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 587,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODY2NTQ1",
      "title": "Clarify immediate racing",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/587",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #577",
      "createdAt": "2020-06-19T03:23:16Z",
      "updatedAt": "2020-06-19T12:34:36Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "2d39515fbc533f28b3a46ba88d584f703749e115",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/immediate-clarify",
      "headRefOid": "5282e377aa0f743a21958d3e9f0ccdfdc6717783",
      "closedAt": "2020-06-19T12:34:12Z",
      "mergedAt": "2020-06-19T12:34:12Z",
      "mergedBy": "abrunstrom",
      "mergeCommit": {
        "oid": "0a6a582bf79f7d5ddf056b91fe71f540c29ca7f7"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I actually really like: \"Simultaneous\" and \"Staggered\" as descriptive terms that avoid the question of \"delaying\".",
          "createdAt": "2020-06-19T08:27:48Z",
          "updatedAt": "2020-06-19T08:27:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODc1MTM4",
          "commit": {
            "abbreviatedOid": "5282e37"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\n(side note - nothing blocking, this is just an idea: to me, \"Simultaneous\" and \"Staggered\" would be better names than \"Immediate\" and \"Delayed\". Just from these terms, I would normally think that \"Immediate\" means to start racing right away, whereas \"Delayed\" means that nothing would happen for some time. So these two terms are slightly misleading in my opinion.)",
          "createdAt": "2020-06-19T07:52:55Z",
          "updatedAt": "2020-06-19T07:52:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MDM5NDUz",
          "commit": {
            "abbreviatedOid": "5282e37"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks! I will close this and open a separate issue for the naming.",
          "createdAt": "2020-06-19T12:32:31Z",
          "updatedAt": "2020-06-19T12:33:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 590,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MTY1ODU1",
      "title": "Clarify Transport Property name text - resolves #568",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/590",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Clarify how the IANA protocol numbers registry keywords (largely upper-case) textually relate to Transport Property Names.\r\n* Refine some of the surrounding text.",
      "createdAt": "2020-06-19T15:33:33Z",
      "updatedAt": "2020-06-19T15:43:15Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "8596406afbbd2d07c2d6319d4e23a781d5e4359c",
      "headRepository": "squarooticus/api-drafts",
      "headRefName": "patch-1",
      "headRefOid": "dc0f17dcad0ea9c5e876e05baaa60bec10aa3e1f",
      "closedAt": "2020-06-19T15:43:15Z",
      "mergedAt": "2020-06-19T15:43:15Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "e045cb7f65183c061fa9b01a2a7721a6d8c4383e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 591,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MTcxNDY5",
      "title": "Opening of subflows removed from multipath property",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/591",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-19T15:45:38Z",
      "updatedAt": "2020-09-11T16:33:23Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e045cb7f65183c061fa9b01a2a7721a6d8c4383e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-2",
      "headRefOid": "542cdffb3053babd21aff2b50758c7768d2763f3",
      "closedAt": "2020-06-19T15:52:20Z",
      "mergedAt": "2020-06-19T15:52:20Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3568b746cd1e9bb2dc825feb93eb27a95aea0d85"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 592,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MTc0MDI1",
      "title": "Remove GetOriginalRequest(), fix #455",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/592",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-19T15:51:13Z",
      "updatedAt": "2020-07-03T05:00:08Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e045cb7f65183c061fa9b01a2a7721a6d8c4383e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "no-get-original-req-455",
      "headRefOid": "1c38b0b0b240a78fb7ff0da8f441bf03484bfb17",
      "closedAt": "2020-06-19T16:38:20Z",
      "mergedAt": "2020-06-19T16:38:19Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "f0bc25d2bcaf3906de6597ee91b4441e56b36f7a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 593,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MTgwNzUy",
      "title": "No Fragmentation, fix #447",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/593",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-19T16:01:29Z",
      "updatedAt": "2020-09-11T16:33:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "42ef22ac8c4fc82b76ffa9d8ea60fa4b2d582dea",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "no-frag-447",
      "headRefOid": "e33ca94c366a9a7fd852a8d88d2622ee39fb7368",
      "closedAt": "2020-06-19T16:38:33Z",
      "mergedAt": "2020-06-19T16:38:33Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "074939f1e513eb83a786598d7db0c1a6aec4b587"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 594,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MTgyODIy",
      "title": "Update security parameters as discussed in #440 to make them mare TAPSlike",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/594",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-06-19T16:06:06Z",
      "updatedAt": "2020-06-19T16:42:45Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "42ef22ac8c4fc82b76ffa9d8ea60fa4b2d582dea",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/security-parameters",
      "headRefOid": "4d7891aa74601c4acba75e14ac9f84ea66faba97",
      "closedAt": "2020-06-19T16:42:42Z",
      "mergedAt": "2020-06-19T16:42:42Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "281fa7dbe6bea02045f8b9b5aab1b4d39888f8a6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTk2NjQx",
          "commit": {
            "abbreviatedOid": "4d7891a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm, will let @mwelzl merge it though.",
          "createdAt": "2020-06-19T16:13:41Z",
          "updatedAt": "2020-06-19T16:13:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 596,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQzODY1Njc3",
      "title": "Remove the \"lower-case\" requirement for transport property names",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/596",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This doesn't change the idea of translating keywords from the IANA protocol numbers registry to lower-case; it just removes the requirement for all Transport Property Names to be lower-case.\r\n\r\nWhy? Right now, they're camlCase, and I guess that reads better than changing them all into hardtoreadstrings or using-hyphens-everywhere ...\r\n",
      "createdAt": "2020-07-03T05:51:57Z",
      "updatedAt": "2020-09-11T16:33:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d8f2deffc14eb3db66eb419603e16f14c60927cd",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-transportPropertyNames-no-lowercase-required",
      "headRefOid": "b82278ba4a4ce9de0b42708933a58b3d7d140c3d",
      "closedAt": "2020-07-03T07:37:30Z",
      "mergedAt": "2020-07-03T07:37:30Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "23d72ced4a028d39562894f388c8fcdbe0332fde"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 597,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQzODkzNTE3",
      "title": "Unify establishment errors",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/597",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "No need to have a different type of Event for initiate, listen and rendezvous. Closes #510.",
      "createdAt": "2020-07-03T07:13:47Z",
      "updatedAt": "2020-09-11T16:33:08Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d8f2deffc14eb3db66eb419603e16f14c60927cd",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-combine-some-errors",
      "headRefOid": "cb682ab3c19091d4fd21bb519b9167f4b7cd0557",
      "closedAt": "2020-07-13T17:57:34Z",
      "mergedAt": "2020-07-13T17:57:33Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "97ec061e9c37a82b38781298fed743ecfe8e195c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDc1NDEz",
          "commit": {
            "abbreviatedOid": "cb682ab"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:57:27Z",
          "updatedAt": "2020-07-13T17:57:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 598,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQzOTMzODU4",
      "title": "Align message properties between impl and API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/598",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #540.\r\n\r\nI also added a link to NEATPy in the overview of implementations, and inserted a missing word in interface (a missing \"without\", must have been a nit)",
      "createdAt": "2020-07-03T08:44:47Z",
      "updatedAt": "2020-09-11T16:33:07Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "23d72ced4a028d39562894f388c8fcdbe0332fde",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-align-impl-api-messageproperties",
      "headRefOid": "7dd021cbfe8548c3a01d548fa3c7edbb0a8c9aa0",
      "closedAt": "2020-07-13T17:56:54Z",
      "mergedAt": "2020-07-13T17:56:54Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1c0a24e8ebd2b24c38ef0f0eecee7c16a421dbfb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDc0OTM4",
          "commit": {
            "abbreviatedOid": "7dd021c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:56:50Z",
          "updatedAt": "2020-07-13T17:56:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 599,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0MDA4Mzkz",
      "title": "Impl: update batch send text",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/599",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #542.",
      "createdAt": "2020-07-03T11:27:09Z",
      "updatedAt": "2020-09-11T16:33:06Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "23d72ced4a028d39562894f388c8fcdbe0332fde",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-batchsend",
      "headRefOid": "b9da73b39d5bcf8d8ba8b7cab6acb1c19e49bec0",
      "closedAt": "2020-07-13T17:55:58Z",
      "mergedAt": "2020-07-13T17:55:58Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "cfb943ceab0739d47ae81b596824687e17a1e5f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDc0MjQ2",
          "commit": {
            "abbreviatedOid": "b9da73b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:55:53Z",
          "updatedAt": "2020-07-13T17:55:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 600,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0MDEyMTk5",
      "title": "adjusted text according to #531",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/600",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #531.",
      "createdAt": "2020-07-03T11:36:41Z",
      "updatedAt": "2020-09-11T16:33:05Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "23d72ced4a028d39562894f388c8fcdbe0332fde",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-properties-terminology-cleanup",
      "headRefOid": "c00405a35ad902c8be8d01a8fa37837796bfd41b",
      "closedAt": "2020-07-13T17:55:25Z",
      "mergedAt": "2020-07-13T17:55:25Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "99277f5400914a1db454f0f23c4040dcbe8c44a9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjIwNjc4",
          "commit": {
            "abbreviatedOid": "c00405a"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Some small changes suggested",
          "createdAt": "2020-07-10T08:33:06Z",
          "updatedAt": "2020-07-10T08:33:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDczODE0",
          "commit": {
            "abbreviatedOid": "c00405a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:55:17Z",
          "updatedAt": "2020-07-13T17:55:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 601,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4Mzk2MDYz",
      "title": "Clarify naming convention variance",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/601",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " * Updates PR #596 to remove reference to lower-case in namespaces\r\n   corresponding to IANA protocol names.\r\n\r\n * Express that strict adherence to the doc's naming convention is not\r\n   required, but that symbols in different languages should be\r\n   visually similar.",
      "createdAt": "2020-07-13T17:37:54Z",
      "updatedAt": "2020-07-13T17:58:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "23d72ced4a028d39562894f388c8fcdbe0332fde",
      "headRepository": "squarooticus/api-drafts",
      "headRefName": "krose-interface-clarify-naming-convention-update-PR-596",
      "headRefOid": "d0e9df47f698f816c9d3ab21e670610a5130d4f3",
      "closedAt": "2020-07-13T17:58:24Z",
      "mergedAt": "2020-07-13T17:58:24Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "3890ed357036f5ebe6183cdd6fd8bf0f7ab7ac9e"
      },
      "comments": [
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "@mwelzl @britram \r\n\r\nLast minute PR \u23f0",
          "createdAt": "2020-07-13T17:39:18Z",
          "updatedAt": "2020-07-13T17:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDc2MDY3",
          "commit": {
            "abbreviatedOid": "d0e9df4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T17:58:20Z",
          "updatedAt": "2020-07-13T17:58:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 602,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwMzkxNzAz",
      "title": "Use \"Simultaneous\" and \"Staggered\"",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/602",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #588 ",
      "createdAt": "2020-07-16T18:02:17Z",
      "updatedAt": "2020-07-16T20:44:13Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fcebd514b11856fca6cba16f2f3b0dd8fefff934",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/racing-names",
      "headRefOid": "47949d850d04103fac1a3b98ac29b6c07fc7b2f1",
      "closedAt": "2020-07-16T20:44:01Z",
      "mergedAt": "2020-07-16T20:44:00Z",
      "mergedBy": "abrunstrom",
      "mergeCommit": {
        "oid": "39bc00f2d03ca2e47bc52c26a6a898dc0494d631"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTM3Nzc0",
          "commit": {
            "abbreviatedOid": "47949d8"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM  (of course :-) )",
          "createdAt": "2020-07-16T19:13:00Z",
          "updatedAt": "2020-07-16T19:13:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTk2MjYw",
          "commit": {
            "abbreviatedOid": "47949d8"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-16T20:35:09Z",
          "updatedAt": "2020-07-16T20:35:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjAxNjk4",
          "commit": {
            "abbreviatedOid": "47949d8"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, looks good!",
          "createdAt": "2020-07-16T20:43:25Z",
          "updatedAt": "2020-07-16T20:43:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 603,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwMzkzNjI4",
      "title": "Update multipath interactive definition",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/603",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #578 ",
      "createdAt": "2020-07-16T18:05:22Z",
      "updatedAt": "2020-09-11T16:33:03Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fcebd514b11856fca6cba16f2f3b0dd8fefff934",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/multipath-interactive",
      "headRefOid": "a377c16571e307f39a80eb31f00396fedd624dcd",
      "closedAt": "2020-07-18T23:47:54Z",
      "mergedAt": "2020-07-18T23:47:54Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e84de80d5208989201fd258a3a7a7f2b4f9850a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTM1ODQ3",
          "commit": {
            "abbreviatedOid": "ef1c2b5"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-07-16T19:10:04Z",
          "updatedAt": "2020-07-16T19:10:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjA5Mzgw",
          "commit": {
            "abbreviatedOid": "ef1c2b5"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for following up on this one.",
          "createdAt": "2020-07-16T20:55:18Z",
          "updatedAt": "2020-07-16T21:05:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sounds like data is always sent over multiple paths. Perhaps add \"if beneficial\" or similar at the end.",
              "createdAt": "2020-07-16T20:55:19Z",
              "updatedAt": "2020-07-18T23:46:54Z"
            },
            {
              "originalPosition": 8,
              "body": "Should we add \"The actual strategy is implementation specific.\" at the end. I think we should be consistent, so either add it back here or remove it also for Aggregate.",
              "createdAt": "2020-07-16T20:57:31Z",
              "updatedAt": "2020-07-18T23:46:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDg4NTg5",
          "commit": {
            "abbreviatedOid": "ef1c2b5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T23:46:12Z",
          "updatedAt": "2020-07-18T23:46:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: The connection should attempt to minimize the latency for interactive traffic patterns by transmitting data across multiple paths when it is beneficial to do so.\r\n```",
              "createdAt": "2020-07-18T23:46:12Z",
              "updatedAt": "2020-07-18T23:46:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDg4NjA4",
          "commit": {
            "abbreviatedOid": "ef1c2b5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T23:46:41Z",
          "updatedAt": "2020-07-18T23:46:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\non multiple paths in parallel to achieve the lowest latency possible. The specific scheduling algorithm is implementation-specific.\r\n```",
              "createdAt": "2020-07-18T23:46:41Z",
              "updatedAt": "2020-07-18T23:46:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDg4NjE4",
          "commit": {
            "abbreviatedOid": "a377c16"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T23:47:06Z",
          "updatedAt": "2020-07-18T23:47:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Fixed",
              "createdAt": "2020-07-18T23:47:06Z",
              "updatedAt": "2020-07-18T23:47:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDg4NjIy",
          "commit": {
            "abbreviatedOid": "a377c16"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T23:47:12Z",
          "updatedAt": "2020-07-18T23:47:13Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Fixed",
              "createdAt": "2020-07-18T23:47:13Z",
              "updatedAt": "2020-07-18T23:47:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 604,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNTA0MzEw",
      "title": "Add diagram and more explanation for message framers in API doc",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/604",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #457",
      "createdAt": "2020-07-16T20:47:42Z",
      "updatedAt": "2020-07-21T09:13:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39bc00f2d03ca2e47bc52c26a6a898dc0494d631",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/framer-interface-diagram",
      "headRefOid": "2f859a735e160188899f900036396d350a9adc49",
      "closedAt": "2020-07-21T09:13:13Z",
      "mergedAt": "2020-07-21T09:13:13Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "523d8dbe942bd46acc7691e980758c336bb6dff6"
      },
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this helps, but one of the confusions is the distinction between a framing to provide a message-oriented API, and the use of framers underneath that API to change the representation of messages on the wire. I wonder if some of the difficulties we've had with framers is that some of us have been using the term to represent one of these concepts, and some the other?\r\n\r\nOne is the concept of a framer that accumulates data and returns an `HttpResponse` object from a `recv()` call, rather than returning a byte array containing a (partial) HTTP response. That's the API-level framer.\r\n\r\nThe other is the sort of framer that performs TLS encryption on the HTTP request, after `send()` has been called. This transforms data, below the API. \r\n\r\nDo we need two different terms?\r\n",
          "createdAt": "2020-07-17T14:20:24Z",
          "updatedAt": "2020-07-17T14:20:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins - personally, I always thought that Framers can do both of these things; if this wasn't clear enough before, then I think your part 1 (returning an HTTPResponse object) was clear from before, and now this PR makes it clear that they also intercept the send call to transform data afterwards. So IMHO that's just the clarification that was needed.",
          "createdAt": "2020-07-17T14:59:00Z",
          "updatedAt": "2020-07-17T14:59:00Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry! Obviously I only wanted to comment, but hit the wrong button  :)",
          "createdAt": "2020-07-17T14:59:30Z",
          "updatedAt": "2020-07-17T14:59:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDM4MzY0",
          "commit": {
            "abbreviatedOid": "602170f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks a lot for doing this - to me, this looks really good. It makes things much clearer for readers of this document.",
          "createdAt": "2020-07-17T07:38:34Z",
          "updatedAt": "2020-07-17T07:38:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQwNzU1",
          "commit": {
            "abbreviatedOid": "602170f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:12:21Z",
          "updatedAt": "2020-07-17T15:12:22Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Denote that what a framer vends in receive is a well-defined message object (as opposed to a byte stream below)",
              "createdAt": "2020-07-17T15:12:21Z",
              "updatedAt": "2020-07-18T23:56:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzY1NDYx",
          "commit": {
            "abbreviatedOid": "602170f"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think it'll be helpful to be a bit clearer on the timing here, see comment.",
          "createdAt": "2020-07-17T15:44:22Z",
          "updatedAt": "2020-07-17T15:45:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "To me this sounds a bit like Framers are only coming into effect when/after the Preconnection becomes a Connection. Also, this makes me wonder what \"load into Connections\" means.\r\n\r\nMaybe let's rather say something like:\r\n\"To use a Message Framer, an application has to add it to a Preconnection.\r\nThen, the Message Framer can interact with the setup and teardown of the Connection. ...\"",
              "createdAt": "2020-07-17T15:44:22Z",
              "updatedAt": "2020-07-18T23:56:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDg4OTE3",
          "commit": {
            "abbreviatedOid": "2f859a7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T23:56:37Z",
          "updatedAt": "2020-07-18T23:56:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Reworked this text, let me know if that works!",
              "createdAt": "2020-07-18T23:56:37Z",
              "updatedAt": "2020-07-18T23:56:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNzQxMTI3",
          "commit": {
            "abbreviatedOid": "2f859a7"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T15:54:46Z",
          "updatedAt": "2020-07-20T15:54:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Better, I think",
              "createdAt": "2020-07-20T15:54:46Z",
              "updatedAt": "2020-07-20T15:54:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDMyMDk3",
          "commit": {
            "abbreviatedOid": "2f859a7"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this should clarify it, thanks!",
          "createdAt": "2020-07-20T23:45:18Z",
          "updatedAt": "2020-07-20T23:45:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 605,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNTExNTMy",
      "title": "Keep Minset protocol mappings, create template for new mappings",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/605",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #398 ",
      "createdAt": "2020-07-16T20:58:25Z",
      "updatedAt": "2020-09-11T16:33:00Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39bc00f2d03ca2e47bc52c26a6a898dc0494d631",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/split-mappings",
      "headRefOid": "0e34093f32bec3970d9a06ea98e2d6792c2b9e77",
      "closedAt": "2020-08-14T15:07:03Z",
      "mergedAt": "2020-08-14T15:07:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "9b7fb3629588bb0320fd825b6df3bd92682f3e21"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please merge. Completeness really isn't necessary. If this spec is used, the published RFC **CAN** be updated or added to, at the moment, I'd prefer to ship a spec sooner, rather than add too much, so let's converge:-).",
          "createdAt": "2020-07-17T08:04:11Z",
          "updatedAt": "2020-07-17T08:04:11Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbln Brought back multicast for now. Good to merge?",
          "createdAt": "2020-08-13T17:29:07Z",
          "updatedAt": "2020-08-13T17:29:07Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we can merge this and break out the remaining parts as separate issues as suggested by @tfpauly .",
          "createdAt": "2020-08-13T22:50:16Z",
          "updatedAt": "2020-08-13T22:50:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjQyNzE2",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for starting on the split.",
          "createdAt": "2020-07-16T21:53:33Z",
          "updatedAt": "2020-07-16T22:06:42Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Not sure we can merge TCP and MPTCP? Some of the descriptions will be different for MPTCP and we would also need the mapping to the multipath-specific parts fo the API.",
              "createdAt": "2020-07-16T21:53:33Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            },
            {
              "originalPosition": 28,
              "body": "We would need to add something specific for UDP-Lite as well I guess, but UDP and UDP-Lite seem simpler to merge.",
              "createdAt": "2020-07-16T21:55:25Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            },
            {
              "originalPosition": 225,
              "body": "Perhaps we should also indicate how the template should be used? Should one just leave out the parts that are not relevant for a particular protocol or all fields should be included and fields that are not relevant are marked as such.",
              "createdAt": "2020-07-16T21:57:24Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            },
            {
              "originalPosition": 226,
              "body": "How was the list below selected? What about API primitives that are not in the list, e.g. Rendezvous?",
              "createdAt": "2020-07-16T22:00:21Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDQzMTY1",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I saw the comments from @abrunstrom and agree with them; we should make sure that we don't lose them. Yet, to make progress with this, I suggest to open up an issue where we copy her comments and merge this PR in the meantime. It will be easier to make small PRs with fixes per protocol then, rather than discussing them all in this PR.",
          "createdAt": "2020-07-17T07:46:44Z",
          "updatedAt": "2020-07-17T07:46:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDQ4MTU0",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T07:54:48Z",
          "updatedAt": "2020-07-17T07:54:49Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "The answer is that someone started it like this at some point, very very early in the document's history. But since you ask, this is where things get a bit ugly... we could also ask: \"What about the Generic Connection Properties?\" and \"What about Message Properties?\".  Honestly I think that, in principle, ALL of these mappings should be covered here... but it's also a huge amount of work, and it will make the document very long, with questionable benefit (for all the primitives and properties that are indeed contained in minset, the mapping can be back-traced from there). Perhaps we should discuss this at the interim?",
              "createdAt": "2020-07-17T07:54:48Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDUzMTYy",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T08:02:50Z",
          "updatedAt": "2020-07-17T08:02:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I think we can cover this easily by a few sentences that say UDP-Lite follows UDP, except for explicitly identified cases.",
              "createdAt": "2020-07-17T08:02:50Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTE1NTc0",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T09:35:38Z",
          "updatedAt": "2020-07-17T09:35:39Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Yes, my question was general and Rendezvous just an example. Let's discuss this at the interim. \r\n\r\nDepending on how we define the use of the template, what is in covered by the template and what is in specified in a particular mapping may not have to overlap one to one.",
              "createdAt": "2020-07-17T09:35:38Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTMwODE5",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T09:58:59Z",
          "updatedAt": "2020-07-17T09:58:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Agreed, but perhaps it is still cleaner to have UDP-Lite as its own protocol heading and refer back to UDP and just add the specifics. This is how we did it for MPTCP and UDP-Lite  in RFC 8303 and 8304.",
              "createdAt": "2020-07-17T09:58:59Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQ0NTkz",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:17:27Z",
          "updatedAt": "2020-07-17T15:17:28Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Add mapping for enable/disable multipath, talk about automatable properties.\r\n\r\nSplit out MPTCP",
              "createdAt": "2020-07-17T15:17:27Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQ1Mjg2",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:18:25Z",
          "updatedAt": "2020-07-17T15:18:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Note: This will also close #595",
              "createdAt": "2020-07-17T15:18:25Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQ3ODg5",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:21:52Z",
          "updatedAt": "2020-07-17T15:21:53Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "We can go through the exercise of adding all functions/properties to the template",
              "createdAt": "2020-07-17T15:21:52Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjcwNDIz",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "We should apply this as soon as possible as it makes the implementation consistent with minset, but deleting UDP multicast really hurts .Can we re-add the UDP multicast part, especially as this does not seem to be enough for an individual mapping document. ",
          "createdAt": "2020-07-25T08:12:26Z",
          "updatedAt": "2020-07-25T08:12:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzY5Njc4",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T10:02:00Z",
          "updatedAt": "2020-08-12T10:02:00Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "That also would work for me.",
              "createdAt": "2020-08-12T10:02:00Z",
              "updatedAt": "2020-08-13T17:27:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzMjA4",
          "commit": {
            "abbreviatedOid": "0e34093"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:15Z",
          "updatedAt": "2020-08-13T17:28:15Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Split out for now, and started mentioning properties",
              "createdAt": "2020-08-13T17:28:15Z",
              "updatedAt": "2020-08-13T17:28:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzMjcz",
          "commit": {
            "abbreviatedOid": "0e34093"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:20Z",
          "updatedAt": "2020-08-13T17:28:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Split out",
              "createdAt": "2020-08-13T17:28:20Z",
              "updatedAt": "2020-08-13T17:28:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzNDY5",
          "commit": {
            "abbreviatedOid": "0e34093"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:35Z",
          "updatedAt": "2020-08-13T17:28:35Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "I like this, but think we can do it in another PR",
              "createdAt": "2020-08-13T17:28:35Z",
              "updatedAt": "2020-08-13T17:28:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzNjE5",
          "commit": {
            "abbreviatedOid": "0e34093"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:47Z",
          "updatedAt": "2020-08-13T17:28:48Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Let's do this, but separately?",
              "createdAt": "2020-08-13T17:28:47Z",
              "updatedAt": "2020-08-13T17:28:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTgyMjc2",
          "commit": {
            "abbreviatedOid": "3cd8a41"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Let's merge and fix the rest separately.",
          "createdAt": "2020-08-13T22:51:11Z",
          "updatedAt": "2020-08-13T22:52:59Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "Agreed.",
              "createdAt": "2020-08-13T22:51:11Z",
              "updatedAt": "2020-08-13T22:52:59Z"
            },
            {
              "originalPosition": 226,
              "body": "Agreed.",
              "createdAt": "2020-08-13T22:52:02Z",
              "updatedAt": "2020-08-13T22:52:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 606,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNTIwMzQx",
      "title": "Clarify text on staggered racing, reference happy eyeballs and ICE",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/606",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #537",
      "createdAt": "2020-07-16T21:12:11Z",
      "updatedAt": "2020-09-11T16:32:59Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39bc00f2d03ca2e47bc52c26a6a898dc0494d631",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/staggered-racing",
      "headRefOid": "eb089b2fcbf084093965600b6350d69d3e312b90",
      "closedAt": "2020-08-14T15:05:54Z",
      "mergedAt": "2020-08-14T15:05:54Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "2df355bbdb0630a18f2f740a6e1005139e1e1956"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom @theri please take a look at the updated text!",
          "createdAt": "2020-08-13T17:17:18Z",
          "updatedAt": "2020-08-13T17:17:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQ5MTky",
          "commit": {
            "abbreviatedOid": "3d2c44d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Do not understand the last part, otherwise looks good!",
          "createdAt": "2020-07-17T10:28:59Z",
          "updatedAt": "2020-07-17T10:40:48Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "I think this needs to be \"Staggered racing attempts may occur in parallel\" considering that the part that now follows right after in the text is the case when they do not occur in parallel.",
              "createdAt": "2020-07-17T10:29:00Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            },
            {
              "originalPosition": 13,
              "body": "I do not understand this part. How does the minimum and maximum come in to play? And who sets these values?",
              "createdAt": "2020-07-17T10:35:31Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQ4OTMx",
          "commit": {
            "abbreviatedOid": "ebe00a5"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-17T15:23:14Z",
          "updatedAt": "2020-07-17T15:23:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzUzODkw",
          "commit": {
            "abbreviatedOid": "ebe00a5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:29:22Z",
          "updatedAt": "2020-07-17T15:29:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "layers -> branching levels",
              "createdAt": "2020-07-17T15:29:22Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzU1NTk0",
          "commit": {
            "abbreviatedOid": "ebe00a5"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:31:27Z",
          "updatedAt": "2020-07-17T15:31:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "In the Impl draft we actually call it Branch Types. Section 4.1.3 says:\r\n\"There are three types of branching from a parent node into one or more child nodes. [\u2026] Derived Endpoints [\u2026] Alternate Paths [\u2026] Protocol Options\"\r\nSo maybe we can go with branch types here, too?",
              "createdAt": "2020-07-17T15:31:27Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzU1NjUw",
          "commit": {
            "abbreviatedOid": "ebe00a5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T15:31:32Z",
          "updatedAt": "2020-07-17T15:31:32Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Explain that because implementations may choose the delay based on dynamic information, they should have min/max bounds in the implementation (and can choose to ignore a branch).",
              "createdAt": "2020-07-17T15:31:32Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzU4NTE2",
          "commit": {
            "abbreviatedOid": "0e1e02d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T09:46:18Z",
          "updatedAt": "2020-08-12T09:46:19Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Is this clearer: \"\"Staggered racing attempts can proceed in parallel\"?",
              "createdAt": "2020-08-12T09:46:19Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc0NzY1",
          "commit": {
            "abbreviatedOid": "9f5537c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:16:41Z",
          "updatedAt": "2020-08-13T17:16:42Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done!",
              "createdAt": "2020-08-13T17:16:41Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc0ODU0",
          "commit": {
            "abbreviatedOid": "9f5537c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:16:49Z",
          "updatedAt": "2020-08-13T17:16:49Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Updated!",
              "createdAt": "2020-08-13T17:16:49Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc0OTU2",
          "commit": {
            "abbreviatedOid": "9f5537c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:16:58Z",
          "updatedAt": "2020-08-13T17:16:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "See update!",
              "createdAt": "2020-08-13T17:16:58Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTY2MTkz",
          "commit": {
            "abbreviatedOid": "9f5537c"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, looks good. (Just marked a nit.)",
          "createdAt": "2020-08-13T22:13:12Z",
          "updatedAt": "2020-08-13T22:14:01Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "be chose --> be chosen",
              "createdAt": "2020-08-13T22:13:12Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjUwNTU4",
          "commit": {
            "abbreviatedOid": "9f5537c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T15:04:07Z",
          "updatedAt": "2020-08-14T15:04:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nGenerally, the delay before starting a given child node ought to be based on the length of time the previously started child node is expected to take before it succeeds or makes progress in connection establishment. Algorithms like Happy Eyeballs choose a delay based on how long the transport connection handshake is expected to take. When performing staggered races in multiple branch types (such as racing between network interfaces, and then racing between IP addresses), a longer delay may be chosen for some branch types. For example, when racing between network interfaces, the delay should also take into account the amount of time it takes to prepare the network interface (such as radio association) and name resolution over that interface, in addition to the delay that would be added for a single transport connection handshake.\r\n```",
              "createdAt": "2020-08-14T15:04:07Z",
              "updatedAt": "2020-08-14T15:04:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjUwNzk0",
          "commit": {
            "abbreviatedOid": "eb089b2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T15:04:23Z",
          "updatedAt": "2020-08-14T15:04:24Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Done!",
              "createdAt": "2020-08-14T15:04:23Z",
              "updatedAt": "2020-08-14T15:04:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 607,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNTYzMTc3",
      "title": "Rename ListenClone",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/607",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #508",
      "createdAt": "2020-07-16T22:24:59Z",
      "updatedAt": "2020-07-21T09:09:46Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39bc00f2d03ca2e47bc52c26a6a898dc0494d631",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/listen-clone",
      "headRefOid": "71d197129172feabbacaaa124c3098ac166d990e",
      "closedAt": "2020-07-21T09:09:30Z",
      "mergedAt": "2020-07-21T09:09:30Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "500502e09109b41ceac379620f630c045b54c01a"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal: replace this with a way to query for a connection what the other connections in a group are (which will only happen passively for multi streamed protocols today).",
          "createdAt": "2020-07-17T15:52:27Z",
          "updatedAt": "2020-07-17T15:52:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Implemented #610; @mwelzl does this work?",
          "createdAt": "2020-07-19T00:09:04Z",
          "updatedAt": "2020-07-19T00:09:04Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm merging this now so I can proceed with re-structuring. It reflects what we discussed at the interim, so I don't think there should be more concerns.",
          "createdAt": "2020-07-21T09:09:05Z",
          "updatedAt": "2020-07-21T09:09:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNDIwMDAz",
          "commit": {
            "abbreviatedOid": "8d751cc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I hate the last sentence  :-)   LGTM otherwise.",
          "createdAt": "2020-07-17T07:05:43Z",
          "updatedAt": "2020-07-17T07:12:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm very sorry for only bringing this up here - I should have said it at the last interim, or at least write it in the issue ... somehow I overlooked this:\r\n\r\nI'm strongly *against* writing that this should fail in case the Connection doesn't support multi-streaming.\r\n\r\nFirst, I just don't think that should happen - we have produced lots of research on heuristics to detect common bottlenecks, and methods to combine congestion controls; we have shown that, with multiple TCP connections, it's quite possible to offer something VERY similar to multi-streaming (and this gets much easier when one can *assume* a common bottleneck, e.g. when all is tunneled over the same five-tuple, e.g. with a VPN; if you're interested, please get in touch  :)  ). So, at least, we shouldn't prohibit that.\r\n\r\nSecond, there are no guarantees offered regarding mux'ing, and e.g. priorities making a difference - so, why fail anyway? One just has to make sure that, if e.g. multiple TCP connections are below, calls that configure something on TCP connection 1 lead to a similar configuration for TCP connection 2.\r\n\r\nThird, it's an implementation detail; we shouldn't be so prescriptive here anyway.\r\n\r\nFourth, a (capital-c) \"Connection\" is what we expose, not what the underlying transport uses. FWIW, there could in fact be multiple underlying connections that we're multiplexing a single transfer on!\r\n\r\nThis is all easily fixed by removing the last sentence   :)",
              "createdAt": "2020-07-17T07:05:43Z",
              "updatedAt": "2020-07-20T15:47:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTI0MzUx",
          "commit": {
            "abbreviatedOid": "8d751cc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T09:49:17Z",
          "updatedAt": "2020-07-17T09:49:17Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "BTW - in fact, some text about how this would work in case of TCP below is what I wanted to write for issue #507",
              "createdAt": "2020-07-17T09:49:17Z",
              "updatedAt": "2020-07-20T15:47:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQzMTkw",
          "commit": {
            "abbreviatedOid": "8d751cc"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-17T10:18:26Z",
          "updatedAt": "2020-07-17T10:18:27Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I missed the interim discussion on this, but I agree with @mwelzl that ListenWithClone should not fail for transports without multi-streaming. That would break the Connection abstraction.",
              "createdAt": "2020-07-17T10:18:26Z",
              "updatedAt": "2020-07-20T15:47:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDQwNjU0",
          "commit": {
            "abbreviatedOid": "8d751cc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-18T08:06:26Z",
          "updatedAt": "2020-07-18T08:06:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "To make progress on this one: at the interim, I have been convinced that, at least with today's protocols (hmm hmm... what if connections connections arrive via the same tunnel, e.g. in a VPN case?), supporting connection coupling on the server side will not be possible.\r\n\r\nHowever, there's also no need to be so restrictive in the text in the interface draft, IMO. The final statement regarding multi-streaming could safely be removed here, and included in the implementation draft. That would be my proposal.",
              "createdAt": "2020-07-18T08:06:26Z",
              "updatedAt": "2020-07-20T15:47:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTA1MDYw",
          "commit": {
            "abbreviatedOid": "0c9586a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm ok with this modulo one suggested change",
          "createdAt": "2020-07-19T07:06:46Z",
          "updatedAt": "2020-07-19T07:08:46Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The last sentence again  :)\r\nI'd much prefer it if this could be written as an example.\r\n```suggestion\r\nPassive Connections can also be added to the same group -- e.g., when a Listener receives a new Connection that is just a new stream of an already active multi-streaming protocol instance.\r\n```\r\n",
              "createdAt": "2020-07-19T07:06:46Z",
              "updatedAt": "2020-07-20T15:47:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 611,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU0ODU2MDgw",
      "title": "Transport Properties and Security Parameters: Set() not Add()",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/611",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "If I understand correctly, we're staying with the current master.\r\nTherefore, here's my PR to fix #609 - I think we always want to override, and if we override, calling it Set() makes this clearer than Add().\r\n\r\nFor Security Parameters, perhaps it should be possible to add multiple identities, ciphersuites, etc.\r\nBut that's out of scope for this PR.",
      "createdAt": "2020-07-22T03:23:25Z",
      "updatedAt": "2020-09-11T16:33:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "22b8d80c12e228f1247c6bc7c930b8120d793b90",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/transport-properties-set-not-add",
      "headRefOid": "19db754577dafa0d614eea1c1fcf29e77a67f9bb",
      "closedAt": "2020-07-27T09:38:06Z",
      "mergedAt": "2020-07-27T09:38:06Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "794b7577864371847844e039b5d9f38d9159a21a"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@philsbn - I agree with the response by @theri in #612, which concludes: \"If I misunderstood, I think the best approach is to indeed allow specifying multiple (Preference, Enumeration) in a single Set() call.\"   KISS, I say :)",
          "createdAt": "2020-07-27T09:37:55Z",
          "updatedAt": "2020-07-27T09:37:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMTE4Nzc2",
          "commit": {
            "abbreviatedOid": "19db754"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Regarding continuing with the current master: yes, correct.\r\nAbout this PR: looks fine to me! Thanks a lot for doing this",
          "createdAt": "2020-07-22T08:48:24Z",
          "updatedAt": "2020-07-22T08:48:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNDk0OTU5",
          "commit": {
            "abbreviatedOid": "19db754"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-22T16:37:46Z",
          "updatedAt": "2020-07-22T16:37:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjY5NjY0",
          "commit": {
            "abbreviatedOid": "19db754"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for changing this \u2013 makes sense given that we removed the Intents. \r\n\r\nAfter applying this PR, we should consider whether setting multiple values is not only needed for Security Properties (as stated in #612), but also for Transport Properties like Interface and PvD. ",
          "createdAt": "2020-07-25T07:55:54Z",
          "updatedAt": "2020-07-25T07:55:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 613,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyOTk4NzIw",
      "title": "Typo",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/613",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-04T20:46:04Z",
      "updatedAt": "2020-08-05T03:08:39Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "794b7577864371847844e039b5d9f38d9159a21a",
      "headRepository": "martinduke/api-drafts",
      "headRefName": "patch-1",
      "headRefOid": "d1904dab0ef94f5df9ce39c803c0a0cab47bc0f6",
      "closedAt": "2020-08-05T03:08:39Z",
      "mergedAt": "2020-08-05T03:08:39Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "d82e15c873d16573ba37472f43a2b49e95d941cf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 614,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzMzMxOTIy",
      "title": "Edits on Section on Handling Path Changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/614",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "This is a first attempt to work on the section \"Handling Path Changes\" (see issue #545), however, I think more work is needed.\r\n\r\nTo be honest I don't fully understand this part and it would be could if someone else could provide more input about the System Policy part:\r\n\"For protocols that do not support multipath or migration, the Protocol Instances should be informed of the path change, but should not be forcibly disconnected if the previously used path becomes unavailable. An exception to this case is if the System Policy changes to prohibit traffic from the Connection based on its properties, in which case the Protocol Stack should be disconnected.\"\r\n\r\nAlso the last part about pooled connection should say more but I'm not sure what. We currently have now only this sentence left:\r\n\"Pooled Connections {{pooled-connections}} may add or remove underlying transport connections in a similar manner.\"\r\n\r\nAnd finally the originally issue #545 was also mentioning fallback which I didn't address yet but I have this feeling that that might need a separate section. Should I add a separate issue for that or is that already addressed somewhere and I missed it?",
      "createdAt": "2020-08-05T11:46:55Z",
      "updatedAt": "2021-05-26T11:51:01Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d82e15c873d16573ba37472f43a2b49e95d941cf",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-3",
      "headRefOid": "0341888f062877b8ab97957e6d52977c461593db",
      "closedAt": "2020-10-23T15:38:21Z",
      "mergedAt": "2020-10-23T15:38:21Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "69de07d0d562380b3130d9d7101bd76a92c2894a"
      },
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "II like your change - makes the text much clearer.\r\n",
          "createdAt": "2020-08-12T07:16:11Z",
          "updatedAt": "2020-08-12T07:16:11Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak : Is the path change problem resolved here - there's been stuff added on paths and policy since this.",
          "createdAt": "2021-05-26T11:51:01Z",
          "updatedAt": "2021-05-26T11:51:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NjU3MTA0",
          "commit": {
            "abbreviatedOid": "22ad6e6"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T07:29:02Z",
          "updatedAt": "2020-08-12T07:29:03Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nIn case of Pooled Connections {{pooled-connections}}, the transport system may add connections over new paths or different protocols to the pool if permissible based on the multipath policy and Selection Properties. In case a previously used path becomes unavailable, the transport system may disconnect all connections that require this path, but should not disconnect the pooled connection object exposed to the application. The strategy how is implementation specific, but should me consistent with the behaviour of multipath transports. \r\n```",
              "createdAt": "2020-08-12T07:29:02Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTUxMTMy",
          "commit": {
            "abbreviatedOid": "92ae963"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T21:41:50Z",
          "updatedAt": "2020-08-13T21:41:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Changing one IP address is a somewhat degenerate case\u2014the more interesting case is a new interface/link coming up or down, and that's what drives more significant multipath and migration events. I also think that focusing first on the case that make break connectivity is not a great way to start out.",
              "createdAt": "2020-08-13T21:41:51Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTUxOTMw",
          "commit": {
            "abbreviatedOid": "92ae963"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T21:43:26Z",
          "updatedAt": "2020-08-13T21:43:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is trying to explain the case where an address goes away due to an interface going down, but one shouldn't necessarily tear down the transport immediately. For example, if someone walks into an elevator, drops off of Wi-Fi, and then exits the elevator and comes back onto Wi-Fi, a non-migrating connection would do better to just wait for the network to come back, rather than tear down and interrupt a download.",
              "createdAt": "2020-08-13T21:43:26Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTQ3ODkx",
          "commit": {
            "abbreviatedOid": "92ae963"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:50:15Z",
          "updatedAt": "2020-08-14T12:50:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "My question was more about when you should ever even try to \"forcibly disconnect\" rather the just let the connection/protocol instance decide to close the connection...? And what the relevant policy bit here?",
              "createdAt": "2020-08-14T12:50:15Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTQ5OTIx",
          "commit": {
            "abbreviatedOid": "92ae963"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:53:28Z",
          "updatedAt": "2020-08-14T12:53:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I was trying to separate this in the cases where a) the protocol does not support multipath migration in any more and b) where is does (however also realising that full multipath support like MPTCP and path migration ala QUIC is maybe not that similar). So for a) the only interesting event is to know that a path somehow is confirmed to be failed and therefore the protocol instance can decide to close the connection immediately rather than waiting for a time out, no? ",
              "createdAt": "2020-08-14T12:53:29Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjM0NjY1",
          "commit": {
            "abbreviatedOid": "ee5347d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T15:27:35Z",
          "updatedAt": "2020-10-02T15:27:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Is this is about interfaces that fail, and what happens after. ... SCTP-PR, MP-TCP, QUIC, etc. I'm unsure I see why this is important except in corner cases, isn't this action like a reset (from the local network layer)?\r\n... but transports can also survive link up/down events, so not sure where this is heading?",
              "createdAt": "2020-10-02T15:27:35Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODAzNjMy",
          "commit": {
            "abbreviatedOid": "ee5347d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T07:58:06Z",
          "updatedAt": "2020-10-05T07:58:06Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I agree with Tommy - if the protocol implements fail-over in some way, then it can use this. Otherwise, the transport ought to treat this as a soft error. It should not alter its state (to disconnect) because this makes it think a part of the path might not work. ",
              "createdAt": "2020-10-05T07:58:06Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NDg5MjIz",
          "commit": {
            "abbreviatedOid": "ee5347d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T08:59:45Z",
          "updatedAt": "2020-10-09T08:59:46Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I also agree. I was asking if there every is a case where the protocol instance should be forcibly disconnect. If not we should rephrase this.",
              "createdAt": "2020-10-09T08:59:45Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDc5NjA5",
          "commit": {
            "abbreviatedOid": "ee5347d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T10:06:28Z",
          "updatedAt": "2020-10-12T10:06:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think if the case exists, it is likely a special design - or a function of a specific transport, in general I'd say leave the transport to make the correct action.",
              "createdAt": "2020-10-12T10:06:28Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzYyNjQ4",
          "commit": {
            "abbreviatedOid": "ee5347d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T15:14:58Z",
          "updatedAt": "2020-10-23T15:33:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nWhen a path change occurs, e.g., when the IP address of an interface changes or a new interface becomes available, the Transport Services implementation is responsible for notifying the application of the change. The path change may interrupt connectivity on a path for an active connection or provide an opportunity for a transport that supports multipath or migration to adapt to the new paths.\r\n```",
              "createdAt": "2020-10-23T15:14:58Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nIf the Protocol Stack includes a transport protocol that also supports multipath connectivity with migration support, the Transport Services implementation should also inform the Protocol Instance of potentially new paths that become permissible based on the Selection Properties passed by the application. A protocol can then establish new subflows over new paths while an active path is still available or, if migration is supported, also after a break has been detected, and should attempt to tear down subflows over paths that are no longer used. The Transport Services API provides an interface to set a multipath policy that indicates when and how different paths should be used. However, detailed handling of these policies is still implementation-specific. The decision about when to create a new path or to announce a new path or set of paths to the remote endpoint, e.g., in the form of additional IP addresses, is implementation-specific or could be be supported by future API extensions. If the Protocol Stack includes a transport protocol that does not support multipath, but does support migrating between paths, the update to the set of available paths can trigger the connection to be migrated. \r\n```",
              "createdAt": "2020-10-23T15:19:29Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nIn case of Pooled Connections {{pooled-connections}}, the transport system may add connections over new paths or different protocols to the pool if permissible based on the multipath policy and Selection Properties. In case a previously used path becomes unavailable, the transport system may disconnect all connections that require this path, but should not disconnect the pooled connection object exposed to the application. The strategy how is implementation-specific, but should be consistent with the behavior of multipath transports. \r\n```",
              "createdAt": "2020-10-23T15:20:55Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nFor protocols that do not support multipath or migration, the Protocol Instances should be informed of the path change, but should not be forcibly disconnected if the previously used path becomes unavailable.\r\n```",
              "createdAt": "2020-10-23T15:31:01Z",
              "updatedAt": "2020-10-23T15:38:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 615,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzNTM0NTg5",
      "title": "Nits in 5.2",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/615",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-05T17:24:33Z",
      "updatedAt": "2020-08-06T12:41:12Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d82e15c873d16573ba37472f43a2b49e95d941cf",
      "headRepository": "martinduke/api-drafts",
      "headRefName": "patch-2",
      "headRefOid": "7629963c1014405eb69c0288d192bcd16e7d5750",
      "closedAt": "2020-08-06T12:41:12Z",
      "mergedAt": "2020-08-06T12:41:12Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "d3356e1e0ba1fa0f77b0b93dc9f5e7ff5a9157dc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 616,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzNjE4NzU5",
      "title": "Fix typo",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/616",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-05T20:14:05Z",
      "updatedAt": "2020-08-06T12:40:16Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d82e15c873d16573ba37472f43a2b49e95d941cf",
      "headRepository": "martinduke/api-drafts",
      "headRefName": "patch-3",
      "headRefOid": "d14a4d4a06589471c3d44cb56d87e029671366ed",
      "closedAt": "2020-08-06T12:40:16Z",
      "mergedAt": "2020-08-06T12:40:16Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "02dac955fd44118e94209903bc89fffda6b5e8c4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 617,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY0MTcxMTE3",
      "title": "More nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/617",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-06T17:37:00Z",
      "updatedAt": "2020-08-09T13:43:03Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "d3356e1e0ba1fa0f77b0b93dc9f5e7ff5a9157dc",
      "headRepository": "martinduke/api-drafts",
      "headRefName": "patch-4",
      "headRefOid": "21ce8344b94d59be7df12a7a5adc3a52dba0a963",
      "closedAt": "2020-08-09T13:43:02Z",
      "mergedAt": "2020-08-09T13:43:02Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "a7394014a2309af542ffcb52a9d61ed257111965"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 633,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1MjQwMzEy",
      "title": "Clarify that amount of 0-RTT data varies by protocol, closes #580",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/633",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Removed phrasing that implies 0-RTT data is just one packet and added a reference to the Maximum Message Size with Connection Establishment property.\r\nAdded a sentence on how/when an implementation can set this property.",
      "createdAt": "2020-08-10T02:09:39Z",
      "updatedAt": "2020-08-14T09:25:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a7394014a2309af542ffcb52a9d61ed257111965",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "TE/fast-open-message-size",
      "headRefOid": "f23dc8ff0c932628ecaa18119f512506ca8aaad7",
      "closedAt": "2020-08-14T09:16:43Z",
      "mergedAt": "2020-08-14T09:16:43Z",
      "mergedBy": "abrunstrom",
      "mergeCommit": {
        "oid": "0019a3ff00f1146815c44560d774ef75ef19160e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzY4NjQy",
          "commit": {
            "abbreviatedOid": "f23dc8f"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Seems like a useful addition that resolves my issue.",
          "createdAt": "2020-08-12T10:00:36Z",
          "updatedAt": "2020-08-12T10:00:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1OTc5",
          "commit": {
            "abbreviatedOid": "f23dc8f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-13T17:18:22Z",
          "updatedAt": "2020-08-13T17:18:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTcwMzM2",
          "commit": {
            "abbreviatedOid": "f23dc8f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks @theri, looks fine, just added a question to see that I understood it right :)",
          "createdAt": "2020-08-13T22:22:08Z",
          "updatedAt": "2020-08-13T22:23:57Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "So this means the implementation would set it to the minimum size supported by all the protocols that may be raced? I think it is ok to leave the text as is, just want to check that I understand it correctly.",
              "createdAt": "2020-08-13T22:22:08Z",
              "updatedAt": "2020-08-13T22:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3Mjk0MjA3",
          "commit": {
            "abbreviatedOid": "f23dc8f"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T04:06:14Z",
          "updatedAt": "2020-08-14T04:06:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I don't think we actually specify that anywhere, so I kept it vague just saying it's based on the protocols, not what exactly the size should be. \r\nI guess that, unless the application sets 0-RTT as Required, there's no guarantee that the message will indeed be sent using 0-RTT. But if a message is sent, it should be the entire message and not just part of it, so setting the minimum probably makes sense.\r\nAnyone have an opinion on whether I should add this to the PR?",
              "createdAt": "2020-08-14T04:06:14Z",
              "updatedAt": "2020-08-14T04:06:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDM0NjIw",
          "commit": {
            "abbreviatedOid": "f23dc8f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T09:25:27Z",
          "updatedAt": "2020-08-14T09:25:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think the current text is fine. As you say I think this is a property that you would set as Preferred rather than Required anyway. If it needs to be the whole message or not I think depends on the implementation and the protocol, for TCP this does not hold. I have merged the pull request.",
              "createdAt": "2020-08-14T09:25:27Z",
              "updatedAt": "2020-08-14T09:25:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 637,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4MDIzMDUz",
      "title": "Clarify behaviour of Rendezvous()",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/637",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #584",
      "createdAt": "2020-08-14T14:42:22Z",
      "updatedAt": "2020-09-11T15:07:57Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "53c737ecffa5b67a5dc942874e1c669251784e97",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-rendezvous-detail",
      "headRefOid": "e27c26748f9d37d0368238897e6463faecce751d",
      "closedAt": "2020-09-11T15:07:54Z",
      "mergedAt": "2020-09-11T15:07:53Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "755a8b4859ff003f0d5049567169ec4028d39b8d"
      },
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl 7df2d9c should address this",
          "createdAt": "2020-09-11T11:15:49Z",
          "updatedAt": "2020-09-11T11:15:49Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\n   The Preconnection Object must be specified with both a Local Endpoint\r\n   and a Remote Endpoint, and also the transport properties and security\r\n   parameters needed for Protocol Stack selection.\r\n```\r\n\r\nTo `Rendezvous()` we need multiple local and remote candidates. Should this be represented as either:\r\n1) `Rendezvous()` taking two lists of `Preconnection` objects; or\r\n2) as two `Preconnection` objects each with multiple addresses, ports, etc.\r\n\r\nI suggest option 1, since this makes it easier to resolve a `Preconnection` to multiple preconnections, for NAT binding discovery.\r\n\r\nRelates to #571 but with also different types of endpoint.",
          "createdAt": "2020-09-11T12:07:47Z",
          "updatedAt": "2020-09-11T12:07:47Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like option 1 because it contains complexity.",
          "createdAt": "2020-09-11T12:46:27Z",
          "updatedAt": "2020-09-11T12:46:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjY0MDMw",
          "commit": {
            "abbreviatedOid": "8091217"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "modulo the do-we-want-to-bind-tightly-to-ICE question...",
          "createdAt": "2020-08-14T15:21:07Z",
          "updatedAt": "2020-08-14T15:27:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Do we need to specify this this tightly? (I think it's safe to do so, ICE is an approach, not a protocol. But we've pointedly avoided to make tight bindings to a Single Way Of Doing Things, so we should make this choice explicitly)",
              "createdAt": "2020-08-14T15:21:07Z",
              "updatedAt": "2020-09-11T15:02:36Z"
            },
            {
              "originalPosition": 13,
              "body": "also, if we're specifying ICE, this needs to be {{!RFC5245}}.",
              "createdAt": "2020-08-14T15:27:37Z",
              "updatedAt": "2020-09-11T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwOTk4MDY3",
          "commit": {
            "abbreviatedOid": "8091217"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T22:06:07Z",
          "updatedAt": "2020-08-19T22:06:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Will rephrase to be slightly more general: \"If there are multiple local or remote endpoints configured, then a rendezvous action will need to systematically probe reachability of those endpoints following an approach such as that used in Interactive Connectivity Establishment (ICE) {{?RFC5245}}.\"",
              "createdAt": "2020-08-19T22:06:07Z",
              "updatedAt": "2020-09-11T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzM2NzAz",
          "commit": {
            "abbreviatedOid": "f22333a"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-20T07:33:22Z",
          "updatedAt": "2020-08-20T07:33:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Should Local and Remote Endpoint be capitalised?",
              "createdAt": "2020-08-20T07:33:22Z",
              "updatedAt": "2020-09-11T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMDAzNjg0",
          "commit": {
            "abbreviatedOid": "f22333a"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-20T21:37:21Z",
          "updatedAt": "2020-08-20T21:37:21Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yes, will fix.",
              "createdAt": "2020-08-20T21:37:21Z",
              "updatedAt": "2020-09-11T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzOTA5Nzk0",
          "commit": {
            "abbreviatedOid": "27b7273"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks a lot for doing this, this is what I was hoping to see!\r\n\r\nSo, this LGTM except that I also request what @britram already said - maybe you could just do a quick check of the whole text (not just the sentence @britram quoted) to see if it's too prescriptive.",
          "createdAt": "2020-09-08T08:29:27Z",
          "updatedAt": "2020-09-08T08:29:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NzczNTgy",
          "commit": {
            "abbreviatedOid": "7df2d9c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-11T12:47:07Z",
          "updatedAt": "2020-09-11T12:47:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 638,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4MDY1OTk1",
      "title": "remove requirement for enumeration of enumerations",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/638",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "fixes #621",
      "createdAt": "2020-08-14T16:08:38Z",
      "updatedAt": "2020-09-11T16:31:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9b7fb3629588bb0320fd825b6df3bd92682f3e21",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "demust-enum-enum-621",
      "headRefOid": "c8bb09ca72ff4c2c87a2dff6545ba3d6ae4873de",
      "closedAt": "2020-09-09T08:26:57Z",
      "mergedAt": "2020-09-09T08:26:57Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "7d88c4d7bbea421c7786d48a7fa55309cb931509"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzYzNzY0",
          "commit": {
            "abbreviatedOid": "c8bb09c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T10:56:23Z",
          "updatedAt": "2020-08-17T10:56:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 639,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4Mjg3MDky",
      "title": "Clarify priority framework",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/639",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "fixes #619 \r\n\r\n(well, the priority framework is still confusing, this PR makes it clear that that is intentional, and why)",
      "createdAt": "2020-08-15T09:46:59Z",
      "updatedAt": "2020-09-18T07:00:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b4437f7f9050f86446a78ff69a81ab4c9bd71422",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "priority-619",
      "headRefOid": "a72e586226398b1c65aa627e6b3d2baa37f330a6",
      "closedAt": "2020-09-18T07:00:01Z",
      "mergedAt": "2020-09-18T07:00:01Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "757b217da062f4bf9cb96938d9620daed5e12ba1"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Martin (I think) said that he'd check this offline after the Sep 11 interim.",
          "createdAt": "2020-09-11T17:36:24Z",
          "updatedAt": "2020-09-11T17:36:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzU2OTg1",
          "commit": {
            "abbreviatedOid": "a65b420"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Ok for me  (and thanks for doing this!)",
          "createdAt": "2020-08-17T10:44:42Z",
          "updatedAt": "2020-08-17T10:55:19Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nusing the same approach as in {{msg-priority}}: when allocating available network\r\n```",
              "createdAt": "2020-08-17T10:44:42Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nway to share capacity that it sees fit. See {{priority-in-taps}}.\r\n```",
              "createdAt": "2020-08-17T10:45:50Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nand implementation of a wide variety of approaches to transmission priority in \r\n```",
              "createdAt": "2020-08-17T10:54:04Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nare left to the transport system implementation and/or the implementation of \r\n```",
              "createdAt": "2020-08-17T10:54:21Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDM0OTQ2",
          "commit": {
            "abbreviatedOid": "a3fd71f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Some nits, but I believe this addresses my concerns in the issue.",
          "createdAt": "2020-09-11T18:34:51Z",
          "updatedAt": "2020-09-11T18:44:03Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Not a big deal, but if this could live a little earlier in the document, that might help with comprehension.",
              "createdAt": "2020-09-11T18:34:51Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            },
            {
              "originalPosition": 20,
              "body": "Bikeshed alert: can we just call it the \"Priority Connection Property\" to go with the \"Priority Message Property\"?",
              "createdAt": "2020-09-11T18:36:31Z",
              "updatedAt": "2020-09-18T06:59:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 640,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4NjgzODI5",
      "title": "caveats on temporary local addresses",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/640",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "fixes #626 ",
      "createdAt": "2020-08-17T08:41:45Z",
      "updatedAt": "2020-09-11T16:52:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "755a8b4859ff003f0d5049567169ec4028d39b8d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "caveat-4941-626",
      "headRefOid": "e5e9ab461558a2fb2bfec5d018041fa0fc78fd25",
      "closedAt": "2020-09-11T16:52:24Z",
      "mergedAt": "2020-09-11T16:52:24Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "b4437f7f9050f86446a78ff69a81ab4c9bd71422"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair PTAL",
          "createdAt": "2020-09-11T16:07:39Z",
          "updatedAt": "2020-09-11T16:07:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4Mjg3NzIw",
          "commit": {
            "abbreviatedOid": "ed28fd4"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-17T08:59:49Z",
          "updatedAt": "2020-08-17T08:59:49Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't understand what is intended by \"using a stack\"... \"in the presence of network address translation\" ",
              "createdAt": "2020-08-17T08:59:49Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTQyNDA4",
          "commit": {
            "abbreviatedOid": "ed28fd4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T02:05:03Z",
          "updatedAt": "2020-08-18T02:05:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNjAwNDY3",
          "commit": {
            "abbreviatedOid": "ed28fd4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T15:56:27Z",
          "updatedAt": "2020-08-19T15:56:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I agree with Gorry. A NAT would have a similar impact as a temporary address; proof-of-address tokens would no longer function.",
              "createdAt": "2020-08-19T15:56:27Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTE2OTQ1",
          "commit": {
            "abbreviatedOid": "ed28fd4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-11T15:39:39Z",
          "updatedAt": "2020-09-11T15:39:39Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Comment from Martin: \"in the presence of NAT\" is wrong, should be removed",
              "createdAt": "2020-09-11T15:39:39Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTQ2ODA2",
          "commit": {
            "abbreviatedOid": "82e8e3e"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-11T16:20:33Z",
          "updatedAt": "2020-09-11T16:20:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nrely on to reduce initial latency.\r\n```",
              "createdAt": "2020-09-11T16:20:34Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTQ2ODQz",
          "commit": {
            "abbreviatedOid": "82e8e3e"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This looks pretty close ... check these words and submit.",
          "createdAt": "2020-09-11T16:20:38Z",
          "updatedAt": "2020-09-11T16:23:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "/as/because/ ... do not exist?",
              "createdAt": "2020-09-11T16:20:38Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            },
            {
              "originalPosition": 10,
              "body": "/may involve/might involve/",
              "createdAt": "2020-09-11T16:23:12Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            },
            {
              "originalPosition": 12,
              "body": "... /first-packet/packet/ ....can it be more than the first packet?",
              "createdAt": "2020-09-11T16:23:15Z",
              "updatedAt": "2020-09-11T16:49:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 641,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4NzIwMTcy",
      "title": "Editorial draft-ietf-taps-arch.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/641",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a set of proposed editorial changes, following a complete pass through the ID. It also offers a one-word fix for Issue #634\r\n\r\nThis is mainly minor editorial work - except for a proposal to move the definition of \"endpoint\" upwards, because I found discussion of endpoints in preconception relied upon the endpoint concept. I also think we should have made our meaning of endpoint more explicit, because it is a term that we use a lot.\r\n\r\nI also suggested we replaced the word \"options\" within the selection properties para, because a long time ago I think we changed the use of that word in this context  to \"properties\".",
      "createdAt": "2020-08-17T09:46:46Z",
      "updatedAt": "2020-08-20T09:11:26Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9b7fb3629588bb0320fd825b6df3bd92682f3e21",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-4",
      "headRefOid": "888bb5950c8bf6f73072c3d6b1b9257c92563fbe",
      "closedAt": "2020-08-18T02:03:43Z",
      "mergedAt": "2020-08-18T02:03:43Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7c0863daa503e8c25a80db070b63fe87ab33dd72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzY4Njkz",
          "commit": {
            "abbreviatedOid": "565e465"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "these LGTM",
          "createdAt": "2020-08-17T11:05:08Z",
          "updatedAt": "2020-08-17T11:05:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTQxMTI3",
          "commit": {
            "abbreviatedOid": "565e465"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T02:00:46Z",
          "updatedAt": "2020-08-18T02:02:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nAllowing applications to interact with messages is backwards-compatible with existing protocols and APIs because it does not change the wire format of any protocol. Instead, it gives the protocol stack additional information to allow it to make better use of modern transport services, while simplifying the application's role in parsing data. For protocols which natively use a streaming abstraction, framers ({{datatransfer}}) bridge the gap between the two abstractions.\r\n```",
              "createdAt": "2020-08-18T02:00:46Z",
              "updatedAt": "2020-08-18T02:02:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 642,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4ODAzNjE1",
      "title": "Set of updates to API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/642",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This contains a mix of normalising editorial work, corrections to text and other issues.",
      "createdAt": "2020-08-17T12:35:16Z",
      "updatedAt": "2020-09-11T16:32:57Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9b7fb3629588bb0320fd825b6df3bd92682f3e21",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-5",
      "headRefOid": "e29b135d94ce664d28406c22dbc7d7cf2c17a70d",
      "closedAt": "2020-09-07T20:29:26Z",
      "mergedAt": "2020-09-07T20:29:26Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "7dc1f7b0e645c9791f8ceec8e7109f0131797a5e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMzY1NjI3",
          "commit": {
            "abbreviatedOid": "ede777d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "What a major effort!  Thanks; I mostly agree, but I left a few comments and suggestions.",
          "createdAt": "2020-09-07T08:40:41Z",
          "updatedAt": "2020-09-07T09:56:42Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "```suggestion\r\ncongestion control in accordance with {{!RFC2914}}, {{!RFC2119}}. Also note that reliability\r\n```",
              "createdAt": "2020-09-07T08:40:41Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 295,
              "body": "The PR fails to compile because of these BCP references, so these should definitely be updated to refer to the RFC instead. Also, I changed to RFC2914 reference to normative in this suggestion - wouldn't that be more suitable?",
              "createdAt": "2020-09-07T08:41:21Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 581,
              "body": "```suggestion\r\nany corruption within the non-protected part of the message {{!RFC8085}}.\r\n```",
              "createdAt": "2020-09-07T08:45:38Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 581,
              "body": "The PR fails to compile because of these BCP references, so these should definitely be updated to refer to the RFC instead.",
              "createdAt": "2020-09-07T08:46:04Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 397,
              "body": "```suggestion\r\nupon receiving them {{!RFC8085}}.\r\n```",
              "createdAt": "2020-09-07T08:46:23Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 397,
              "body": "The PR fails to compile because of these BCP references, so these should definitely be updated to refer to the RFC instead.",
              "createdAt": "2020-09-07T08:46:28Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 22,
              "body": "Since the reason is connected to the error (like a parameter), saying \"a specific error\" here is a bit odd, as it might allow error 1 to inform about error 2?\r\nMaybe this could be clearer by rephrasing it in this direction: \"An error can provide an optional reason to give the application further details as to why it occurred.\"",
              "createdAt": "2020-09-07T08:50:15Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nbetween the Local and Remote Endpoints that provides Reliable Data Transfer, Preservation of\r\n```",
              "createdAt": "2020-09-07T08:51:01Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 199,
              "body": "To me, the original sentence is confusing, and \"might often be frequently used\" just highlights the strangeness of this more (\"often frequently\"?). Would it be better to just remove the first sentence altogether? It doesn't seem to add much value anyway.",
              "createdAt": "2020-09-07T09:04:22Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 259,
              "body": "```suggestion\r\nestablishment. This Message can potentially be received multiple times (i.e., multiple copies of the message data\r\n```",
              "createdAt": "2020-09-07T09:21:50Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 333,
              "body": "```suggestion\r\nProvisioning Domain (PvD) or categories of PVDs it wants to\r\n```",
              "createdAt": "2020-09-07T09:24:08Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 345,
              "body": "```suggestion\r\nimplementation- and system-specific, because there is currently no portable standard\r\n```",
              "createdAt": "2020-09-07T09:24:32Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 437,
              "body": "```suggestion\r\nand transmission of the first message can be combined in a single action {{initiate-and-send}}.\r\n```",
              "createdAt": "2020-09-07T09:30:55Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 484,
              "body": "```suggestion\r\nConnections will belong to the same group if the application previously called Clone.\r\n```",
              "createdAt": "2020-09-07T09:31:53Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 902,
              "body": "\"maximum packet segment size\" sounds like a strange concept. Is it a packet or a segment? Actually segment most commonly refers to TCP, doesn't it... being general, maybe this word shouldn't be used?",
              "createdAt": "2020-09-07T09:46:14Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            },
            {
              "originalPosition": 1074,
              "body": "This is a semantic change. If all data are delivered (e.g., consider that the where this error is firing has no more data to send), and then the other side does \"Abort\", a ConnectionError will still happen.\r\n\r\nSuggestion:\r\nA ConnectionError informs the application that one of the following things happened: 1) data could not be delivered after a timeout, or 2) the other side has aborted the Connection.",
              "createdAt": "2020-09-07T09:54:49Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDMxOTk2",
          "commit": {
            "abbreviatedOid": "ede777d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T10:09:42Z",
          "updatedAt": "2020-09-07T10:09:43Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Let's go ahead and do this.",
              "createdAt": "2020-09-07T10:09:42Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDM2NjM3",
          "commit": {
            "abbreviatedOid": "91a9de1"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T10:16:36Z",
          "updatedAt": "2020-09-07T10:16:37Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Understood, new text proposed",
              "createdAt": "2020-09-07T10:16:36Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDM5NjQw",
          "commit": {
            "abbreviatedOid": "fabded9"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T10:21:12Z",
          "updatedAt": "2020-09-07T10:21:12Z",
          "comments": [
            {
              "originalPosition": 1074,
              "body": ".. or both. Would this work: \"A ConnectionError informs the application that: 1) data could not be delivered after a timeout, or 2) the other side has aborted the Connection.\"",
              "createdAt": "2020-09-07T10:21:12Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDQ3MTQ4",
          "commit": {
            "abbreviatedOid": "bfbddb8"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T10:33:08Z",
          "updatedAt": "2020-09-07T10:33:09Z",
          "comments": [
            {
              "originalPosition": 1074,
              "body": "Resolved?",
              "createdAt": "2020-09-07T10:33:08Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTQwNzMy",
          "commit": {
            "abbreviatedOid": "510050e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T13:05:05Z",
          "updatedAt": "2020-09-07T13:05:06Z",
          "comments": [
            {
              "originalPosition": 1074,
              "body": "Yes, resolved. Thanks!",
              "createdAt": "2020-09-07T13:05:05Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTQ1NTU2",
          "commit": {
            "abbreviatedOid": "3060279"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T13:12:53Z",
          "updatedAt": "2020-09-07T13:12:53Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Now resolved",
              "createdAt": "2020-09-07T13:12:53Z",
              "updatedAt": "2020-09-07T19:43:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 643,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4ODYxMjEy",
      "title": "Add new sections on keep alives",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/643",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Responds to issue #628.",
      "createdAt": "2020-08-17T14:16:35Z",
      "updatedAt": "2020-10-02T15:22:07Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9b7fb3629588bb0320fd825b6df3bd92682f3e21",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-6",
      "headRefOid": "d2ffe4d9ac8d3055653718c316b8fc87fe5df6c6",
      "closedAt": "2020-10-02T15:22:07Z",
      "mergedAt": "2020-10-02T15:22:07Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "edad2b56c6c3ae6983bfa93bcfb08db2e4322e11"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim: to be turned into a single knob",
          "createdAt": "2020-09-11T15:45:20Z",
          "updatedAt": "2020-09-11T15:45:20Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging because GitHub UX is confusing. @gorryfair to go over these comments again and add a second PR if necessary.",
          "createdAt": "2020-10-02T15:22:00Z",
          "updatedAt": "2020-10-02T15:22:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDU2MjQ5",
          "commit": {
            "abbreviatedOid": "04cccb9"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-18T13:30:17Z",
          "updatedAt": "2020-08-18T13:40:39Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Where does BCP145 actually say that? Usually if the application sends keeps-lives with a higher rate that just mean the transport would never do as there is never a large enough idle time. So that's no problem. BCP145 says \"Keep-alive messages are NOT RECOMMENDED for general use.\" however this is specific recommendation for UDP as time-out usually have to be low(er) for UDP (than TCP).",
              "createdAt": "2020-08-18T13:30:17Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 45,
              "body": "If it's possible to set this to disable we actually don't need the boolean on/of switch at all. But don't we usually set it to 0 or -1 and say that's a special value (didn't check but should do this uniformly).",
              "createdAt": "2020-08-18T13:32:44Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 54,
              "body": "Actually BCP145 is only for UDP. The default value for TCP is much larger. I guess we need a way to just config please use the default of the transport you select...?",
              "createdAt": "2020-08-18T13:34:02Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 59,
              "body": "Not sure we need this as this might usually be the same as the usual retry count in other cases of loss...?",
              "createdAt": "2020-08-18T13:35:12Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 65,
              "body": "I guess this should be disabled as well if the other one is disabled by default.",
              "createdAt": "2020-08-18T13:35:31Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 67,
              "body": "This sentence makes me convince even more that we should leave this one to protocol specific parameters.",
              "createdAt": "2020-08-18T13:36:06Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 75,
              "body": "Not sure if this is an issue as you only send keep-alives when your are idle otherwise, so taking more time to detect failure is not a huge issue. However, not sure if you even should start the failover when you are idle anyway or just wait until new data is coming. But that might depend on the application (and protocol e.g. if 0-RTT is supported or not). I guess  that is a good discussion to have somewhere in some draft but maybe not here but somewhere in the implementation draft? ",
              "createdAt": "2020-08-18T13:39:13Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 77,
              "body": "Hm, just reading this now. That's not what I would have read as disabled. But it's that really a protocol-specific thing but then usually something that just there or not and can not be configured?",
              "createdAt": "2020-08-18T13:40:34Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDc0NTI1",
          "commit": {
            "abbreviatedOid": "04cccb9"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T13:49:55Z",
          "updatedAt": "2020-08-18T13:49:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I was trying to find a REF that said don't waste bandwidth on excessive keep-alives. BCP145 probably wasn't the best, I'm removing that - because it's not the focus at all - so do we need a REF?",
              "createdAt": "2020-08-18T13:49:55Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDg1Njg3",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:01:25Z",
          "updatedAt": "2020-08-18T14:01:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Sure, added that this was only datagrams. I think the RFC 5382 as I recall only says that with TCP you need to tune per app.",
              "createdAt": "2020-08-18T14:01:26Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDg2ODIw",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:02:35Z",
          "updatedAt": "2020-08-18T14:02:35Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I don't think it is the same number. I'm also not sure all Apps need the same number.",
              "createdAt": "2020-08-18T14:02:35Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDg4Mjk1",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:04:08Z",
          "updatedAt": "2020-08-18T14:04:08Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "That might be OK, but then it means the App needs to say if you use SCTP, do this, if you use TCP do that, if you use STUN do this, etc. I suspect this becomes messy very quickly.",
              "createdAt": "2020-08-18T14:04:08Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDkwOTAw",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:06:50Z",
          "updatedAt": "2020-08-18T14:06:50Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I'd be happy to remove line 1734...  I'll remove \"A larger value can increase the time to detect a path failure or to perform multipath fail-over {{multipath-policy}}. \"",
              "createdAt": "2020-08-18T14:06:50Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDkzNjkx",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:09:47Z",
          "updatedAt": "2020-08-18T14:09:47Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "You could also say \"infinite\" has the same semantics, since it carries on trying to probe for ever.... so maybe we don't need an explicit disable. I'll remove that also and see what is left.",
              "createdAt": "2020-08-18T14:09:47Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NDk1NDA0",
          "commit": {
            "abbreviatedOid": "c4363bc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T14:11:33Z",
          "updatedAt": "2020-08-18T14:11:33Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Not so. I think this is a real number, that you can use a safe robustness factor. The default when the method is enabled it should be this.",
              "createdAt": "2020-08-18T14:11:33Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTQ4Nzc4",
          "commit": {
            "abbreviatedOid": "fa9827e"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T15:05:21Z",
          "updatedAt": "2020-08-18T15:05:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Don't waste bandwidth is a good advise and BCP145 might be a good reference, however, it not relevant on switch layer you waste the bandwidth :-) ",
              "createdAt": "2020-08-18T15:05:21Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTUwODg4",
          "commit": {
            "abbreviatedOid": "fa9827e"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T15:07:39Z",
          "updatedAt": "2020-08-18T15:07:40Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "What I'm saying is that this is rather a protocol decision than an application one. Why do I as an application that is anyway idle need to control when the connection will be declared failed?",
              "createdAt": "2020-08-18T15:07:39Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNzYyOTQ5",
          "commit": {
            "abbreviatedOid": "fa9827e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me... I'm a bit uneasy about this but maybe it's because my thinking isn't grounded in a concrete use case...",
          "createdAt": "2020-09-04T15:43:18Z",
          "updatedAt": "2020-09-04T15:53:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I agree that this eliminates the need for the on/off switch (unless I'm mising something?). And no, special values 0 or -1 aren't used anymore, they have been replaced with more appropriate types.",
              "createdAt": "2020-09-04T15:43:18Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nwill only take effect when the underlying stack supports sending keep-alive packets. The special value\r\n```",
              "createdAt": "2020-09-04T15:44:52Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 51,
              "body": "Shouldn't the \"when\" in this sentence be an \"if\" ?   Both choices can be justified, I guess, as things can change over time, but I think that \"if\" matches the more common case.",
              "createdAt": "2020-09-04T15:45:57Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n: Numeric\r\n```",
              "createdAt": "2020-09-04T15:48:21Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            },
            {
              "originalPosition": 67,
              "body": "Yes, I think the intention is to design a generic, protocol-independent type of keep-alive here?  I certainly don't think \"if you use SCTP do this, if you use TCP do that\" etc. is how this should become.",
              "createdAt": "2020-09-04T15:50:38Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODg3NTI2",
          "commit": {
            "abbreviatedOid": "fa9827e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T08:00:54Z",
          "updatedAt": "2020-09-08T08:00:54Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": ".... and this is another case of a BCP reference that makes the compilation fail. Please replace the BCP reference with {{!RFC8085}}.",
              "createdAt": "2020-09-08T08:00:54Z",
              "updatedAt": "2020-09-11T16:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTk1Mzky",
          "commit": {
            "abbreviatedOid": "04cccb9"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:41:18Z",
          "updatedAt": "2020-10-02T14:41:18Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I am OK with /if/, however the surrounding text says /when/.",
              "createdAt": "2020-10-02T14:41:18Z",
              "updatedAt": "2020-10-02T14:41:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjA1MTg3",
          "commit": {
            "abbreviatedOid": "d2ffe4d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:52:33Z",
          "updatedAt": "2020-10-02T14:52:34Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Done in the text.",
              "createdAt": "2020-10-02T14:52:34Z",
              "updatedAt": "2020-10-02T14:52:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 644,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1NDI5NDAw",
      "title": "Clairified collections - closes #612",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/644",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2020-08-28T14:10:56Z",
      "updatedAt": "2020-09-11T16:32:53Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7c0863daa503e8c25a80db070b63fe87ab33dd72",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/collections",
      "headRefOid": "6a3b67250d4f3321b103dd7f407e36e3637fb37a",
      "closedAt": "2020-09-09T08:37:40Z",
      "mergedAt": "2020-09-09T08:37:40Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "53c737ecffa5b67a5dc942874e1c669251784e97"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I should have said: I approve this, modulo the changes requested by @theri.",
          "createdAt": "2020-09-08T08:13:09Z",
          "updatedAt": "2020-09-08T08:13:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODQ4ODE4",
          "commit": {
            "abbreviatedOid": "b28ba6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T16:02:35Z",
          "updatedAt": "2020-08-28T16:02:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  The actual representation, e.g. as a set or an array, is implementation-dependent.\r\n```",
              "createdAt": "2020-08-28T16:02:36Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODQ5Mzgz",
          "commit": {
            "abbreviatedOid": "b28ba6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T16:03:22Z",
          "updatedAt": "2020-08-28T16:03:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n- Collection: A group of one or more value types.\r\n```",
              "createdAt": "2020-08-28T16:03:22Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODQ5NDg1",
          "commit": {
            "abbreviatedOid": "b28ba6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T16:03:30Z",
          "updatedAt": "2020-08-28T16:03:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n  The composition of types and the order depends on the property and is fixed for the property.\r\n```",
              "createdAt": "2020-08-28T16:03:30Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODQ5OTc2",
          "commit": {
            "abbreviatedOid": "b28ba6b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T16:04:13Z",
          "updatedAt": "2020-08-28T16:04:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n- Tuple: A specific grouping of multiple value types.\r\n```",
              "createdAt": "2020-08-28T16:04:14Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NjE4OTc1",
          "commit": {
            "abbreviatedOid": "367ad69"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-31T13:32:33Z",
          "updatedAt": "2020-08-31T13:32:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I like your wording but would prefer to stress that these have to be of the same type.",
              "createdAt": "2020-08-31T13:32:33Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzU3OTM0",
          "commit": {
            "abbreviatedOid": "367ad69"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this PR!\r\nI agree with the definitions.\r\nJust a couple of suggestions on wording.",
          "createdAt": "2020-09-01T02:25:57Z",
          "updatedAt": "2020-09-01T02:34:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n- Tuple: An ordered grouping of multiple value types.\r\n```\r\nUnless \"specific\" really means something here? But I wouldn't know what it means.",
              "createdAt": "2020-09-01T02:25:57Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  The actual representation is implementation-dependent.\r\n```",
              "createdAt": "2020-09-01T02:27:19Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n  The composition of types and their order depends on the property and is fixed for the property.\r\n```",
              "createdAt": "2020-09-01T02:27:42Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n- Collection: An unordered grouping of one or more values of the same type.\r\n```\r\nThis way, it's consistent with Tuple being a \"grouping\" as well.",
              "createdAt": "2020-09-01T02:28:06Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            },
            {
              "originalPosition": 9,
              "body": "Not sure we need this sentence. It basically says \"The implementation is implementation-dependent\", doesn't it? \r\nAlso, a set is not necessarily ordered, while an array is usually ordered, I would say. So I think removing this sentence would make the entire thing less confusing.",
              "createdAt": "2020-09-01T02:28:53Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTU4NDky",
          "commit": {
            "abbreviatedOid": "367ad69"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T07:17:29Z",
          "updatedAt": "2020-09-08T08:11:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "As below, I don't think that sentence is necessary.",
              "createdAt": "2020-09-03T07:17:29Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            },
            {
              "originalPosition": 9,
              "body": "Looking at the context, I think this was added because it appears further up, for some other types - e.g.: \"Integer: can take positive or negative numeric integer values; range and representation is implementation-dependent.\"  For the first four types in the list, I think it makes sense though, as a way to stress that this is NOT prescribed as being the type with the same name in your language of choice.\r\n\r\nFor these new types, I agree with you: it doesn't add value to add this sentence, and I'd suggest to remove it.",
              "createdAt": "2020-09-03T07:19:33Z",
              "updatedAt": "2020-09-08T14:00:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MTcyMTQ0",
          "commit": {
            "abbreviatedOid": "6a3b672"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T14:02:10Z",
          "updatedAt": "2020-09-08T14:02:10Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I still see value in the sentence \u2013 especially stressing that the grouping is by design unordered, but might be implemented with some ordered data structure. ",
              "createdAt": "2020-09-08T14:02:10Z",
              "updatedAt": "2020-09-08T14:02:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjUzOTc3",
          "commit": {
            "abbreviatedOid": "6a3b672"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for incorporating my suggested changes. I think this can be merged now.",
          "createdAt": "2020-09-09T04:34:31Z",
          "updatedAt": "2020-09-09T04:35:02Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I'm not sure why it'd be necessary to stress how it could be implemented in the interface draft.\r\nBut I'm fine with merging this PR as it is.",
              "createdAt": "2020-09-09T04:34:31Z",
              "updatedAt": "2020-09-09T04:35:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 645,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1NDQzMTk3",
      "title": "Fix figure legends in API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/645",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Fixes #635",
      "createdAt": "2020-08-28T14:36:08Z",
      "updatedAt": "2020-09-11T16:32:54Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7c0863daa503e8c25a80db070b63fe87ab33dd72",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/fix-635",
      "headRefOid": "253d8aae06a97d3d4ee1ca10d7ade59f20e04c3a",
      "closedAt": "2020-09-09T08:29:06Z",
      "mergedAt": "2020-09-09T08:29:06Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "340b42a22b0f1f5113cb544287991d757755856c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODQ4MDg4",
          "commit": {
            "abbreviatedOid": "3634303"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-28T16:01:37Z",
          "updatedAt": "2020-08-28T16:01:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTQ5OTAx",
          "commit": {
            "abbreviatedOid": "3634303"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T07:03:47Z",
          "updatedAt": "2020-09-03T07:03:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n{: #tab-pref-levels title=\"Selection Property Preference Levels\"}\r\n```",
              "createdAt": "2020-09-03T07:03:47Z",
              "updatedAt": "2020-09-08T13:56:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 648,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4MDMwNzg4",
      "title": "Path Change event added",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/648",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "addresses #630 \r\n\r\nHowever, we now have this path change event but it seems we actually don't have an interface to the access the path object to figure out what exactly changed...?",
      "createdAt": "2020-09-02T17:42:59Z",
      "updatedAt": "2020-09-11T16:17:31Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7c0863daa503e8c25a80db070b63fe87ab33dd72",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-4",
      "headRefOid": "d4dc790e94af9a66d2459296ee5e9ce51c277b64",
      "closedAt": "2020-09-11T16:17:27Z",
      "mergedAt": "2020-09-11T16:17:27Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c130f66ecaf9aa1af8c83a1eb2199d88a958278a"
      },
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the  point is that we don't have an interface anymore to configure when and if a new subpath should be opened (or closed) for multipath transports, so I guess we need a way to provide the respective information to the application in order to potentially implement some logic there.\r\n\r\nWe can separate this out into two events if we are sure that these are the only two cases where we would want to trigger the application.",
          "createdAt": "2020-09-03T10:17:54Z",
          "updatedAt": "2020-09-03T10:17:54Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You say \"I guess\" and \"potentially\", which gives me the impression that you also don't know what that logic would be. I tend towards not including control over subpaths (or information about them, which may only be useful if the application can also exercise some control) unless we have a clear idea about how an application should use this.\r\n\r\n- or was there consensus already on adding such information? In this case, I'm not going to fight it, but clearly that's much more than just addressing #630.\r\n\r\nI didn't follow this particular discussion back when it happened, but there has to be a reason for RFC 6897 only being Informational... I've seen others presenting MPTCP APIs but somehow these things never made it into a standards recommendation. Maybe there's agreement somewhere that such logic should be placed below the application, not inside? Then that logic also seems more in line with TAPS to me.",
          "createdAt": "2020-09-03T10:33:47Z",
          "updatedAt": "2020-09-03T10:33:47Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\n> On 3 Sep 2020, at 11:18, mirjak <notifications@github.com> wrote:\n> \n> \ufeff\n> So the point is that we don't have an interface anymore to configure when and if a new subpath should be opened (or closed) for multipath transports, so I guess we need a way to provide the respective information to the application in order to potentially implement some logic there.\n> \n> We can separate this out into two events if we are sure that these are the only two cases where we would want to trigger the application.\n> \n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> \nMaybe I misunderstand?, I think this seems like rather MP centric thinking. There are other events, we talked on the call about an MPS change, and I am sure some people will wish to see ICMP events, etc. I am hopeful we can evolve to have more signals ... if we have an interface that can supply the events and so apps can expect to eat these.\n\nSo I think for me at least this is at best a reason come in the event, splitting this into multiple events seems a bad idea.\n\nGorry\n\n\n",
          "createdAt": "2020-09-03T10:44:05Z",
          "updatedAt": "2020-09-03T10:44:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTM0OTM0",
          "commit": {
            "abbreviatedOid": "4f4912b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm sceptical about this.\r\n\r\nYour comment about the application not being able to figure out what exactly happened made me wonder what this is really good for, beyond being notified of a PMTU change? We should add a bit of text explaining what the application is supposed to do with this information.\r\n\r\nThe following two use cases come to mind:\r\n1) The PMTU has changed => do some probing in the application. This is relevant for UDP only.\r\n2) Congestion control should perhaps restart, as whatever was probed before may now be wrong. This is relevant for applications doing congestion control only, i.e. when running over UDP.\r\n\r\nIn both of these cases, there is only a single path associated with the Connection. If the underlying protocol uses multiple paths, or can migrate, such stuff is up to the transport system, not the application.\r\n\r\nSo, in conclusion, I would suggest to notify the application *ONLY* in case there is only a single underlying path; actually, perhaps we should even make this a protocol-specific event, for UDP only.",
          "createdAt": "2020-09-03T06:42:57Z",
          "updatedAt": "2020-09-03T06:59:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThis event notifies the application when at least one of the paths underlying a Connection has changed. Changes occur\r\n```",
              "createdAt": "2020-09-03T06:42:57Z",
              "updatedAt": "2020-09-11T15:57:34Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nin a Connection Group and paths are added or removed, or a handover has been performed.\r\n```",
              "createdAt": "2020-09-03T06:49:43Z",
              "updatedAt": "2020-09-11T15:57:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTI5NjUz",
          "commit": {
            "abbreviatedOid": "30495cf"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-11T15:56:40Z",
          "updatedAt": "2020-09-11T15:56:40Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "cut \"in a Connection Group\"",
              "createdAt": "2020-09-11T15:56:40Z",
              "updatedAt": "2020-09-11T15:57:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTQzODA4",
          "commit": {
            "abbreviatedOid": "d4dc790"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-09-11T16:16:12Z",
          "updatedAt": "2020-09-11T16:16:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 649,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyMDUxODI1",
      "title": "Rename recvChecksumLen to draft-ietf-taps-interface.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/649",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-08T13:41:12Z",
      "updatedAt": "2020-09-11T16:32:55Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7dc1f7b0e645c9791f8ceec8e7109f0131797a5e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "da6142cf9701a36f0eb332f82f3b5d813167f0a5",
      "closedAt": "2020-09-08T13:44:47Z",
      "mergedAt": "2020-09-08T13:44:47Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5ae2ee199f259c5f80d6b5cf3df6675d9794f598"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 650,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyMTA0ODY1",
      "title": "Change Excessive Retransmit to Excessive Loss",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/650",
      "state": "CLOSED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "discuss"
      ],
      "body": "This PR is a try to apply the change discussed in Issue #647 \"retransmission vs. loss?\"\r\n\r\ncloses #647 if merged",
      "createdAt": "2020-09-08T14:55:08Z",
      "updatedAt": "2020-09-11T17:30:59Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "bdb27c654ef57bede839f43954755b12b8882d73",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/rexmit-to-loss",
      "headRefOid": "9c94a28290b78fb778bd2a8ff96a72a0a603580b",
      "closedAt": "2020-09-11T17:30:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess @mirjak's idea behind #647 was to challenge the hard separation between reliable and unreliable transport (as QUIC datagrams enables mixing both), while @mwelzl's two points, exactly refer to Minset and state that there is a need for a hard separation. \u2013 This gap is exactly why I marked this PR as discuss and we need to agree on.\r\n\r\n- If we want to accompany QUIC datagram in a more general framework, we have to talk about loss (and set aside whether it was compensated by retransmitting the packet), which slightly diverges from TCP semantics in a deterministic way.\r\n  We can still expose in a TCP specific properties/events \u2013 what this PR tries to do.\r\n- If we want to exactly match TCP as described in Minset, we need to separate retransmit and loss and either need to build ugly QUIC specific stuff or ignore QUIC datagrams.",
          "createdAt": "2020-09-10T08:14:21Z",
          "updatedAt": "2020-09-10T08:14:21Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not see why a separation of the events for reliable and unreliable transport is not aligned with QUIC datagrams? I think it makes sense to separate the two events as different information makes sense for reliable and unreliable transport. You will not ask to send something reliably and get it sent in a QUIC datagram? The underlying QUIC connection may carry both a reliable and an unrelaible TAPS connection, but it will still provide different semantics to the two.\r\n\r\nPerhaps what @mirjak was really after is that QUIC datagrams now provide additional information that we could expose.\r\n",
          "createdAt": "2020-09-10T08:55:24Z",
          "updatedAt": "2020-09-10T08:56:48Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See my suggestions in #647 - I think there's a pretty easy way to address both worlds, and this is what my text changes proposed (but they would all need to be applied together).",
          "createdAt": "2020-09-10T11:45:45Z",
          "updatedAt": "2020-09-10T11:45:45Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TODO after interim: Close this, make another PR to remove \"Excessive Retransm.\" (TCP, for Michael)",
          "createdAt": "2020-09-11T16:10:43Z",
          "updatedAt": "2020-09-11T16:10:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjYwOTM2",
          "commit": {
            "abbreviatedOid": "015c272"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-08T15:32:23Z",
          "updatedAt": "2020-09-08T15:32:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0ODAxOTM5",
          "commit": {
            "abbreviatedOid": "015c272"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I suggested many changes. They build upon the following premise:\r\n\r\n- for unreliable data transfer, we shouldn't assume that the underlying transport can allow a threshold to be configured (losing so many packets / sec), but just inform the application every time. The application can ignore these notifications, or decide to act depending on how many notifications have arrived, possibly per time interval, but these decisions should be application logic.\r\n- for reliable transfer, we need to apply a threshold based on retransmissions, or else we're not compatible with TCP.\r\n\r\nIf you agree with these two points, please accept all my suggestions, and then this should be good to go  :-)",
          "createdAt": "2020-09-09T08:58:06Z",
          "updatedAt": "2020-09-09T09:07:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "That doesn't work: data are either lost or not, exactly once. For compatibility with TCP, the threshold needs to be about retransmissions (see RFC 1122 section 4.2.3.5 for specifics). I suggest:\r\n\r\nThis property specifies whether an application considers it useful to be informed in case sent data was lost. In case of reliable data transfer, this is determined by having retransmitted the data more often than a certain threshold (see {{conn-excss-loss}} for configuration of this threshold).",
              "createdAt": "2020-09-09T08:58:07Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n### Retransmission Threshold before Excessive Loss Notification {#conn-excss-loss}\r\n```\r\n\r\nI'm keeping the anchor unchanged to avoid problems. It doesn't matter what the anchor is called as long as references work.",
              "createdAt": "2020-09-09T08:59:00Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n: retransmitNotifyThreshold\r\n```",
              "createdAt": "2020-09-09T08:59:25Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nFor reliable data transfer, this property specifies the number of retransmissions required to cause the application\r\n```",
              "createdAt": "2020-09-09T09:00:25Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nto be notified of `Excessive Retransmission`. In case of unreliable data transfer, configuring this threshold will not have any effect.\r\n```",
              "createdAt": "2020-09-09T09:01:23Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n### Notification of Loss {#prop-establish-excss-loss-notify}\r\n```",
              "createdAt": "2020-09-09T09:02:16Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n### Loss {#conn-excss-loss-notify}\r\n```",
              "createdAt": "2020-09-09T09:02:49Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nThis event notifies the application of loss events,\r\n```",
              "createdAt": "2020-09-09T09:02:59Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\ne.g., indicated by non-acked packets or (in case of reliable data transfer) retransmissions,\r\n```\r\n(note: if you don't accept this suggestion, still fix the typo: s/exessive/excessive)",
              "createdAt": "2020-09-09T09:03:58Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nConnection -> Loss<>\r\n```",
              "createdAt": "2020-09-09T09:04:40Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n`Notification of loss` property ({{prop-establish-excss-loss-notify}}).\r\n```",
              "createdAt": "2020-09-09T09:05:02Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NjY1MTM0",
          "commit": {
            "abbreviatedOid": "015c272"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T07:45:31Z",
          "updatedAt": "2020-09-10T07:45:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Okay\u2026 I agree on that one \u2013 In case we want to keep the semantics of this PR (see comment below) packets of the PR, it hast to say \r\n```suggestion\r\ninformed in case packets of the underlying transport protocol have been lost more often than a certain\r\nthreshold (see {{conn-excss-loss}} for configuration of this threshold).\r\n```\r\nor it makes no sense.",
              "createdAt": "2020-09-10T07:45:31Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NjY4NzIw",
          "commit": {
            "abbreviatedOid": "015c272"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T07:50:24Z",
          "updatedAt": "2020-09-10T07:50:24Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This makes sense for TCP, but not for QUIC with datagrams as @mirjak stated in issue #647 \u2013 QUIC still detects the loss, but does not necessarily retransmit the data. Each retransmit is usually also a loss event (ignoring re-ordering problems), but not the other way around.",
              "createdAt": "2020-09-10T07:50:24Z",
              "updatedAt": "2020-09-10T08:16:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NzE2ODU1",
          "commit": {
            "abbreviatedOid": "9c94a28"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T08:47:09Z",
          "updatedAt": "2020-09-10T08:47:09Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The transport data was not \"lost\" the IP packets were. I've changed my position to argue against having this metric at all. It is very transport specific. (see my comment in #647).",
              "createdAt": "2020-09-10T08:47:09Z",
              "updatedAt": "2020-09-10T08:47:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODM4Mjkz",
          "commit": {
            "abbreviatedOid": "9c94a28"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T11:33:33Z",
          "updatedAt": "2020-09-10T11:33:33Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Right - generally, the threshold doesn't make sense for QUIC, but my other proposed text changes eliminate the threshold's meaning for unreliable data transfer.",
              "createdAt": "2020-09-10T11:33:33Z",
              "updatedAt": "2020-09-10T11:33:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODQyNjMz",
          "commit": {
            "abbreviatedOid": "9c94a28"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T11:40:11Z",
          "updatedAt": "2020-09-10T11:40:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The IP packets are not known to the application (and I agree that \"data\" is too vague). This should really refer to Messages.",
              "createdAt": "2020-09-10T11:40:11Z",
              "updatedAt": "2020-09-10T11:40:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODQ0ODMx",
          "commit": {
            "abbreviatedOid": "9c94a28"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T11:43:34Z",
          "updatedAt": "2020-09-10T11:43:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "My point was that having a loss notification does make sense for unreliable transports like datagram in QUIC and therefore it should not only apply for reliable protocols.",
              "createdAt": "2020-09-10T11:43:35Z",
              "updatedAt": "2020-09-10T11:43:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODQ2OTUw",
          "commit": {
            "abbreviatedOid": "9c94a28"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T11:46:45Z",
          "updatedAt": "2020-09-10T11:46:45Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Yes! but the threshold makes no sense, and calling it \"Excessive\" doesn't, either. Keep the loss notification, but use the threshold for reliable transfers only, I say.",
              "createdAt": "2020-09-10T11:46:45Z",
              "updatedAt": "2020-09-10T11:46:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 651,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyNzA5NDE3",
      "title": "Editorial fixes to API draft.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/651",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Closes #625, #627, #629. Partially addresses #631.",
      "createdAt": "2020-09-09T09:35:09Z",
      "updatedAt": "2020-09-11T16:09:07Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "53c737ecffa5b67a5dc942874e1c669251784e97",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-editorial",
      "headRefOid": "6307526cc8fa153fbd44d4f6009dc0e0e280d215",
      "closedAt": "2020-09-11T16:09:03Z",
      "mergedAt": "2020-09-11T16:09:02Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "71911b992386af26df4f6945e40a1f1db431d2d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTM4Njc5",
          "commit": {
            "abbreviatedOid": "6307526"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-11T16:08:57Z",
          "updatedAt": "2020-09-11T16:08:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 652,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgyNzM2MDcz",
      "title": "Add a Group Connection Limit, extend Client example with clone.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/652",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #618.",
      "createdAt": "2020-09-09T10:17:40Z",
      "updatedAt": "2020-09-11T16:30:57Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "53c737ecffa5b67a5dc942874e1c669251784e97",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "nw-api-clone",
      "headRefOid": "b5a6fbbcd82136ba2957f8dd70974b0a05e38901",
      "closedAt": "2020-09-11T16:30:38Z",
      "mergedAt": "2020-09-11T16:30:38Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "6110720dea9147f1e1471de82da304dc112b0d79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTQxMzkz",
          "commit": {
            "abbreviatedOid": "b496a8c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-11T16:12:48Z",
          "updatedAt": "2020-09-11T16:12:58Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nThis property controls the number of Connections that may arrive from\r\n```",
              "createdAt": "2020-09-11T16:12:48Z",
              "updatedAt": "2020-09-11T16:13:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 653,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgzNzc3ODM3",
      "title": "Text on clone for TCP, and a little bit for SCTP. Closes #507.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/653",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #507. \r\nThis provides more detail on how to implement Clone with TCP, and clarifies that SCTP's \"Initiate\" should not yield a stream of an already existing SCTP Association in case \"activeReadBeforeSend\" is Preferred or Required.",
      "createdAt": "2020-09-10T12:23:43Z",
      "updatedAt": "2020-12-11T16:18:56Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "53c737ecffa5b67a5dc942874e1c669251784e97",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-cloning_tcp",
      "headRefOid": "859568e5bcb71193cd73b1b92ffd82f7ccee2e2a",
      "closedAt": "2020-12-11T16:18:51Z",
      "mergedAt": "2020-12-11T16:18:51Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "344cd5ba8d5e6520d0418e1ebe11e25a17007ba8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjE1Mjcz",
          "commit": {
            "abbreviatedOid": "fd5451f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Added a question for @mwelzl ",
          "createdAt": "2020-10-02T15:03:59Z",
          "updatedAt": "2020-10-02T15:05:29Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I do not understand the part about the Priority being ignored if connections traverse the same path?",
              "createdAt": "2020-10-02T15:03:59Z",
              "updatedAt": "2020-10-19T10:55:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjQwMjQw",
          "commit": {
            "abbreviatedOid": "fd5451f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T10:54:41Z",
          "updatedAt": "2020-10-19T10:54:41Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "These are two separate things, the semicolon was misleading (now fixed). My point was that the property can be ignored, as no guarantees are given to the application.",
              "createdAt": "2020-10-19T10:54:41Z",
              "updatedAt": "2020-10-23T11:33:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjQxODIy",
          "commit": {
            "abbreviatedOid": "859568e"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T16:18:21Z",
          "updatedAt": "2020-12-11T16:18:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n: Calling `Clone` on a TCP Connection creates a new Connection with equivalent parameters. These Connections, and Connections generated via later calls to `Clone` on one of them, form a Connection Group. To realize `entanglement` for these Connections, with the exception of `Connection Priority`, changing a Connection Property on one of them must affect the Connection Properties of the others too. No guarantees of honoring the Connection Property `Connection Priority` are given, and thus it is safe for an implementation of a transport system to ignore this property. When it is reasonable to assume that Connections traverse the same path (e.g., when they share the same encapsulation), support for `Connection Priority` can also experimentally be implemented using a congestion control coupling mechanism (see for example {{TCP-COUPLING}} or {{?RFC3124}}).\r\n```",
              "createdAt": "2020-12-11T16:18:21Z",
              "updatedAt": "2020-12-11T16:18:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjQyMDM2",
          "commit": {
            "abbreviatedOid": "859568e"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T16:18:38Z",
          "updatedAt": "2020-12-11T16:18:38Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I think this would have helped my confusion ",
              "createdAt": "2020-12-11T16:18:38Z",
              "updatedAt": "2020-12-11T16:18:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 654,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg0MTM4NjE5",
      "title": "Various nits and wordsmithing",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/654",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Feel free to cherry-pick. Some of these are self-explanatory; in other cases, I'll add a comment to explain the change.",
      "createdAt": "2020-09-10T17:34:54Z",
      "updatedAt": "2020-09-11T16:30:11Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c130f66ecaf9aa1af8c83a1eb2199d88a958278a",
      "headRepository": "squarooticus/api-drafts",
      "headRefName": "krose-nits-20200910",
      "headRefOid": "9553fb96096abebd51ea8c3392a0756b9374514d",
      "closedAt": "2020-09-11T16:30:11Z",
      "mergedAt": "2020-09-11T16:30:10Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c9c4d9a63996e15459a098abcff3f381e8182bd4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Nzc2MDMw",
          "commit": {
            "abbreviatedOid": "9f02cf2"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks a lot for doing this, several great catches there!  I made a few minor suggestions",
          "createdAt": "2020-09-11T12:50:28Z",
          "updatedAt": "2020-09-11T13:22:27Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks, to me this reads much better - but the sentence is still very long. As a possible way to shorten it, I wonder: do we really need the \"application design patterns\" part here? Couldn't we just remove this?",
              "createdAt": "2020-09-11T12:50:28Z",
              "updatedAt": "2020-09-11T16:29:47Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nsequence of Messages into a byte stream and vice versa ({{framing}}).\r\n```\r\n\r\nI like your suggestion better than what we have (the original just maps better to why this is really necessary in our own minds IMO), but now it seems awkward to begin with the byte stream... I just think that it reads a bit nicer with the change above.",
              "createdAt": "2020-09-11T13:12:58Z",
              "updatedAt": "2020-09-11T16:29:47Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nan application might provide a Message Framer, which can transform a\r\n```\r\nI suggest to keep the \"can transform\" because I don't think Message Framers *always* do this transformation.",
              "createdAt": "2020-09-11T13:16:07Z",
              "updatedAt": "2020-09-11T16:29:47Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nand eviction policies, e.g., LRU or FIFO.\r\n```\r\n\r\nI agree with your proposed change, but this missed something more - the sentence was broken (\"FIFO.may ...\"). ISTM that this extra sentence is not needed here anyway.",
              "createdAt": "2020-09-11T13:20:53Z",
              "updatedAt": "2020-09-11T16:29:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 673,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg1MDEyMDM4",
      "title": "Various edits, addressing Kyle's easier points.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/673",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #660, #663, #665, #670, #671. Partially addresses #655.\r\n\r\nA few comments:\r\n\r\n#655: Kyle's comment addressed (\"Connection Properties can be set on Preconnections\" fixed to \"Connection Properties can be set on Preconnections and Connections\")\r\n\r\n#660: I don't think the sentence explaining what an application could do upon an establisment error is necessary. I removed it, and now the text should be clearer.\r\n\r\n#663: All Connection Properties but \"Priority (Connection)\" are entangled. This is now clearly stated, not mentioned as an example.\r\n\r\n#665: Great catch. I now replaced this with an example that talks about ordering (clearly, requiring ordering from UDP will have to fail).\r\n\r\n#670: Reworded all the bits you point out, hopefully it's all clearer now.\r\n\r\n#671: first, there was a broken sentence, which seemed to miss \"will not occur\", so I added this. Then, I removed the last sentence which had the contradictory \"ConnectionError<> can occur after Closed<>, ...\" statement.\r\n",
      "createdAt": "2020-09-11T12:21:35Z",
      "updatedAt": "2020-09-11T16:15:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "53c737ecffa5b67a5dc942874e1c669251784e97",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-editorial-fixes",
      "headRefOid": "0de1dc9c4f2b344ead5eda2ed878bd4c451e8148",
      "closedAt": "2020-09-11T16:14:59Z",
      "mergedAt": "2020-09-11T16:14:59Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "e4099c784bfb67554f12d1c67c58e7c72a5235ae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 674,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg1MjU1MjMy",
      "title": "move text on early name binding to privacy consideration",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/674",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "closes #657",
      "createdAt": "2020-09-11T16:42:17Z",
      "updatedAt": "2020-10-02T15:12:43Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6110720dea9147f1e1471de82da304dc112b0d79",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-privacy-657",
      "headRefOid": "7015df90a2b64e860c99ab8fefd24a58303d88b7",
      "closedAt": "2020-10-02T15:12:43Z",
      "mergedAt": "2020-10-02T15:12:42Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "03580545f8e17ebc6505f399b7057b486cf0c608"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Mjg4MTEy",
          "commit": {
            "abbreviatedOid": "bfc1712"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM  (note: accept 1 nit fix before pressing Merge)",
          "createdAt": "2020-09-13T08:57:54Z",
          "updatedAt": "2020-09-13T08:59:22Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nconsiderations for the timing of this resolution are given in {{privacy-security}}.\r\n```",
              "createdAt": "2020-09-13T08:57:54Z",
              "updatedAt": "2020-10-02T15:10:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 678,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4NjYwNDQ0",
      "title": "Remove \"excessive retransmissions\". Closes #677.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/678",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #677.",
      "createdAt": "2020-09-17T13:15:31Z",
      "updatedAt": "2020-10-02T15:10:06Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b4437f7f9050f86446a78ff69a81ab4c9bd71422",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-remove_excessive_rexmit",
      "headRefOid": "c2cfa2570a54e52fbe5a4624bf38f49482e8ed2b",
      "closedAt": "2020-10-02T15:10:06Z",
      "mergedAt": "2020-10-02T15:10:05Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "7bd1ee82283489eb095f540120f76459c6ef4f8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTcyNDEy",
          "commit": {
            "abbreviatedOid": "c2cfa25"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This appears \"to do exactly as it says on the tin\", and removes the text. Looks good to me.",
          "createdAt": "2020-10-02T14:13:36Z",
          "updatedAt": "2020-10-02T14:13:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 679,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4NjY1NTc5",
      "title": "Clarifying example for partial receives. Closes #669.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/679",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #669.",
      "createdAt": "2020-09-17T13:22:39Z",
      "updatedAt": "2020-10-02T15:09:35Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b4437f7f9050f86446a78ff69a81ab4c9bd71422",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-partial_and_interleaved_msgs",
      "headRefOid": "92ae1ca7b91d245dbee1e6e0029efee85b27461e",
      "closedAt": "2020-10-02T15:09:29Z",
      "mergedAt": "2020-10-02T15:09:29Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "ac93522a170415a258c49348e9b5cccab9e144fc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNTk3MTI2",
          "commit": {
            "abbreviatedOid": "92ae1ca"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-17T13:31:21Z",
          "updatedAt": "2020-09-17T13:31:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 680,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5MTUwNTQ4",
      "title": "Inherit some msg defaults from the connection, and divide fragmentation into layers 3 and 4.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/680",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #666. Closes #667.\r\n",
      "createdAt": "2020-09-18T08:06:40Z",
      "updatedAt": "2020-10-23T15:39:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "757b217da062f4bf9cb96938d9620daed5e12ba1",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-msg-property-inherit",
      "headRefOid": "3c2150c47eddfeb7371ac18edded21ee31b131c7",
      "closedAt": "2020-10-23T15:39:34Z",
      "mergedAt": "2020-10-23T15:39:33Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "9dc8d06d08f7134e1f01a53cff8c8de913590b85"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNDkzMjk3",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T14:00:47Z",
          "updatedAt": "2020-09-18T14:00:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTc3MDgy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this heads in the correct direction, but I still have issues that I think need thought, and probably changes",
          "createdAt": "2020-10-02T14:19:17Z",
          "updatedAt": "2020-10-02T14:25:03Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Why only IPv4? IPv4 and IPv6 stacks can perform host fragmentation.\r\nI'd expected: \"When it does take effect, setting this property to true will inhibit network layer fragmentation by the endpoint, and will cause the IPv4 to set the Don't Fragment bis in the IP header, ...\r\n",
              "createdAt": "2020-10-02T14:19:18Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            },
            {
              "originalPosition": 79,
              "body": "Still slightly unhappy with the \"v4-centric\" words of \"DF field\" and would prefer something different and definitely to omit \"field\"",
              "createdAt": "2020-10-02T14:22:53Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            },
            {
              "originalPosition": 56,
              "body": "We could call this \"segmentation\"?\r\n- At least I would use \"segmentation\" here, to avoid the ever-returning argument about fragments being good/bad.",
              "createdAt": "2020-10-02T14:22:56Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            },
            {
              "originalPosition": 45,
              "body": "This isn't really about the feature of /transports/ ?????\r\n- Actually this is the transport service when the transport uses a network layer that supports....",
              "createdAt": "2020-10-02T14:23:23Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjEwMTE1",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:57:57Z",
          "updatedAt": "2020-10-02T14:57:57Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I think the concern was about making a false promise for the IPv6 case. As long as we say that the system will attempt to do this, that's okay.",
              "createdAt": "2020-10-02T14:57:57Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjExNTA0",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T14:59:32Z",
          "updatedAt": "2020-10-02T14:59:33Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Here I actually disagree: I don't think that \"segment\" is the word used by all transports? Seems rather TCP-specific to me...   IMO, there's a slight risk that \"segmentation\" is more cryptic to some readers than \"transport-layer fragmentation\", which is rather explicit about what exactly it is. Don't you think?",
              "createdAt": "2020-10-02T14:59:33Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjEyMTcy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T15:00:18Z",
          "updatedAt": "2020-10-02T15:00:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Oh, this shouldn't change, it's a reference to minset, where this is the exact wording!",
              "createdAt": "2020-10-02T15:00:18Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjUyNjg2",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T15:51:02Z",
          "updatedAt": "2020-10-02T15:51:03Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I don't agree - but I also don't care on which words we use, as long as we separate the definition of terms.",
              "createdAt": "2020-10-02T15:51:02Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTcyMDMy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-03T20:23:31Z",
          "updatedAt": "2020-10-03T20:23:31Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Ok - if I couldn't convince you, I feel that going with your view is the better choice. I'll adjust the text.",
              "createdAt": "2020-10-03T20:23:31Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA2MTQ0",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T07:59:57Z",
          "updatedAt": "2020-10-05T07:59:57Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "So, suggest: /This only takes effect when the transport uses a network layer that supports this functionality/",
              "createdAt": "2020-10-05T07:59:57Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA3NTAy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T08:01:48Z",
          "updatedAt": "2020-10-05T08:01:49Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Or... call it transport fragmentation, and explicitly say that it is about how a transport segments the data into network-layer packets.",
              "createdAt": "2020-10-05T08:01:48Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODE0OTkx",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T08:12:15Z",
          "updatedAt": "2020-10-05T08:12:15Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I suggest something like: \r\n\r\nWhen set to true, this property requests the network layer at the \r\nsending endpoint to not fragment the packets generated by the\r\ntransport layer.  When running over IPv4, setting this property to\r\ntrue will also cause the Don't Fragment bit to be set in the IP header\r\nWhen this property is set, an\r\nattempt to send a message size greater than the\r\ntransport's current estimate of its maximum packet size (`singularTransmissionMsgMaxLen`)\r\nwill result in a `SendError`.\r\nThis only takes effect when the transport and network layer \r\nsupport this functionality.",
              "createdAt": "2020-10-05T08:12:15Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjYwMTcy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T11:24:30Z",
          "updatedAt": "2020-10-19T11:24:30Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I'm following your suggestion above, which eliminates the IPv4 part of the sentence too, so I think this is settled.",
              "createdAt": "2020-10-19T11:24:30Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjYzMzMy",
          "commit": {
            "abbreviatedOid": "bbb7f79"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T11:29:12Z",
          "updatedAt": "2020-10-19T11:29:12Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Thanks!  I now used this text; because it says very clearly what is going on, it seemed ok to me to also call the heading \"No Segmentation\".",
              "createdAt": "2020-10-19T11:29:12Z",
              "updatedAt": "2020-10-19T11:29:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjY0MjQ2",
          "commit": {
            "abbreviatedOid": "3c2150c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T11:30:29Z",
          "updatedAt": "2020-10-19T11:30:29Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I went with \"No Segmentation\".",
              "createdAt": "2020-10-19T11:30:29Z",
              "updatedAt": "2020-10-19T11:30:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjkyNzQ1",
          "commit": {
            "abbreviatedOid": "3c2150c"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks like these issues have been addressed in this PR",
          "createdAt": "2020-10-19T12:11:16Z",
          "updatedAt": "2020-10-19T12:11:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 682,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2OTkwMjk2",
      "title": "Clarifying text on Framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/682",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Fixes #681.",
      "createdAt": "2020-10-02T15:47:20Z",
      "updatedAt": "2020-10-02T16:23:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "edad2b56c6c3ae6983bfa93bcfb08db2e4322e11",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-681-yay-framers",
      "headRefOid": "d11fdada2bfbf0b006dd6998e163f0979dee50db",
      "closedAt": "2020-10-02T16:23:14Z",
      "mergedAt": "2020-10-02T16:23:13Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "ffb8d63d1f3f292e83c509d04cf62782c13ce7f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjY0NTM1",
          "commit": {
            "abbreviatedOid": "703ed36"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T16:06:45Z",
          "updatedAt": "2020-10-02T16:06:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nConnection Properties except `Connection Priority` (see {{conn-priority}}) .\r\n```",
              "createdAt": "2020-10-02T16:06:46Z",
              "updatedAt": "2020-10-02T16:17:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 683,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3MDA4NTEx",
      "title": "Update draft-ietf-taps-interface.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/683",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "These are the minor typos that did not come through in the merged text.",
      "createdAt": "2020-10-02T16:21:45Z",
      "updatedAt": "2020-10-02T16:24:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "edad2b56c6c3ae6983bfa93bcfb08db2e4322e11",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-1",
      "headRefOid": "4c795b9fed49f9807f83ed591bf9677b9df4b7e3",
      "closedAt": "2020-10-02T16:24:20Z",
      "mergedAt": "2020-10-02T16:24:20Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "b6cd0b6b48cecd8959da10a93889961d898ec984"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 686,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1ODg2Mzc4",
      "title": "Connection properties: clarify that no guarantees are given for priority,\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/686",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "\u2026 and move the group limit connection property to the right place  (it was misplaced).\r\n\r\nNote that section 8.2.7 (\"Priority in TAPS\") already clarifies that a Connection Priority choice doesn't guarantee a certain outcome; this just adds another sentence in the paragraph describing the Connection property to make it clearer (less easy to miss).",
      "createdAt": "2020-10-19T11:11:29Z",
      "updatedAt": "2020-10-23T15:40:49Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "b6cd0b6b48cecd8959da10a93889961d898ec984",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-tiny-fixes",
      "headRefOid": "e43cf2b33ee3d40031ee9fb224bfdb7b62a1ce26",
      "closedAt": "2020-10-23T15:40:48Z",
      "mergedAt": "2020-10-23T15:40:48Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "b4fdf790cdfb6e7f5892b70c0dda0a22360e27c1"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks ready to merge to me.",
          "createdAt": "2020-10-19T12:12:12Z",
          "updatedAt": "2020-10-19T12:12:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjU3NzEz",
          "commit": {
            "abbreviatedOid": "225f5e5"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "2 minor comments",
          "createdAt": "2020-10-19T11:20:54Z",
          "updatedAt": "2020-10-19T11:21:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Sorry - but being picky - you can't control what \"may arrive\", you can control what might be \"accepted\"",
              "createdAt": "2020-10-19T11:20:55Z",
              "updatedAt": "2020-10-19T12:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjczODY2",
          "commit": {
            "abbreviatedOid": "225f5e5"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T11:44:33Z",
          "updatedAt": "2020-10-19T11:44:34Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "NiT: /in case of/in the case of/\r\nHowever: /this take the role of a/\r\n... why so obscure about a role? ... or is there more to be said? ... I don't understand whether there needs to be more said.\r\n\r\nInstead, would it be fair just to say:\r\n /For a multistreaming transport, this limits the numbering of allowed streams./",
              "createdAt": "2020-10-19T11:44:33Z",
              "updatedAt": "2020-10-19T12:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjg3ODEx",
          "commit": {
            "abbreviatedOid": "e43cf2b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T12:04:23Z",
          "updatedAt": "2020-10-19T12:04:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Fixed; I wrote \"...that can be accepted from ...\"",
              "createdAt": "2020-10-19T12:04:23Z",
              "updatedAt": "2020-10-19T12:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExNjg4MjM4",
          "commit": {
            "abbreviatedOid": "e43cf2b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T12:05:00Z",
          "updatedAt": "2020-10-19T12:05:00Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Done, except that I wrote \"number\" instead of \"numbering\"  (I don't understand the use of \"numbering\" here, but I believe that \"number\" should be ok anyway)",
              "createdAt": "2020-10-19T12:05:00Z",
              "updatedAt": "2020-10-19T12:05:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 687,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MzY0ODc5",
      "title": "Improve API abstraction #658",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/687",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "squarooticus"
      ],
      "labels": [
        "API",
        "ready for text"
      ],
      "body": "This is probably not done, but it's getting closer to separating the abstract API from concrete API details. Edits, comments, and criticism are welcome, of course.",
      "createdAt": "2020-10-20T00:21:49Z",
      "updatedAt": "2021-02-20T14:21:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f5df006a1437f0d86b05c405b38281464aeea3bd",
      "headRepository": "squarooticus/api-drafts",
      "headRefName": "658-krose-abstract",
      "headRefOid": "5740f83755b14e5aafb3e56ff8d38cde48fcd91d",
      "closedAt": "2021-02-20T14:21:24Z",
      "mergedAt": "2021-02-20T14:21:23Z",
      "mergedBy": "squarooticus",
      "mergeCommit": {
        "oid": "5740f83755b14e5aafb3e56ff8d38cde48fcd91d"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@britram - we could do this, and take notes of the suggested changes (which should be easy to apply) in an issue - but then again, how is this more efficient than updating this PR?",
          "createdAt": "2020-12-07T08:03:10Z",
          "updatedAt": "2020-12-07T08:03:10Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Add something about time durations to appendix? In C++ it could be a time duration object, while in C it might be seconds.",
          "createdAt": "2021-01-29T16:27:04Z",
          "updatedAt": "2021-01-29T16:27:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzc1MzAw",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for doings this, I think it's a good change. I added some comments, mostly about reordering things a bit. ",
          "createdAt": "2020-10-21T14:50:14Z",
          "updatedAt": "2020-10-21T14:57:37Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "I think this can be a bit confusing. It might be better to just keep the first two sentences here and move the last one to after the table (line 732).",
              "createdAt": "2020-10-21T14:50:14Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 160,
              "body": "Isn't this redundant (in most languages)? Wouldn't `if TransportProperties.Get(boolean_property) then` deliver the same result? In any case, this should be moved to Appendix A (convenience functions).",
              "createdAt": "2020-10-21T14:53:02Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 203,
              "body": "This might be too implementation specific for the API draft and would maybe better fit into the implementation draft. ",
              "createdAt": "2020-10-21T14:54:54Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NTEyMjE5",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I agree, this is very useful, thanks!  I inserted a few comments.",
          "createdAt": "2020-10-23T09:48:15Z",
          "updatedAt": "2020-10-23T10:04:06Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "\"Preference, which on Preconnection is an Enumeration with six possible values\" is a bit misleading. I think you have correctly identified that Preference types are only used on Preconnections, and this is good to point out. Just the way it appears here makes it sound like these are the six values that apply when a Preference type is used on a Preconnection, while it could take some other form if applied later (and the specific types for this case are not defined).  It's just a phrasing thing. I suggest to remove \"on Preconection\" from that sentence and separately state that the Preference type is only used on Preconnections.",
              "createdAt": "2020-10-23T09:48:15Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 133,
              "body": "I'm not sure if it makes sense to define \"Default\" as a preference level in its own right?  Wouldn't it be better to define five values, and write something like this below this table: \"In this document, 'Default' denotes the implementation's default preference level for this property.\"  ?",
              "createdAt": "2020-10-23T09:56:03Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 203,
              "body": "I'm not sure... it's about the interface, and explains the abstract notation - it can help the reader mentally translate the text into their own language of choice.\r\n\r\nFor instance, Kyle himself probably didn't like the use of \"-1\" as an error because that's not his programming mindset...  and he probably thought that such a section would have helped him, as a reader. I think that applies to others in the same way - so I believe that this fits here.",
              "createdAt": "2020-10-23T10:00:47Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 213,
              "body": "If anything here would rather fit in the implementation section, then it's perhaps this paragraph - because it has the words: \"it is recommended that implementations of this interface ...\"  - this is implementation guidance, then. Maybe re-formulate, or move it there.",
              "createdAt": "2020-10-23T10:03:38Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzY1MjYy",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T15:17:52Z",
          "updatedAt": "2020-10-23T15:17:52Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "The purpose of this PR is to make the abstract API actually abstract. -1 is a C-ism, and C is about as inabstract as languages get. :-)\r\n\r\nFWIW, I absolutely think the guidance in this appendix is appropriate for the interface draft because it's describing via example appropriate patterns for translating an abstract interface into an API in a real language, whereas the implementation draft is about how to implement the functionality that TAPS provides in a language-agnostic way.",
              "createdAt": "2020-10-23T15:17:52Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzczOTY2",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T15:24:30Z",
          "updatedAt": "2020-10-23T18:40:50Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It's subtle, but I agree with you that Default isn't a preference level. Probably the most abstract way to represent this would be to provide the ability to *unset* a preference, leaving it to the implementation to decide.",
              "createdAt": "2020-10-23T15:24:30Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            },
            {
              "originalPosition": 160,
              "body": "Agreed. This is one of the changes that I was least happy with, but I wanted to put something in to propose the general idea. Another problem here is that the property isn't necessarily of type boolean: on read, it's boolean, but on write it could be a preference level. I'm thinking that assigning a type to a property is the wrong way to describe the relationship of the input and output types to the property. The input is really a different object entirely from the output: the input is a request for some behavior in the protocol selection, while the output is a statement about the chosen protocol.",
              "createdAt": "2020-10-23T15:29:37Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzI3NDc0",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T12:29:12Z",
          "updatedAt": "2020-10-26T12:29:13Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "True, it might not be best to have different behaviour depending on wether the connection has been established or not. Perhaps it would be an option to be able to query the transport properties on a Connection object (i.e. Connection.get_property(property)) which will return what the property actually turned out to be while queries on the TransportProperties will always return the preference level. \r\nI am also unsure what the current PR text would mean for reusability of TransportProperties, if the preference level is overwritten with a bool after connection establishment I guess the same TransportProperties object could not be used in a second Preconnection.",
              "createdAt": "2020-10-26T12:29:12Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzQ1MjY3",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T12:54:00Z",
          "updatedAt": "2020-10-26T12:54:01Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Ooh... this might actually make the case for Get != Has: Get returns the original preference, while Has is defined only after protocol selection (e.g., throws an exception prior) and always flattens it to a boolean based on the selected protocol.",
              "createdAt": "2020-10-26T12:54:00Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4Mzg0ODE3",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T07:34:21Z",
          "updatedAt": "2020-10-28T07:34:21Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I agree that unsetting a variable could be a good concept, but I'd be afraid of the number of possible changes to the whole document that this approach might incur... is this worth it?\r\n\r\nAnyway, either way is fine with me; even just keeping \"Default\" as a preference level, I could live with, it's not a big deal IMO.",
              "createdAt": "2020-10-28T07:34:21Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4Mzg1MzUz",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T07:35:22Z",
          "updatedAt": "2020-10-28T07:35:22Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "So this is resolved; sorry for mentioning \"-1\", I realize it was a bad example  :)",
              "createdAt": "2020-10-28T07:35:22Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk3MjEw",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:36:24Z",
          "updatedAt": "2020-11-02T18:36:24Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I still think that would cause some problems if you reuse transport properties. What if you use the same TransportProperties object in two different Preconnections that lead to two Connections with different selected protocols? ",
              "createdAt": "2020-11-02T18:36:24Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MjQ1MTYz",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is a very good start; I'd actually be happy merging it and tweaking in follow-up PRs at this point.",
          "createdAt": "2020-11-19T09:48:37Z",
          "updatedAt": "2020-11-19T09:48:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MjY1NzM5",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T10:13:16Z",
          "updatedAt": "2020-11-19T10:13:16Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n- Preference, which is an Enumeration with six possible\r\n```",
              "createdAt": "2020-11-19T10:13:16Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNDk3NTA3",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-29T16:56:46Z",
          "updatedAt": "2020-11-29T16:56:47Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "That's solvable: Just make ```has``` a method on the connection",
              "createdAt": "2020-11-29T16:56:46Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjAyNDk5",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-09T13:52:56Z",
          "updatedAt": "2020-12-09T13:52:57Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I don't think we have many places where this would require a change \u2013 just in the examples and the description of Preconnection / TransportProperties. Default values stay default values, unset/reset just restores it.",
              "createdAt": "2020-12-09T13:52:56Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MjQzMTQ2",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-09T14:33:43Z",
          "updatedAt": "2020-12-09T14:33:43Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "When would you want to \"reset\" anything?",
              "createdAt": "2020-12-09T14:33:43Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjU3OTAz",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T16:37:37Z",
          "updatedAt": "2020-12-11T16:37:37Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Just agree/do anything ... this isn't super important!",
              "createdAt": "2020-12-11T16:37:37Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjU5MDQ2",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T16:38:59Z",
          "updatedAt": "2020-12-11T16:40:33Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "/may occur/ .. to me /occur/ seems better.",
              "createdAt": "2020-12-11T16:38:59Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NDgzMzkx",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T15:59:02Z",
          "updatedAt": "2021-01-28T15:59:02Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I just moved this; I didn't change the wording. FWIW, I like \"may occur\" both because some errors are synchronous, and because sometimes there aren't errors.",
              "createdAt": "2021-01-28T15:59:02Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NDg0NjI2",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T16:00:08Z",
          "updatedAt": "2021-01-28T16:00:08Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I'll just soften the language.",
              "createdAt": "2021-01-28T16:00:08Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NDk5MTMy",
          "commit": {
            "abbreviatedOid": "67ccd10"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T16:12:52Z",
          "updatedAt": "2021-01-28T16:12:52Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I think we need to discuss this one.",
              "createdAt": "2021-01-28T16:12:52Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTExNDAy",
          "commit": {
            "abbreviatedOid": "64c4463"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T16:24:49Z",
          "updatedAt": "2021-01-28T16:24:49Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Here and below I propose that these times are in seconds. Is that right, or do we want the unit of duration to be implementation-specific?",
              "createdAt": "2021-01-28T16:24:49Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTEyNjM3",
          "commit": {
            "abbreviatedOid": "64c4463"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T16:26:02Z",
          "updatedAt": "2021-01-28T16:26:02Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I removed `Default` here because of the new `Unset` method. Does there need to be a `Disabled` value for when keepalive functionality is off?",
              "createdAt": "2021-01-28T16:26:02Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDAxMDcw",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM now modulo open discussion. FWIW, I don't have a strong opinion regarding spec'ing seconds or leaving it implementation-dependent - there are pro's and con's...",
          "createdAt": "2021-01-29T16:09:53Z",
          "updatedAt": "2021-01-29T16:09:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDExODAy",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:21:48Z",
          "updatedAt": "2021-01-29T16:21:48Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I'd suggest removing this",
              "createdAt": "2021-01-29T16:21:48Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDEyMTUx",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:22:12Z",
          "updatedAt": "2021-01-29T16:22:12Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I'd suggest removing get and has here, and just specifying a bit more detail on Connection.GetProperties()",
              "createdAt": "2021-01-29T16:22:12Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDEyNjk1",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:22:43Z",
          "updatedAt": "2021-01-29T16:22:44Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I suggest adding a reference to Section 7 here, where it explains how to query the \"result\" of your Selection Properties on a Connection.",
              "createdAt": "2021-01-29T16:22:43Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDEzNjM0",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:23:43Z",
          "updatedAt": "2021-01-29T16:23:43Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "* Remove getters: Get, Has, Unset are not a required part of the API for a preconnection-phase Property object.\r\n* Clean up getting preferences in 4.2.2.",
              "createdAt": "2021-01-29T16:23:43Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDE0NjQz",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:24:52Z",
          "updatedAt": "2021-01-29T16:24:52Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Let's instead say that the representation of duration is implementation specific?",
              "createdAt": "2021-01-29T16:24:52Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDE0Njc4",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:24:54Z",
          "updatedAt": "2021-01-29T16:24:54Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Say something about the representation of duration being implementation-specific.",
              "createdAt": "2021-01-29T16:24:54Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDE0Nzk3",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:25:03Z",
          "updatedAt": "2021-01-29T16:25:03Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Same here",
              "createdAt": "2021-01-29T16:25:03Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDE1NDcz",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:25:47Z",
          "updatedAt": "2021-01-29T16:25:47Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Resolve in accordance with removing Unset",
              "createdAt": "2021-01-29T16:25:47Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDE2NDQx",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:26:51Z",
          "updatedAt": "2021-01-29T16:26:52Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "We could mention time duration representation here (can be a strong type in C++, in C it could be milliseconds as an integer).",
              "createdAt": "2021-01-29T16:26:51Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNjkyNDc4",
          "commit": {
            "abbreviatedOid": "76abdc0"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T22:41:53Z",
          "updatedAt": "2021-02-17T22:41:54Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Not sure if I got this right. Check the corresponding text in the updated PR.",
              "createdAt": "2021-02-17T22:41:54Z",
              "updatedAt": "2021-02-17T22:50:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzMTA1NjQ5",
          "commit": {
            "abbreviatedOid": "5740f83"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2021-02-18T11:18:37Z",
          "updatedAt": "2021-02-18T11:18:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzU0ODc2",
          "commit": {
            "abbreviatedOid": "5740f83"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me.\r\n\r\nStill, I think we should re-iterate the case of querying how to query selection results in a new PR.",
          "createdAt": "2021-02-20T14:01:53Z",
          "updatedAt": "2021-02-20T14:02:01Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "I think we should find a better solution for that \u2013 will try to make a PR once this one jas landed.",
              "createdAt": "2021-02-20T14:01:53Z",
              "updatedAt": "2021-02-20T14:02:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 692,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5MDcxMjE5",
      "title": "Remove vestigial reply concept from Post Sockets",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/692",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #668.",
      "createdAt": "2020-10-23T16:17:09Z",
      "updatedAt": "2020-10-23T16:36:42Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "584d73786328dd345dceb3bf03e63913b1785411",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "no-replies-668",
      "headRefOid": "9869df532c02f492c1d7cb7ee98c16f725b90380",
      "closedAt": "2020-10-23T16:36:42Z",
      "mergedAt": "2020-10-23T16:36:42Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "4d837f501aa35e56d6d5bb54673d89ee0e34a732"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 695,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5MTE1OTYx",
      "title": "Update minset and transport-security references to RFCs",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/695",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #691 ",
      "createdAt": "2020-10-23T17:44:03Z",
      "updatedAt": "2020-10-27T22:37:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "4d837f501aa35e56d6d5bb54673d89ee0e34a732",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/rfc-references",
      "headRefOid": "b08aa25a40d5378749a1a508e046fc0f89dd687d",
      "closedAt": "2020-10-27T22:37:19Z",
      "mergedAt": "2020-10-27T22:37:18Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "e5b46c6719d6c7b63380caeb64d257e6330feaca"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 696,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MTcwMzQx",
      "title": "Add pseudocode example for security cache management",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/696",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #659",
      "createdAt": "2020-11-02T16:20:29Z",
      "updatedAt": "2020-11-02T17:11:55Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e5b46c6719d6c7b63380caeb64d257e6330feaca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/sec-cache-example",
      "headRefOid": "129828ec529cb4e7c7c6c3a4e666aa6326a8f016",
      "closedAt": "2020-11-02T17:11:55Z",
      "mergedAt": "2020-11-02T17:11:55Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "85d1053929b8579d22945605cfee4c6741a3777a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNzg2MDkw",
          "commit": {
            "abbreviatedOid": "129828e"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T16:23:29Z",
          "updatedAt": "2020-11-02T16:23:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODIxMzIz",
          "commit": {
            "abbreviatedOid": "129828e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T16:59:42Z",
          "updatedAt": "2020-11-02T16:59:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 697,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MTkzMTU0",
      "title": "Clarify endpoint objects",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/697",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #571, closes #623",
      "createdAt": "2020-11-02T16:56:13Z",
      "updatedAt": "2020-11-02T19:01:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e5b46c6719d6c7b63380caeb64d257e6330feaca",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/endpoints",
      "headRefOid": "6e7d7276c2ac5ece73187e03af854d80e762244f",
      "closedAt": "2020-11-02T18:30:07Z",
      "mergedAt": "2020-11-02T18:30:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "059b5dd5ca6cf0fdefb65305e21abbe4e436fd00"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MaxF12 does the update about transport aliasing help?",
          "createdAt": "2020-11-02T18:17:03Z",
          "updatedAt": "2020-11-02T18:17:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODM3Njg5",
          "commit": {
            "abbreviatedOid": "5d914c4"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:15:54Z",
          "updatedAt": "2020-11-02T17:25:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Shouldn't this be WithPort(443)?",
              "createdAt": "2020-11-02T17:15:54Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            },
            {
              "originalPosition": 58,
              "body": "What exactly does this do?",
              "createdAt": "2020-11-02T17:24:02Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQ3MDk5",
          "commit": {
            "abbreviatedOid": "5d914c4"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, much needed change. I am just not quite sure on the mechanics of withProtocol yet.",
          "createdAt": "2020-11-02T17:27:23Z",
          "updatedAt": "2020-11-02T17:27:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQ4NDM3",
          "commit": {
            "abbreviatedOid": "5d914c4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I left a few comments, but nothing very important.",
          "createdAt": "2020-11-02T17:29:04Z",
          "updatedAt": "2020-11-02T17:38:32Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I stumbled over \"original hostname Remote Endpoint\". Is there a missing \"for the\" before \"Remote\"?",
              "createdAt": "2020-11-02T17:29:04Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nThe Resolve() action on a Preconnection can be used by the application to force\r\n```",
              "createdAt": "2020-11-02T17:29:54Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            },
            {
              "originalPosition": 90,
              "body": "I'm just wondering: is this limited to different protocols? Or would aliases also be a way to, e.g., bundle different IP addresses together to one \"alias\" ?\r\n\r\nIF it is strictly about protocols, maybe the wording could be a bit more explicit about this being the only use case. Maybe insert a limiting sentence here... like \"Aliases cannot be used to specify ... \" ?  These are just vague thoughts, do whatever you want with them. Totally fine to ignore all of this.",
              "createdAt": "2020-11-02T17:37:06Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODY2NDY1",
          "commit": {
            "abbreviatedOid": "5d914c4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:52:58Z",
          "updatedAt": "2020-11-02T17:52:58Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Yes this fits uncomfortably with the transport-agnostic principle of TAPS.",
              "createdAt": "2020-11-02T17:52:58Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc0OTYz",
          "commit": {
            "abbreviatedOid": "8ebaf03"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:04:39Z",
          "updatedAt": "2020-11-02T18:04:40Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Fixed!",
              "createdAt": "2020-11-02T18:04:40Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc1MDgy",
          "commit": {
            "abbreviatedOid": "8ebaf03"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:04:49Z",
          "updatedAt": "2020-11-02T18:04:50Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Good call, fixed",
              "createdAt": "2020-11-02T18:04:49Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc1MjA1",
          "commit": {
            "abbreviatedOid": "8ebaf03"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:05:00Z",
          "updatedAt": "2020-11-02T18:05:00Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Whoops, indeed!",
              "createdAt": "2020-11-02T18:05:00Z",
              "updatedAt": "2020-11-02T18:14:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc4NDcz",
          "commit": {
            "abbreviatedOid": "5d914c4"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T18:09:37Z",
          "updatedAt": "2020-11-02T18:09:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODgyMTY5",
          "commit": {
            "abbreviatedOid": "6e7d727"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:14:59Z",
          "updatedAt": "2020-11-02T18:14:59Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Moved this down to the aliasing section to clarify",
              "createdAt": "2020-11-02T18:14:59Z",
              "updatedAt": "2020-11-02T18:14:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODgzMzcy",
          "commit": {
            "abbreviatedOid": "6e7d727"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:16:36Z",
          "updatedAt": "2020-11-02T18:16:36Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "I'm not sure if we want to limit the alias to this use case only, so let's leave it a bit loose for now, and discuss more?",
              "createdAt": "2020-11-02T18:16:36Z",
              "updatedAt": "2020-11-02T18:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODg0NjMy",
          "commit": {
            "abbreviatedOid": "6e7d727"
          },
          "author": "MaxF12",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T18:18:23Z",
          "updatedAt": "2020-11-02T18:18:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTEzOTU2",
          "commit": {
            "abbreviatedOid": "6e7d727"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:01:18Z",
          "updatedAt": "2020-11-02T19:01:19Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "OK!  I like loose. But then, why not say something like \"can have an alternative definition with different identifiers.\" ?   Else, \"when using different protocols\" really sounds like the only possible case.  Just a thought - if you *want* it half-loose as it is, that's also ok with me.",
              "createdAt": "2020-11-02T19:01:18Z",
              "updatedAt": "2020-11-02T19:01:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 699,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIzODI5ODQ5",
      "title": "move CI pipeline to GitHub Actions; fix #698",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/699",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-19T10:13:57Z",
      "updatedAt": "2020-12-11T16:22:00Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "059b5dd5ca6cf0fdefb65305e21abbe4e436fd00",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "github-actions-migration",
      "headRefOid": "9b6fd08a31e4fb4481445144ebc2d5a339ff5443",
      "closedAt": "2020-12-11T16:22:00Z",
      "mergedAt": "2020-12-11T16:22:00Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3d2eaa2e40a1da0ff1746393bf3408d1a5f9cb01"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note for review: the tests will fail on CircleCI because they remove the CircleCI configuration; this is failing as intended.",
          "createdAt": "2020-11-19T10:15:47Z",
          "updatedAt": "2020-11-19T10:15:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 700,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxMzc4NDc4",
      "title": "Fix typos in taps-impl",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/700",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-03T00:40:14Z",
      "updatedAt": "2020-12-03T11:07:39Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "059b5dd5ca6cf0fdefb65305e21abbe4e436fd00",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "martinduke-patch-1",
      "headRefOid": "0ca2fcc462bd89e9fa3f39aa6714ff645fd6fa8a",
      "closedAt": "2020-12-03T11:07:24Z",
      "mergedAt": "2020-12-03T11:07:24Z",
      "mergedBy": "abrunstrom",
      "mergeCommit": {
        "oid": "fdd2cfabf7576be2f60d9b6dbb37c6a306953e84"
      },
      "comments": [
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Martin!",
          "createdAt": "2020-12-03T11:07:07Z",
          "updatedAt": "2020-12-03T11:07:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNjg5MzIy",
          "commit": {
            "abbreviatedOid": "0ca2fcc"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-03T08:02:00Z",
          "updatedAt": "2020-12-03T08:02:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNzE1NDIz",
          "commit": {
            "abbreviatedOid": "0ca2fcc"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2020-12-03T08:38:43Z",
          "updatedAt": "2020-12-03T08:38:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 709,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MTc4NDM5",
      "title": "Allow multiple Local and Remote Endpoints on Preconnection",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/709",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #675",
      "createdAt": "2020-12-10T19:03:11Z",
      "updatedAt": "2020-12-11T16:26:53Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdd2cfabf7576be2f60d9b6dbb37c6a306953e84",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-675",
      "headRefOid": "fcaaa463885a8d2478b8f05fa5e5c48b2dd15e7a",
      "closedAt": "2020-12-11T16:26:52Z",
      "mergedAt": "2020-12-11T16:26:52Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "51f888317f83127c85e0019d8dfdc8d3651c69fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODYwMjQ3",
          "commit": {
            "abbreviatedOid": "035d829"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM, thanks for doing this!  I only made one tiny suggestion (a nit, I think a sentence is broken as it stands).",
          "createdAt": "2020-12-11T07:38:05Z",
          "updatedAt": "2020-12-11T07:40:53Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nspecified by name, and a later call to Initiate() on the Preconnection\r\n```",
              "createdAt": "2020-12-11T07:38:05Z",
              "updatedAt": "2020-12-11T13:46:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTEwMzA3",
          "commit": {
            "abbreviatedOid": "fcaaa46"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:47:05Z",
          "updatedAt": "2020-12-11T13:47:06Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Fixed, thanks.",
              "createdAt": "2020-12-11T13:47:06Z",
              "updatedAt": "2020-12-11T13:47:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTE4Mjcz",
          "commit": {
            "abbreviatedOid": "fcaaa46"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T13:57:05Z",
          "updatedAt": "2020-12-11T13:57:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 710,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MjA3Nzk1",
      "title": "Update Rendezvous() description",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/710",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #676",
      "createdAt": "2020-12-10T19:45:34Z",
      "updatedAt": "2020-12-11T16:42:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdd2cfabf7576be2f60d9b6dbb37c6a306953e84",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-676",
      "headRefOid": "12710c40e6aed41d77aef2e173baa32410b3d621",
      "closedAt": "2020-12-11T16:42:19Z",
      "mergedAt": "2020-12-11T16:42:19Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "2499f770b1333cfbbaf06654d3106c02922e22fd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODY1NTMx",
          "commit": {
            "abbreviatedOid": "0ac97b8"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM, I made two tiny text suggestions; and thanks!",
          "createdAt": "2020-12-11T07:47:08Z",
          "updatedAt": "2020-12-11T07:55:08Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nthe Preconnection, and pass the resulting list of Local Endpoint candidates to\r\n```",
              "createdAt": "2020-12-11T07:47:08Z",
              "updatedAt": "2020-12-11T16:31:01Z"
            },
            {
              "originalPosition": 100,
              "body": "```suggestion\r\nChanges made to a Preconnection after Rendezvous() has been called do\r\n```",
              "createdAt": "2020-12-11T07:53:17Z",
              "updatedAt": "2020-12-11T16:31:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTEzMDI1",
          "commit": {
            "abbreviatedOid": "0ac97b8"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:50:40Z",
          "updatedAt": "2020-12-11T13:50:41Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Fixed.",
              "createdAt": "2020-12-11T13:50:41Z",
              "updatedAt": "2020-12-11T16:31:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTEzNDYw",
          "commit": {
            "abbreviatedOid": "0ac97b8"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:51:12Z",
          "updatedAt": "2020-12-11T13:51:12Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Fixed",
              "createdAt": "2020-12-11T13:51:12Z",
              "updatedAt": "2020-12-11T16:31:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjQ4MTAy",
          "commit": {
            "abbreviatedOid": "b08bb99"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T16:25:55Z",
          "updatedAt": "2020-12-11T16:25:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjYxNjQ5",
          "commit": {
            "abbreviatedOid": "12710c4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T16:42:00Z",
          "updatedAt": "2020-12-11T16:42:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 711,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MzIwNjM2",
      "title": "Update Rendezvous() examples",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/711",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #636",
      "createdAt": "2020-12-10T22:57:45Z",
      "updatedAt": "2020-12-11T16:44:21Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdd2cfabf7576be2f60d9b6dbb37c6a306953e84",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-636",
      "headRefOid": "ae23beebf9eed9e508f6dc8e9d86e6c6e4e4a229",
      "closedAt": "2020-12-11T16:44:21Z",
      "mergedAt": "2020-12-11T16:44:21Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "1f5c93fb28b9988ad4b68bd8f6623ae98358d83e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODkyMTMx",
          "commit": {
            "abbreviatedOid": "7d9a6fd"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, this looks good, but I inserted a few comments again...",
          "createdAt": "2020-12-11T08:32:35Z",
          "updatedAt": "2020-12-11T08:34:13Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think the underscore is too Python-specific here. Anyway it's clearer to remind the reader that this Resolve() call yields an array of local and remote specifiers. In this case, you want to ignore the remote specifiers, I see - so you could just assign them to a ResolvedRemote array and add a comment saying that, in this example, the ResolvedRemote array will be empty at this stage?",
              "createdAt": "2020-12-11T08:32:35Z",
              "updatedAt": "2020-12-11T13:56:25Z"
            },
            {
              "originalPosition": 44,
              "body": "Actually, ResolvedLocal is an array ... perhaps better to write it as such above, write a comment saying \"In this example, ResolvedLocal contains only one entry\", and then use ResolvedLocal[0] ?",
              "createdAt": "2020-12-11T08:33:48Z",
              "updatedAt": "2020-12-11T13:56:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTE0ODg5",
          "commit": {
            "abbreviatedOid": "7d9a6fd"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:53:01Z",
          "updatedAt": "2020-12-11T13:53:01Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "The underscore works in Python? TIL\r\n\r\nWill fix though",
              "createdAt": "2020-12-11T13:53:01Z",
              "updatedAt": "2020-12-11T13:56:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTE2OTQ1",
          "commit": {
            "abbreviatedOid": "7d9a6fd"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:55:30Z",
          "updatedAt": "2020-12-11T13:55:31Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "The intent is to pass the entire ResolvedLocal array. Will clarify.",
              "createdAt": "2020-12-11T13:55:30Z",
              "updatedAt": "2020-12-11T13:56:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTE5MjY2",
          "commit": {
            "abbreviatedOid": "ae23bee"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-11T13:58:21Z",
          "updatedAt": "2020-12-11T13:58:21Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Ok, so I learned something - clearly that's not its origin. Yes it works like that in Python  :)",
              "createdAt": "2020-12-11T13:58:21Z",
              "updatedAt": "2020-12-11T13:58:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjY0Mjcx",
          "commit": {
            "abbreviatedOid": "ae23bee"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T16:43:19Z",
          "updatedAt": "2020-12-11T16:43:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 719,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MzY3MDcz",
      "title": "2020-12-10 krose review suggested changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/719",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "These are mostly wording changes for clarification. Feel free to cherry pick.",
      "createdAt": "2020-12-11T00:35:26Z",
      "updatedAt": "2020-12-11T16:47:58Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdd2cfabf7576be2f60d9b6dbb37c6a306953e84",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "krose-impl-nits-20201210",
      "headRefOid": "3071aeacb4771be0e3c5737b3841244cffd7971f",
      "closedAt": "2020-12-11T16:47:58Z",
      "mergedAt": "2020-12-11T16:47:58Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "7dd9bb88c32e27d36390a646ed5b0c358c9cb6b2"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can't find any problems here - this looks good.",
          "createdAt": "2020-12-11T16:35:24Z",
          "updatedAt": "2020-12-11T16:35:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTY1MzEw",
          "commit": {
            "abbreviatedOid": "3071aea"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This LGTM, many thanks!",
          "createdAt": "2020-12-11T10:12:29Z",
          "updatedAt": "2020-12-11T10:12:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMjY4MTIw",
          "commit": {
            "abbreviatedOid": "3071aea"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T16:45:15Z",
          "updatedAt": "2020-12-11T16:45:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 720,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM3MTU0NzIy",
      "title": "Transport system -> Transport Services system",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/720",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #712",
      "createdAt": "2020-12-11T17:00:20Z",
      "updatedAt": "2020-12-16T21:46:22Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "7dd9bb88c32e27d36390a646ed5b0c358c9cb6b2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "9b2db0da75ca6178d0c066aed4978287cb620f71",
      "closedAt": "2020-12-16T21:46:22Z",
      "mergedAt": "2020-12-16T21:46:22Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5194aab67b4160ebd92273f901d5774a58bdb302"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl done!",
          "createdAt": "2020-12-11T17:56:14Z",
          "updatedAt": "2020-12-11T17:56:14Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also fixes #690 ",
          "createdAt": "2020-12-11T17:56:33Z",
          "updatedAt": "2020-12-11T17:56:33Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great, thanks!",
          "createdAt": "2020-12-14T09:12:25Z",
          "updatedAt": "2020-12-14T09:12:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzA3ODU3",
          "commit": {
            "abbreviatedOid": "ad8226f"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T17:11:19Z",
          "updatedAt": "2020-12-11T17:11:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzE4NDYw",
          "commit": {
            "abbreviatedOid": "ad8226f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Fantastic PR!  :-)   but I think this was about multiple occurrences of \"transport system\", not just this one",
          "createdAt": "2020-12-11T17:18:44Z",
          "updatedAt": "2020-12-11T17:18:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMTcxMDI0",
          "commit": {
            "abbreviatedOid": "9b2db0d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-14T09:12:38Z",
          "updatedAt": "2020-12-14T09:12:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 722,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0NzEyMDA4",
      "title": "SCTP stream mapping, addressing #708",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/722",
      "state": "CLOSED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #708.\r\nMore details on stream mapping. This also fixes references (hopefully), and adds one.",
      "createdAt": "2020-12-23T10:55:11Z",
      "updatedAt": "2021-04-12T11:08:45Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-clarify-sctp",
      "headRefOid": "317a330a7acdee0efa2812f5755dda2f0c257be9",
      "closedAt": "2021-04-12T11:08:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How do I prevent the new build error from happening?  Delete my repo and just checkout everything again?\r\n\r\nIt says:\r\n\"# No configuration was found in your project. Please refer to https://circleci.com/docs/2.0/ to get started with your configuration.\"\r\n\r\nI did pull the master, create a new branch, work there and push that. This used to work.",
          "createdAt": "2020-12-23T11:03:43Z",
          "updatedAt": "2020-12-23T11:03:43Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a good conversation to have, because the same questions (below) will need to be asked for QUIC. Maybe the answers are trivial for all of them, I don't know - shouldn't be hard to ckeck.\r\n\r\nCloning, groups, entanglement is just how we present it to the application. To implement this, the following questions need to be addressed:\r\n\r\n1. What happens when an application opens a stream-mapped Connection?\r\n2. How does scheduling / prioritization work?\r\n3. What happens when an application closes a stream-mapped Connection?\r\n4. (optional??) What will happen if the peer isn't aware of stream mapping, but it's just a native QUIC / SCTP / ... server?\r\n\r\nLINE ADDED - THIS FORCES NUMBERING TO BEGIN FROM 1 AGAIN\r\n1. is trivial for both SCTP and QUIC: we just start using a new stream, the semantics allow for that.\r\n2. should be easy, but in SCTP we need user message interleaving (\"I-DATA\"), or else we can get heavy HOL blocking delay when sending large messages. That's just an SCTP mechanism that we need so we can turn this on and be efficient; SCTP itself finds out if the peer supports it.\r\n3. here, SCTP's stream reset extension is semantically very close to \"closing\", and it's in line with our strict semantics towards the application. We need *something*... one could also only rely on timeouts perhaps, but then there's the obvious question: when should a Closed event fire? \"Never\" could be an answer, but that comes with resource wastage, or complex timeout management...  when the transport has a signal, surely that's good to use.\r\n4. I wrote \"optional\" above because I think we CAN decide that we don't care about this and assume that the application knows exactly what it's doing. Then we need nothing more. However, if we DO want to be able to allow, e.g., a client to connect to server X without specifying a protocol, and that server may be running native SCTP, or QUIC...  or it may be running TAPS... then what should happen?  In SCTP, the \"adaptation layer indication\" can let a client find out that the SCTP server really does expect stream mapping - and it's safe to use, because, if it's not supported, the client can just fall back. BUT this complicates matters ... for one, we'd need the application to tell us: \"I know I'm talking to a TAPS system\" vs. \"I know nothing, just try\" so that we could ignore this or disable mapping in case we can't negotiate this. We could also *always* require the negotiation, but that can become a deployment hurdle, I suppose.  Perhaps we can discuss item 4 at the interim?  I'm fine with removing this, but it's good to at least talk about this once, I think.",
          "createdAt": "2021-01-27T18:37:07Z",
          "updatedAt": "2021-01-27T20:57:33Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @mwelzl,\r\n\r\nWhat exactly do you mean by \"stream mapping\"? Are you referring to an application requiring stream IDs to map to specific purposes (e.g. certain messages in Stream 0 in RFC4666)?\r\n\r\nMy initial position is that applications defined in this way are tightly coupled to their transports and are therefore poor fits for TAPS. In contrast, HTTP/3 has no such mapping and I strongly suspect you could run it over SCTP or even entangled TCP connections.\r\n\r\nI am having some trouble understanding the numbering of your questions: some of them seem like answers to other questions?",
          "createdAt": "2021-01-27T20:09:24Z",
          "updatedAt": "2021-01-27T20:09:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke  - weird, it shows me 1-4, then 1-4 when editing, even without the line that I just added, but when I finished my comment, it turned into 1-8. Anyway, now the numbering is fixed, sorry!\r\n\r\nRegarding \"stream mapping\", this PR says: 'Mapping Connection objects to SCTP streams is called \"stream mapping\" and has additional requirements as follows.' - so it's the process of turning an application-level Connection into a stream of an underlying transport. Hopefully this clarifies some misunderstandings?",
          "createdAt": "2021-01-27T21:00:19Z",
          "updatedAt": "2021-01-27T21:00:19Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl -- thanks, that helps a lot.\r\n\r\n1) Agreed, although I find your phrasing a little odd and am not sure that the \"stream mapping\" term is a useful construct.\r\n\r\n2) We already have connection (stream) and message prioritization. If an SCTP implementation has limitations (no IDATA) that means it has to finish a message before starting another, I'm not sure that raises to the level of the API. If an SCTP implementation can do I-DATA chunks, it SHOULD use them in case high-priority messages/streams come in.\r\n\r\n3) Yes, SCTP should send a stream reset if it supports that extension. Any new connection object might technically reuse the stream, but that can be hidden from the application.\r\n\r\ntaps-interface says \"The Closed Event informs the application that the Remote Endpoint has closed the Connection. There is no guarantee that a remote Close will indeed be signaled.\" so I think this only fires if the peer says a stream reset.\r\n\r\n4) I don't understand what it means for the peer to be unaware of stream mapping. The TAPS API had *better* have a way of determining exactly what payload bits should go over the wire, and delivering the same to the application. As I said in my previous message, if the application is tightly coupled to the transport semantics, it should not be run over TAPS.",
          "createdAt": "2021-01-27T22:23:24Z",
          "updatedAt": "2021-01-27T22:23:24Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @martinduke  - I think we're converging!  Just to try to clarify some more, I'm answering your points with numbers (and I sure hope numbers stay intact now :-)  ):\r\n\r\n1. sorry for odd phrasing, I did my best to be as clear as possible; regarding the term, it's what we used to call it in the NEAT project, I think, but we can call this whatever fits better, I don't mind!\r\n2. Exactly; and I agree, it doesn't raise to the level of the API - was there something in this PR that made you think that this would affect the API? I'm happy to fix that!\r\n3. Yes, I agree\r\n4. Yes - I guess the concern is better phrased as being downward compatible to previous versions of the application which are not written against TAPS. This may well be an obscure wish - technically, it's not hard to support in SCTP, and that's why I put it there, but it's getting clear to me that the confusion + complexity disadvantage outweighs the minor technical gain. I don't mind removing this!",
          "createdAt": "2021-01-27T22:33:30Z",
          "updatedAt": "2021-01-27T22:33:30Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl I think the answer to question 4 is also related to the default setting of the _multistreaming_ transport property (sorry lost that mail thread). If the default is prefer we can perhaps not assume that the application is aware and then we would have to ensure that the other end supports it. Or do we assume that you only use Connection Groups if you know that the other end support multistreaming? ",
          "createdAt": "2021-01-28T16:14:27Z",
          "updatedAt": "2021-01-28T16:14:27Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And to add one more comment, I think the problem is that you are trying to support both cases now, the application knows that the peer supports multistreaming or the application does not know. But i do not see how taps can distinguish the two cases. We have to select one of them as our assumption and possibly adapt the default setting of the _multistreaming_ transport property accordingly i think.",
          "createdAt": "2021-01-28T16:22:51Z",
          "updatedAt": "2021-01-28T16:22:51Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom just to answer your question: \"Or do we assume that you only use Connection Groups if you know that the other end support multistreaming?\"  => that's how I thought it should work, yes - and that's also quite limiting, unless we make the distinction more explicit in the API.\r\n\r\nAnyway: I do believe we have reached consensus that this mechanism should be taken out. I have no problem doing this!  Glad to keep it simple!",
          "createdAt": "2021-01-28T19:56:57Z",
          "updatedAt": "2021-01-28T19:56:57Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mwelzl ok, good, i agree, based on that assumption the mechanism does not make sense and should be removed. \r\nmaybe we should add a sentence to 6.4 on connection groups in the API draft to make it explicit that if an application does not want multistreaming this can be controlled with the multistreaming transport property?",
          "createdAt": "2021-01-28T20:42:44Z",
          "updatedAt": "2021-01-28T20:42:44Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I removed the adaptation layer indication code point, as we discussed - and with this, the examples, as the idea is to only use this when both sides know what's going on.",
          "createdAt": "2021-02-17T11:34:49Z",
          "updatedAt": "2021-02-17T11:34:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi everyone - I think I addressed all the comments... BUT NOTE: this PR affects the interface draft, and this was an accident!\r\nIt's supposed to be only about impl. I tried to remove the interface draft from the PR, following these steps:\r\nhttps://gist.github.com/half2me/211d1d6b30a074479d181440af56c31f\r\nand now I *believe* that it's ok: it shows changes from the old version of the interface draft, at the time of first writing this PR, to the new version in the current master branch...  but I'd feel better about it if the file could just be removed from this PR altogether. I'm not sure how to do this...\r\n\r\nMy sincere apologies   :(",
          "createdAt": "2021-03-01T08:58:11Z",
          "updatedAt": "2021-03-01T08:59:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NDE0NTcy",
          "commit": {
            "abbreviatedOid": "f26a783"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I just tried to wrap my head around this and I've got a few questions, see below.",
          "createdAt": "2021-01-15T16:33:15Z",
          "updatedAt": "2021-01-15T17:06:02Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "If it requires an association to be in place, does this mean it always starts out mapping an entire SCTP association to a Connection, and then the mapping changes to stream mapping?\r\nBecause otherwise, this would be circular dependency, no?",
              "createdAt": "2021-01-15T16:33:15Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 76,
              "body": "Perhaps here a reference would be helpful. Is this adaptation layer indication what's described in RFC 5043?",
              "createdAt": "2021-01-15T16:34:06Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 87,
              "body": "If the native SCTP server is not a TAPS implementation, what would it even mean for the new Message to \"look like the first Message of a new Connection on the server side\"? I thought Message and Connection were TAPS concepts. Are they defined differently here?",
              "createdAt": "2021-01-15T16:37:10Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 83,
              "body": "The peer \"does not directly access SCTP streams\" means that instead it just sees the association as one object? Or that it just gets messages? Or something else?\r\n\r\nMaybe this would be easier to understand if the following example was illustrating a case that does work even if one side is TAPS and the other one isn't.",
              "createdAt": "2021-01-15T16:38:56Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n: Connection objects can be mapped to an SCTP association or a stream in an SCTP association.\r\nMapping Connection objects to SCTP streams is called \"stream mapping\" and has additional requirements as follows.\r\nThe following explanation assumes a client-server communication model.\r\n```\r\n\r\nI was confused for a bit here because I failed to make the connection between the first two sentences, but misunderstood \"stream mapping\" as a required process or something.\r\nThe suggested wording would have made it clearer to me.",
              "createdAt": "2021-01-15T16:52:13Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nReception of an adaptation layer indication notification with the same adaptation code point value\r\nthen indicates that the peer is capable of stream mapping.\r\n```\r\n\r\n\"Aware of\" sounded like it's supposed to be aware of a particular mapping. But this is just about signaling the general capability, right?",
              "createdAt": "2021-01-15T16:56:19Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nadaptation code point, stream mapping can still be\r\n```",
              "createdAt": "2021-01-15T16:57:35Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 90,
              "body": "When did this section become about disambiguating different protocols? I thought it was just about different associations/streams?",
              "createdAt": "2021-01-15T17:00:35Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3Mzc2MDYz",
          "commit": {
            "abbreviatedOid": "f26a783"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:13:01Z",
          "updatedAt": "2021-01-27T14:13:01Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Correct. Did you see text somewhere that gave a different impression?",
              "createdAt": "2021-01-27T14:13:01Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzgyOTA5",
          "commit": {
            "abbreviatedOid": "f26a783"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:19:37Z",
          "updatedAt": "2021-01-27T14:19:38Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "It is; I can add that. Note that this is all preceded, much earlier in the document, by:\r\n\"Below, terms in capitals with a dot (e.g., \"CONNECT.SCTP\") refer to the primitives with the same name in section 4 of {{!RFC8303}}.\"\r\nand RFC 8803 has LISTEN.SCTP with this parameter (and it has text pointing back to RFC 5043).",
              "createdAt": "2021-01-27T14:19:38Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3Mzg2ODQ4",
          "commit": {
            "abbreviatedOid": "d0d85c9"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:23:31Z",
          "updatedAt": "2021-01-27T14:23:31Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Regarding \"directly access\": an SCTP peer, using the SCTP API, would specify a stream number for receiving or sending - this is what I meant with \"directly access\". I can make this clearer, thanks!\r\n\r\nI liked having the TAPS example because I actually tested that and saw it running exactly as described, with NEATPy. I think I should add a third example though, before the one with two TAPS peers.",
              "createdAt": "2021-01-27T14:23:31Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3Mzk1MzI4",
          "commit": {
            "abbreviatedOid": "d0d85c9"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:31:14Z",
          "updatedAt": "2021-01-27T14:31:14Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "SCTP has (lower-case) messages too, but not Connections (which makes the end of this sentence weird, I agree!). I agree, this should be made clearer, thanks!",
              "createdAt": "2021-01-27T14:31:14Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTUzNjUx",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "So this is not what I expected at all.  I am rusty on the details of SCTP streams, but why all the special flags for stream mapping? Why not just use the concepts of cloning, connection groups, and entanglement to open new streams?",
          "createdAt": "2021-01-27T16:56:28Z",
          "updatedAt": "2021-01-27T16:56:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NjQyNTI2",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T18:52:49Z",
          "updatedAt": "2021-01-28T18:57:26Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "To make my comment more concrete, I'm not convinced that the code point is necessary.",
              "createdAt": "2021-01-28T18:52:49Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 90,
              "body": "I don't understand this failure mode. If for whatever reason the peer doesn't accept the stream, how is this different from the peer rejecting due to HTTP/2 or QUIC stream limits?",
              "createdAt": "2021-01-28T18:54:51Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 105,
              "body": "I don't think I agree with this. A non-8260 SCTP still provides stream multiplexing with some HOLB avoidance properties, even if it's not as good. This is your question (2), which I think we agreed on?",
              "createdAt": "2021-01-28T18:56:17Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 111,
              "body": "Please help someone who hasn't read the SCTP specs in 15 years: is there really no deconfliction when there is simultaneous open of a new stream ID?",
              "createdAt": "2021-01-28T18:57:12Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NjkxOTA0",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T19:57:45Z",
          "updatedAt": "2021-01-28T19:57:46Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah, I think we have consensus on that. Consider it gone.",
              "createdAt": "2021-01-28T19:57:45Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NjkzODgy",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T20:00:25Z",
          "updatedAt": "2021-01-28T20:00:26Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "No point discussing - it's related to the codepoint stuff that goes out.",
              "createdAt": "2021-01-28T20:00:25Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4Njk5NTQ0",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T20:08:17Z",
          "updatedAt": "2021-01-28T20:08:17Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Confused. Question 2 was \"close = stream reset\", 3 was \"I-DATA to avoid HOLB\".\r\nWhat is it you don't agree with? The \"SHOULD only\"?\r\n\r\nI'm sceptical because I believe that small messages could get enqueued behind HUGE other messages, and there's also no per-stream flow control, at least not in the absence of I-DATA. A native SCTP application may know what it's doing, but a TAPS application would just use Connections and get a blockage surprise. So that doesn't seem good to me.",
              "createdAt": "2021-01-28T20:08:17Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzAwOTQ5",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T20:10:21Z",
          "updatedAt": "2021-01-28T20:10:21Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "I wouldn't really know myself. This is how Felix Weinrank and Michael Tuexen implemented it in NEAT - so I figured that this must be necessary. I can check with them if there's really no other way... but if there were, they would probably have used it. This said, this is also a few years ago now.",
              "createdAt": "2021-01-28T20:10:21Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzI3NzQ1",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T20:48:37Z",
          "updatedAt": "2021-01-28T20:48:38Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I-DATA actually was question 2 :) But i agree it seems a bit risky to use multi-streaming without it.",
              "createdAt": "2021-01-28T20:48:37Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NzU0OTU5",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T21:27:49Z",
          "updatedAt": "2021-01-28T21:27:49Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Ahhh yes right, I looked at a response by @martinduke and he had changed the numbering. Tsk :)  First github turns the numbering into 1-8 for me, then this... sorry folks  :)",
              "createdAt": "2021-01-28T21:27:49Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NTA4MDg3",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for the recent changes, that already makes it clearer to me! I still haven't fully understood how stream mapping can still work without the peer application directly accessing SCTP streams, but it's possible I'm missing a larger picture here.",
          "createdAt": "2021-01-29T18:22:17Z",
          "updatedAt": "2021-01-29T18:46:17Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Yes, I was confused about this part when first reading it. But now with the changes to the above paragraph, it works for me.",
              "createdAt": "2021-01-29T18:22:17Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 76,
              "body": "You're right, in this context this is actually clear. Still I guess a reference to 8303 could be helpful here, e.g., \"see Section 3.3 of RFC 8303\".",
              "createdAt": "2021-01-29T18:31:27Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            },
            {
              "originalPosition": 83,
              "body": "> Regarding \"directly access\": an SCTP peer, using the SCTP API, would specify a stream number for receiving or sending - this is what I meant with \"directly access\".\r\n\r\nOk, so if the peer does not directly access SCTP streams, that means it's not specifying a stream number through the SCTP API? And still, stream mapping can be used, if the TAPS implementation is aware that the peer isn't specifying stream numbers?\r\nAdding some clarification sounds good to me, as does adding another example.",
              "createdAt": "2021-01-29T18:32:46Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDg5Mjc1",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T11:20:00Z",
          "updatedAt": "2021-02-17T11:20:01Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Oops, this actually all just goes away, as I remove the code point.",
              "createdAt": "2021-02-17T11:20:01Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDkxNDI4",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T11:22:47Z",
          "updatedAt": "2021-02-17T11:22:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I think that also this text should just go away, as we now assume that this is only used when the applications on both sides know what's going on. Removing it.",
              "createdAt": "2021-02-17T11:22:48Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDkyNjQ5",
          "commit": {
            "abbreviatedOid": "476c36d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T11:24:26Z",
          "updatedAt": "2021-02-17T11:24:26Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Also this text will be removed.",
              "createdAt": "2021-02-17T11:24:26Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDk5MzI2",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T11:33:25Z",
          "updatedAt": "2021-02-17T11:33:25Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "So - what is it we have and don't have agreement about?  The text now says MUST for the \"stream reset\" SCTP extension, as it allows to implement the equivalent of CLOSE (we could be less restrictive, but I fear that it makes things more complex... we have to invent timeouts for this; also, note that this hasn't been tested with an implementation - the only implementation that we have of doing this uses \"stream reset\").  For I-DATA, it says SHOULD.",
              "createdAt": "2021-02-17T11:33:25Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1ODU1MDI2",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T22:45:39Z",
          "updatedAt": "2021-02-22T22:45:39Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I'm afraid we've QUIC-optimized our model; we have connection close and abort, and connection group abort. For SCTP, we'd want connection group close and abort, and an optional connection abort, IIUC\r\n\r\nWe could decide to add connection group close; or, we could just use the lack of a connection (stream) close in SCTP to simply signify it in the API by closing all the connections/streams.\r\n\r\nPersonally, I think we should have graceful close and abort for connection groups and write something in the QUIC mapping about how the former is handled.",
              "createdAt": "2021-02-22T22:45:39Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2MTk1ODkz",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-23T10:38:34Z",
          "updatedAt": "2021-02-23T10:38:35Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "You say \"the lack of a connection (stream) close in SCTP\": but we do have stream reset, and it's practically the same. This is why we require it with a MUST, and this capability is negotiated with the peer by SCTP itself - so if we require it on one side, we have it. A stream reset is quite like a FIN.\r\n\r\nSo, I don't see why you'd need a group close for SCTP?  It may be a convenient thing to have, in general, sure, but I don't see what this has to do with SCTP in particular - being an API addition, I see this as separate from this PR, in fact.",
              "createdAt": "2021-02-23T10:38:35Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2ODk1NTAw",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-23T23:28:33Z",
          "updatedAt": "2021-02-23T23:28:33Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "yes, you're right; it's a clean close. It's the stream abort that we're missing.\r\n\r\nSo in theory a streaming protocol has four possible ending operations: connection close, stream close, connection abort, stream abort. QUIC has 3 of these; SCTP has 2, 3 with RFC 6525; HTTP/2 has all four. In some protocols these are half-closes or aborts, or full. TAPS currently has stream close, stream abort, and connection abort.\r\n\r\nSo I'm going to file a separate issue on this, because it's bigger than the SCTP mapping.",
              "createdAt": "2021-02-23T23:28:33Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2OTEzNDg2",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-24T00:03:14Z",
          "updatedAt": "2021-02-24T00:03:14Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "About stream abort: not quite, I think. Using a \"stream abort\" would mean that the TCP-like half-closed behavior wouldn't work - you couldn't send a stream reset and then expect to receive something on a stream. However, that isn't possible anyway, because SCTP streams are only unidirectional. And, there's only a guarantee of a notification by a returning \"stream reset\" because we define it in this PR.\r\n\r\nI agree that this is bigger and should be separate from this PR... but what's your plan?   Do we really have a big problem here?  In the end, it's a matter of having the right semantics at the API level. This began with just picking the strictest possible semantics: no half-closed connections, calling \"close\" means that what the app already gave to the transport system for transmission before the call will still be sent, but the app cannot expect to send *or* receive anything after this call. This way, SCTP (which doesn't allow half-closed associations) is covered, and the behavior is \"correct\" for TCP as well. These semantics also work for SCTP streams with stream reset as above.\r\n\r\nSo... altogether, I thought we'll be safe if we just go strict.\r\n\r\nNow, quite recently, the wording was changed a bit, because of the need to support TCP half-closed connections (which is implemented via the \"Final\" Message Property). I felt a bit uneasy about this change, but in the end I couldn't see how things would go wrong with the wording that we now have in the API draft.\r\n\r\nMy high-level view is that we still have this rather strict thing, and then there is the option to use \"Final\", with no guarantee of it working (because we don't know if we get a protocol that supports half-closed connections). But there may be a devil in the details on how we worded it... definitely worth another careful look.",
              "createdAt": "2021-02-24T00:03:14Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzM5NzUy",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-02-26T16:29:42Z",
          "updatedAt": "2021-02-26T16:29:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This is incomplete?",
              "createdAt": "2021-02-26T16:29:42Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5OTU5NDcz",
          "commit": {
            "abbreviatedOid": "d7bb5e6"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T21:36:40Z",
          "updatedAt": "2021-02-26T21:36:40Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Argh!  More importantly, it doesn't belong here - this is an accident  :(   will fix",
              "createdAt": "2021-02-26T21:36:40Z",
              "updatedAt": "2021-03-01T08:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MzMyMTEw",
          "commit": {
            "abbreviatedOid": "317a330"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T19:24:29Z",
          "updatedAt": "2021-04-06T19:24:30Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I think this reference is no longer used, and should be removed.",
              "createdAt": "2021-04-06T19:24:29Z",
              "updatedAt": "2021-04-06T19:24:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTI0NTE2",
          "commit": {
            "abbreviatedOid": "317a330"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T15:14:23Z",
          "updatedAt": "2021-04-09T15:14:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "ACK, will do this in the new & clean PR that replaces this one.",
              "createdAt": "2021-04-09T15:14:23Z",
              "updatedAt": "2021-04-09T15:14:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 723,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzMDkzODQ4",
      "title": "Allow disuse of identifiers in a connection group",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/723",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "There are many ways to do this, but this one mimics the \"private browsing\" paradigm\" as I understand it.\r\n\r\nResolves #706.",
      "createdAt": "2021-01-12T00:02:58Z",
      "updatedAt": "2021-01-29T16:55:17Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "martinduke/api-drafts",
      "headRefName": "flush-interface",
      "headRefOid": "d288e28af23444222e0c9a7ce4ec54f8bb3d43c4",
      "closedAt": "2021-01-29T16:55:17Z",
      "mergedAt": "2021-01-29T16:55:17Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f6e0736df055b5a87b52b315cadb7cd61e89a193"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \r\n> \r\n> I like this approach for the simplicity, but it still solves only half of the problem we have with connection groups vs. connection contexts. I am fine with merging this, but IMHO it does not fully resolve #706.\r\n\r\nCan you say more? I read #706 as specifically about flushing state, not Connection Group vs. Connection issues generally. This is not literally \"flushing\" the state but I've update taps-interface to reflect this design while, I think, preserving the spirit of the original text.",
          "createdAt": "2021-01-28T16:25:02Z",
          "updatedAt": "2021-01-28T16:25:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MDE1NTg3",
          "commit": {
            "abbreviatedOid": "c9acd0d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "A very nice approach IMO, thanks for doing this",
          "createdAt": "2021-01-12T08:01:38Z",
          "updatedAt": "2021-01-12T08:01:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4MzYzNTU2",
          "commit": {
            "abbreviatedOid": "c9acd0d"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like this approach for the simplicity, but it still solves only half of the problem we have with connection groups vs. connection contexts. I am fine with merging this, but IMHO it does not fully resolve #706.",
          "createdAt": "2021-01-28T14:04:47Z",
          "updatedAt": "2021-01-28T14:04:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NDM4MDk0",
          "commit": {
            "abbreviatedOid": "c9acd0d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T15:16:47Z",
          "updatedAt": "2021-01-28T15:16:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I like the intent, however\r\n(1) This wasn't clear: /if desired/  ... if who desires? The application, the TAPS system, the implementor. \r\n(2) I'm not a huge fan of /if desired/... /must/ even when it is lower case.\r\nCould this be: Applications can request that the TAPS system ought not to use the cached protocol state for certain connections?",
              "createdAt": "2021-01-28T15:16:47Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NDczMTcw",
          "commit": {
            "abbreviatedOid": "c9acd0d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T15:49:32Z",
          "updatedAt": "2021-01-28T15:49:32Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "One question on the phrase \"not use cached protocol state\". I read that as not using the cached state that is there when initiating a connection, but the taps system should also not cache state about this connection for use in later connections.  Not sure if that is captured by the wording or should be made explicit? It is clear in the update to the API section.\r\nOtherwise looks good to me as well!",
              "createdAt": "2021-01-28T15:49:32Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTE3OTg1",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks @martinduke, looks good to me now.",
          "createdAt": "2021-01-28T16:30:55Z",
          "updatedAt": "2021-01-28T16:30:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTkzMjYy",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T17:51:54Z",
          "updatedAt": "2021-01-28T17:51:54Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nprotocol state. Connections in the group will not use cached state\r\n```",
              "createdAt": "2021-01-28T17:51:54Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTkzNDc3",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T17:52:10Z",
          "updatedAt": "2021-01-28T17:52:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nApplications can request that a Connection Group maintain a separate cache for\r\n```",
              "createdAt": "2021-01-28T17:52:10Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTkzODE0",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T17:52:33Z",
          "updatedAt": "2021-01-28T17:52:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n### Private Session (#private-session}\r\n\r\n```",
              "createdAt": "2021-01-28T17:52:33Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTk0NzIy",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T17:53:33Z",
          "updatedAt": "2021-01-28T17:53:33Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nconnections that are not entangled with it. Any state generated by this connection will\r\n```",
              "createdAt": "2021-01-28T17:53:33Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTk1MDI1",
          "commit": {
            "abbreviatedOid": "f48a16b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T17:53:52Z",
          "updatedAt": "2021-01-28T17:53:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think \"connections\" should be capitalized throughout?",
              "createdAt": "2021-01-28T17:53:52Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDI3NjU5",
          "commit": {
            "abbreviatedOid": "a791ba9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:39:45Z",
          "updatedAt": "2021-01-29T16:39:46Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Interim discussion: rename to \"isolate\" instead of \"private\".",
              "createdAt": "2021-01-29T16:39:45Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDI5ODI1",
          "commit": {
            "abbreviatedOid": "a791ba9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:42:16Z",
          "updatedAt": "2021-01-29T16:42:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Note that this not guarantee no leakage of information, since things like RTT estimates, etc, may be fully isolated.",
              "createdAt": "2021-01-29T16:42:17Z",
              "updatedAt": "2021-01-29T16:52:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDQwNjIy",
          "commit": {
            "abbreviatedOid": "d288e28"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-29T16:54:49Z",
          "updatedAt": "2021-01-29T16:54:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 724,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzMzMwMzMw",
      "title": "Half-closed connections and such. Resolves #707",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/724",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "Closing: be more explicit about half-closed connections, allow it in the API too, fix errneous ConnectionError text.\r\nResolves #707.",
      "createdAt": "2021-01-12T09:50:57Z",
      "updatedAt": "2021-01-29T17:42:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "12fee9ffd34037f5a28d86fbd757a079ed0bff8f",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-closing",
      "headRefOid": "ab3805993efbc2bb6959f4f5b4f9b0484f22875d",
      "closedAt": "2021-01-29T17:42:37Z",
      "mergedAt": "2021-01-29T17:42:37Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f5df006a1437f0d86b05c405b38281464aeea3bd"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Same build error. I don't know what to do about this missing circleci file thing  :(",
          "createdAt": "2021-01-12T09:52:05Z",
          "updatedAt": "2021-01-12T09:52:05Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinduke good catch, thanks, incorporated",
          "createdAt": "2021-01-14T11:34:17Z",
          "updatedAt": "2021-01-14T11:34:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MTU3MTM0",
          "commit": {
            "abbreviatedOid": "7925a3d"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-12T10:59:46Z",
          "updatedAt": "2021-01-12T10:59:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTc2MzIy",
          "commit": {
            "abbreviatedOid": "717a510"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, except for one thing.",
          "createdAt": "2021-01-13T20:04:37Z",
          "updatedAt": "2021-01-13T20:05:16Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n: Calling `Close` on a TCP Connection indicates that the Connection should be gracefully closed (CLOSE.TCP) by sending a FIN to the peer. It will then still be possible to receive data until the peer closes or aborts the TCP connection. The `Closed` event will be issued upon reception of a FIN.\r\n```",
              "createdAt": "2021-01-13T20:04:37Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTUwMjAx",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks @mwelzl , this mainly look good. Few details that need fixing.",
          "createdAt": "2021-01-28T17:03:36Z",
          "updatedAt": "2021-01-28T17:32:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "\"the `Closed` event is immediately delivered to the application\" may sound a bit misleading as data sent from either end but not yet delivered is reliably delivered before this event fires I think. So you can still receive data after issuing the Close if it was already in the peers send queue, right?\r\n\r\nDo we not need to also specify when the 'Closed' event should fire in the multistreamed case. After getting the RESET_STREAM-EVENT.SCTP back I guess?",
              "createdAt": "2021-01-28T17:03:36Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            },
            {
              "originalPosition": 19,
              "body": "This is in the old text, but why is ABORT-EVENT.TCP listed for receiving a FIN?",
              "createdAt": "2021-01-28T17:05:34Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTkyNjMw",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-28T17:51:09Z",
          "updatedAt": "2021-01-28T17:51:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MDE3Mzk4",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T08:03:28Z",
          "updatedAt": "2021-01-29T08:03:28Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Good catch! Sorry, I don't know how that happened, it's obviously wrong. I'll fix it!",
              "createdAt": "2021-01-29T08:03:28Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MDI1MTI5",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T08:15:55Z",
          "updatedAt": "2021-01-29T08:15:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "1) Right! in the peers send queue, or in flight, or in the local host's receive buffer, I believe. Would it be ok to fix this as follows:\r\nIf this is the only Connection object that is assigned to the SCTP association, CLOSE.SCTP `Closed` event is delivered to the application when this call returns.\r\n[no need for us to go into these specifics here? Close semantics are given in the interface document anyway.]\r\n\r\n2) Right! Would it be ok to fix this as follows:\r\n\"The resulting local RESET_STREAM-EVENT.SCTP informs the transport system that the stream number can now be re-used by the next `Initiate`, `InitiateWithSend` or `Listen` calls, and invokes a `Closed` event towards the application.\r\n[I suppose that \"after delivering any data from the local receive buffer\" could be added, but I also don't think that this adds clarity, and so I would just formulate it as above).",
              "createdAt": "2021-01-29T08:15:55Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzcxOTU1",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T15:39:13Z",
          "updatedAt": "2021-01-29T15:39:13Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "For 1. perhaps \"... when the call is completed\". I guess the call will return immediately, but the close event is delivered to the application when the shutdown complete event is received.\r\n\r\n2. looks good!",
              "createdAt": "2021-01-29T15:39:13Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5Mzc4MjI1",
          "commit": {
            "abbreviatedOid": "f50f92d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T15:45:53Z",
          "updatedAt": "2021-01-29T15:45:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "About 1) also true, thanks - silly me, it should be upon \"CLOSE-EVENT.SCTP\" from RFC 8303. I once wrote that, after all  :-)",
              "createdAt": "2021-01-29T15:45:53Z",
              "updatedAt": "2021-01-29T17:42:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDUyNDk4",
          "commit": {
            "abbreviatedOid": "115a286"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2021-01-29T17:08:52Z",
          "updatedAt": "2021-01-29T17:08:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 725,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzMzczNDYx",
      "title": "Fix \"confirmed route\". Resolves #703",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/725",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "My first try to make a PR from the web interface. Maybe this compiles without problems?\r\nResolves #703.",
      "createdAt": "2021-01-12T11:01:28Z",
      "updatedAt": "2021-02-26T16:41:14Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mwelzl-patch-impl-1",
      "headRefOid": "63fda7cc8ac7bbf5fc09a4169396b165e4d2fc95",
      "closedAt": "2021-02-26T16:41:11Z",
      "mergedAt": "2021-02-26T16:41:11Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "37cb223621a0fc67f782448c6744b0cbeb98d853"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aha, the error appears even when doing it over the web interface.",
          "createdAt": "2021-01-12T11:02:20Z",
          "updatedAt": "2021-01-12T11:02:20Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I am missing something ... how do endpoints know a route exists (is present)? My thinking from NEAT was that endpoints only knew this was established when there was some \"confirmation\" from the remote endpoint. Do you mean something else?",
          "createdAt": "2021-01-28T19:23:05Z",
          "updatedAt": "2021-01-28T19:23:05Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair this is for UDP, nothing is sent to the other end until the application sends data. it was the same in neat, our open call in neat just returned immediately for UDP.",
          "createdAt": "2021-01-28T20:28:28Z",
          "updatedAt": "2021-01-28T20:28:28Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True - for UDP, as you say, you basically know the Interface is up (and often not much more), but the words \"established\" sounds more like what happened when you get the first packet back... Maybe I could live with this, but it doesn't immediately inspire the right sense...",
          "createdAt": "2021-01-28T20:51:12Z",
          "updatedAt": "2021-01-28T20:51:12Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, \"connectivity is established\" is not good at all, this is why I said the proposed update made it worse :) \r\nOr you mean that \"local port reservations has been established\" also triggers the wrong idea because of \"established\"?\r\nHow about \"... any necessary state like local port reservations is available/has been allocated.\"\r\nOr just remove that part all together.",
          "createdAt": "2021-01-28T21:01:11Z",
          "updatedAt": "2021-01-28T21:02:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTc3NjAz",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-13T20:06:27Z",
          "updatedAt": "2021-01-13T20:06:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTI4NTg4",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This update made things less clear to me.",
          "createdAt": "2021-01-28T16:41:38Z",
          "updatedAt": "2021-01-28T16:43:51Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I do not think this update helped. In fact, I think it made it worse. What does \"connectivity with the peer endpoint is established\" mean for an unconnected protocol?",
              "createdAt": "2021-01-28T16:41:38Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NTkxNTUz",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-01-28T17:49:55Z",
          "updatedAt": "2021-01-28T17:49:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agreed. How about \"as soon as a route on which to send and receive packets is present, and any necessary state like local port reservations has been established.\"",
              "createdAt": "2021-01-28T17:49:56Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDY3MDky",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:27:05Z",
          "updatedAt": "2021-01-29T17:27:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nWhile protocols that use an explicit handshake to validate a Connection to a peer can be used for racing multiple establishment attempts in parallel, \"unconnected\" protocols such as raw UDP do not offer a way to validate the presence of a peer or the usability of a Connection without application feedback. An implementation should consider such a protocol stack to be established as soon as the Transport Services system has selected a path on which to send data.\r\n```",
              "createdAt": "2021-01-29T17:27:05Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDY3MjI4",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:27:15Z",
          "updatedAt": "2021-01-29T17:27:15Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n## Handling \"unconnected\" protocols {#unconnected-racing}\r\n```",
              "createdAt": "2021-01-29T17:27:15Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDY5OTQ4",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:30:40Z",
          "updatedAt": "2021-01-29T17:30:41Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "We can recommend that applications other than a \"fire-and-forget\" case make their connections stateful, such as with a Message Framer on top of UDP that can verify when the peer is reachable.",
              "createdAt": "2021-01-29T17:30:41Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwOTIxMzE3",
          "commit": {
            "abbreviatedOid": "26f621f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-02T01:51:28Z",
          "updatedAt": "2021-02-02T01:51:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Tommy's text is an improvement, but I wonder if we should be more brutally obvious. Perhaps \"the Transport Services system has selected a destination IP address to which it has a route.\"\r\n\r\nThat text is unambiguous, with no wiggle room about what is \"valid\", etc. ",
              "createdAt": "2021-02-02T01:51:28Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDUyMzE2",
          "commit": {
            "abbreviatedOid": "f0cbbaa"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T10:35:45Z",
          "updatedAt": "2021-02-17T10:35:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I understand the problem now. I like Tommy's text, and I like your suggestion even better. Let's see how many thumbs up this gets...  if we get the critical mass, maybe we can just apply this fix and be done with this.",
              "createdAt": "2021-02-17T10:35:45Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDkwOTUx",
          "commit": {
            "abbreviatedOid": "f0cbbaa"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T11:22:11Z",
          "updatedAt": "2021-02-17T11:22:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Close: I don't that much like \"route\" - I'd prefer to not mention the routing system. So I suggest:\r\n\"the Transport Services system has selected a  a valid path and the corresponding destination IP address it will use.\"",
              "createdAt": "2021-02-17T11:22:11Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NTYyNjk3",
          "commit": {
            "abbreviatedOid": "f0cbbaa"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T13:14:33Z",
          "updatedAt": "2021-02-26T13:14:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think @martinduke was trying to get rid of \"valid path\", I agree that term is not very clear.",
              "createdAt": "2021-02-26T13:14:33Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzI0MTg4",
          "commit": {
            "abbreviatedOid": "f0cbbaa"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:12:23Z",
          "updatedAt": "2021-02-26T16:12:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "ah - but valid \"route\" is much worse. \"established\" connection is yucky. Maybe \"A path on which it is valid to send\" ...not implying the path is valid end-to-end?",
              "createdAt": "2021-02-26T16:12:24Z",
              "updatedAt": "2021-02-26T16:38:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 727,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYzNzEzMzgz",
      "title": "Describe framer passthrough mode",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/727",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #694 ",
      "createdAt": "2021-01-29T03:47:26Z",
      "updatedAt": "2021-01-29T17:32:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/passthrough",
      "headRefOid": "ce0d378d8b890366ae73097322e607b945ea6747",
      "closedAt": "2021-01-29T17:32:37Z",
      "mergedAt": "2021-01-29T17:32:37Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "10848b3b7933f91879e04ae056cf67b0962690a2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 728,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYzNzE0NzYz",
      "title": "Add a security consideration about partial messages",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/728",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #717",
      "createdAt": "2021-01-29T03:52:28Z",
      "updatedAt": "2021-02-22T14:25:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/partial-warning",
      "headRefOid": "d8c87969aebb37f938e2b782660dbc2404480c9b",
      "closedAt": "2021-02-22T14:25:34Z",
      "mergedAt": "2021-02-22T14:25:34Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "498c08b9aa9bb94c2aa6ab77b7fb1f8d1db23c2c"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understood this right:\r\nhttps://en.wikipedia.org/wiki/Security_of_Transport_Layer_Security#Truncation_attack\r\n...and if this is even a reasonable source ... then what this attack does, is to take the TCP connection away underneath the application's feet. Then, an application may still expect parts of a message but they may in fact never arrive because the Connection is in fact gone.\r\n\r\nDoesn't this mean that this exploits a detachment between TCP and a protocol atop TCP, which doesn't inform the application of the arrival of a FIN?  In this case, I don't understand the concern raised by @squarooticus in #717: the delivery of \"outstanding partial messages\" means that the receiver has them in the buffer, and then a FIN arrives - upon reception of the FIN, these \"outstanding partial messages\" should be delivered. That seems right to me.\r\n\r\nI may easily be completely off track!  But either way, @gorryfair also noted in #717 that the attack should be described, so I don't think that this PR satisfies the issue as it stands.",
          "createdAt": "2021-01-29T07:55:24Z",
          "updatedAt": "2021-01-29T07:55:24Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "A contrived example of the problem is if you intend to execute \"rm -rf /some/path\" and it somehow gets truncated to \"rm -rf /\". Protocols need to be designed in such a way that they deal properly with partial messages. I think the proposed text is fine.",
          "createdAt": "2021-01-29T14:38:42Z",
          "updatedAt": "2021-01-29T14:38:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Aha!  That's completely different than my reading of the Wikipedia page. Then that's fine, I also agree.",
          "createdAt": "2021-01-29T14:46:30Z",
          "updatedAt": "2021-01-29T14:46:30Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My 2c: You can always design bad apps: I don't think transports should be designed to do application data checks... applications should do that on the data they send. ",
          "createdAt": "2021-01-29T15:05:34Z",
          "updatedAt": "2021-01-29T15:05:34Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The new text seems to say what it should, although I don't see what this is an \"attack\", it would happen naturally when communications breaks.",
          "createdAt": "2021-01-29T15:08:32Z",
          "updatedAt": "2021-01-29T15:08:32Z"
        },
        {
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe we should discuss this. I see the need for something here as twofold:\r\n\r\n1. Warn users that they should not ignore the API-enabled distinction between full and partial messages.\r\n2. Make sure implementors properly classify partial messages as partial, so truncated messages (whether resulting from an attack or not) are presented to the application in a way that it can respond appropriately.\r\n\r\nSpecifically because TAPS provides message and layer abstractions (for security and framing), it's imperative that the implementor of each stage of the pipeline preserve the partial/full message distinction because unlike applications built on top of TCP sockets the application author may not have the ability to detect a partial message because windowing/framing at the lower layers aren't exposed to the application.\r\n\r\nBased on this conversation, it sounds like we do need the text to make this a bit clearer.",
          "createdAt": "2021-01-29T15:19:07Z",
          "updatedAt": "2021-01-29T15:19:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is useful to keep in. Security considerations are always good to point out.\r\n\r\nHappy to take suggestions for clarity.",
          "createdAt": "2021-01-29T16:07:26Z",
          "updatedAt": "2021-01-29T16:07:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzE1MTcz",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-29T14:38:53Z",
          "updatedAt": "2021-01-29T14:38:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDQ1NjQx",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:00:33Z",
          "updatedAt": "2021-01-29T17:00:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nof truncation attacks if applications do not distinguish between partial messages and complete messages.\r\nThe Transport Services system MUST NOT deliver partial data without correctly marking it as partial.\r\n```",
              "createdAt": "2021-01-29T17:00:33Z",
              "updatedAt": "2021-01-29T17:00:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDQ1ODI4",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:00:46Z",
          "updatedAt": "2021-01-29T17:00:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "@squarooticus does this work?",
              "createdAt": "2021-01-29T17:00:46Z",
              "updatedAt": "2021-01-29T17:00:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDQ2NDk4",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:01:32Z",
          "updatedAt": "2021-01-29T17:01:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Clarify that complete receives *are* complete.",
              "createdAt": "2021-01-29T17:01:33Z",
              "updatedAt": "2021-01-29T17:01:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMDQ5MDQx",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This LGTM",
          "createdAt": "2021-02-17T10:31:52Z",
          "updatedAt": "2021-02-17T10:31:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzYwMzY1",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-20T15:16:52Z",
          "updatedAt": "2021-02-20T15:17:20Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "LGTM.",
              "createdAt": "2021-02-20T15:16:52Z",
              "updatedAt": "2021-02-20T15:17:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODQ5NTgy",
          "commit": {
            "abbreviatedOid": "d8c8796"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGMT with @tfpauly's additions",
          "createdAt": "2021-02-21T14:59:12Z",
          "updatedAt": "2021-02-21T14:59:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 729,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYzNzE3MTM5",
      "title": "Add AbortGroup action",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/729",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #705 ",
      "createdAt": "2021-01-29T04:00:04Z",
      "updatedAt": "2021-01-29T17:03:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/abort-group",
      "headRefOid": "84fdd1881fc4f66af93d2688cb033d636c42a0a5",
      "closedAt": "2021-01-29T17:03:20Z",
      "mergedAt": "2021-01-29T17:03:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "b9854d3b62959a3be0a019e71682ad82db95a91b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MDA1MTUz",
          "commit": {
            "abbreviatedOid": "3c1eb61"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-29T07:41:51Z",
          "updatedAt": "2021-01-29T07:41:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDAzOTQ5",
          "commit": {
            "abbreviatedOid": "3c1eb61"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:13:02Z",
          "updatedAt": "2021-01-29T16:13:02Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "this on --> this one",
              "createdAt": "2021-01-29T16:13:02Z",
              "updatedAt": "2021-01-29T17:02:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDQ3MzY5",
          "commit": {
            "abbreviatedOid": "3c1eb61"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:02:38Z",
          "updatedAt": "2021-01-29T17:02:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nentangled with this one in a Connection Group. For example, all of the Connections in a\r\n```",
              "createdAt": "2021-01-29T17:02:38Z",
              "updatedAt": "2021-01-29T17:02:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 730,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYzNzE5NTc0",
      "title": "Describe reasons to not tear connections down during path changes",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/730",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #688",
      "createdAt": "2021-01-29T04:08:24Z",
      "updatedAt": "2021-01-29T17:36:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "5194aab67b4160ebd92273f901d5774a58bdb302",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/path-changes",
      "headRefOid": "35668ed41cb8d15b376ad30d02d87bb337d71ad2",
      "closedAt": "2021-01-29T17:36:24Z",
      "mergedAt": "2021-01-29T17:36:24Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "12fee9ffd34037f5a28d86fbd757a079ed0bff8f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MDA0MzU3",
          "commit": {
            "abbreviatedOid": "31f006c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-29T07:40:21Z",
          "updatedAt": "2021-01-29T07:40:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzUxMzg1",
          "commit": {
            "abbreviatedOid": "31f006c"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Two nits, otherwise looks good, thanks!",
          "createdAt": "2021-01-29T15:17:30Z",
          "updatedAt": "2021-01-29T15:18:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "user in --> user is in\r\n\r\n\"Thus, while it is useful for an application\" - I think the context is informing Protocol Instances, so this should be \"Protocol Instance\" rather than \"application\" I think?",
              "createdAt": "2021-01-29T15:17:30Z",
              "updatedAt": "2021-01-29T17:34:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzU0NzMz",
          "commit": {
            "abbreviatedOid": "1f37ef7"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T15:20:46Z",
          "updatedAt": "2021-01-29T15:20:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Seems the first nit was fixed while i was typing :)",
              "createdAt": "2021-01-29T15:20:46Z",
              "updatedAt": "2021-01-29T17:34:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5Mzk3NjUw",
          "commit": {
            "abbreviatedOid": "1f37ef7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T16:06:13Z",
          "updatedAt": "2021-01-29T16:06:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That was @gorryfair =)",
              "createdAt": "2021-01-29T16:06:13Z",
              "updatedAt": "2021-01-29T17:34:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NDcyODUw",
          "commit": {
            "abbreviatedOid": "1f37ef7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T17:34:36Z",
          "updatedAt": "2021-01-29T17:34:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThere are many common user scenarios that can lead to a path becoming temporarily unavailable, and then recovering before the transport protocol reaches a timeout error. These are particularly common using mobile devices. Examples include: an Ethernet cable becoming unplugged and then plugged back in; a device losing a Wi-Fi signal while a user is in an elevator, and reattaching when the user leaves the elevator; and a user losing the radio signal while riding a train through a tunnel. If the device is able to rejoin a network with the same IP address, a stateful transport connection can generally resume. Thus, while it is useful for a Protocol Instance to be aware of a temporary loss of connectivity, the Transport Services implementation should not aggressively close connections in these scenarios.\r\n```",
              "createdAt": "2021-01-29T17:34:36Z",
              "updatedAt": "2021-01-29T17:34:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 733,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwMTU3MjEw",
      "title": "Update affiliation of P. Tiesel",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/733",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-02-25T14:50:54Z",
      "updatedAt": "2021-02-26T16:29:05Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3af8aec7e90e34282ba335b0a7dcd65738899305",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/update-affiliation",
      "headRefOid": "d1b7bf4c18205145386ef862a1dea3e93c2d6433",
      "closedAt": "2021-02-26T16:29:02Z",
      "mergedAt": "2021-02-26T16:29:02Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "78063627dd11a3d94ec939f1226c1c8a9c316ba2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 734,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwMjA2MDk3",
      "title": "Separate connection context and groups - closes #721",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/734",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture"
      ],
      "body": " - Fix terminology in -arch\r\n - Add minimal connection contexts in -interface",
      "createdAt": "2021-02-25T15:55:29Z",
      "updatedAt": "2021-02-26T17:12:12Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3af8aec7e90e34282ba335b0a7dcd65738899305",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/connection-group-context",
      "headRefOid": "f39d4a41b12bb6217bfe3d4ddbb6ccd8dd82227b",
      "closedAt": "2021-02-26T17:09:41Z",
      "mergedAt": "2021-02-26T17:09:41Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "a3b8f648b2e356b7429d736d74d81c8a266ad3a5"
      },
      "comments": [
        {
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We had not decided that yet: \r\n - We agreed that the ```Isolate Session``` property was sufficient as portable interface for the purpose\r\n - We did not close #721 yet because #723 did nit fix the inconsistencies between Connection Groups in -architecture and -interface \r\n\r\nSo what we could do (als an alternative to this PR) to close #721\r\n - Drop the stuff this PR renamed to \"Connection Context\" from -arch all-together\r\n - Merge the changes in -arch, but do not include the minimal Connection Context into -interface an try to squish question about the context missing in -interface in later reviews\r\n",
          "createdAt": "2021-02-26T08:43:35Z",
          "updatedAt": "2021-02-26T08:43:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5MzQ3MjQ5",
          "commit": {
            "abbreviatedOid": "17324d8"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Did we decide to explicitly introduce this new connection context?",
          "createdAt": "2021-02-26T08:26:10Z",
          "updatedAt": "2021-02-26T08:26:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzUwNzA1",
          "commit": {
            "abbreviatedOid": "17324d8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:42:09Z",
          "updatedAt": "2021-02-26T16:42:10Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n## Specifying Connection Context {#contextspec}\r\n```",
              "createdAt": "2021-02-26T16:42:09Z",
              "updatedAt": "2021-02-26T17:08:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzcxNTE3",
          "commit": {
            "abbreviatedOid": "0786083"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T17:06:13Z",
          "updatedAt": "2021-02-26T17:06:14Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThis is used for separating Connection Contexts as specified in {{I-D.ietf-taps-arch}}.\r\n```",
              "createdAt": "2021-02-26T17:06:13Z",
              "updatedAt": "2021-02-26T17:08:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzcyNTM1",
          "commit": {
            "abbreviatedOid": "5504934"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T17:07:33Z",
          "updatedAt": "2021-02-26T17:07:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nWhile Connection Groups are managed implicitly by the transport system, an application can explicitly define Connection Contexts to control caching boundaries, as discussed in {{conn-context}}.\r\n```",
              "createdAt": "2021-02-26T17:07:33Z",
              "updatedAt": "2021-02-26T17:08:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzcyOTcx",
          "commit": {
            "abbreviatedOid": "5504934"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T17:08:03Z",
          "updatedAt": "2021-02-26T17:08:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nWhile Connection Groups are managed by the transport system, an application can define Connection Contexts to control caching boundaries, as discussed in {{conn-contexts}}.\r\n```",
              "createdAt": "2021-02-26T17:08:04Z",
              "updatedAt": "2021-02-26T17:08:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzczMzI5",
          "commit": {
            "abbreviatedOid": "a17b9cd"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T17:08:31Z",
          "updatedAt": "2021-02-26T17:08:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nWhile Connection Groups are managed by the transport system, an application can define Connection Contexts to control caching boundaries, as discussed in {{conn-context}}.\r\n```",
              "createdAt": "2021-02-26T17:08:31Z",
              "updatedAt": "2021-02-26T17:08:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 735,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwOTk5MzM2",
      "title": "Clarify what it means to not connect",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/735",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #702",
      "createdAt": "2021-02-26T17:05:48Z",
      "updatedAt": "2021-02-26T17:10:18Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "37cb223621a0fc67f782448c6744b0cbeb98d853",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "702-fwdref",
      "headRefOid": "5c572557ac1f451f259b0cab2a2da95d77e400ee",
      "closedAt": "2021-02-26T17:10:15Z",
      "mergedAt": "2021-02-26T17:10:15Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "64a5702d3336adb87baa96bbd1517e730325a9a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 736,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgxMDEzOTc3",
      "title": "Change Unconnected to Connectionless",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/736",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #716 ",
      "createdAt": "2021-02-26T17:32:05Z",
      "updatedAt": "2021-02-26T17:35:45Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9ce898e830ebf50f360a6f24ac88b335c8d6de93",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "716-unconnected-is-not-connectionless",
      "headRefOid": "2408e09399f16697ce51ae4359d545e9111f9444",
      "closedAt": "2021-02-26T17:33:28Z",
      "mergedAt": "2021-02-26T17:33:28Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "f16b618d1c0e5beb412d73a51be19a854cce1878"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just check \"connected\" - in case we mean connection-oriented; and that usage of \"connect\" is sane, we need care.\r\n",
          "createdAt": "2021-02-26T17:35:45Z",
          "updatedAt": "2021-02-26T17:35:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzkzNDI0",
          "commit": {
            "abbreviatedOid": "2408e09"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-26T17:33:11Z",
          "updatedAt": "2021-02-26T17:33:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 739,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2NzU1NTI4",
      "title": "Add CloseGroup",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/739",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #732 ",
      "createdAt": "2021-03-19T17:23:45Z",
      "updatedAt": "2021-03-21T02:12:49Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "f16b618d1c0e5beb412d73a51be19a854cce1878",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfp/close-group",
      "headRefOid": "85863ae19f631d5295599f7578209fd0fae1be7a",
      "closedAt": "2021-03-21T02:12:49Z",
      "mergedAt": "2021-03-21T02:12:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "cdb48e0a18f0b8125a785a5f0ba51608b63220aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2ODQzNjgx",
          "commit": {
            "abbreviatedOid": "85863ae"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-19T23:13:20Z",
          "updatedAt": "2021-03-19T23:13:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2ODkxMzc5",
          "commit": {
            "abbreviatedOid": "85863ae"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks for doing this!",
          "createdAt": "2021-03-20T07:27:14Z",
          "updatedAt": "2021-03-20T07:27:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 740,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAwNTQ2Mzkw",
      "title": "Small updates to the minset appendix for consistency",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/740",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "I did a check of the minset appendix to see if anything should be updated, as some property names etc. could have changed.\r\n\r\nI wrongly expected a small PR to only be \"editorial\" before, but this time I'm really sure   :-)",
      "createdAt": "2021-03-25T08:43:00Z",
      "updatedAt": "2021-04-09T15:07:42Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cdb48e0a18f0b8125a785a5f0ba51608b63220aa",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-minsetfixes",
      "headRefOid": "6fcc857c62a13c83bd01fab16a867bb0179a0d35",
      "closedAt": "2021-04-09T15:07:41Z",
      "mergedAt": "2021-04-09T15:07:41Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "508ace451ecfae57be36a94d094c3b7348e996db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjQ5NjQ2",
          "commit": {
            "abbreviatedOid": "6fcc857"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-26T15:10:50Z",
          "updatedAt": "2021-03-26T15:10:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 741,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAwNTUzMTM4",
      "title": "Reference to arch section 4.2.2 for \"racing\". Closes #714.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/741",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Closes #714.\r\n\r\nOh yes, and it IS editorial !  :-D",
      "createdAt": "2021-03-25T08:53:47Z",
      "updatedAt": "2021-03-25T10:38:53Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cdb48e0a18f0b8125a785a5f0ba51608b63220aa",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-racingreference",
      "headRefOid": "a2c71d3e8c576cb9f8dfa55de286235061746d32",
      "closedAt": "2021-03-25T10:38:43Z",
      "mergedAt": "2021-03-25T10:38:43Z",
      "mergedBy": "abrunstrom",
      "mergeCommit": {
        "oid": "85d742a0af2e3be11b620b5f3d5cbcf419172a72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwOTU2Mzg4",
          "commit": {
            "abbreviatedOid": "a2c71d3"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for fixing this!",
          "createdAt": "2021-03-25T10:37:59Z",
          "updatedAt": "2021-03-25T10:37:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 742,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAwNjg1MTgw",
      "title": "Bring the multipath text in line with the API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/742",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #704.\r\n\r\nNote, the change to the API draft here is a purely editorial detail that I fixed here in passing: the multipath selection property was renamed and this fixes the text referring to it.\r\n",
      "createdAt": "2021-03-25T12:11:21Z",
      "updatedAt": "2021-04-09T15:08:58Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "85d742a0af2e3be11b620b5f3d5cbcf419172a72",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-multipath",
      "headRefOid": "67864b1f630d95b98d3914c3b7dc401aec73e465",
      "closedAt": "2021-04-09T15:08:58Z",
      "mergedAt": "2021-04-09T15:08:58Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "920c88a9a5f80e8ec4e8e546d67e24fedc4da51e"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"what we discussed\" - you mean in #704, where I say that I stumbled over a sentence? This PR does update that sentence (simply removing \"with migration support\" from it because any multipath protocol can do that).",
          "createdAt": "2021-03-26T08:39:04Z",
          "updatedAt": "2021-03-26T08:39:04Z"
        },
        {
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"what we discussed\" - you mean in #704, where I say that I stumbled over a sentence? \r\n\r\nno, i meant what we discussed at the interim about using the handover, interactive, aggregate terminology. but i saw that this was not so easily done and we are all happy with your solution, so all good :) ",
          "createdAt": "2021-03-26T15:58:16Z",
          "updatedAt": "2021-03-26T15:58:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNDg0OTY0",
          "commit": {
            "abbreviatedOid": "4bd4666"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-25T19:04:55Z",
          "updatedAt": "2021-03-25T19:04:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIxNTA1MTIw",
          "commit": {
            "abbreviatedOid": "4bd4666"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Not sure this is what we discussed, but I like it better so I am happy with the update, thanks! Noticed two small things to update on the \"old\" text.",
          "createdAt": "2021-03-25T19:29:57Z",
          "updatedAt": "2021-03-25T19:35:28Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "\"may add connections over new paths or different protocols\", I think the \"or different protocols\" part has nothing to do with multipath and should be removed.",
              "createdAt": "2021-03-25T19:31:44Z",
              "updatedAt": "2021-03-26T08:36:53Z"
            },
            {
              "originalPosition": 5,
              "body": "notifying the application of the change. --> notifying the Protocol Instance of the change.",
              "createdAt": "2021-03-25T19:32:17Z",
              "updatedAt": "2021-03-26T08:36:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMjQ4OTk2",
          "commit": {
            "abbreviatedOid": "67864b1"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2021-03-26T15:10:13Z",
          "updatedAt": "2021-03-26T15:10:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyMzAxNTU2",
          "commit": {
            "abbreviatedOid": "67864b1"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for fixing the nits!",
          "createdAt": "2021-03-26T15:59:11Z",
          "updatedAt": "2021-03-26T15:59:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 745,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5ODIxNDIx",
      "title": "Editorial rollup",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/745",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "",
      "createdAt": "2021-04-06T12:47:11Z",
      "updatedAt": "2021-04-09T15:24:54Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "48c737532b70535602e6092a46c6e8944e588242",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-impl-editorial",
      "headRefOid": "d10dd3f4168985a4b92cdf06acc3265720c6225d",
      "closedAt": "2021-04-09T15:15:19Z",
      "mergedAt": "2021-04-09T15:15:19Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "8a25771dfa728cd9e66f4c7dff084e0a619d7120"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MzA3Nzkz",
          "commit": {
            "abbreviatedOid": "992655a"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks! Two comments on the updates.",
          "createdAt": "2021-04-06T18:54:39Z",
          "updatedAt": "2021-04-06T19:00:05Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "\"an object\" sounds odd to me here. I think it needs to store it in \"the Connection Object\" if we want to express it at this abstraction level.",
              "createdAt": "2021-04-06T18:54:39Z",
              "updatedAt": "2021-04-09T15:15:04Z"
            },
            {
              "originalPosition": 41,
              "body": "I think keeping \"datagram\" is more aligned with the surrounding text here.",
              "createdAt": "2021-04-06T18:55:50Z",
              "updatedAt": "2021-04-09T15:15:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTIzNzIx",
          "commit": {
            "abbreviatedOid": "992655a"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T15:13:32Z",
          "updatedAt": "2021-04-09T15:13:33Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nProtocols that provide the framing (such as length-value protocols, or protocols that use delimiters) provide data boundaries that may be longer than the typical datagram. Each Message for framing protocols corresponds to a single frame, which may be sent either as a complete Message, or in multiple parts.\r\n```",
              "createdAt": "2021-04-09T15:13:32Z",
              "updatedAt": "2021-04-09T15:15:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTI0NzA4",
          "commit": {
            "abbreviatedOid": "8d5396b"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T15:14:36Z",
          "updatedAt": "2021-04-09T15:14:37Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nin storage common to all protocols, and notify all protocol instances in the Protocol Stack whenever the properties have been modified by the application.\r\n```",
              "createdAt": "2021-04-09T15:14:36Z",
              "updatedAt": "2021-04-09T15:15:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTM0OTE4",
          "commit": {
            "abbreviatedOid": "d10dd3f"
          },
          "author": "squarooticus",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T15:24:54Z",
          "updatedAt": "2021-04-09T15:24:54Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "\"...that may not fit within a single datagram.\"",
              "createdAt": "2021-04-09T15:24:54Z",
              "updatedAt": "2021-04-09T15:24:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 748,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5ODM1ODcw",
      "title": "Clarify \"consumed\" and \"failed to send\" timing.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/748",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "Fixes #747",
      "createdAt": "2021-04-06T13:07:49Z",
      "updatedAt": "2021-04-09T15:19:38Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "48c737532b70535602e6092a46c6e8944e588242",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "747-send-timing",
      "headRefOid": "d08a598c0eedb0890e9b13bb4a689d6d8cb329c4",
      "closedAt": "2021-04-09T15:19:32Z",
      "mergedAt": "2021-04-09T15:19:32Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "0d804a611d93c0e3d25011dafab1dcfa5337d8f0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MDE2NzQx",
          "commit": {
            "abbreviatedOid": "deae7c1"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2021-04-06T14:08:28Z",
          "updatedAt": "2021-04-06T14:08:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5MjgwMTM2",
          "commit": {
            "abbreviatedOid": "deae7c1"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-06T18:21:00Z",
          "updatedAt": "2021-04-06T18:21:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Not sure about the \"finally failed to send\" rather than just \"failed to send\". The send may also fail if the set of Message Properties are not consistent with the Connection's transport properties, so it may also fail immediately. Possibly we should add this a second example?",
              "createdAt": "2021-04-06T18:21:00Z",
              "updatedAt": "2021-04-09T15:18:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTI4MzM1",
          "commit": {
            "abbreviatedOid": "deae7c1"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T15:18:09Z",
          "updatedAt": "2021-04-09T15:18:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe application should be notified whenever a Message or partial Message has been consumed by the Protocol Stack, or has failed to send. The time at which a Message is considered to have been consumed by the Protocol Stack may vary depending on the protocol. For example, for a basic datagram protocol like UDP, this may correspond to the time when the packet is sent into the interface driver. For a protocol that buffers data in queues, like TCP, this may correspond to when the data has entered the send buffer. The time at which a message has failed to send is after the Protocol Stack or the Transport Services implementation itself has not successfully sent the entire Message content or partial Message content on any open candidate connection; this may depend on protocol-specific timeouts.\r\n```",
              "createdAt": "2021-04-09T15:18:09Z",
              "updatedAt": "2021-04-09T15:18:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTI4Nzgz",
          "commit": {
            "abbreviatedOid": "d08a598"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T15:18:35Z",
          "updatedAt": "2021-04-09T15:18:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 764,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNTQ4MzIw",
      "title": "add Closing to the state diagram",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/764",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #731.",
      "createdAt": "2021-04-09T15:36:07Z",
      "updatedAt": "2021-04-09T15:54:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0d804a611d93c0e3d25011dafab1dcfa5337d8f0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "731-closing-exists",
      "headRefOid": "edc4deeb6c45f2e834df83a4c84ec3e9b18b008f",
      "closedAt": "2021-04-09T15:54:02Z",
      "mergedAt": "2021-04-09T15:54:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "3e72ee3f315e14a9adae34274503d7de86880fa3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTYxNzkz",
          "commit": {
            "abbreviatedOid": "edc4dee"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T15:53:55Z",
          "updatedAt": "2021-04-09T15:53:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 765,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNTUzMzI4",
      "title": "Packet vs. datagram",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/765",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now I feel like I'm shaving the yak. This is more than what we talked about in the interim, but it felt like the following sentence required additional clarity. Let me know if I misunderstood the intended meaning, in which case I will rephrase.",
      "createdAt": "2021-04-09T15:44:18Z",
      "updatedAt": "2021-04-09T15:59:10Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0d804a611d93c0e3d25011dafab1dcfa5337d8f0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "krose-packet-vs-datagram",
      "headRefOid": "508326df587d94452003cfbb4a051ec08fc66209",
      "closedAt": "2021-04-09T15:59:10Z",
      "mergedAt": "2021-04-09T15:59:10Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "3653ddf181256884e9d6881aaea7d6eeff6fb292"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTY5ODgz",
          "commit": {
            "abbreviatedOid": "508326d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T15:59:05Z",
          "updatedAt": "2021-04-09T15:59:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 766,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNTc5NTQw",
      "title": "Update draft-ietf-taps-impl.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/766",
      "state": "MERGED",
      "author": "zaheduzzaman",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "explained the \"deep-copy\" term.",
      "createdAt": "2021-04-09T16:21:11Z",
      "updatedAt": "2021-04-09T16:33:12Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3653ddf181256884e9d6881aaea7d6eeff6fb292",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "zaheduzzaman-patch-1",
      "headRefOid": "278161763ffc7e61838525e892128059b63d4a33",
      "closedAt": "2021-04-09T16:33:12Z",
      "mergedAt": "2021-04-09T16:33:12Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "b9d37d207bda1a233ee6e8a38091eafd05238e34"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTkyMTM4",
          "commit": {
            "abbreviatedOid": "cf32ab8"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T16:23:23Z",
          "updatedAt": "2021-04-09T16:23:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nPreconnection objects should be implemented as bundles of properties that an application can both read and write. Once a Preconnection has been used to create an outbound Connection or a Listener, the implementation should ensure that the copy of the properties held by the Connection or Listener is immutable. This may involve performing a deep-copy, copying the object with all the objects it references, if the application is still able to modify properties on the original Preconnection object.\r\n```\r\n\r\n(I'm not a native English speaker, but I *believe* that \"references\" or \"refers _to_\" are correct, not just \"refers)",
              "createdAt": "2021-04-09T16:23:23Z",
              "updatedAt": "2021-04-09T16:31:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTk4Mzcz",
          "commit": {
            "abbreviatedOid": "cf32ab8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T16:31:22Z",
          "updatedAt": "2021-04-09T16:31:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 767,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNTgzOTAx",
      "title": "Editorial rollup, bis.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/767",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation",
        "editorial"
      ],
      "body": "fixes #749. fixes #746.",
      "createdAt": "2021-04-09T16:29:10Z",
      "updatedAt": "2021-04-09T16:34:17Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "3653ddf181256884e9d6881aaea7d6eeff6fb292",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-impl-editorial-more",
      "headRefOid": "816ef6c6010bc5d712bcef671dffde77e067c67d",
      "closedAt": "2021-04-09T16:34:17Z",
      "mergedAt": "2021-04-09T16:34:16Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTk5MDI4",
          "commit": {
            "abbreviatedOid": "9ffda96"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-09T16:32:11Z",
          "updatedAt": "2021-04-09T16:32:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMyNTk5Njk2",
          "commit": {
            "abbreviatedOid": "9ffda96"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-09T16:33:02Z",
          "updatedAt": "2021-04-09T16:33:02Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nSince sending a Message may involve a context switch between the application and the transport system, sending patterns that involve multiple small Messages can incur high overhead if each needs to be enqueued separately. To avoid this, the application can indicate a batch of Send actions through the API. When this is used, the implementation can defer the processing of Messages until the batch is complete.\r\n```",
              "createdAt": "2021-04-09T16:33:02Z",
              "updatedAt": "2021-04-09T16:33:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 768,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEyNTk1OTY0",
      "title": "Restructure tree structure",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/768",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "\ud83c\udfb6 \r\n\r\nFixes #743. Fixes #756.",
      "createdAt": "2021-04-09T16:51:44Z",
      "updatedAt": "2021-05-04T14:53:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "743-retree",
      "headRefOid": "66569b5f031d7fc21dd92237516abda5bd35ea79",
      "closedAt": "2021-05-04T14:53:19Z",
      "mergedAt": "2021-05-04T14:53:18Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "9aedd18c46d78aae2f0bdccc599fdd195cf31918"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Best reviewed by reading the full rendered document [here](https://ietf-tapswg.github.io/api-drafts/743-retree/draft-ietf-taps-impl.html#name-implementing-connection-est)",
          "createdAt": "2021-04-09T16:54:17Z",
          "updatedAt": "2021-04-09T16:54:17Z"
        },
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Going ahead and merging this ahead of other editorial changes (since it's a big move and highly likely to conflict)",
          "createdAt": "2021-05-04T14:50:34Z",
          "updatedAt": "2021-05-04T14:50:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDg5OTY3",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Heading in what seems the correct direction, but needs changes to improve reading/consistency.",
          "createdAt": "2021-04-23T09:09:54Z",
          "updatedAt": "2021-04-23T09:24:36Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "/it is not necessary for an implementation to do so, but it/a tree structure is not the only way in which bus can be implemented, but this does/ ... might seem to be clearer.",
              "createdAt": "2021-04-23T09:09:54Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 9,
              "body": "Is this /vary/ or /differ/ ?",
              "createdAt": "2021-04-23T09:12:02Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 67,
              "body": "/it's/it is/\r\nis /be able to/ needed?\r\n/give the protocol stack/provide the protocol stack with/\r\n/it attempts/the Local Endpoint attempts/\r\n",
              "createdAt": "2021-04-23T09:18:02Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 71,
              "body": "/allocates ephemeral source ports/and allocates ephemeral source ports/\r\n/locals/Local Endpoints/\r\n/the source/a source/\r\n/transient/????",
              "createdAt": "2021-04-23T09:19:34Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 81,
              "body": "At the start of a para /How this is/How this resolution is/",
              "createdAt": "2021-04-23T09:21:04Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 81,
              "body": "/types of remote/ is this /types of Remote Endpoint/ or /remote peer/\r\n/candidate locals/candidate Local Endpoints/\r\n/candidate remote addresses/set of remote ???what??/",
              "createdAt": "2021-04-23T09:22:50Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            },
            {
              "originalPosition": 84,
              "body": "/with the remote/with the remote peer/\r\n/candidate locals to the remote/candidate Local Endpoints to the Remote Endpoint/",
              "createdAt": "2021-04-23T09:23:50Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzIzNDEy",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:43:20Z",
          "updatedAt": "2021-05-04T14:43:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nThis document structures the candidates for racing as a tree as terminological convention. While a \r\na tree structure is not the only way in which racing can be implemented, it does ease the illustration of how racing works. \r\n```",
              "createdAt": "2021-05-04T14:43:20Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzIzNzg3",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:43:36Z",
          "updatedAt": "2021-05-04T14:43:36Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "(added suggested change)",
              "createdAt": "2021-05-04T14:43:36Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI0Mzkx",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:44:07Z",
          "updatedAt": "2021-05-04T14:44:07Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Differ is better.",
              "createdAt": "2021-05-04T14:44:07Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI0Njk2",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:44:22Z",
          "updatedAt": "2021-05-04T14:44:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nThe most simple example of this process might involve identifying the single IP address to which the implementation wishes to connect, using the system's current default interface or path, and starting a TCP handshake to establish a stream to the specified IP address. However, each step may also differ depending on the requirements of the connection: if the endpoint is defined as a hostname and port, then there may be multiple resolved addresses that are available; there may also be multiple interfaces or paths available, other than the default system interface; and some protocols may not need any transport handshake to be considered \"established\" (such as UDP), while other connections may utilize layered protocol handshakes, such as TLS over TCP.\r\n```",
              "createdAt": "2021-05-04T14:44:22Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI2Mjkx",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:45:44Z",
          "updatedAt": "2021-05-04T14:45:45Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nBoth Local and Remote Endpoint Candidates must be discovered during connection establishment.  To support Interactive Connectivity Establishment (ICE) {{?RFC8445}}, or similar protocols that involve out-of-band indirect signalling to exchange candidates with the Remote Endpoint, it is important to query the set of candidate Local Endpoints, and provide the protocol stack with a set of candidate Remote Endpoints, before the Local Endpoint attempts to establish connections.\r\n```",
              "createdAt": "2021-05-04T14:45:44Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI2NzA3",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:46:06Z",
          "updatedAt": "2021-05-04T14:46:06Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "\"be able to\" is actually doing something here but I won't quibble. made all these in a suggested change.",
              "createdAt": "2021-05-04T14:46:06Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI3OTcx",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:47:12Z",
          "updatedAt": "2021-05-04T14:47:13Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I'm not sure what transient is doing here (all these are from the original text). Made a suggested change. ",
              "createdAt": "2021-05-04T14:47:13Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI4MDc0",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:47:18Z",
          "updatedAt": "2021-05-04T14:47:19Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nThe set of possible Local Endpoints is gathered.  In the simple case, this merely enumerates the local interfaces and protocols, and allocates ephemeral source ports.  For example, a system that has WiFi and Ethernet and supports IPv4 and IPv6 might gather four candidate Local Endpoints (IPv4 on Ethernet, IPv6 on Ethernet, IPv4 on WiFi, and IPv6 on WiFi) that can form the source for a transient.\r\n```",
              "createdAt": "2021-05-04T14:47:19Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI5MjU2",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:48:20Z",
          "updatedAt": "2021-05-04T14:48:20Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Same; accepted suggestions, will pull remaining ??? into a separate issue after merge.",
              "createdAt": "2021-05-04T14:48:20Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI5Mzgw",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:48:27Z",
          "updatedAt": "2021-05-04T14:48:28Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nHow this resolution is done will depend on the type of the Remote Endpoint, and can also be specific to each Local Endpoint.  A common case is when the Remote Endpoint is a DNS name, in which case it is resolved to give a set of IPv4 and IPv6 addresses representing that name.  Some types of Remote Endpoint might require more complex resolution.  Resolving the Remote Endpoint for a peer-to-peer connection might involve communication with a rendezvous server, which in turn contacts the peer to gain consent to communicate and retrieve its set of candidate Local Endpoints, which are returned and form the candidate remote addresses for contacting that peer.\r\n```",
              "createdAt": "2021-05-04T14:48:27Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzI5ODU3",
          "commit": {
            "abbreviatedOid": "c352062"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-04T14:48:52Z",
          "updatedAt": "2021-05-04T14:48:53Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nResolving the Remote Endpoint is not a local operation.  It will involve a directory service, and can require communication with the Remote Endpoint to rendezvous and exchange peer addresses.  This can expose some or all of the candidate Local Endpoints to the Remote Endpoint.\r\n```",
              "createdAt": "2021-05-04T14:48:52Z",
              "updatedAt": "2021-05-04T14:50:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 769,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEzNTMwNDg3",
      "title": "SCTP stream mapping, closes #708. (manual re-application of PR #722)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/769",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Implementation"
      ],
      "body": "Closes #708.\r\n\r\nThis is a manual re-application of all the changes to -impl in PR #722.\r\n\r\n(Other methods didn't easily work because the master has changed quite a bit during discussion of PR #722; at least I found no easy way).",
      "createdAt": "2021-04-12T11:08:00Z",
      "updatedAt": "2021-05-04T14:24:16Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-impl-clarify-sctp-manual",
      "headRefOid": "4a6766ad875f9e4374c2f3a0feb300d64788392e",
      "closedAt": "2021-05-04T14:24:16Z",
      "mergedAt": "2021-05-04T14:24:16Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "01a8147f02ba56af6a0a4ab594bde3122b418633"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 770,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEzNTY2OTIz",
      "title": "Events upon Clone",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/770",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Clarify that the Connection returned by Clone will send a Ready Event or an InitiateError Event.\r\nCloses #760.\r\n",
      "createdAt": "2021-04-12T12:02:16Z",
      "updatedAt": "2021-04-15T11:49:02Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-clone_event",
      "headRefOid": "65a29050bcb8864da93273d1a006dcd4b8a5c99b",
      "closedAt": "2021-04-15T11:49:02Z",
      "mergedAt": "2021-04-15T11:49:02Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "e3335b297a76b0b55ab17db47117a651c31c7f29"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjM0Mzc2",
          "commit": {
            "abbreviatedOid": "65a2905"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-12T14:51:27Z",
          "updatedAt": "2021-04-12T14:51:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 771,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEzNTgwNzM2",
      "title": "Clarify Events upon various close / abort calls.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/771",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "(Gracefully,  he he  :)  ) Closes #761.\r\n ",
      "createdAt": "2021-04-12T12:21:56Z",
      "updatedAt": "2021-06-11T16:22:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-closegroup-abortgroup-events",
      "headRefOid": "aa6bab1fa613a776aca29b3e72b92ad560929667",
      "closedAt": "2021-06-11T16:22:20Z",
      "mergedAt": "2021-06-11T16:22:19Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "fdea22b1f5acaabecd5c5a6c576d8f64a111833d"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I see, sorry!  I just committed a fix; is it better now?\r\n\r\nThe new text describing the Closed Event is only this:\r\n\r\n> The Closed Event informs the application that a Close Action has successfully completed, or that the Remote Endpoint has closed the Connection.\r\n",
          "createdAt": "2021-04-12T15:34:09Z",
          "updatedAt": "2021-04-12T15:34:09Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still, it says that this means either everything has been delivered, or the peer has closed the connection. Does this mean I would get two events on a clean TCP close?",
          "createdAt": "2021-05-03T17:50:42Z",
          "updatedAt": "2021-05-03T17:50:42Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, one: because the Connection was \"closed\". Case 1 in the sentence, where it says \"Close Action\", refers to the call made by the local application - the application made the call, and it terminated correctly. The remote close is the other case leading to a Connection being closed - since it doesn't say \"abort\" or \"forcefully closed\", it's the same thing, a graceful close. So... there are two reasons leading to one thing happening, and when that one thing is over, the applications gets an Event.\r\n\r\nI'm not sure how you read this differently... it's clear to me. Would this variant help?\r\n\r\n> The Closed Event informs the application that the Connection has been closed - either because a Close Action call has successfully completed, or because the Remote Endpoint has closed the Connection.",
          "createdAt": "2021-05-05T06:26:55Z",
          "updatedAt": "2021-05-05T06:26:55Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've read this again, and I think it's OK.",
          "createdAt": "2021-05-05T15:53:27Z",
          "updatedAt": "2021-05-05T15:53:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we explain in the start of the connection termination section a specific list of the different end states/events a connection can have? (Either Closed or ConnectionError, for example).",
          "createdAt": "2021-05-07T15:42:58Z",
          "updatedAt": "2021-05-07T15:42:58Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note to self: also add some introductory text for this section as requested by @abrunstrom in #818:\r\n\"This section would benefit from some introductory sentences on the different ways to terminate a connection, i.e. local and remote actions and Connection errors.\"",
          "createdAt": "2021-05-07T15:48:27Z",
          "updatedAt": "2021-05-20T09:15:49Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done - please take a look at the new intro.",
          "createdAt": "2021-05-20T09:56:07Z",
          "updatedAt": "2021-05-20T09:56:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMzNjQ1MTgy",
          "commit": {
            "abbreviatedOid": "21d42a9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "From this text I still don't understand when TAPS sends Closed<>. Is it (1) in response to a Close(), when all data has been delivered, or when the remote endpoint has closed?\r\n\r\nIs it the first of these two events to occur?",
          "createdAt": "2021-04-12T15:00:02Z",
          "updatedAt": "2021-04-12T15:00:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MzYyNTU5",
          "commit": {
            "abbreviatedOid": "fd924b7"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-18T19:59:35Z",
          "updatedAt": "2021-04-18T19:59:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NDc2NTE0",
          "commit": {
            "abbreviatedOid": "fd924b7"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I am still missing a clear statement whether a developer can rely on eventually receiving either a Closed event or a ConnectionError event per Connection.",
          "createdAt": "2021-05-07T13:47:29Z",
          "updatedAt": "2021-05-07T13:47:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MjQ0NzMw",
          "commit": {
            "abbreviatedOid": "5cbe85d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A couple of minor queries",
          "createdAt": "2021-05-20T11:08:32Z",
          "updatedAt": "2021-05-20T11:13:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "is this /to either send/ ... I'm unsure what the \"or\" refers to.",
              "createdAt": "2021-05-20T11:08:32Z",
              "updatedAt": "2021-05-20T11:13:06Z"
            },
            {
              "originalPosition": 39,
              "body": "why /indeed/ in /will indeed be signaled./?",
              "createdAt": "2021-05-20T11:10:46Z",
              "updatedAt": "2021-05-20T11:13:06Z"
            },
            {
              "originalPosition": 81,
              "body": "Similarly, should this /will be signalled/?",
              "createdAt": "2021-05-20T11:12:53Z",
              "updatedAt": "2021-05-20T11:13:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 783,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0MTc5MzIy",
      "title": "Update draft-ietf-taps-interface.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/783",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Suggested sentence to unambiguously explain datagram v. connection opening.",
      "createdAt": "2021-04-13T06:42:50Z",
      "updatedAt": "2021-04-23T09:08:24Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-2",
      "headRefOid": "ef093730858021bab488441cde759b3073a30185",
      "closedAt": "2021-04-23T09:08:24Z",
      "mergedAt": "2021-04-23T09:08:24Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "a4cb89104baf7850767ba4e61dbbf42d0526a657"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NDQ4NzU3",
          "commit": {
            "abbreviatedOid": "b3e5e28"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I added a tiny suggestion to fix a nit, if it is one",
          "createdAt": "2021-04-13T10:55:24Z",
          "updatedAt": "2021-04-13T11:04:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n- A unified interface to datagram and connection-oriented transports, allowing\r\n```\r\nIs this a nit, or is it my limited English that makes me think this needs an \"A\"?  Also, I wonder: would this be better with a dash after datagram?  (i.e., \"to datagram- and connection-oriented...\")",
              "createdAt": "2021-04-13T10:55:24Z",
              "updatedAt": "2021-04-13T12:54:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTcxNzk4",
          "commit": {
            "abbreviatedOid": "ef09373"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good!  Thank you!",
          "createdAt": "2021-04-13T19:54:56Z",
          "updatedAt": "2021-04-13T19:54:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 784,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0MTg3NDU3",
      "title": "Update to fix NITS in draft-ietf-taps-interface.md",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/784",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To address NiTs",
      "createdAt": "2021-04-13T06:55:48Z",
      "updatedAt": "2021-04-14T09:43:16Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "87a0cc3b6f1990a597d60c5cb6b614d2dcbbf57b",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-3",
      "headRefOid": "cff75dbb204ffcd5931d7de2ac41aece1f28a95a",
      "closedAt": "2021-04-14T09:42:59Z",
      "mergedAt": "2021-04-14T09:42:59Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "cbe26fba23a70ea2aff0388e643b8422f32626e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NDU5NzEz",
          "commit": {
            "abbreviatedOid": "cff75db"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This LGTM, thanks!",
          "createdAt": "2021-04-13T11:08:36Z",
          "updatedAt": "2021-04-13T11:08:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 786,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0NjE3OTE4",
      "title": "Proposed editorial changes to abstract and intro",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/786",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "While reviewing for last call, I didn't find the abstract very strong. Given I'm an authors, I thought I make another proposal, however, really just that - a proposal...",
      "createdAt": "2021-04-13T16:54:28Z",
      "updatedAt": "2021-05-04T14:26:34Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "01a8147f02ba56af6a0a4ab594bde3122b418633",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mirjak-patch-1",
      "headRefOid": "3ba5d75cfca8fd1fb9fa15c85ec8b33a80f439f6",
      "closedAt": "2021-05-04T14:26:34Z",
      "mergedAt": "2021-05-04T14:26:34Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "fc1368ed4e9792cce3afc9d5db4c61e62f68d917"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0ODIzMzkw",
          "commit": {
            "abbreviatedOid": "c77f036"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T16:55:29Z",
          "updatedAt": "2021-04-13T16:55:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nApplications that adopt this interface will benefit from a wide set of\r\n```",
              "createdAt": "2021-04-13T16:55:29Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1MjcwODQ3",
          "commit": {
            "abbreviatedOid": "852a7c7"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like this a lot, in particular the change to the abstract is just right IMO. Thanks!\r\nI added a few comments, but these are just nits.",
          "createdAt": "2021-04-14T06:57:18Z",
          "updatedAt": "2021-04-14T07:01:08Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nprotocols. It can support applications by offering racing and fallback\r\n```\r\n\"Especially\" is a bit strange to me here. I agree with the wish to remove \"also\" though... so would it be better as I suggest?",
              "createdAt": "2021-04-14T06:57:18Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            },
            {
              "originalPosition": 46,
              "body": "I think this is *much* better, thanks!",
              "createdAt": "2021-04-14T06:58:55Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nof new protocols and protocol features without requiring changes to the\r\n```",
              "createdAt": "2021-04-14T06:59:36Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nby providing asynchronous, atomic transmission of messages. It is intended to replace the\r\n```",
              "createdAt": "2021-04-14T07:00:13Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1NDgyNTg2",
          "commit": {
            "abbreviatedOid": "4d31b24"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-14T10:55:19Z",
          "updatedAt": "2021-04-14T10:55:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDg3NTQ3",
          "commit": {
            "abbreviatedOid": "4d31b24"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T09:07:07Z",
          "updatedAt": "2021-04-23T09:07:08Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I suggest /supports/enables/  ... Just because the word /supports/ is later used to describes what the API offers.",
              "createdAt": "2021-04-23T09:07:07Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDkwOTEw",
          "commit": {
            "abbreviatedOid": "4d31b24"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-23T09:11:01Z",
          "updatedAt": "2021-04-23T09:11:02Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nnetwork paths dynamically at runtime. This API enables faster deployment\r\n```",
              "createdAt": "2021-04-23T09:11:02Z",
              "updatedAt": "2021-05-04T14:26:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 787,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE1MTAwMTg2",
      "title": "PR for when a transport system replays messages",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/787",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Addition to clarify what happens when a transport system replays messages - #780",
      "createdAt": "2021-04-14T09:53:23Z",
      "updatedAt": "2021-05-04T14:27:14Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cbe26fba23a70ea2aff0388e643b8422f32626e0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-3",
      "headRefOid": "fb1adcb164693e38ea9ef82782d03cc5ee841de4",
      "closedAt": "2021-05-04T14:27:14Z",
      "mergedAt": "2021-05-04T14:27:14Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "4259007649eb38b82ae7e22d96e07b2e051a450d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1NjY2NDIx",
          "commit": {
            "abbreviatedOid": "fbe110f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A small suggestion",
          "createdAt": "2021-04-14T14:09:22Z",
          "updatedAt": "2021-04-14T14:09:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- Safely Replayable: when this is true, this means that the Message can be used by a transport mechanism that might transfer it multiple times -- e.g., as a result of racing multiple transports or as part of TCP Fast Open. Also, protocols that do not protect against duplicated messages, such as UDP (when used directly, without a protocol layered atop), can only be used with Messages that are Safely Replayable. When a transport system is permitted to replay messages, replay protection could be provided by the application.\r\n```\r\n\r\nJust a suggestion, fine by me to phrase this differently - but now, you have:\r\n- typo directlty\r\n- \"protocols that do not protect against duplicated messages, such as directly layered over UDP\" ... is this really okay to write? It reads awkwardly to me ... I mean, such as asks for, what, a protocol? So this would mean \"such as protocols that are directly layered over UDP?\" but QUIC is such a protocol. This is about the application being layered directly over UDP!  So ...   hence my suggestion above.",
              "createdAt": "2021-04-14T14:09:22Z",
              "updatedAt": "2021-04-14T14:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1NjkxMzY4",
          "commit": {
            "abbreviatedOid": "fb1adcb"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-14T14:29:48Z",
          "updatedAt": "2021-04-14T14:29:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 793,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE1Mjg3Mjc1",
      "title": "Tiny minset fix",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/793",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This fixes a wrong reference to the \"no segmentation\" property: in fact, the \"request not to bundle messages\" is SCTP's Nagle, and covered by the Capacity profile.\r\n(I mentioned this mistake in #782).\r\n",
      "createdAt": "2021-04-14T14:24:44Z",
      "updatedAt": "2021-05-04T14:35:40Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "cbe26fba23a70ea2aff0388e643b8422f32626e0",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-tiny-minset-fix",
      "headRefOid": "7adf2e19df05667cae09cd2e28c5bb33bdf765f7",
      "closedAt": "2021-05-04T14:35:39Z",
      "mergedAt": "2021-05-04T14:35:39Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3643c0307656f286fb1f78ecc89b42fe5dad6344"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDg1MjYx",
          "commit": {
            "abbreviatedOid": "7adf2e1"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, as discussed.",
          "createdAt": "2021-04-23T09:04:30Z",
          "updatedAt": "2021-04-23T09:04:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 794,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2MDAzNTgw",
      "title": "Fixes around Clone and entanglement",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/794",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #774. Closes #788.\r\nThis changes the use of the term \"entanglement\" as discussed in #774, and moves some text around in this section for better clarity and less repetition. Also, addressing #788, it introduces a framer as an optional parameter to the Clone call.",
      "createdAt": "2021-04-15T12:20:16Z",
      "updatedAt": "2021-05-04T14:38:47Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3335b297a76b0b55ab17db47117a651c31c7f29",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-entanglement",
      "headRefOid": "49935e9971ba14962d1d704fb8eafeb8151e5177",
      "closedAt": "2021-05-04T14:38:46Z",
      "mergedAt": "2021-05-04T14:38:46Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "a68050a8e6d4e638c1a8767bbaa5aafe31aa80d2"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gorryfair I incorporated all of your suggestions, thanks!",
          "createdAt": "2021-04-23T12:19:23Z",
          "updatedAt": "2021-04-23T12:19:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODc0NTM2",
          "commit": {
            "abbreviatedOid": "33984e8"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This resolves the issues with the entangled wording, many thanks",
          "createdAt": "2021-04-16T16:17:09Z",
          "updatedAt": "2021-04-16T16:17:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDc5OTg3",
          "commit": {
            "abbreviatedOid": "33984e8"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the way this is going, but I have suggestions for various changes that might improve this.",
          "createdAt": "2021-04-23T08:58:28Z",
          "updatedAt": "2021-04-23T09:03:27Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "/and so on/ ... is not necessary.",
              "createdAt": "2021-04-23T08:58:28Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            },
            {
              "originalPosition": 32,
              "body": "/it/the Connection Property/ ",
              "createdAt": "2021-04-23T08:59:11Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            },
            {
              "originalPosition": 35,
              "body": "Suggest: \r\n/will automatically make the same change to this Connection Property for all other Connections in the Connection Group./",
              "createdAt": "2021-04-23T09:00:09Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            },
            {
              "originalPosition": 38,
              "body": "/changing/in this case, a later change to the/",
              "createdAt": "2021-04-23T09:01:02Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            },
            {
              "originalPosition": 45,
              "body": "/get/have/\r\nand \r\n/framer/Message Framer/",
              "createdAt": "2021-04-23T09:01:22Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            },
            {
              "originalPosition": 74,
              "body": "/multiple such connections being opened/the opening of multiple such connections,/",
              "createdAt": "2021-04-23T09:02:36Z",
              "updatedAt": "2021-04-23T12:17:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMjc3NTE3",
          "commit": {
            "abbreviatedOid": "49935e9"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2021-04-23T13:08:16Z",
          "updatedAt": "2021-04-23T13:08:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 795,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMTg4NDQ1",
      "title": "Hopefully clearer text for the ReceiveError Event.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/795",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #792.",
      "createdAt": "2021-04-21T13:02:45Z",
      "updatedAt": "2021-06-11T16:11:54Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3335b297a76b0b55ab17db47117a651c31c7f29",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-receive-errors",
      "headRefOid": "5bf923dd704dc8a4ee63f8d602642b3745a5c8e7",
      "closedAt": "2021-06-11T16:11:51Z",
      "mergedAt": "2021-06-11T16:11:51Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "400525d9f198e816beca4086cde566ca64c03c7a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxOTM5ODY0",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T08:49:54Z",
          "updatedAt": "2021-04-22T08:49:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why did you make the messageContext option? Don't you always need this to assign it to a message somehow?",
              "createdAt": "2021-04-22T08:49:54Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxOTQyNzAx",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T08:52:44Z",
          "updatedAt": "2021-04-22T08:52:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "And you also removed the text below that said the messageContext would be optional (e.g. for partially received messages). Was that on purpose? However, I think for the two examples you mention below, it seems to make sense to provide some messageContext.",
              "createdAt": "2021-04-22T08:52:44Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxOTY3NjQy",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-22T09:17:44Z",
          "updatedAt": "2021-04-22T09:17:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I made it optional because, according to the text that was there, it was optional - it just wasn't written like that in the signature, which I thought was an oversight.\r\n\r\nThen I removed the text that said it would be optional because I didn't see the added value of repeating what the Event signature above already shows. I checked, the document doesn't consistently always say \"and there is this parameter, and that parameter\".\r\n\r\nRegarding really making the messageContext optional or not... well... I can't see other uses than the two examples, and I agree that the messageContext makes sense to include in these two cases. But that doesn't mean that there couldn't be any other reception errors, where handing over a messageContext might not be possible. I don't know, personally, I can't think of any such case...",
              "createdAt": "2021-04-22T09:17:45Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NDY2OTE2",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mich clearer, but need more refinement.",
          "createdAt": "2021-05-07T13:38:01Z",
          "updatedAt": "2021-05-07T13:39:02Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Are these _only_ signalled only by an Connection Error or (if one ore more effected messages are known) _in addition_ to a ReceiveError for these messages?",
              "createdAt": "2021-05-07T13:38:01Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NTQwMzcw",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T14:47:32Z",
          "updatedAt": "2021-05-07T14:47:32Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The current text says that a ReceiveError occurs when data is received that can't be full retrieved or parsed, and when it's useful for the application to be notified. I don't see the sentence about the ConnectionError contradicting or in some way eliminating this statement about the ReceiveError.\r\n\r\nSo - to answer your question: if some messages are known, and if it's useful to inform the application, a ReceiveError would occur for them in addition to the ConnectionError.",
              "createdAt": "2021-05-07T14:47:32Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjI3MzUx",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T15:47:30Z",
          "updatedAt": "2021-05-07T15:47:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's make it non-optional",
              "createdAt": "2021-05-07T15:47:30Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjI3NzA3",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T15:47:56Z",
          "updatedAt": "2021-05-07T15:47:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nindicate that a Message (identified via the MessageContext)\r\n```",
              "createdAt": "2021-05-07T15:47:56Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjI4MjEy",
          "commit": {
            "abbreviatedOid": "efbe421"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T15:48:31Z",
          "updatedAt": "2021-05-07T15:48:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nConnection -> ReceiveError<messageContext, reason?>\r\n```",
              "createdAt": "2021-05-07T15:48:31Z",
              "updatedAt": "2021-05-08T08:14:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1MDE1ODQy",
          "commit": {
            "abbreviatedOid": "5bf923d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-08T19:17:54Z",
          "updatedAt": "2021-05-08T19:17:58Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Yeah, I think the proposed text is fine now.",
              "createdAt": "2021-05-08T19:17:54Z",
              "updatedAt": "2021-05-08T19:17:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 796,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMTk1NTg0",
      "title": "Remove one confusing sentence (#790)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/796",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #790.",
      "createdAt": "2021-04-21T13:06:37Z",
      "updatedAt": "2021-05-04T14:39:32Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3335b297a76b0b55ab17db47117a651c31c7f29",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-singlestream-priority",
      "headRefOid": "f1f4e5d420acfcd631e4be22ccc10b52445c4b4e",
      "closedAt": "2021-05-04T14:39:32Z",
      "mergedAt": "2021-05-04T14:39:32Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "998c53c6bdcda339f36dff0b07c797e25b694a8d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDc5MTQz",
          "commit": {
            "abbreviatedOid": "f1f4e5d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like simple examples, this one wasn't great so this is OK.",
          "createdAt": "2021-04-23T08:57:33Z",
          "updatedAt": "2021-04-23T08:57:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 797,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwODExMjAy",
      "title": "Remove the mention of \"hierarchy\" in priority text",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/797",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #779 ",
      "createdAt": "2021-04-22T06:49:59Z",
      "updatedAt": "2021-05-04T14:40:01Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e3335b297a76b0b55ab17db47117a651c31c7f29",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-priorities-no-hierarchies",
      "headRefOid": "0f513f8c7cc4926730fc90a8c8f490d0bf1b058a",
      "closedAt": "2021-05-04T14:40:00Z",
      "mergedAt": "2021-05-04T14:40:00Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "797e1a04248c50212e0079f0eec25db68d99e3f0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzMDc3NTYx",
          "commit": {
            "abbreviatedOid": "0f513f8"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems to resolving the odd wording.",
          "createdAt": "2021-04-23T08:55:48Z",
          "updatedAt": "2021-04-23T08:55:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 824,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMwNTczOTg4",
      "title": "minset appendix: remove sentence about framers",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/824",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "... in text that refers to receiving a byte stream. Closes #822.",
      "createdAt": "2021-05-05T13:01:31Z",
      "updatedAt": "2021-05-07T15:26:22Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9aedd18c46d78aae2f0bdccc599fdd195cf31918",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-minset-receive-data-mapping",
      "headRefOid": "142dfbbfae937094aa4b3c924f1305d66cde7923",
      "closedAt": "2021-05-07T15:26:22Z",
      "mergedAt": "2021-05-07T15:26:21Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "a0060b15366d17328b47f7ef8fee8752666939da"
      },
      "comments": [
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@abrunstrom you're right. Done",
          "createdAt": "2021-05-07T14:59:10Z",
          "updatedAt": "2021-05-07T14:59:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUzOTYyMzQ2",
          "commit": {
            "abbreviatedOid": "10c10bf"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-06T23:06:17Z",
          "updatedAt": "2021-05-06T23:06:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0Mzg2NzUy",
          "commit": {
            "abbreviatedOid": "10c10bf"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-07T12:09:14Z",
          "updatedAt": "2021-05-07T12:09:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NDk1MjAx",
          "commit": {
            "abbreviatedOid": "10c10bf"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fine to remove the framer part. Reading the update I am wondering if it should also mention the Receive Action?",
          "createdAt": "2021-05-07T14:04:48Z",
          "updatedAt": "2021-05-07T14:04:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 825,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMyODc3MDc0",
      "title": "Fixes minor editorial nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/825",
      "state": "MERGED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-07T14:42:49Z",
      "updatedAt": "2021-05-07T15:26:51Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "9aedd18c46d78aae2f0bdccc599fdd195cf31918",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "abrunstrom-small-edits",
      "headRefOid": "c219cd081b66d93df4be9dd5393fb6b0ae527fbe",
      "closedAt": "2021-05-07T15:26:51Z",
      "mergedAt": "2021-05-07T15:26:51Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 826,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzMDA4MTIx",
      "title": "Clarify applicability of specific properties; fix #789",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/826",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2021-05-07T16:05:43Z",
      "updatedAt": "2021-06-11T15:37:32Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "789-better-musts",
      "headRefOid": "7d6ac01e1d69facbe113c0d01dbdc21e9d07fb11",
      "closedAt": "2021-06-11T15:37:28Z",
      "mergedAt": "2021-06-11T15:37:27Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "fc1d1dce7eb568f9035e63f2be47b7add67152df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjkwMjAw",
          "commit": {
            "abbreviatedOid": "0d019fe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's make it consistent to the terms in 3.2",
          "createdAt": "2021-05-07T17:02:54Z",
          "updatedAt": "2021-05-07T17:03:53Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nProtocol Specific Properties are defined in a transport- and \r\n```",
              "createdAt": "2021-05-07T17:02:54Z",
              "updatedAt": "2021-05-07T17:03:53Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nToo much reliance by an application on Protocol Specific Properties can significantly \r\n```",
              "createdAt": "2021-05-07T17:03:14Z",
              "updatedAt": "2021-05-07T17:03:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1MDE1OTUx",
          "commit": {
            "abbreviatedOid": "0d019fe"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-08T19:19:49Z",
          "updatedAt": "2021-05-08T19:19:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This terminology is what's already used in the doc, so I say to keep it.",
              "createdAt": "2021-05-08T19:19:49Z",
              "updatedAt": "2021-05-08T19:19:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MzcwNTIy",
          "commit": {
            "abbreviatedOid": "0d019fe"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T14:49:10Z",
          "updatedAt": "2021-06-03T14:49:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yes, in the current version, we have three times \"Protocol Specific Properties\" and three times \"Specific Protocol Properties\" meaning the same thing. We should really unify on one term.",
              "createdAt": "2021-06-03T14:49:10Z",
              "updatedAt": "2021-06-03T14:49:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1OTI2NTAx",
          "commit": {
            "abbreviatedOid": "0d019fe"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T05:23:40Z",
          "updatedAt": "2021-06-04T05:23:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Oh yes, absolutely, it should be Protocol Specific Properties everywhere  (actually I wonder if this wouldn't be even better with a dash?  I.e., \"Protocol-specific Properties\"?).\r\n\r\nTo me, \"Specific Protocol Properties\" doesn't read like it would even mean the same thing, it reads to me as \"specific ones as opposed to very vague ones\"  (well, as opposed to \"generic\" ones ... so that kinda works, but it's less clear that these are specific *to* a protocol, IMO).",
              "createdAt": "2021-06-04T05:23:41Z",
              "updatedAt": "2021-06-04T05:23:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDE0NTI4",
          "commit": {
            "abbreviatedOid": "0d019fe"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T03:22:23Z",
          "updatedAt": "2021-06-11T03:22:23Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "@philsbln - Looking good, but would \"Protocol-Specific Properties\" also be OK for all the cases?",
              "createdAt": "2021-06-11T03:22:23Z",
              "updatedAt": "2021-06-11T03:22:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 827,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzMDM4NDQ1",
      "title": "Explicitly distinguish Callbacks from Events",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/827",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes issue #775",
      "createdAt": "2021-05-07T16:27:12Z",
      "updatedAt": "2021-06-11T15:34:26Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/callbacks",
      "headRefOid": "2374e1004ab5d6a0c8b454c22c8146bc9aefb2dd",
      "closedAt": "2021-06-11T15:34:26Z",
      "mergedAt": "2021-06-11T15:34:26Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "7890dd740c62239ef5b7830e294f6e316a95a56c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NjcyMTU0",
          "commit": {
            "abbreviatedOid": "0a670bc"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T16:40:02Z",
          "updatedAt": "2021-05-07T16:40:03Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nCallbacks block the progress of a connection, which distinguishes them from other Events in the transport system. How callbacks and events are implemented is specific to each implementation.\r\n```",
              "createdAt": "2021-05-07T16:40:02Z",
              "updatedAt": "2021-05-07T16:40:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0Njg2NjY4",
          "commit": {
            "abbreviatedOid": "3c0f9c9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-07T16:58:23Z",
          "updatedAt": "2021-05-07T16:58:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MDYzOTcx",
          "commit": {
            "abbreviatedOid": "3c0f9c9"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Minor suggestion",
          "createdAt": "2021-05-20T08:00:04Z",
          "updatedAt": "2021-05-20T08:05:58Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nCallbacks block the progress of a Connection's establishment, which distinguishes them from other Events in the transport system. How callbacks and events are implemented is specific to each implementation.\r\n```",
              "createdAt": "2021-05-20T08:00:05Z",
              "updatedAt": "2021-05-20T08:05:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1MzY0MzI5",
          "commit": {
            "abbreviatedOid": "3c0f9c9"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T14:43:54Z",
          "updatedAt": "2021-06-03T14:43:54Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I would prefer to leave the connection on lower case (as I am not sure that the connection object we refer to in upper case has/makes progress, but something in the underlaying transport system).\r\n\r\n ```suggestion\r\nCallbacks block the progress of the connection establishment, which distinguishes them from other Events in the transport system. How callbacks and events are implemented is specific to each implementation.\r\n```",
              "createdAt": "2021-06-03T14:43:54Z",
              "updatedAt": "2021-06-03T14:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MDcxOTUw",
          "commit": {
            "abbreviatedOid": "2374e10"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T08:58:12Z",
          "updatedAt": "2021-06-04T08:58:13Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "ok, this makes sense to me",
              "createdAt": "2021-06-04T08:58:12Z",
              "updatedAt": "2021-06-04T08:58:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MDcyMzQ5",
          "commit": {
            "abbreviatedOid": "2374e10"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-04T08:58:38Z",
          "updatedAt": "2021-06-04T08:58:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTYxOTk4",
          "commit": {
            "abbreviatedOid": "2374e10"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T15:32:43Z",
          "updatedAt": "2021-06-11T15:32:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 828,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzMDU0OTgw",
      "title": "Ignore preservation of message boundaries for selection by default.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/828",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Fixes #806",
      "createdAt": "2021-05-07T16:39:02Z",
      "updatedAt": "2021-05-08T08:20:20Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "806-ignore-boundaries",
      "headRefOid": "494392f4e0694678686f69df0f392970a1462348",
      "closedAt": "2021-05-08T08:20:13Z",
      "mergedAt": "2021-05-08T08:20:13Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "5c98275e0d5b4fa2a1707600237f4e6d20cfc0da"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0Njc0NTU4",
          "commit": {
            "abbreviatedOid": "494392f"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-07T16:43:03Z",
          "updatedAt": "2021-05-07T16:43:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 829,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzMDcwMzQz",
      "title": "Fix #809",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/829",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2021-05-07T16:50:18Z",
      "updatedAt": "2021-05-08T19:20:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "0139c0e22a6f7e8c85f3c591a5495bde1f439ace",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "809-delete-confusing-sentence",
      "headRefOid": "5478335b9f72059ea92f08f1871e74ef9d607840",
      "closedAt": "2021-05-08T19:20:37Z",
      "mergedAt": "2021-05-08T19:20:37Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e142ddd93d7c3f64ed8882076bceb30bd8a47ec2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1MDE2MDAz",
          "commit": {
            "abbreviatedOid": "5478335"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-08T19:20:33Z",
          "updatedAt": "2021-05-08T19:20:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 830,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM0ODE2ODk5",
      "title": "Add appendix note about object freeing",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/830",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #762",
      "createdAt": "2021-05-08T19:30:48Z",
      "updatedAt": "2021-06-02T15:49:21Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e142ddd93d7c3f64ed8882076bceb30bd8a47ec2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "7df496e7029ea48f48d44ca4aa89973f25484488",
      "closedAt": "2021-06-02T15:49:20Z",
      "mergedAt": "2021-06-02T15:49:20Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "c80574dcd331039ec0a80988d319d2031220efe8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNjc1Nzk1",
          "commit": {
            "abbreviatedOid": "7df496e"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2021-05-19T21:26:49Z",
          "updatedAt": "2021-05-19T21:26:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MDcyOTk3",
          "commit": {
            "abbreviatedOid": "7df496e"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-20T08:09:26Z",
          "updatedAt": "2021-05-20T08:09:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 831,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM0ODMyNjU5",
      "title": "Explain rationale for path > protocol preference",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/831",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "API"
      ],
      "body": "Closes #785",
      "createdAt": "2021-05-08T19:46:52Z",
      "updatedAt": "2021-05-11T19:13:04Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e142ddd93d7c3f64ed8882076bceb30bd8a47ec2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "74b6fc6ee86c208c248d0f21510f5c8134cc004a",
      "closedAt": "2021-05-11T19:13:04Z",
      "mergedAt": "2021-05-11T19:13:04Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "252c0fe19a7e33c5840af33a1dd680083588d047"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2NzA4MzM1",
          "commit": {
            "abbreviatedOid": "74b6fc6"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-11T13:29:32Z",
          "updatedAt": "2021-05-11T13:29:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 832,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM0ODQ3NTIw",
      "title": "Make disabling security explicit",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/832",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #804",
      "createdAt": "2021-05-08T20:02:03Z",
      "updatedAt": "2021-06-02T15:48:43Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "e142ddd93d7c3f64ed8882076bceb30bd8a47ec2",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "tfpauly-patch-4",
      "headRefOid": "b8a06857c78193fd0b725e61a0e4a7e28a383c13",
      "closedAt": "2021-06-02T15:48:43Z",
      "mergedAt": "2021-06-02T15:48:43Z",
      "mergedBy": "mwelzl",
      "mergeCommit": {
        "oid": "a2cd004723e6a54f1968cdf1beba54ff012b6836"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1OTg2MjU1",
          "commit": {
            "abbreviatedOid": "b8a0685"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-10T18:55:47Z",
          "updatedAt": "2021-05-10T18:55:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MDI3NzY5",
          "commit": {
            "abbreviatedOid": "b8a0685"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2021-05-10T19:49:41Z",
          "updatedAt": "2021-05-10T19:49:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MDgwOTAy",
          "commit": {
            "abbreviatedOid": "b8a0685"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-20T08:17:23Z",
          "updatedAt": "2021-05-20T08:17:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 833,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQzODg2NTc2",
      "title": "Transport Segmentation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/833",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This attempts to clarify transport segmentation (a sparate PR will propose to clarify Frag)",
      "createdAt": "2021-05-13T10:54:58Z",
      "updatedAt": "2021-05-19T13:00:23Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "252c0fe19a7e33c5840af33a1dd680083588d047",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-seg",
      "headRefOid": "7623be543bb104144506ae4fe38b8995c7464a35",
      "closedAt": "2021-05-19T13:00:15Z",
      "mergedAt": "2021-05-19T13:00:15Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing Set part of the Frag story",
          "createdAt": "2021-05-19T13:00:23Z",
          "updatedAt": "2021-05-19T13:00:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5OTM2NTM0",
          "commit": {
            "abbreviatedOid": "7623be5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-14T15:14:08Z",
          "updatedAt": "2021-05-14T15:14:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 834,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQzODk0NjE3",
      "title": "Suggestion for no fragmentation",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/834",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This attempts to set \"no segmentation\" as the usual case, and this as a corner case - such as would be from a transport that segments at layer 4, but does not fragment at layer 3. This latter case is what is desired to send one message using a sequence of seprate IP packets.",
      "createdAt": "2021-05-13T11:09:36Z",
      "updatedAt": "2021-05-19T12:59:19Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "252c0fe19a7e33c5840af33a1dd680083588d047",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-frag",
      "headRefOid": "09e940e1493cabf98a643e58c668393c26e48906",
      "closedAt": "2021-05-19T12:59:11Z",
      "mergedAt": "2021-05-19T12:59:11Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "5377e72e2769e34614ac09ccc31e3bfdf6355a31"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing the Frag part of the story",
          "createdAt": "2021-05-19T12:58:39Z",
          "updatedAt": "2021-05-19T12:58:39Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this and merging the Frag parts",
          "createdAt": "2021-05-19T12:59:19Z",
          "updatedAt": "2021-05-19T12:59:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5OTM2NDgx",
          "commit": {
            "abbreviatedOid": "09e940e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-14T15:14:05Z",
          "updatedAt": "2021-05-14T15:14:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 836,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3NjUwNjc5",
      "title": "Trying to add some policy to the path selection",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/836",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "This tries to write something small but specific about Network Policies #701",
      "createdAt": "2021-05-19T13:10:04Z",
      "updatedAt": "2021-06-11T16:05:47Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-policy",
      "headRefOid": "c61928e74220e81a6834cb768b6a5af6db28c04d",
      "closedAt": "2021-06-11T16:05:47Z",
      "mergedAt": "2021-06-11T16:05:47Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "47fcd8e11f61c3b9dca9b2a4db076e99a021b459"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2021-05-19T20:52:18Z",
          "updatedAt": "2021-05-19T20:52:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNjM2MDQz",
          "commit": {
            "abbreviatedOid": "192435f"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think the policy is separate from the API.",
          "createdAt": "2021-05-19T20:33:43Z",
          "updatedAt": "2021-05-19T20:56:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This reads strangely to me as it is not really the API that provides support for this. Not sure anything needs to be added to this section.",
              "createdAt": "2021-05-19T20:33:43Z",
              "updatedAt": "2021-05-19T20:56:26Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nServices System is generally independent of the specific mechanism/protocol \r\n```",
              "createdAt": "2021-05-19T20:37:46Z",
              "updatedAt": "2021-05-19T20:56:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MDg2NTUz",
          "commit": {
            "abbreviatedOid": "743562d"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for doing this!  I like it, but I have inserted one comment that needs clarification, I think",
          "createdAt": "2021-05-20T08:23:09Z",
          "updatedAt": "2021-05-20T08:23:37Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This seems like the same issue that @abrunstrom pointed out about a different part of this text: \"is provided\" gives me the impression that it might be the application's job to provide this information to the transport system via the API. That's not what this is, right? In this case, I'd rather go with something like:\r\n\r\nWhen the transport system has additional information (..). ... available ... about the networks over which ...\r\n",
              "createdAt": "2021-05-20T08:23:09Z",
              "updatedAt": "2021-05-20T08:23:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTExOTc0",
          "commit": {
            "abbreviatedOid": "743562d"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T08:48:37Z",
          "updatedAt": "2021-05-20T08:48:37Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "available will do. I will rework.",
              "createdAt": "2021-05-20T08:48:37Z",
              "updatedAt": "2021-05-20T08:48:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNzA3MzI0",
          "commit": {
            "abbreviatedOid": "6b568d0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T10:58:31Z",
          "updatedAt": "2021-06-11T10:58:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think you've done this but not resolved this conversation. Clicking the button.",
              "createdAt": "2021-06-11T10:58:32Z",
              "updatedAt": "2021-06-11T10:58:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNzA3NTE0",
          "commit": {
            "abbreviatedOid": "6b568d0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T10:58:47Z",
          "updatedAt": "2021-06-11T10:58:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTgzOTk0",
          "commit": {
            "abbreviatedOid": "c61928e"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-06-11T15:55:43Z",
          "updatedAt": "2021-06-11T15:55:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 837,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3NjYxMTg2",
      "title": "Not unreliable, but no reliability guarentees.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/837",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Not requiring things to be unreliable, but allow no reliability guarentees.\r\nand /throw/generate/",
      "createdAt": "2021-05-19T13:21:16Z",
      "updatedAt": "2021-05-26T11:42:51Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-unreliable",
      "headRefOid": "39fa0594c0f39e73344490235a19d327dbbcf4d4",
      "closedAt": "2021-05-26T11:42:51Z",
      "mergedAt": "2021-05-26T11:42:50Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "b1c34e11f85167e17357571db0a62f87e1a32318"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYzNzAyNjYx",
          "commit": {
            "abbreviatedOid": "b0c61b9"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, only one possible small change suggested.",
          "createdAt": "2021-05-19T22:11:27Z",
          "updatedAt": "2021-05-19T22:13:37Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Perhaps \"without reliability guarantees\"?",
              "createdAt": "2021-05-19T22:11:27Z",
              "updatedAt": "2021-05-19T22:13:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MDkxNjg0",
          "commit": {
            "abbreviatedOid": "360c1f8"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "DISMISSED",
          "body": "LGTM except for one detail (I made a suggestion)",
          "createdAt": "2021-05-20T08:28:17Z",
          "updatedAt": "2021-05-26T11:42:40Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n* \"Reliably transfer data, with congestion control\", \"Reliably transfer a message, with congestion control\" and \"Unreliably transfer a message\":\r\n```\r\n\r\nLike it or not, but this is a reference to a specific term from RFC 8923, and should therefore be kept as it is. The point of this appendix is to enable back-tracking to the original spec, via 8923 => 8303 or 8304.",
              "createdAt": "2021-05-20T08:28:17Z",
              "updatedAt": "2021-05-20T08:28:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 838,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3Njc0MzYx",
      "title": "Local/Remote Endpoints",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/838",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Fix #755",
      "createdAt": "2021-05-19T13:34:58Z",
      "updatedAt": "2021-05-26T14:06:00Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-locrem",
      "headRefOid": "2e95dde8151144d639c67193d9b4e6c0a58b295d",
      "closedAt": "2021-05-26T14:05:54Z",
      "mergedAt": "2021-05-26T14:05:54Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "be3cea7faa69e507a7d2f62b7a650b0e53a18044"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTA1Nzk2",
          "commit": {
            "abbreviatedOid": "00f6355"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "just a nit, else LGTM",
          "createdAt": "2021-05-20T08:42:26Z",
          "updatedAt": "2021-05-20T08:42:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nestablish a Connection with an \r\n```",
              "createdAt": "2021-05-20T08:42:26Z",
              "updatedAt": "2021-05-20T08:42:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDM2MDMy",
          "commit": {
            "abbreviatedOid": "2e95dde"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T13:41:52Z",
          "updatedAt": "2021-05-26T13:41:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 839,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3NzYyMjc3",
      "title": "Unconfuse checksum for gorry",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/839",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mwelzl"
      ],
      "labels": [
        "API"
      ],
      "body": "I was so confused, if people like this PR I think I might be less confused in future.",
      "createdAt": "2021-05-19T14:58:55Z",
      "updatedAt": "2021-05-26T11:36:44Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-checksum",
      "headRefOid": "e220b5e18135bacf13d0cef9d3f51ae44678295b",
      "closedAt": "2021-05-26T11:36:33Z",
      "mergedAt": "2021-05-26T11:36:33Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "baaa4f22fce193030e4499e28e7956dec0f7994f"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thought to fix #776",
          "createdAt": "2021-05-19T14:59:25Z",
          "updatedAt": "2021-05-19T14:59:25Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR for issue: #776 ",
          "createdAt": "2021-05-19T15:07:11Z",
          "updatedAt": "2021-05-19T15:07:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTA3NzU3",
          "commit": {
            "abbreviatedOid": "1fa209b"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks - great catch about s/perMsgChecksumLenSend/perMsgChecksumSend  (and -Recv) in particular, these must have been historical remnants.\r\n\r\nI added one comment related to English, take a look to see if you agree.",
          "createdAt": "2021-05-20T08:44:20Z",
          "updatedAt": "2021-05-20T08:48:08Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Shouldn't this be \"A receiving Endpoint will not forward messages that have less coverage to the application.\" ?",
              "createdAt": "2021-05-20T08:46:10Z",
              "updatedAt": "2021-05-20T08:48:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTI2Mjk0",
          "commit": {
            "abbreviatedOid": "1fa209b"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T09:02:24Z",
          "updatedAt": "2021-05-20T09:02:24Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Can't tell the difference here. so accepted yours.",
              "createdAt": "2021-05-20T09:02:24Z",
              "updatedAt": "2021-05-20T09:02:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 840,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3Nzc2OTUx",
      "title": "Fix Case of Loc/Remote",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/840",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Architecture",
        "editorial"
      ],
      "body": "NiT",
      "createdAt": "2021-05-19T15:13:39Z",
      "updatedAt": "2021-05-20T09:05:30Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-locrem-1",
      "headRefOid": "383841f9a8c8c274bcdfd7943c4ee2555abdc2f4",
      "closedAt": "2021-05-20T09:05:30Z",
      "mergedAt": "2021-05-20T09:05:30Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "e9c8baf83fd647394d31250722eef48b2590491c"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Part of Issue  #755",
          "createdAt": "2021-05-19T15:15:28Z",
          "updatedAt": "2021-05-19T15:15:28Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged ",
          "createdAt": "2021-05-20T09:05:21Z",
          "updatedAt": "2021-05-20T09:05:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTEyMzQ0",
          "commit": {
            "abbreviatedOid": "383841f"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-20T08:48:59Z",
          "updatedAt": "2021-05-20T08:48:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 841,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3Nzg3NTU1",
      "title": "Local/Remote in Impl",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/841",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Architecture",
        "Implementation"
      ],
      "body": "Trying to address use of \u201cremote\u201d and \"local\"  #755",
      "createdAt": "2021-05-19T15:24:57Z",
      "updatedAt": "2021-05-26T11:44:09Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "ab6e6e5f2c40d904086bc26b4e7742aa79a62a4d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-localremimpl",
      "headRefOid": "ebb7b6d15a054982c6e92514b0a045ab8ca17c81",
      "closedAt": "2021-05-26T11:44:09Z",
      "mergedAt": "2021-05-26T11:44:09Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "c967ef38fe465979e7821ef58ad033a52b8e1dbe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0MTEzNjEy",
          "commit": {
            "abbreviatedOid": "ba8073a"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-20T08:50:14Z",
          "updatedAt": "2021-05-20T08:51:40Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nThe process of connection establishment completes when one leaf node of the tree has successfully completed negotiation with the Remote Endpoint, or else all nodes of the tree have failed to connect. The first leaf node to complete its connection is then used by the application to send and receive data.\r\n```\r\n\r\nThis just removes a space before the comma",
              "createdAt": "2021-05-20T08:50:15Z",
              "updatedAt": "2021-05-20T08:51:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 845,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MDkxNzE4",
      "title": "Update names full checksum conn. properties",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/845",
      "state": "MERGED",
      "author": "abrunstrom",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "",
      "createdAt": "2021-06-11T12:29:16Z",
      "updatedAt": "2021-06-11T16:12:29Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "abrunstrom-patch-checksum",
      "headRefOid": "3b8ad3777879930fc15397514e61fc6ae461bcce",
      "closedAt": "2021-06-11T16:12:22Z",
      "mergedAt": "2021-06-11T16:12:21Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "397dc2dd4a3f38a4cbb8f8a9294a609cc349bfab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNzkyMjQ3",
          "commit": {
            "abbreviatedOid": "3b8ad37"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I do not mind what the name is called as long as it is clear. I think the proposal looks good.",
          "createdAt": "2021-06-11T12:49:06Z",
          "updatedAt": "2021-06-11T12:49:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 847,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MTI0NzIx",
      "title": "Clarifications around Connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/847",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Tries to clarify that a Connection is a logical connection, and doesn't necessarily require a connection oriented underlying transport protocol. \r\n\r\nCross-reference to the descriptions of Preconnection and the connection establishment procedures.",
      "createdAt": "2021-06-11T13:03:06Z",
      "updatedAt": "2021-06-11T16:03:27Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-connections20210611",
      "headRefOid": "facfc1c4a7c93e2e63cd54887ad04194d5161c86",
      "closedAt": "2021-06-11T16:03:27Z",
      "mergedAt": "2021-06-11T16:03:27Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c04810af88e7de2f340095ff5b0d4fc377e290f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxODExODEx",
          "commit": {
            "abbreviatedOid": "facfc1c"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good.\r\nCan we also change to something like this in section 1: /A unified interface to datagram and connection-oriented transport protocols, allowing use of a common API for connection-establishment and closing;/\r\n",
          "createdAt": "2021-06-11T13:09:20Z",
          "updatedAt": "2021-06-11T13:09:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 848,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MTQ0OTMz",
      "title": "No such protocol\u2026",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/848",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [],
      "body": "Nit: Section 3.1: No such protocol\u2026 #753",
      "createdAt": "2021-06-11T13:22:52Z",
      "updatedAt": "2021-06-11T16:47:44Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-4",
      "headRefOid": "5f808d61f8fb665ff09cf8652b58e3cb11c37982",
      "closedAt": "2021-06-11T15:36:45Z",
      "mergedAt": "2021-06-11T15:36:45Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "0e7710fab72f73c61ce65c58b58ceeda98676d8e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 853,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MTg5NzAz",
      "title": "Clarify Setting Message Properties on Preconnections and Connections",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/853",
      "state": "OPEN",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "closes #808",
      "createdAt": "2021-06-11T14:06:54Z",
      "updatedAt": "2021-06-16T10:44:40Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/message-properties-closing-808",
      "headRefOid": "1f9e73c6e20ef065b25ae783a374500deb1c353e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDExMjEy",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-11T16:13:31Z",
          "updatedAt": "2021-06-11T16:14:32Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Might be nitpicking here, but -- the Message Properties at this time are not configuring the Protocol Stack, they're just setting common defaults for Send, correct?",
              "createdAt": "2021-06-11T16:13:31Z",
              "updatedAt": "2021-06-11T16:14:32Z"
            },
            {
              "originalPosition": 16,
              "body": "This change seems unrelated to the main change (and we've gone back and forth here); propose removing it.",
              "createdAt": "2021-06-11T16:14:24Z",
              "updatedAt": "2021-06-11T16:14:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDMzNzM2",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:40:20Z",
          "updatedAt": "2021-06-11T16:40:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Correct, but there is no implication when the configuration will actually take effect.",
              "createdAt": "2021-06-11T16:40:21Z",
              "updatedAt": "2021-06-11T16:40:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDM2MDA0",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "philsbln",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:43:23Z",
          "updatedAt": "2021-06-11T16:43:23Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Reading it without this hint felt a little confusing to me after not reading it a long time. I am happy to remove it, but would prefer third opinion here.",
              "createdAt": "2021-06-11T16:43:23Z",
              "updatedAt": "2021-06-11T16:43:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODI5MDg1",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I also wonder if this really does all that's requested in #808...",
          "createdAt": "2021-06-16T07:42:39Z",
          "updatedAt": "2021-06-16T07:52:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nof the selected Protocol Stacks on a per-Connection and Message level.\r\n```\r\n\r\nI agree that @britram is nitpicking  :-)   ... because I think that pointing out that Message Properties only influence the send call will only make this harder to read, at no real benefit.",
              "createdAt": "2021-06-16T07:42:39Z",
              "updatedAt": "2021-06-16T07:52:59Z"
            },
            {
              "originalPosition": 16,
              "body": "I agree to remove it. The text below the Clone call explains it all, and it was revised not too long ago in a PR, so this sits with agreement behind it.\r\n\r\nA side note, we no longer talk about Connections being \"entangled\": the term only applies to their Connection Properties.  Also, using the term here before it's explained isn't good... at best, we could use the \"streams in a multi-streaming protocol\" example, but if you're missing this, it also fits better as an addition to the text below the call.",
              "createdAt": "2021-06-16T07:48:35Z",
              "updatedAt": "2021-06-16T07:52:59Z"
            },
            {
              "originalPosition": 27,
              "body": "The sentence that you included here is only making things more confusing, IMO. Suggest to remove it.",
              "createdAt": "2021-06-16T07:52:02Z",
              "updatedAt": "2021-06-16T07:52:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MDAxOTEy",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T10:35:34Z",
          "updatedAt": "2021-06-16T10:35:34Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Agree to remove.",
              "createdAt": "2021-06-16T10:35:34Z",
              "updatedAt": "2021-06-16T10:35:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MDA5Mjgw",
          "commit": {
            "abbreviatedOid": "1f9e73c"
          },
          "author": "abrunstrom",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T10:44:39Z",
          "updatedAt": "2021-06-16T10:44:40Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I think a first modified sentence is sufficient \"Message Properties set on a Connection also apply only to that Connection\". Actually reading it again now I realize that it is the example that confuses things, because that talks about setting a Message Property on a Message, so maybe we can just remove the example as it does not belong in this section. ",
              "createdAt": "2021-06-16T10:44:40Z",
              "updatedAt": "2021-06-16T10:44:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 855,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MTkwMjk0",
      "title": "Resolve #672: increase consistency of formatting/spelling",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/855",
      "state": "OPEN",
      "author": "squarooticus",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DO NOT MERGE YET. This is a partial proposed change. See #672 for more info and questions.",
      "createdAt": "2021-06-11T14:07:25Z",
      "updatedAt": "2021-06-11T14:07:25Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "672-krose-edit-pass",
      "headRefOid": "3b411f46a50514a17543037d467c583590b16039",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 856,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MjM5ODQ0",
      "title": "Editorial nits",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/856",
      "state": "MERGED",
      "author": "csperkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "Fix a bunch of nits",
      "createdAt": "2021-06-11T14:56:24Z",
      "updatedAt": "2021-07-08T11:48:18Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c05374ca4827d08327163bc1bc260456b919bb64",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "csperkins-nits20210611",
      "headRefOid": "dbbf12d31bd2e340b86654a777d7955a9f788c64",
      "closedAt": "2021-07-08T11:48:14Z",
      "mergedAt": "2021-07-08T11:48:14Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "9718e754ce1f7a573a51e7c330c04f094254372b"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good.",
          "createdAt": "2021-06-11T15:29:29Z",
          "updatedAt": "2021-06-11T15:29:29Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would just go ahead and merge it, but, sigh, it has a conflict...  I hope someone more git-savvy than me can solve this.",
          "createdAt": "2021-06-16T13:47:26Z",
          "updatedAt": "2021-06-16T13:47:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxOTQxMTE3",
          "commit": {
            "abbreviatedOid": "83da2b0"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good",
          "createdAt": "2021-06-11T15:11:41Z",
          "updatedAt": "2021-06-11T15:11:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MTkxMTQz",
          "commit": {
            "abbreviatedOid": "83da2b0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-16T13:46:43Z",
          "updatedAt": "2021-06-16T13:46:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 857,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MjQ0NTQx",
      "title": "Fixes #812",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/857",
      "state": "MERGED",
      "author": "philsbln",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "closes #812 ",
      "createdAt": "2021-06-11T15:00:40Z",
      "updatedAt": "2021-07-08T10:46:11Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c80574dcd331039ec0a80988d319d2031220efe8",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "philsbln/multipath-812",
      "headRefOid": "8d248148c6f86adcc9cec6e74e1df6dfc78d7333",
      "closedAt": "2021-07-08T10:46:11Z",
      "mergedAt": "2021-07-08T10:46:10Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "9cd3d5e18d59b7a8efa3cb62a686284920c83f50"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQ1Mjg2",
          "commit": {
            "abbreviatedOid": "8d24814"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This reflects what we agreed on, during the last interim.",
          "createdAt": "2021-06-15T16:39:18Z",
          "updatedAt": "2021-06-15T16:39:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 858,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4MjkxMTk2",
      "title": "PR to align Capacity profile with API",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/858",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Implementation"
      ],
      "body": "This is a first cut, I'll update next.",
      "createdAt": "2021-06-11T15:48:52Z",
      "updatedAt": "2021-06-18T09:25:08Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fc1d1dce7eb568f9035e63f2be47b7add67152df",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-5",
      "headRefOid": "1cbcb83472f33741cf33ad121ad3e4c7d1fcdbee",
      "closedAt": "2021-06-16T13:59:52Z",
      "mergedAt": "2021-06-16T13:59:52Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "53d54d078fc360fb42e59b7ce46ce78d16df18dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDMwNjM3",
          "commit": {
            "abbreviatedOid": "2982824"
          },
          "author": "theri",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T16:37:50Z",
          "updatedAt": "2021-06-11T16:37:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n     Prefer adapting to paths to determine the highest available capacity, based on the observed maximum throughput.\r\n```",
              "createdAt": "2021-06-11T16:37:51Z",
              "updatedAt": "2021-06-11T16:37:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MjAwOTI5",
          "commit": {
            "abbreviatedOid": "1cbcb83"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2021-06-16T13:53:55Z",
          "updatedAt": "2021-06-16T13:53:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 860,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5Mzc5ODA4",
      "title": "Freezing pre-connection state.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/860",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API",
        "Implementation"
      ],
      "body": "To clarify when and how objects are froze.  #859\r\n\r\nArch: No current change needed\r\nAPI: Clarify \r\nImpl: Explain how\r\n",
      "createdAt": "2021-06-14T08:54:49Z",
      "updatedAt": "2021-06-16T14:01:56Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdea22b1f5acaabecd5c5a6c576d8f64a111833d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-deep-properties",
      "headRefOid": "bfb28e44a2cbcf1b32ca59efc4383953015d5837",
      "closedAt": "2021-06-16T14:01:52Z",
      "mergedAt": "2021-06-16T14:01:52Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "6f07eb75c5e847e37460140cc4b57bb406acd320"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM.",
          "createdAt": "2021-06-15T17:44:34Z",
          "updatedAt": "2021-06-15T17:44:34Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm merging this I think I have resolved the issues I was addressing, if there are still issues, let's open a new PR.",
          "createdAt": "2021-06-16T14:01:56Z",
          "updatedAt": "2021-06-16T14:01:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNzk2MTg5",
          "commit": {
            "abbreviatedOid": "ae3d914"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T11:24:32Z",
          "updatedAt": "2021-06-14T11:24:32Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The original seems clearer to me: it's more explicit about what happens, and when. Maybe remove the second sentence, since it's covered below?",
              "createdAt": "2021-06-14T11:24:32Z",
              "updatedAt": "2021-06-14T11:25:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODI3NDMx",
          "commit": {
            "abbreviatedOid": "ae3d914"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:03:44Z",
          "updatedAt": "2021-06-14T12:03:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Oh dear we don't seem to agree - I think the original hints at everything being immutable. Instead, I think everything should be copied; but only the selection params are immutable, the other params are mutable on the copy.",
              "createdAt": "2021-06-14T12:03:44Z",
              "updatedAt": "2021-06-14T12:03:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODM0MTIz",
          "commit": {
            "abbreviatedOid": "ae3d914"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:11:31Z",
          "updatedAt": "2021-06-14T12:11:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That would be fine, but I didn't get that meaning from the new text.",
              "createdAt": "2021-06-14T12:11:31Z",
              "updatedAt": "2021-06-14T12:11:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODM3Njg3",
          "commit": {
            "abbreviatedOid": "ae3d914"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:15:40Z",
          "updatedAt": "2021-06-14T12:15:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "So... what's missing? - The text on copying was moved to the section after \"once a connection is established.",
              "createdAt": "2021-06-14T12:15:40Z",
              "updatedAt": "2021-06-14T12:15:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyODQyMjM3",
          "commit": {
            "abbreviatedOid": "ae3d914"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T12:20:51Z",
          "updatedAt": "2021-06-14T12:20:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I can't parse \"An implementation could allow properties of a preconnection to be updated, but changes to the Preconnection Selection and Connection may be language dependent and is to be avoided in code that could be used across different implementations\". I read it as trying to simplify the original wording, but actually making it less clear to me. I don't see how it relates to the selection parameters being immutable and while the other parameters remain mutable.\r\n",
              "createdAt": "2021-06-14T12:20:51Z",
              "updatedAt": "2021-06-14T12:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyOTEzNTA0",
          "commit": {
            "abbreviatedOid": "032f1d7"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T13:30:36Z",
          "updatedAt": "2021-06-14T13:30:44Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Improved text",
              "createdAt": "2021-06-14T13:30:36Z",
              "updatedAt": "2021-06-14T13:30:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMTQxNTkw",
          "commit": {
            "abbreviatedOid": "032f1d7"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I found the first change a bit unclear. Here's proposed rewording:",
          "createdAt": "2021-06-14T16:53:38Z",
          "updatedAt": "2021-06-14T16:55:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nPreconnection objects should be implemented as bundles of properties that an application can both read and write. An implementation could allow applications to update the properties or endpoints of a preconnection after it is initiated. However, an application should avoid changes to the Preconnection properties and endpoints to improve consistent operation across different implementations.\r\n```",
              "createdAt": "2021-06-14T16:53:38Z",
              "updatedAt": "2021-06-14T16:55:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTQxMjUw",
          "commit": {
            "abbreviatedOid": "6018ca0"
          },
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T22:22:08Z",
          "updatedAt": "2021-06-15T22:22:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The last two sentences here still seem vague and contradictory with the below. I think it'd be clearer just to remove them, and leave the detailed following explanations.",
              "createdAt": "2021-06-15T22:22:08Z",
              "updatedAt": "2021-06-15T22:22:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0Nzg5NTI1",
          "commit": {
            "abbreviatedOid": "6018ca0"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T06:57:59Z",
          "updatedAt": "2021-06-16T06:57:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@martinduke :  The expected operation is now clearer, csp suggests simply not mentioning the \"update during pre-connection\" possibility. What do you think?",
              "createdAt": "2021-06-16T06:57:59Z",
              "updatedAt": "2021-06-16T06:57:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODc2MzM3",
          "commit": {
            "abbreviatedOid": "6018ca0"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is going in a good direction, I like it!\r\n\r\nCan I make a request to change one more thing as a part of this PR, because it really belongs here?\r\n\r\nThis sentence in section 3.1 of the implementation draft is broken:\r\n\r\n\"To avoid allocating resources, it is important that such cases fail as early as possible, e.g., prior to endpoint resolution, only to find out later that there is no protocol that satisfies the requirements.\"\r\n\r\nPlese remove the \"only to find out later...\" part from it.",
          "createdAt": "2021-06-16T08:29:52Z",
          "updatedAt": "2021-06-16T08:38:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I have to agree with @csperkins that the original was clearer, mainly for being more explicit - but I think that, after looking at this for some time, I now see where the problem is (which @csperkins is perhaps missing, and which @gorryfair is perhaps trying to fix).\r\n\r\nI suspect that @gorryfair wants to avoid that we say, here, that properties on a Connection cannot be changed after creating an outbound Connection or a Listener. This would, of course, be wrong, but the text says that they are all \"immutable\", which gives a wrong indication.\r\n\r\nThen again, the proposed text now doesn't look like a good fix to me. E.g., it says \"an implementation could allow applications to...\", followed by \"however, applications should not do this\". This is awkward. Maybe you meant to write \"Connection\", not \"preconnection\" in the  second sentence?\r\n\r\nHere's a proposal: a change to the original text that avoids falsely indicating that everything becomes immutable:\r\n\r\n***\r\nPreconnection objects should be implemented as bundles of properties that an application can both read and write. A Preconnection object influences a Connection only at one point in time: when the Connection is created. Once a Preconnection has been used to create an outbound Connection or a Listener, the implementation should ensure that the copy of the properties held by the Connection or Listener is not affected when the application makes changes to the Preconnection object. This may involve performing a deep-copy, copying the object with all the objects it references.\r\n***\r\n\r\nI also removed the trailing \"if the application is still able...\" because I don't think this added clarity.",
              "createdAt": "2021-06-16T08:29:52Z",
              "updatedAt": "2021-06-16T08:38:01Z"
            },
            {
              "originalPosition": 10,
              "body": "Here, the original text said \"may ultimately represent the interface into\", and the proposed text now says \"may ultimately interface to\"...  all this reads a bit clumsy to me.\r\n\r\nCould we not just say \"may ultimately represent a single instance ......\"\r\nMaybe it's a bit vague, that's in the nature of the word \"represent\", but I think the meaning is clear enough and this would read better.",
              "createdAt": "2021-06-16T08:32:48Z",
              "updatedAt": "2021-06-16T08:38:01Z"
            },
            {
              "originalPosition": 11,
              "body": "I see that this adds the explicit parts from the original text. I like it for being clear about what's mutable and what isn't, and I still think that the whole thing would be best with my suggested text change above - this here just adds further clarification.\r\n\r\nThe first sentence of this paragraph says \"... is independent of other connections.\"  I guess this should really say \"\"... is independent of any other connections that are not part of the same Connection Group.\"",
              "createdAt": "2021-06-16T08:35:38Z",
              "updatedAt": "2021-06-16T08:38:01Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nAlthough Connection Properties (see {{connection-props}}) can be set during pre-establishment, they may be changed later. They are used to inform decisions made during establishment and to fine-tune the established connection. Calling Initiate on a Preconnection creates an outbound Connection or a Listener, and the Selection Properties remain readable from the Connection or Listener, but become immutable. \r\n```",
              "createdAt": "2021-06-16T08:36:21Z",
              "updatedAt": "2021-06-16T08:38:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0ODk3MTQ2",
          "commit": {
            "abbreviatedOid": "17132e4"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:49:50Z",
          "updatedAt": "2021-06-16T08:49:50Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yes, that didn't seem right to me - I would like to align with the Arch and say \"instance\"",
              "createdAt": "2021-06-16T08:49:50Z",
              "updatedAt": "2021-06-16T08:49:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTA1MjQ1",
          "commit": {
            "abbreviatedOid": "53a8967"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T08:57:02Z",
          "updatedAt": "2021-06-16T08:57:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Could is /use/ better than /represent/?:  \r\n(1) For example, the same Connection object may ultimately use a single instance of one transport protocol ",
              "createdAt": "2021-06-16T08:57:03Z",
              "updatedAt": "2021-06-16T08:57:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTE5NzI0",
          "commit": {
            "abbreviatedOid": "bfb28e4"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:10:34Z",
          "updatedAt": "2021-06-16T09:10:34Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I tried, and merged. Please check the new diff and suggest improvements.",
              "createdAt": "2021-06-16T09:10:34Z",
              "updatedAt": "2021-06-16T09:10:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0OTIwMjAz",
          "commit": {
            "abbreviatedOid": "bfb28e4"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-16T09:11:03Z",
          "updatedAt": "2021-06-16T09:11:04Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think this was done.",
              "createdAt": "2021-06-16T09:11:03Z",
              "updatedAt": "2021-06-16T09:11:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1MTgyMDk1",
          "commit": {
            "abbreviatedOid": "bfb28e4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-16T13:39:43Z",
          "updatedAt": "2021-06-16T13:40:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "FWIW, I agree with this update. Thanks!",
              "createdAt": "2021-06-16T13:39:44Z",
              "updatedAt": "2021-06-16T13:40:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 861,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5NDEyMTYw",
      "title": "Change B.2.3. unreliable-datagram profile",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/861",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update and explain choices\r\nSeeks to address #821 ",
      "createdAt": "2021-06-14T09:39:14Z",
      "updatedAt": "2021-06-15T16:50:11Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdea22b1f5acaabecd5c5a6c576d8f64a111833d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-4",
      "headRefOid": "a3a7cd410bb2f8928f74210ac55d0246b220e813",
      "closedAt": "2021-06-15T16:50:11Z",
      "mergedAt": "2021-06-15T16:50:11Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "6db57a457feb37767373157b5251023d060164bc"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged copy after Interim",
          "createdAt": "2021-06-15T16:49:31Z",
          "updatedAt": "2021-06-15T16:49:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjQzMTMz",
          "commit": {
            "abbreviatedOid": "a3a7cd4"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the way this is phrased, it gives a good argument for the default property values.",
          "createdAt": "2021-06-15T16:37:04Z",
          "updatedAt": "2021-06-15T16:37:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 862,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5NDIzMTEw",
      "title": "Help UDP fit wrt connection",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/862",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "Architecture"
      ],
      "body": "Added a couple of sentences to Arch that are hoped to early introduce that connections are things in the API, not aretfacts of the transport protocol instances.\r\n\r\nDifferent to, but related to an issue for the description in API.",
      "createdAt": "2021-06-14T09:55:39Z",
      "updatedAt": "2021-07-06T07:20:39Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "fdea22b1f5acaabecd5c5a6c576d8f64a111833d",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-7",
      "headRefOid": "263a23af8797070250042fb317af99885a756e73",
      "closedAt": "2021-07-06T07:20:12Z",
      "mergedAt": "2021-07-06T07:20:12Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "39c11c205ec33e50ccd4f78988c474f47daa6bdb"
      },
      "comments": [
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"A `Connection` is an abstraction that represents the communication. If the transport services interface selects a protocol such as TCP for the communication, a `Connection` will correspond to an underlying protocol connection. In the other hand, if a protocol such as UDP is selected, the `Connection` remains an abstraction in the end points and doesn't correspond to explicit protocol state\" ?",
          "createdAt": "2021-06-14T11:21:44Z",
          "updatedAt": "2021-06-14T11:21:44Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@csperkins : Could you live with the update in this PR?\r\n",
          "createdAt": "2021-07-05T16:25:07Z",
          "updatedAt": "2021-07-05T16:25:07Z"
        },
        {
          "author": "csperkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, I think so (assuming I'm reading the diff right)",
          "createdAt": "2021-07-05T22:25:40Z",
          "updatedAt": "2021-07-05T22:25:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 863,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4ODE5NzQ3",
      "title": "Re-group managing  properties & protocol instances",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/863",
      "state": "MERGED",
      "author": "gorryfair",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "gorryfair"
      ],
      "labels": [
        "API",
        "editorial"
      ],
      "body": "In response to #813 ... This moves the discussion of protocol instances into bullet 4, and the properties (mainly selection) into bullet 5. It does not intend to change any text, and is intended to avoid what appeared to be overlap.",
      "createdAt": "2021-06-28T08:19:37Z",
      "updatedAt": "2021-07-05T16:25:55Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6f07eb75c5e847e37460140cc4b57bb406acd320",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "gorryfair-patch-managing",
      "headRefOid": "d000a3b5b2ec51f44aa0183a3c46f918c80092b8",
      "closedAt": "2021-07-05T16:25:48Z",
      "mergedAt": "2021-07-05T16:25:48Z",
      "mergedBy": "gorryfair",
      "mergeCommit": {
        "oid": "c4dd4d22510fb1eea38ec9f29b3d94f60380ca47"
      },
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved issue following MW review",
          "createdAt": "2021-07-05T16:25:55Z",
          "updatedAt": "2021-07-05T16:25:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2ODc5Mjc4",
          "commit": {
            "abbreviatedOid": "9088885"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, but note that I marked a nit (missing full stop).",
          "createdAt": "2021-07-01T06:49:14Z",
          "updatedAt": "2021-07-01T06:50:08Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n  a certain Selection Property, see {{selection-props}}.   \r\n```",
              "createdAt": "2021-07-01T06:49:14Z",
              "updatedAt": "2021-07-01T06:50:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 866,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgzNTY5OTIw",
      "title": "Preconnections are just structs",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/866",
      "state": "MERGED",
      "author": "mwelzl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "API"
      ],
      "body": "Closes #859\r\n\r\nThis is quite minimal... meant as a start. Or is this already enough?",
      "createdAt": "2021-07-05T10:18:51Z",
      "updatedAt": "2021-07-08T10:46:50Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "6f07eb75c5e847e37460140cc4b57bb406acd320",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "mw-api-precons-are-just-structs",
      "headRefOid": "c4e374a9376d75d7338d699619a9a3b16a13ddd4",
      "closedAt": "2021-07-08T10:46:49Z",
      "mergedAt": "2021-07-08T10:46:49Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "3745c5cdb97d146c7c9b5a34e9c52e4c410ec2b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5MzE5NzMw",
          "commit": {
            "abbreviatedOid": "89f0949"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T16:27:44Z",
          "updatedAt": "2021-07-05T16:27:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "After Initiated wouldn't this also be OK?",
              "createdAt": "2021-07-05T16:27:44Z",
              "updatedAt": "2021-07-05T16:27:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NDI3NDY4",
          "commit": {
            "abbreviatedOid": "89f0949"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T21:49:52Z",
          "updatedAt": "2021-07-05T21:49:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Of course - anywhere, really, it's just a struct. But this gets a bit harder to write about (\"a similar line would also work below the 'initiate' call higher above\"), unless we use more code just to show this; I think, with the explanation below, it should be clear enough as it is.",
              "createdAt": "2021-07-05T21:49:52Z",
              "updatedAt": "2021-07-05T21:49:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NTI3MDA0",
          "commit": {
            "abbreviatedOid": "89f0949"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm good with this!",
          "createdAt": "2021-07-06T04:34:03Z",
          "updatedAt": "2021-07-06T04:34:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NjEyMDI2",
          "commit": {
            "abbreviatedOid": "89f0949"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T07:18:12Z",
          "updatedAt": "2021-07-06T07:18:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Could we try: \r\n\"Preconnections are reusable after being used to initiate a Connection. Hence, for example, after the Connections were closed,\r\n the following would be correct:\"",
              "createdAt": "2021-07-06T07:18:12Z",
              "updatedAt": "2021-07-06T07:18:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NjE5NTU1",
          "commit": {
            "abbreviatedOid": "89f0949"
          },
          "author": "mwelzl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T07:27:26Z",
          "updatedAt": "2021-07-06T07:27:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Your wish has been granted.",
              "createdAt": "2021-07-06T07:27:26Z",
              "updatedAt": "2021-07-06T07:27:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NjIxNDY3",
          "commit": {
            "abbreviatedOid": "c4e374a"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me...",
          "createdAt": "2021-07-06T07:29:36Z",
          "updatedAt": "2021-07-06T07:29:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 867,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg1ODg0NjQ2",
      "title": "Many editorial fixes (rollup 1)",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/867",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #798, fix #799, fix #802, fix #803, fix #805, fix #807, fix #811, fix #813, fix #814, fix #816, fix #817.\r\n\r\nMore to follow in a subsequent PR (it's lunchtime. :) )",
      "createdAt": "2021-07-08T10:23:06Z",
      "updatedAt": "2021-07-08T11:26:08Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39c11c205ec33e50ccd4f78988c474f47daa6bdb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-editorial-rollup-1",
      "headRefOid": "f541a6156822398d61fc219478e78c1cd1841399",
      "closedAt": "2021-07-08T11:26:08Z",
      "mergedAt": "2021-07-08T11:26:07Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "f150121d4ae18eb3f1b44de23d6b0fe919b5d81a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxODk4Mjcx",
          "commit": {
            "abbreviatedOid": "10daa83"
          },
          "author": "gorryfair",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for getting to this: My lunch-time was offset from yours, so here are a few initial NiTs to help finish this.",
          "createdAt": "2021-07-08T10:28:40Z",
          "updatedAt": "2021-07-08T10:33:05Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "/a connection/",
              "createdAt": "2021-07-08T10:28:40Z",
              "updatedAt": "2021-07-08T10:33:05Z"
            },
            {
              "originalPosition": 46,
              "body": "English messy: However, I intended ... informing the selection ... rather than the other possibility of informing the app.",
              "createdAt": "2021-07-08T10:30:19Z",
              "updatedAt": "2021-07-08T10:33:05Z"
            },
            {
              "originalPosition": 94,
              "body": "/ot/to/",
              "createdAt": "2021-07-08T10:31:03Z",
              "updatedAt": "2021-07-08T10:33:05Z"
            },
            {
              "originalPosition": 114,
              "body": "could simply remove /suggested/  entirely?",
              "createdAt": "2021-07-08T10:31:45Z",
              "updatedAt": "2021-07-08T10:33:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTE0MTk3",
          "commit": {
            "abbreviatedOid": "10daa83"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T10:47:33Z",
          "updatedAt": "2021-07-08T10:47:33Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n  a connection can operate (e.g. Provisioning Domain (PvD) information {{RFC7556}}).  \r\n```",
              "createdAt": "2021-07-08T10:47:33Z",
              "updatedAt": "2021-07-08T10:47:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTE1OTY3",
          "commit": {
            "abbreviatedOid": "10daa83"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T10:49:47Z",
          "updatedAt": "2021-07-08T10:49:48Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nEach Transport Property has a one of the basic types described in {{notation}}.\r\n```",
              "createdAt": "2021-07-08T10:49:48Z",
              "updatedAt": "2021-07-08T10:49:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTE2MTQ1",
          "commit": {
            "abbreviatedOid": "10daa83"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T10:50:02Z",
          "updatedAt": "2021-07-08T10:50:03Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nProperties. The default values for each property below represent a\r\n```",
              "createdAt": "2021-07-08T10:50:02Z",
              "updatedAt": "2021-07-08T10:50:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTQyMzc2",
          "commit": {
            "abbreviatedOid": "10daa83"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T11:22:05Z",
          "updatedAt": "2021-07-08T11:22:05Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "(will resolve outside this thread, for some reason having a comment here breaks multiline suggestions)",
              "createdAt": "2021-07-08T11:22:05Z",
              "updatedAt": "2021-07-08T11:22:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTQzODUy",
          "commit": {
            "abbreviatedOid": "db21ee4"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T11:23:56Z",
          "updatedAt": "2021-07-08T11:23:57Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n- Selection between alternate network paths, using additional information about the \r\n  networks over which a connection can operate (e.g. Provisioning Domain (PvD) \r\n  information {{RFC7556}}) where available.  \r\n```",
              "createdAt": "2021-07-08T11:23:57Z",
              "updatedAt": "2021-07-08T11:23:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 868,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg1ODk5NDgw",
      "title": "More editorial fixes.",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/868",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #819. fix #820. fix #843. fix #850. fix #854.",
      "createdAt": "2021-07-08T10:45:16Z",
      "updatedAt": "2021-07-08T11:26:37Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "39c11c205ec33e50ccd4f78988c474f47daa6bdb",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-editorial-rollup-2",
      "headRefOid": "9d15c98e66d7ce7471319845d732c332ff20b54c",
      "closedAt": "2021-07-08T11:26:32Z",
      "mergedAt": "2021-07-08T11:26:32Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c05374ca4827d08327163bc1bc260456b919bb64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTQ0NTE1",
          "commit": {
            "abbreviatedOid": "7d0dba3"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T11:24:49Z",
          "updatedAt": "2021-07-08T11:24:49Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n{: #tabrm title=\"reliable-message preferences\"}\r\n```",
              "createdAt": "2021-07-08T11:24:49Z",
              "updatedAt": "2021-07-08T11:24:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxOTQ0Njc0",
          "commit": {
            "abbreviatedOid": "7d0dba3"
          },
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T11:25:03Z",
          "updatedAt": "2021-07-08T11:25:04Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "```suggestion\r\n{: #tabud title=\"unreliable-datagram preferences\"}\r\n```",
              "createdAt": "2021-07-08T11:25:03Z",
              "updatedAt": "2021-07-08T11:25:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 869,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg1OTM4Mzgy",
      "title": "section refactor",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/869",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #849. fix #851.",
      "createdAt": "2021-07-08T11:42:02Z",
      "updatedAt": "2021-07-08T12:01:16Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c05374ca4827d08327163bc1bc260456b919bb64",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "849-make-sections-better",
      "headRefOid": "0587901bdc3d5236d92756d0478c9c07b208af7a",
      "closedAt": "2021-07-08T12:00:44Z",
      "mergedAt": "2021-07-08T12:00:44Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "c144fed3a92829e334a2b212cae1670dd5dd064a"
      },
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Once this is merged, numeric section references will change in the API document as follows\r\n\r\n1 --> 1\r\n2 --> 2\r\n3 --> 3\r\n3.2 --> 4\r\n3.3 --> 5 \r\n4 --> 6\r\n5 --> 7\r\n6 --> 8\r\n\r\n... and so on\r\n",
          "createdAt": "2021-07-08T11:57:06Z",
          "updatedAt": "2021-07-08T11:59:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 870,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MDMwMTE2",
      "title": "editorial rollup number three",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/870",
      "state": "MERGED",
      "author": "britram",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix #846. fix #801.",
      "createdAt": "2021-07-08T13:44:48Z",
      "updatedAt": "2021-07-08T13:50:26Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "c144fed3a92829e334a2b212cae1670dd5dd064a",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "britram-more-editorial",
      "headRefOid": "ea3c542cc932ab97980b933343725eeda0b4edd1",
      "closedAt": "2021-07-08T13:50:23Z",
      "mergedAt": "2021-07-08T13:50:23Z",
      "mergedBy": "britram",
      "mergeCommit": {
        "oid": "a0061a7d0eb2979fed595b5be2d7b2a5eecc349e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 871,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MzIxNDQ4",
      "title": "Resolve #852: text disclaiming multicast rendezvous",
      "url": "https://github.com/ietf-tapswg/api-drafts/pull/871",
      "state": "OPEN",
      "author": "GrumpyOldTroll",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-08T20:58:23Z",
      "updatedAt": "2021-07-08T21:54:41Z",
      "baseRepository": "ietf-tapswg/api-drafts",
      "baseRefName": "master",
      "baseRefOid": "a0061a7d0eb2979fed595b5be2d7b2a5eecc349e",
      "headRepository": "ietf-tapswg/api-drafts",
      "headRefName": "872-multicast-rendezvous",
      "headRefOid": "3fcb27b5a246262fe03bf49aa343f32563bcb927",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}